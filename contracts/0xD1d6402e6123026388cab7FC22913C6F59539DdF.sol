contract main {




// =====================  Runtime code  =====================


#
#  - sub_2c267097(?)
#  - sub_39815037(?)
#  - sub_c5327ae0(?)
#  - sub_edca6525(?)
#
const CHI_ADDRESS = 0x4946c0e9f43f4dee607b0ef1fa1c


address owner;
mapping of uint8 stor1;
address WMATICAddress;
address sub_67491cb9Address;
address sub_5fdba4b7Address;
address feeReceiverAddress;
uint256 sub_fcb53d36;
mapping of uint8 stor7;
uint256 sub_b38e50ee;
address sub_8807b6a8Address;
address sub_bff723b4Address;
address sub_beaa26d7Address;
mapping of uint8 stor12;
mapping of address sub_cabba38a;
mapping of address sub_eab402bd;

function sub_40682152(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor1[arg1])
}

function WMATIC() payable {
    return WMATICAddress
}

function sub_5fdba4b7(?) payable {
    return sub_5fdba4b7Address
}

function sub_607dd6e4(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor12[arg1])
}

function sub_67491cb9(?) payable {
    return sub_67491cb9Address
}

function sub_8807b6a8(?) payable {
    return sub_8807b6a8Address
}

function owner() payable {
    return owner
}

function sub_b38e50ee(?) payable {
    return sub_b38e50ee
}

function feeReceiver() payable {
    return feeReceiverAddress
}

function sub_beaa26d7(?) payable {
    return sub_beaa26d7Address
}

function sub_bff723b4(?) payable {
    return sub_bff723b4Address
}

function sub_cabba38a(?) payable {
    require calldata.size - 4 >= 32
    return sub_cabba38a[arg1]
}

function sub_eab402bd(?) payable {
    require calldata.size - 4 >= 32
    return sub_eab402bd[arg1]
}

function sub_fcb53d36(?) payable {
    return sub_fcb53d36
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function setPrecision(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_b38e50ee = arg1
}

function setWETH(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    WMATICAddress = arg1
}

function sub_9b2c0711(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_beaa26d7Address = address(arg1)
}

function sub_36396a35(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    feeReceiverAddress = address(arg1)
    sub_fcb53d36 = arg2
}

function sub_5d7bab8f(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor7[address(arg1)] = uint8(bool(arg2))
}

function sub_efc229fa(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor12[address(arg1)] = uint8(bool(arg2))
}

function sub_4df3f50b(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_67491cb9Address = address(arg1)
    sub_5fdba4b7Address = address(arg2)
}

function sub_a9f24668(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_8807b6a8Address = address(arg1)
    sub_bff723b4Address = address(arg2)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        return eth.balance(this.address)
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_fd9ec6fe(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] == bool(cd[36])
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
        mem[32] = 12
        stor12[address(cd[((32 * idx) + cd[4] + 36)])] = uint8(bool(cd[36]))
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
}

function recover(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if stor1[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'TokenRecover#recover: Cannot recover tokens from the denylist'
    if not arg1:
        call owner with:
           value arg2 wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(arg1)
        call arg1.transfer(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args owner, arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_5e63b90d(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if tx.origin == owner:
        if arg1:
            if arg2 <= !arg3:
                if var31002 >= arg2 + arg3:
                mem[96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
                mem[100] = var33001
                require ext_code.size(sub_bff723b4Address)
                staticcall sub_bff723b4Address.mem[var35003 len 4] with:
                        gas gas_remaining wei
                       args mem[var35003 + 4 len var35004 - 4]
                mem[var35005] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require var39002 - var39001 >= 32
                _196 = mem[var41002]
                require mem[var41002] == mem[var41002 + 12 len 20]
                mem[0] = var41005
                mem[32] = 14
                sub_eab402bd[var41005] = address(_196)
                s = _196
                s = _196
                s = var41002
                s = var41003
                idx = var41005
                while idx != -1:
                    if arg2 > !arg3:
                        revert with 'NH{q', 17
                    if idx + 1 >= arg2 + arg3:
                    mem[mem[64] + 4] = idx + 1
                    require ext_code.size(sub_bff723b4Address)
                    staticcall sub_bff723b4Address.allPairs(uint256 arg1) with:
                            gas gas_remaining wei
                           args (idx + 1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _232 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _236 = mem[_232]
                    require mem[_232] == mem[_232 + 12 len 20]
                    mem[0] = idx + 1
                    mem[32] = 14
                    sub_eab402bd[idx + 1] = address(_236)
                    s = _236
                    s = _236
                    s = _232
                    s = _232 + return_data.size
                    idx = idx + 1
                    continue 
        else:
            if arg2 <= !arg3:
                if var31002 >= arg2 + arg3:
                mem[96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
                mem[100] = var33001
                require ext_code.size(sub_8807b6a8Address)
                staticcall sub_8807b6a8Address.mem[var35003 len 4] with:
                        gas gas_remaining wei
                       args mem[var35003 + 4 len var35004 - 4]
                mem[var35005] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require var39002 - var39001 >= 32
                _197 = mem[var41002]
                require mem[var41002] == mem[var41002 + 12 len 20]
                mem[0] = var41005
                mem[32] = 13
                sub_cabba38a[var41005] = address(_197)
                s = _197
                s = _197
                s = var41002
                s = var41003
                idx = var41005
                while idx != -1:
                    if arg2 > !arg3:
                        revert with 'NH{q', 17
                    if idx + 1 >= arg2 + arg3:
                    mem[mem[64] + 4] = idx + 1
                    require ext_code.size(sub_8807b6a8Address)
                    staticcall sub_8807b6a8Address.allPairs(uint256 arg1) with:
                            gas gas_remaining wei
                           args (idx + 1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _233 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _237 = mem[_233]
                    require mem[_233] == mem[_233 + 12 len 20]
                    mem[0] = idx + 1
                    mem[32] = 13
                    sub_cabba38a[idx + 1] = address(_237)
                    s = _237
                    s = _237
                    s = _233
                    s = _233 + return_data.size
                    idx = idx + 1
                    continue 
    else:
        mem[0] = tx.origin
        mem[32] = 12
        if not stor12[tx.origin]:
            revert with 0, 'nworker!'
        if arg1:
            if arg2 <= !arg3:
                if var32002 >= arg2 + arg3:
                mem[96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
                mem[100] = var34001
                require ext_code.size(sub_bff723b4Address)
                staticcall sub_bff723b4Address.mem[var36003 len 4] with:
                        gas gas_remaining wei
                       args mem[var36003 + 4 len var36004 - 4]
                mem[var36005] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require var40002 - var40001 >= 32
                _198 = mem[var42002]
                require mem[var42002] == mem[var42002 + 12 len 20]
                mem[0] = var42005
                mem[32] = 14
                sub_eab402bd[var42005] = address(_198)
                s = _198
                s = _198
                s = var42002
                s = var42003
                idx = var42005
                while idx != -1:
                    if arg2 > !arg3:
                        revert with 'NH{q', 17
                    if idx + 1 >= arg2 + arg3:
                    mem[mem[64] + 4] = idx + 1
                    require ext_code.size(sub_bff723b4Address)
                    staticcall sub_bff723b4Address.allPairs(uint256 arg1) with:
                            gas gas_remaining wei
                           args (idx + 1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _234 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _238 = mem[_234]
                    require mem[_234] == mem[_234 + 12 len 20]
                    mem[0] = idx + 1
                    mem[32] = 14
                    sub_eab402bd[idx + 1] = address(_238)
                    s = _238
                    s = _238
                    s = _234
                    s = _234 + return_data.size
                    idx = idx + 1
                    continue 
        else:
            if arg2 <= !arg3:
                if var32002 >= arg2 + arg3:
                mem[96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
                mem[100] = var34001
                require ext_code.size(sub_8807b6a8Address)
                staticcall sub_8807b6a8Address.mem[var36003 len 4] with:
                        gas gas_remaining wei
                       args mem[var36003 + 4 len var36004 - 4]
                mem[var36005] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require var40002 - var40001 >= 32
                _199 = mem[var42002]
                require mem[var42002] == mem[var42002 + 12 len 20]
                mem[0] = var42005
                mem[32] = 13
                sub_cabba38a[var42005] = address(_199)
                s = _199
                s = _199
                s = var42002
                s = var42003
                idx = var42005
                while idx != -1:
                    if arg2 > !arg3:
                        revert with 'NH{q', 17
                    if idx + 1 >= arg2 + arg3:
                    mem[mem[64] + 4] = idx + 1
                    require ext_code.size(sub_8807b6a8Address)
                    staticcall sub_8807b6a8Address.allPairs(uint256 arg1) with:
                            gas gas_remaining wei
                           args (idx + 1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _235 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _239 = mem[_235]
                    require mem[_235] == mem[_235 + 12 len 20]
                    mem[0] = idx + 1
                    mem[32] = 13
                    sub_cabba38a[idx + 1] = address(_239)
                    s = _239
                    s = _239
                    s = _235
                    s = _235 + return_data.size
                    idx = idx + 1
                    continue 
    revert with 'NH{q', 17
}

function sub_1f0bb6bb(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if tx.origin == owner:
        mem[96] = 0xf03e8adc00000000000000000000000000000000000000000000000000000000
        if arg1:
            require ext_code.size(sub_bff723b4Address)
            staticcall sub_bff723b4Address.mem[var29003 len 4] with:
                    gas gas_remaining wei
                   args mem[var29003 + 4 len var29004 - 4]
            mem[var29005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 96
            require var33002 - var33001 >= 32
            if var37002 >= var37001:
            mem[ceil32(return_data.size) + 96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 100] = var39001
            require ext_code.size(sub_bff723b4Address)
            staticcall sub_bff723b4Address.mem[var41003 len 4] with:
                    gas gas_remaining wei
                   args mem[var41003 + 4 len var41004 - 4]
            mem[var41005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require var45002 - var45001 >= 32
            _428 = mem[var47002]
            require mem[var47002] == mem[var47002 + 12 len 20]
            mem[0] = var47005
            mem[32] = 14
            sub_eab402bd[var47005] = address(_428)
            s = _428
            s = _428
            s = var47002
            s = var47003
            idx = var47005
            while idx != -1:
                require ext_code.size(sub_bff723b4Address)
                staticcall sub_bff723b4Address.0xf03e8adc with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _480 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx + 1 >= mem[_480]:
                mem[mem[64] + 4] = idx + 1
                require ext_code.size(sub_bff723b4Address)
                staticcall sub_bff723b4Address.allPairs(uint256 arg1) with:
                        gas gas_remaining wei
                       args (idx + 1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _496 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _500 = mem[_496]
                require mem[_496] == mem[_496 + 12 len 20]
                mem[0] = idx + 1
                mem[32] = 14
                sub_eab402bd[idx + 1] = address(_500)
                s = _500
                s = _500
                s = _496
                s = _496 + return_data.size
                idx = idx + 1
                continue 
        else:
            require ext_code.size(sub_8807b6a8Address)
            staticcall sub_8807b6a8Address.mem[var29003 len 4] with:
                    gas gas_remaining wei
                   args mem[var29003 + 4 len var29004 - 4]
            mem[var29005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 96
            require var33002 - var33001 >= 32
            if var37002 >= var37001:
            mem[ceil32(return_data.size) + 96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 100] = var39001
            require ext_code.size(sub_8807b6a8Address)
            staticcall sub_8807b6a8Address.mem[var41003 len 4] with:
                    gas gas_remaining wei
                   args mem[var41003 + 4 len var41004 - 4]
            mem[var41005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require var45002 - var45001 >= 32
            _429 = mem[var47002]
            require mem[var47002] == mem[var47002 + 12 len 20]
            mem[0] = var47005
            mem[32] = 13
            sub_cabba38a[var47005] = address(_429)
            s = _429
            s = _429
            s = var47002
            s = var47003
            idx = var47005
            while idx != -1:
                require ext_code.size(sub_8807b6a8Address)
                staticcall sub_8807b6a8Address.0xf03e8adc with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _481 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx + 1 >= mem[_481]:
                mem[mem[64] + 4] = idx + 1
                require ext_code.size(sub_8807b6a8Address)
                staticcall sub_8807b6a8Address.allPairs(uint256 arg1) with:
                        gas gas_remaining wei
                       args (idx + 1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _497 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _501 = mem[_497]
                require mem[_497] == mem[_497 + 12 len 20]
                mem[0] = idx + 1
                mem[32] = 13
                sub_cabba38a[idx + 1] = address(_501)
                s = _501
                s = _501
                s = _497
                s = _497 + return_data.size
                idx = idx + 1
                continue 
    else:
        mem[0] = tx.origin
        mem[32] = 12
        if not stor12[tx.origin]:
            revert with 0, 'nworker!'
        mem[96] = 0xf03e8adc00000000000000000000000000000000000000000000000000000000
        if arg1:
            require ext_code.size(sub_bff723b4Address)
            staticcall sub_bff723b4Address.mem[var30003 len 4] with:
                    gas gas_remaining wei
                   args mem[var30003 + 4 len var30004 - 4]
            mem[var30005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 96
            require var34002 - var34001 >= 32
            if var38002 >= var38001:
            mem[ceil32(return_data.size) + 96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 100] = var40001
            require ext_code.size(sub_bff723b4Address)
            staticcall sub_bff723b4Address.mem[var42003 len 4] with:
                    gas gas_remaining wei
                   args mem[var42003 + 4 len var42004 - 4]
            mem[var42005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require var46002 - var46001 >= 32
            _430 = mem[var48002]
            require mem[var48002] == mem[var48002 + 12 len 20]
            mem[0] = var48005
            mem[32] = 14
            sub_eab402bd[var48005] = address(_430)
            s = _430
            s = _430
            s = var48002
            s = var48003
            idx = var48005
            while idx != -1:
                require ext_code.size(sub_bff723b4Address)
                staticcall sub_bff723b4Address.0xf03e8adc with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _482 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx + 1 >= mem[_482]:
                mem[mem[64] + 4] = idx + 1
                require ext_code.size(sub_bff723b4Address)
                staticcall sub_bff723b4Address.allPairs(uint256 arg1) with:
                        gas gas_remaining wei
                       args (idx + 1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _498 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _502 = mem[_498]
                require mem[_498] == mem[_498 + 12 len 20]
                mem[0] = idx + 1
                mem[32] = 14
                sub_eab402bd[idx + 1] = address(_502)
                s = _502
                s = _502
                s = _498
                s = _498 + return_data.size
                idx = idx + 1
                continue 
        else:
            require ext_code.size(sub_8807b6a8Address)
            staticcall sub_8807b6a8Address.mem[var30003 len 4] with:
                    gas gas_remaining wei
                   args mem[var30003 + 4 len var30004 - 4]
            mem[var30005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 96
            require var34002 - var34001 >= 32
            if var38002 >= var38001:
            mem[ceil32(return_data.size) + 96] = 0x1e3dd18b00000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 100] = var40001
            require ext_code.size(sub_8807b6a8Address)
            staticcall sub_8807b6a8Address.mem[var42003 len 4] with:
                    gas gas_remaining wei
                   args mem[var42003 + 4 len var42004 - 4]
            mem[var42005] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require var46002 - var46001 >= 32
            _431 = mem[var48002]
            require mem[var48002] == mem[var48002 + 12 len 20]
            mem[0] = var48005
            mem[32] = 13
            sub_cabba38a[var48005] = address(_431)
            s = _431
            s = _431
            s = var48002
            s = var48003
            idx = var48005
            while idx != -1:
                require ext_code.size(sub_8807b6a8Address)
                staticcall sub_8807b6a8Address.0xf03e8adc with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _483 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx + 1 >= mem[_483]:
                mem[mem[64] + 4] = idx + 1
                require ext_code.size(sub_8807b6a8Address)
                staticcall sub_8807b6a8Address.allPairs(uint256 arg1) with:
                        gas gas_remaining wei
                       args (idx + 1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _499 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _503 = mem[_499]
                require mem[_499] == mem[_499 + 12 len 20]
                mem[0] = idx + 1
                mem[32] = 13
                sub_cabba38a[idx + 1] = address(_503)
                s = _503
                s = _503
                s = _499
                s = _499 + return_data.size
                idx = idx + 1
                continue 
    revert with 'NH{q', 17
}

function elkCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function apeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function babyCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function zeroCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function bnEXCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function cafeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function oliveCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function shibaCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function lydiaCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function canaryCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function wardenCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function BiswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function swapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function definixCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function polyZapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pantherCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function polydexCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function hswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function jetswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function stableXCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function BSCswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pancakeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function wakaSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function coinswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function baguetteCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function ThugswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function yetiswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function pangolinCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function complusV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function waultSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function cheeseswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require arg4.length >= 128
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] <= test266151307()
    require arg4 + cd[(arg4 + 68)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 68)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(arg4 + cd[(arg4 + 68)] + 36)]
    require cd[(arg4 + 68)] + (32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 68)] + 68
    t = 128
    while idx < cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + cd[(arg4 + 100)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 100)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 97] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require cd[(arg4 + 100)] + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 100)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[(arg4 + 132)] <= test266151307()
    require arg4 + cd[(arg4 + 132)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 132)] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 < 98 or ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 98] = cd[(arg4 + cd[(arg4 + 132)] + 36)]
    require cd[(arg4 + 132)] + (32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 68 <= arg4.length + 36
    idx = 0
    s = arg4 + cd[(arg4 + 132)] + 68
    t = ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130
    while idx < cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 135] = _118
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(arg4 + cd[(arg4 + 132)] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(arg4 + cd[(arg4 + 68)] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(arg4 + cd[(arg4 + 68)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + ceil32(32 * cd[(arg4 + cd[(arg4 + 132)] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_00d79885(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_042fb303(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_0e7c2d0e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_13b977c1(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1750699e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_1a7f26cb(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_29764754(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_29a9cf88(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_32f58371(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3aa99232(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_3e606615(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_437f1ee4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_48c5b27e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_4afa36ff(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_4c53de6e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5d7d72db(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_5fa45711(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_61987d16(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_6dca4cd4(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_78b94ae6(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_7b4c893e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_801d49f8(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_813029ee(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8649b473(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_87c26197(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8955316a(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_8d07fe0d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9b6dda6e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_9bdb3b48(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_a5cc261d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ace1c26f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ae457fcd(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_c0b6d79f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_c0fc3ce6(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ca5623b9(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_cdcaf6a0(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_cf90dbbe(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d053452f(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_d9f7cd9e(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f0cc0646(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_f83eb0bb(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_fd5cc49d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_ffcd3013(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    if not stor12[tx.origin]:
        revert with 0, 'nworker!'
    require ('cd', 100).length >= 128
    require ('cd', 100)[0] == address(('cd', 100)[0])
    require ('cd', 100)[1] <= test266151307()
    require cd[100] + ('cd', 100)[1] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[1] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 < 96 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = cd[(cd[100] + ('cd', 100)[1] + 36)]
    require ('cd', 100)[1] + (32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[1] + 68
    t = 128
    while idx < cd[(cd[100] + ('cd', 100)[1] + 36)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100)[2] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[2] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 < 97 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 97] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100)[2] + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[2] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ('cd', 100)[3] <= test266151307()
    require cd[100] + ('cd', 100)[3] + 67 < cd[100] + ('cd', 100).length + 36
    if cd[(cd[100] + ('cd', 100)[3] + 36)] > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 < 98 or ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 98] = cd[(cd[100] + ('cd', 100)[3] + 36)]
    require ('cd', 100)[3] + (32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 68 <= ('cd', 100).length + 36
    idx = 0
    s = cd[100] + ('cd', 100)[3] + 68
    t = ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130
    while idx < cd[(cd[100] + ('cd', 100)[3] + 36)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 0 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 0 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    _118 = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103] = mem[140 len 20]
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 135] = _118
    require ext_code.size(address(('cd', 100)[0]))
    call address(('cd', 100)[0]).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 103], _118
    mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + 99] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if var108001 < 1:
        revert with 'NH{q', 17
    if var112002 >= var112001:
    if var114001 >= cd[(cd[100] + ('cd', 100)[3] + 36)]:
        revert with 'NH{q', 50
    if var118001 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
        revert with 'NH{q', 50
    if 1 > !var122002:
        revert with 'NH{q', 17
    if var126001 >= cd[(cd[100] + ('cd', 100)[2] + 36)]:
        revert with 'NH{q', 50
    if mem[(32 * var116001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 130] != 0:
        _746 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126005:
            revert with 'NH{q', 17
        if var126005 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _750 = mem[(32 * var126005 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = _746
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_750)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126004)
            call var126004.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _746, 0, address(_750), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
    else:
        _747 = mem[(32 * var126001) + ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + 129]
        if 1 > !var126006:
            revert with 'NH{q', 17
        if var126006 + 1 >= cd[(cd[100] + ('cd', 100)[1] + 36)]:
            revert with 'NH{q', 50
        _751 = mem[(32 * var126006 + 1) + 128]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 135] = 0
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 167] = _747
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 199] = address(_751)
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 231] = 128
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 263] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]
        mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])] = mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 131 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
        if ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]) <= mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99]:
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var147001 == -1:
                revert with 'NH{q', 17
            # nil
        else:
            mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99] + 295] = 0
            require ext_code.size(var126005)
            call var126005.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _747, address(_751), 128, mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99], mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 295 len ceil32(mem[ceil32(32 * cd[(cd[100] + ('cd', 100)[1] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + ceil32(32 * cd[(cd[100] + ('cd', 100)[3] + 36)]) + ceil32(return_data.size) + 99])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if var148001 == -1:
                revert with 'NH{q', 17
            # nil
}

function sub_850b46c0(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _154 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _155 = mem[_154]
        if mem[_154]:
            if sub_fcb53d36 <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _161 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _163 = mem[_161]
                if mem[_161]:
                    mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                    mem[32] = 1
                    if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                        revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                    if not address(cd[((32 * idx) + cd[4] + 36)]):
                        call owner with:
                           value _163 wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[mem[64] + 4] = owner
                        mem[mem[64] + 36] = _163
                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                        call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args owner, _163
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _185 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_185] == bool(mem[_185])
            else:
                mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                mem[32] = 7
                if not stor7[address(cd[((32 * idx) + cd[4] + 36)])]:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _162 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _164 = mem[_162]
                    if mem[_162]:
                        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                        mem[32] = 1
                        if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                            revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                        if not address(cd[((32 * idx) + cd[4] + 36)]):
                            call owner with:
                               value _164 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[mem[64] + 4] = owner
                            mem[mem[64] + 36] = _164
                            require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                            call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args owner, _164
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _186 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_186] == bool(mem[_186])
                else:
                    if _155 and sub_fcb53d36 > -1 / _155:
                        revert with 'NH{q', 17
                    if not _155 * sub_fcb53d36 / 1000:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _181 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _187 = mem[_181]
                        if mem[_181]:
                            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                            mem[32] = 1
                            if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                            if not address(cd[((32 * idx) + cd[4] + 36)]):
                                call owner with:
                                   value _187 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[mem[64] + 4] = owner
                                mem[mem[64] + 36] = _187
                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args owner, _187
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _208 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_208] == bool(mem[_208])
                    else:
                        if WMATICAddress == address(cd[((32 * idx) + cd[4] + 36)]):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                            staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _188 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _192 = mem[_188]
                            if mem[_188]:
                                mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                mem[32] = 1
                                if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                    revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                if not address(cd[((32 * idx) + cd[4] + 36)]):
                                    call owner with:
                                       value _192 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[mem[64] + 4] = owner
                                    mem[mem[64] + 36] = _192
                                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                    call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args owner, _192
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _214 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_214] == bool(mem[_214])
                        else:
                            mem[mem[64] + 4] = address(cd[((32 * idx) + cd[4] + 36)])
                            mem[mem[64] + 36] = WMATICAddress
                            require ext_code.size(sub_67491cb9Address)
                            staticcall sub_67491cb9Address.getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(cd[((32 * idx) + cd[4] + 36)]), WMATICAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _184 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_184] == mem[_184 + 12 len 20]
                            if not mem[_184 + 12 len 20]:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _212 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _216 = mem[_212]
                                if mem[_212]:
                                    mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                    mem[32] = 1
                                    if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                        revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                    if not address(cd[((32 * idx) + cd[4] + 36)]):
                                        call owner with:
                                           value _216 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[mem[64] + 4] = owner
                                        mem[mem[64] + 36] = _216
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args owner, _216
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _228 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_228] == bool(mem[_228])
                            else:
                                _201 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_201]:
                                    revert with 'NH{q', 50
                                mem[_201 + 32] = address(cd[((32 * idx) + cd[4] + 36)])
                                if 1 >= mem[_201]:
                                    revert with 'NH{q', 50
                                mem[_201 + 64] = WMATICAddress
                                mem[_201 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_201 + 100] = _155 * sub_fcb53d36 / 1000
                                mem[_201 + 132] = 64
                                mem[_201 + 164] = mem[_201]
                                s = 0
                                t = _201 + 32
                                u = _201 + 196
                                while s < mem[_201]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(sub_5fdba4b7Address)
                                staticcall sub_5fdba4b7Address.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _201 + (32 * mem[_201]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _305 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _306 = mem[_305]
                                require mem[_305] <= test266151307()
                                require _305 + return_data.size > _305 + mem[_305] + 31
                                _307 = mem[_305 + mem[_305]]
                                if mem[_305 + mem[_305]] > test266151307():
                                    revert with 'NH{q', 65
                                if ceil32(32 * mem[_305 + mem[_305]]) + 1 < 0 or _305 + ceil32(return_data.size) + ceil32(32 * mem[_305 + mem[_305]]) + 1 > test266151307():
                                    revert with 'NH{q', 65
                                mem[64] = _305 + ceil32(return_data.size) + ceil32(32 * mem[_305 + mem[_305]]) + 1
                                mem[_305 + ceil32(return_data.size)] = _307
                                require _306 + (32 * _307) + 32 <= return_data.size
                                t = _305 + _306 + 32
                                u = _305 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _307:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                if 1 >= _307:
                                    revert with 'NH{q', 50
                                if mem[_305 + ceil32(return_data.size) + 64] <= 0:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _390 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _392 = mem[_390]
                                    if mem[_390]:
                                        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                        mem[32] = 1
                                        if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                            revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                        if not address(cd[((32 * idx) + cd[4] + 36)]):
                                            call owner with:
                                               value _392 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        else:
                                            mem[mem[64] + 4] = owner
                                            mem[mem[64] + 36] = _392
                                            require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                            call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args owner, _392
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _407 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_407] == bool(mem[_407])
                                else:
                                    if 0 >= _307:
                                        revert with 'NH{q', 50
                                    _384 = mem[_305 + ceil32(return_data.size) + 32]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = sub_5fdba4b7Address
                                    require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).allowance(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args this.address, sub_5fdba4b7Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _389 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_389] >= _384:
                                        if 1 >= _307:
                                            revert with 'NH{q', 50
                                        _396 = mem[_305 + ceil32(return_data.size) + 64]
                                        if 3600 > !block.timestamp:
                                            revert with 'NH{q', 17
                                        _402 = mem[64]
                                        mem[mem[64]] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _155 * sub_fcb53d36 / 1000
                                        mem[mem[64] + 36] = _396
                                        mem[mem[64] + 68] = 160
                                        _406 = mem[_201]
                                        mem[mem[64] + 164] = mem[_201]
                                        s = 0
                                        t = _201 + 32
                                        u = mem[64] + 196
                                        while s < _406:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_402 + 100] = feeReceiverAddress
                                        mem[_402 + 132] = block.timestamp + 3600
                                        require ext_code.size(sub_5fdba4b7Address)
                                        call sub_5fdba4b7Address.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _402 + (32 * _406) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _455 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _457 = mem[_455]
                                        require mem[_455] <= test266151307()
                                        require _455 + return_data.size > _455 + mem[_455] + 31
                                        _459 = mem[_455 + mem[_455]]
                                        if mem[_455 + mem[_455]] > test266151307():
                                            revert with 'NH{q', 65
                                        if ceil32(32 * mem[_455 + mem[_455]]) + 1 < 0 or _455 + ceil32(return_data.size) + ceil32(32 * mem[_455 + mem[_455]]) + 1 > test266151307():
                                            revert with 'NH{q', 65
                                        mem[64] = _455 + ceil32(return_data.size) + ceil32(32 * mem[_455 + mem[_455]]) + 1
                                        mem[_455 + ceil32(return_data.size)] = _459
                                        require _457 + (32 * _459) + 32 <= return_data.size
                                        t = _455 + _457 + 32
                                        u = _455 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _459:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _495 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _497 = mem[_495]
                                        if mem[_495]:
                                            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                            mem[32] = 1
                                            if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                                revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                            if not address(cd[((32 * idx) + cd[4] + 36)]):
                                                call owner with:
                                                   value _497 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            else:
                                                mem[mem[64] + 4] = owner
                                                mem[mem[64] + 36] = _497
                                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                                call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args owner, _497
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _511 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_511] == bool(mem[_511])
                                    else:
                                        mem[mem[64] + 4] = sub_5fdba4b7Address
                                        mem[mem[64] + 36] = -1
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        call address(cd[((32 * idx) + cd[4] + 36)]).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args sub_5fdba4b7Address, -1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _398 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_398] == bool(mem[_398])
                                        if 1 >= _307:
                                            revert with 'NH{q', 50
                                        _412 = mem[_305 + ceil32(return_data.size) + 64]
                                        if 3600 > !block.timestamp:
                                            revert with 'NH{q', 17
                                        mem[mem[64]] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _155 * sub_fcb53d36 / 1000
                                        mem[mem[64] + 36] = _412
                                        mem[mem[64] + 68] = 160
                                        _416 = mem[_201]
                                        mem[mem[64] + 164] = mem[_201]
                                        s = 0
                                        t = _201 + 32
                                        u = mem[64] + 196
                                        while s < _416:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[mem[64] + 100] = feeReceiverAddress
                                        mem[mem[64] + 132] = block.timestamp + 3600
                                        require ext_code.size(sub_5fdba4b7Address)
                                        call sub_5fdba4b7Address.swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args _155 * sub_fcb53d36 / 1000, _412, 160, feeReceiverAddress, block.timestamp + 3600, mem[mem[64] + 164 len (32 * _416) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _456 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _458 = mem[_456]
                                        require mem[_456] <= test266151307()
                                        require _456 + return_data.size > _456 + mem[_456] + 31
                                        _460 = mem[_456 + mem[_456]]
                                        if mem[_456 + mem[_456]] > test266151307():
                                            revert with 'NH{q', 65
                                        if ceil32(32 * mem[_456 + mem[_456]]) + 1 < 0 or _456 + ceil32(return_data.size) + ceil32(32 * mem[_456 + mem[_456]]) + 1 > test266151307():
                                            revert with 'NH{q', 65
                                        mem[64] = _456 + ceil32(return_data.size) + ceil32(32 * mem[_456 + mem[_456]]) + 1
                                        mem[_456 + ceil32(return_data.size)] = _460
                                        require _458 + (32 * _460) + 32 <= return_data.size
                                        t = _456 + _458 + 32
                                        u = _456 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _460:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                        staticcall address(cd[((32 * idx) + cd[4] + 36)]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _496 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _498 = mem[_496]
                                        if mem[_496]:
                                            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                            mem[32] = 1
                                            if stor1[address(cd[((32 * idx) + cd[4] + 36)])]:
                                                revert with 0, 'TokenRecover#recover: Cannot recover tokens from the denylist'
                                            if not address(cd[((32 * idx) + cd[4] + 36)]):
                                                call owner with:
                                                   value _498 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            else:
                                                mem[mem[64] + 4] = owner
                                                mem[mem[64] + 36] = _498
                                                require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
                                                call address(cd[((32 * idx) + cd[4] + 36)]).transfer(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args owner, _498
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _512 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_512] == bool(mem[_512])
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
}

function sub_e6ac556a(?) payable {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 'NH{q', 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if ('cd', 4).length < 1:
        revert with 'NH{q', 17
    if ('cd', 4).length - 1 >= ('cd', 4).length:
        revert with 'NH{q', 50
    _519 = mem[(32 * ('cd', 4).length - 1) + 128]
    if ('cd', 68).length < 1:
        revert with 'NH{q', 17
    if ('cd', 68).length - 1 >= ('cd', 68).length:
        revert with 'NH{q', 50
    require ext_code.size(mem[(32 * ('cd', 4).length - 1) + 140 len 20])
    if 0 == mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]:
        staticcall mem[(32 * ('cd', 4).length - 1) + 140 len 20].token1() with:
                gas gas_remaining wei
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 103] = this.address
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 135] = address(_519)
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args this.address, address(_519)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _559 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                var94001 = ('cd', 68).length
                var94002 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 130
                var94007 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _559
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _559, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
            else:
                _561 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                var94001 = ('cd', 68).length
                var94002 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 130
                var94007 = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _561
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _561, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
        else:
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 103] = address(_519)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 135] = -1
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(_519), -1
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _595 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _595
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _595, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
            else:
                _597 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _597
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _597, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
    else:
        staticcall mem[(32 * ('cd', 4).length - 1) + 140 len 20].token0() with:
                gas gas_remaining wei
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 103] = this.address
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 135] = address(_519)
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args this.address, address(_519)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 99] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _566 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _566
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _566, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
            else:
                _568 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _568
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _568, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99])]
        else:
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 103] = address(_519)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 135] = -1
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(_519), -1
            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 99] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if ('cd', 68).length < 1:
                revert with 'NH{q', 17
            if ('cd', 68).length - 1 >= ('cd', 68).length:
                revert with 'NH{q', 50
            if ('cd', 36).length < 1:
                revert with 'NH{q', 17
            if ('cd', 36).length - 1 >= ('cd', 36).length:
                revert with 'NH{q', 50
            if mem[(32 * ('cd', 68).length - 1) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] != 0:
                _605 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = _605
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _605, 0, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
            else:
                _607 = mem[(32 * ('cd', 36).length - 1) + ceil32(32 * ('cd', 4).length) + 129]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131] = address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 163] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 259] = ('cd', 4).length
                idx = 0
                s = 128
                t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 291
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 195] = (32 * ('cd', 4).length) + 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 291] = ('cd', 36).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + 323 len 32 * ('cd', 36).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 36).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 227] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 323] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 355 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 32 * ('cd', 68).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 355] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 359] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 391] = _607
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 423] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 455] = 128
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 487] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 131 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
                if ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]) > mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99] + 519] = 0
                require ext_code.size(address(_519))
                call address(_519).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _607, address(this.address), 128, mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99], mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 519 len ceil32(mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(return_data.size)) + 99])]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}
