contract main {




// =====================  Runtime code  =====================


#
#  - safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4)
#
const DEFAULT_ADMIN_ROLE = 0

const MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6

const PAUSER_ROLE = 0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a

const BASE = 10000


uint256 stor0;
uint16 stor1;
mapping of struct roleAdmin;
array of struct roleMember;
array of struct stor7;
array of struct stor8;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor12;
mapping of uint256 tokenOfOwnerByIndex;
mapping of uint256 stor14;
array of uint256 tokenByIndex;
mapping of uint256 stor16;
uint8 stor17;
address owner;
uint256 mintPrice;
uint8 maxPerMint; offset 16
uint16 maxSupply;
uint16 stor22; offset 168
address sub_50f80d52Address; offset 24
mapping of address sub_519db647;
mapping of address sub_24ebafb3;
mapping of uint256 sub_8f53cc89;
array of address sub_4bd7ba59;
array of struct sub_14248c40;
mapping of uint8 stor28;
uint256 stor29;
array of struct stor30;
uint8 isLocked; offset 160
uint8 isMigrated; offset 168
address stor31;
array of address stor2481041784956016742021570618494952475758789857281704946240779902470294861374;

function getApproved(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function sub_14248c40(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_14248c40.length
    return sub_14248c40[arg1].field_0
}

function totalSupply() {
    return tokenByIndex.length
}

function getRoleAdmin(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return roleAdmin[arg1].field_256
}

function sub_24ebafb3(?) {
    require calldata.size - 4 >= 32
    return sub_24ebafb3[arg1]
}

function tokenOfOwnerByIndex(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if arg2 >= balanceOf[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: owner index out of bounds'
    return tokenOfOwnerByIndex[address(arg1)][arg2]
}

function sub_4bd7ba59(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_4bd7ba59.length
    return sub_4bd7ba59[arg1]
}

function tokenByIndex(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= tokenByIndex.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: global index out of bounds'
    return tokenByIndex[arg1]
}

function maxPerMint() {
    return maxPerMint
}

function sub_50f80d52(?) {
    return sub_50f80d52Address
}

function sub_519db647(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_519db647[arg1]
}

function paused() {
    return bool(stor17)
}

function sub_61ee56f9(?) {
    return sub_4bd7ba59.length
}

function ownerOf(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function mintPrice() {
    return mintPrice
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function owner() {
    return owner
}

function sub_8f53cc89(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_8f53cc89[arg1]
}

function getRoleMember(bytes32 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if arg2 >= roleMember[arg1].field_0:
        revert with 0, 50
    return roleMember[arg1][arg2].field_0
}

function hasRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return bool(roleAdmin[arg1][address(arg2)].field_0)
}

function isLocked() {
    return bool(isLocked)
}

function isMigrated() {
    return bool(isMigrated)
}

function getRoleMemberCount(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return roleMember[arg1].field_0
}

function maxSupply() {
    return maxSupply
}

function sub_e090656a(?) {
    return sub_14248c40.length
}

function destroyContract() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isMigrated:
        if isMigrated:
            revert with 0, 'Invalid migration status.'
    selfdestruct(msg.sender)
}

function _fallback() payable {
    mem[64] = 128
    if calldata.size < 4:
        require not calldata.size
    else:
        if unknown_0x6817c76c(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x31062623(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x21492351(?????) > uint32(call.func_hash) >> 224:
                    if destroyContract() <= uint32(call.func_hash) >> 224:
                        if destroyContract() == uint32(call.func_hash) >> 224:
                            require not msg.value
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if isMigrated:
                                if isMigrated:
                                    revert with 0, 'Invalid migration status.'
                            selfdestruct(msg.sender)
                        if uint32(call.func_hash) >> 224 != approve(address arg1, uint256 arg2):
                            if uint32(call.func_hash) >> 224 != unknown_0x14248c40(?????):
                                require unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                return tokenByIndex.length
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] < sub_14248c40.length
                            return sub_14248c40[cd[4]].field_0
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        if not ownerOf[cd[36]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        if address(cd[4]) == ownerOf[cd[36]]:
                            revert with 0, 'ERC721: approval to current owner'
                        if ownerOf[cd[36]] != msg.sender:
                            if not stor28[address(msg.sender)]:
                                if not stor12[stor9[cd[36]]][address(msg.sender)]:
                                    revert with 0, 'ERC721: approve caller is not owner nor approved for all'
                        approved[cd[36]] = address(cd[4])
                        if not ownerOf[cd[36]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[cd[36]], address(cd[4]), cd[36]);
                    if supportsInterface(bytes4 arg1) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == Mask(32, 224, cd[4])
                        if 0x2a55205a00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                            return True
                        if Mask(32, 224, cd[4]) != 0x1ffc9a700000000000000000000000000000000000000000000000000000000:
                            if 0x780e9d6300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                                return True
                            if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                                return True
                            if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                                return True
                            if 0x5a05180f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                                return True
                            if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                                return True
                            if 0x2a55205a00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                                return True
                        return (Mask(32, 224, cd[4]) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
                    if setMaxSupply(uint16 arg1) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == uint16(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if isLocked:
                            revert with 0, 'Locked: contract is locked.'
                        if uint16(cd[4]) > maxSupply:
                            revert with 0, 'Invalid supply.'
                        maxSupply = uint16(cd[4])
                    if uint32(call.func_hash) >> 224 != name():
                        require getApproved(uint256 arg1) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if not ownerOf[cd[4]]:
                            revert with 0, 'ERC721: approved query for nonexistent token'
                        return approved[cd[4]]
                    require not msg.value
                    if bool(stor7.length):
                        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor7.length):
                            if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor7.length):
                                if 31 < uint255(stor7.length) * 0.5:
                                    mem[160] = uint256(stor7.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor7.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor7[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[160 len ceil32(uint255(stor7.length) * 0.5)])
                                mem[160] = 256 * stor7.length.field_8
                        else:
                            if bool(stor7.length) == stor7.length.field_1 < 32:
                                revert with 0, 34
                            if stor7.length.field_1:
                                if 31 < stor7.length.field_1:
                                    mem[160] = uint256(stor7.field_0)
                                    idx = 160
                                    s = 0
                                    while stor7.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor7[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[160 len ceil32(uint255(stor7.length) * 0.5)])
                                mem[160] = 256 * stor7.length.field_8
                        mem[ceil32(uint255(stor7.length) * 0.5) + 224 len ceil32(uint255(stor7.length) * 0.5)] = mem[160 len ceil32(uint255(stor7.length) * 0.5)]
                        if ceil32(uint255(stor7.length) * 0.5) > uint255(stor7.length) * 0.5:
                            mem[(uint255(stor7.length) * 0.5) + ceil32(uint255(stor7.length) * 0.5) + 224] = 0
                        return Array(len=2 * Mask(256, -1, stor7.length), data=mem[160 len ceil32(uint255(stor7.length) * 0.5)], mem[(2 * ceil32(uint255(stor7.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor7.length) * 0.5)]), 
                    if bool(stor7.length) == stor7.length.field_1 < 32:
                        revert with 0, 34
                    if bool(stor7.length):
                        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor7.length):
                            if 31 < uint255(stor7.length) * 0.5:
                                mem[160] = uint256(stor7.field_0)
                                idx = 160
                                s = 0
                                while (uint255(stor7.length) * 0.5) + 128 > idx:
                                    mem[idx + 32] = stor7[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor7.length % 128, data=mem[160 len ceil32(stor7.length.field_1)])
                            mem[160] = 256 * stor7.length.field_8
                    else:
                        if bool(stor7.length) == stor7.length.field_1 < 32:
                            revert with 0, 34
                        if stor7.length.field_1:
                            if 31 < stor7.length.field_1:
                                mem[160] = uint256(stor7.field_0)
                                idx = 160
                                s = 0
                                while stor7.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor7[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor7.length % 128, data=mem[160 len ceil32(stor7.length.field_1)])
                            mem[160] = 256 * stor7.length.field_8
                    mem[ceil32(stor7.length.field_1) + 224 len ceil32(stor7.length.field_1)] = mem[160 len ceil32(stor7.length.field_1)]
                    if ceil32(stor7.length.field_1) > stor7.length.field_1:
                        mem[stor7.length.field_1 + ceil32(stor7.length.field_1) + 224] = 0
                    return Array(len=stor7.length % 128, data=mem[160 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 224 len 2 * ceil32(stor7.length.field_1)]), 
                if unknown_0x25e8b88f(?????) <= uint32(call.func_hash) >> 224:
                    if uint32(call.func_hash) >> 224 != unknown_0x25e8b88f(?????):
                        if unknown_0x2a55205a(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            if not ownerOf[cd[4]]:
                                revert with 0, 'This token id does not exist.'
                            if cd[36] and stor1 > -1 / cd[36]:
                                revert with 0, 17
                            return sub_24ebafb3[cd[4]], cd[36] * stor1 / 10000
                        if unknown_0x2bff884f(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if isMigrated:
                                if isMigrated:
                                    revert with 0, 'Invalid migration status.'
                            isMigrated = 1
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0x2f2ff15d(?????):
                                require unknown_0x2f745c59(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                require calldata.size - 4 >= 64
                                require cd[4] == address(cd[4])
                                if not address(cd[4]):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                if cd[36] >= balanceOf[address(cd[4])]:
                                    revert with 0, 'ERC721Enumerable: owner index out of bounds'
                                return tokenOfOwnerByIndex[address(cd[4])][cd[36]]
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require cd[36] == address(cd[36])
                            if not roleAdmin[roleAdmin[cd[4]].field_256][address(msg.sender)].field_0:
                                mem[160 len 42] = call.data[calldata.size len 42]
                                idx = 41
                                s = address(msg.sender)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= 42:
                                        revert with 0, 50
                                    mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if msg.sender + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                mem[256 len 66] = call.data[calldata.size len 66]
                                idx = 65
                                s = roleAdmin[cd[4]].field_256
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= 66:
                                        revert with 0, 50
                                    mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if roleAdmin[cd[4]].field_256 + 16384:
                                    revert with 0, 'Strings: hex length insufficient'
                                revert with 0, 32, 148, 'AccessControl: account ', mem[192 len 42], 8297, mem[320 len 66], 0, 0 >> 928, 0
                            if not roleAdmin[cd[4]][address(cd[36])].field_0:
                                roleAdmin[cd[4]][address(cd[36])].field_0 = 1
                                emit RoleGranted(cd[4], address(cd[36]), msg.sender);
                            if not roleMember[cd[4]][1][address(cd[36])].field_0:
                                roleMember[cd[4]].field_0++
                                roleMember[cd[4]][roleMember[cd[4]].field_0].field_0 = address(cd[36])
                                roleMember[cd[4]][roleMember[cd[4]].field_0].field_160 = 0
                                roleMember[cd[4]][1][address(cd[36])].field_0 = roleMember[cd[4]].field_0
                    else:
                        require calldata.size - 4 >= 32
                        require cd[4] == uint8(cd[4])
                        if not isMigrated:
                            revert with 0, 'Invalid migration status.'
                        if maxPerMint < uint8(cd[4]):
                            revert with 0, 'Too many for one transaction.'
                        if mintPrice and uint8(cd[4]) > -1 / mintPrice:
                            revert with 0, 17
                        if mintPrice * uint8(cd[4]) != msg.value:
                            revert with 0, 'The value != minting price.'
                        if stor29 > !uint8(cd[4]):
                            revert with 0, 17
                        if maxSupply < stor29 + uint8(cd[4]):
                            revert with 0, 'There are not this many tokens.'
                        if sub_519db647[address(msg.sender)]:
                            mem[0] = msg.sender
                            mem[32] = 23
                            idx = 0
                            while uint8(idx) < uint8(cd[4]):
                                stor29++
                                _11886 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_11886] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor29]:
                                    revert with 0, 'ERC721: token already minted'
                                stor16[stor29] = tokenByIndex.length
                                tokenByIndex.length++
                                tokenByIndex[tokenByIndex.length] = stor29
                                if msg.sender:
                                    if not msg.sender:
                                        if stor17:
                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = stor29
                                        mem[32] = 9
                                        ownerOf[stor29] = msg.sender
                                        emit Transfer(0, msg.sender, stor29);
                                        if ext_code.size(msg.sender):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = stor29
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11886 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, stor29, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21100 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21100] == Mask(32, 224, mem[_21100])
                                            if Mask(32, 224, mem[_21100]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not msg.sender:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(msg.sender)][stor10[address(msg.sender)]] = stor29
                                        stor14[stor29] = balanceOf[address(msg.sender)]
                                        if stor17:
                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = stor29
                                        mem[32] = 9
                                        ownerOf[stor29] = msg.sender
                                        emit Transfer(0, msg.sender, stor29);
                                        if ext_code.size(msg.sender):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = stor29
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _11886 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, stor29, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21102 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21102] == Mask(32, 224, mem[_21102])
                                            if Mask(32, 224, mem[_21102]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor16[stor29] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor16[stor29]] = tokenByIndex[tokenByIndex.length]
                                    stor16[stor15[stor15.length]] = stor16[stor29]
                                    stor16[stor29] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    if stor17:
                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = stor29
                                    mem[32] = 9
                                    ownerOf[stor29] = msg.sender
                                    emit Transfer(0, msg.sender, stor29);
                                    if ext_code.size(msg.sender):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = stor29
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _11886 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, stor29, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21104 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21104] == Mask(32, 224, mem[_21104])
                                        if Mask(32, 224, mem[_21104]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                mem[0] = stor29
                                mem[32] = 24
                                sub_24ebafb3[stor29] = sub_519db647[msg.sender]
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                continue 
                        else:
                            mem[128] = 2
                            mem[160] = sub_50f80d52Address
                            mem[192] = msg.sender
                            mem[224] = 2
                            mem[64] = 320
                            mem[256] = 5000
                            mem[288] = 5000
                            mem[320 len 3487] = code.data[20530 len 3487]
                            mem[3807] = this.address
                            mem[3839] = 96
                            mem[3903] = 2
                            idx = 0
                            s = 160
                            t = 3935
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[3871] = 192
                            mem[3999] = 2
                            idx = 0
                            s = 4031
                            t = 256
                            while idx < 2:
                                mem[s] = mem[t + 30 len 2]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            create contract with 0 wei
                                            code: code.data[20530 len 3487], address(this.address), 96, 192, 2, mem[3935 len 64], 2, mem[4031 len 64]
                            if not create.new_address:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_519db647[address(msg.sender)] = address(create.new_address)
                            sub_4bd7ba59.length++
                            stor57C3[stor26.length] = address(create.new_address)
                            mem[320] = address(create.new_address)
                            emit 0x709f7933: address(create.new_address), msg.sender
                            mem[0] = msg.sender
                            mem[32] = 23
                            idx = 0
                            while uint8(idx) < uint8(cd[4]):
                                stor29++
                                _27234 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_27234] = 0
                                if not msg.sender:
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor29]:
                                    revert with 0, 'ERC721: token already minted'
                                stor16[stor29] = tokenByIndex.length
                                tokenByIndex.length++
                                tokenByIndex[tokenByIndex.length] = stor29
                                if msg.sender:
                                    if not msg.sender:
                                        if stor17:
                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = stor29
                                        mem[32] = 9
                                        ownerOf[stor29] = msg.sender
                                        emit Transfer(0, msg.sender, stor29);
                                        if ext_code.size(msg.sender):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = stor29
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _27234 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, stor29, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33414 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33414] == Mask(32, 224, mem[_33414])
                                            if Mask(32, 224, mem[_33414]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not msg.sender:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(msg.sender)][stor10[address(msg.sender)]] = stor29
                                        stor14[stor29] = balanceOf[address(msg.sender)]
                                        if stor17:
                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                        if balanceOf[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)]++
                                        mem[0] = stor29
                                        mem[32] = 9
                                        ownerOf[stor29] = msg.sender
                                        emit Transfer(0, msg.sender, stor29);
                                        if ext_code.size(msg.sender):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = stor29
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _27234 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(msg.sender)
                                            call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, stor29, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33416 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_33416] == Mask(32, 224, mem[_33416])
                                            if Mask(32, 224, mem[_33416]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor16[stor29] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor16[stor29]] = tokenByIndex[tokenByIndex.length]
                                    stor16[stor15[stor15.length]] = stor16[stor29]
                                    stor16[stor29] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    if stor17:
                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                    if balanceOf[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)]++
                                    mem[0] = stor29
                                    mem[32] = 9
                                    ownerOf[stor29] = msg.sender
                                    emit Transfer(0, msg.sender, stor29);
                                    if ext_code.size(msg.sender):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = stor29
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _27234 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(msg.sender)
                                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, stor29, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _33418 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_33418] == Mask(32, 224, mem[_33418])
                                        if Mask(32, 224, mem[_33418]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                mem[0] = stor29
                                mem[32] = 24
                                sub_24ebafb3[stor29] = sub_519db647[msg.sender]
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                continue 
                        emit 0xda2aa9ce: uint8(cd[4]), msg.sender
                else:
                    if unknown_0x21492351(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if isMigrated:
                            if isMigrated:
                                revert with 0, 'Invalid migration status.'
                        if not ownerOf[cd[4]]:
                            revert with 0, 'This token id does not exist.'
                        if 1 > !cd[4]:
                            revert with 0, 17
                        if ownerOf[cd[4] + 1]:
                            revert with 0, 'Invalid initial supply.'
                        stor29 = cd[4]
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0x23b872dd(?????):
                            if unknown_0x248a9ca3(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 32
                                return roleAdmin[cd[4]].field_256
                            require unknown_0x24ebafb3(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            return sub_24ebafb3[cd[4]]
                        require not msg.value
                        require calldata.size - 4 >= 96
                        require cd[4] == address(cd[4])
                        require cd[36] == address(cd[36])
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: operator query for nonexistent token'
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        if ownerOf[cd[68]] != msg.sender:
                            if not ownerOf[cd[68]]:
                                revert with 0, 'ERC721: approved query for nonexistent token'
                            if approved[cd[68]] != msg.sender:
                                if not stor28[address(msg.sender)]:
                                    if not stor12[stor9[cd[68]]][address(msg.sender)]:
                                        revert with 0, 'ERC721: transfer caller is not owner nor approved'
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        if ownerOf[cd[68]] != address(cd[4]):
                            revert with 0, 'ERC721: transfer of token that is not own'
                        if not address(cd[36]):
                            revert with 0, 'ERC721: transfer to the zero address'
                        if not address(cd[4]):
                            stor16[cd[68]] = tokenByIndex.length
                            tokenByIndex.length++
                            tokenByIndex[tokenByIndex.length] = cd[68]
                        else:
                            if address(cd[4]) != address(cd[36]):
                                if not address(cd[4]):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                if balanceOf[address(cd[4])] < 1:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])] - 1 != stor14[cd[68]]:
                                    tokenOfOwnerByIndex[address(cd[4])][stor14[cd[68]]] = tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])] - 1]
                                    stor14[stor13[address(cd[4])][stor10[address(cd[4])] - 1]] = stor14[cd[68]]
                                stor14[cd[68]] = 0
                                tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])] - 1] = 0
                        if address(cd[36]):
                            if address(cd[36]) != address(cd[4]):
                                if not address(cd[36]):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(cd[36])][stor10[address(cd[36])]] = cd[68]
                                stor14[cd[68]] = balanceOf[address(cd[36])]
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor16[cd[68]] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor16[cd[68]]] = tokenByIndex[tokenByIndex.length]
                            stor16[stor15[stor15.length]] = stor16[cd[68]]
                            stor16[cd[68]] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[cd[68]] = 0
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[cd[68]], 0, cd[68]);
                        if balanceOf[address(cd[4])] < 1:
                            revert with 0, 17
                        balanceOf[address(cd[4])]--
                        if balanceOf[address(cd[36])] > -2:
                            revert with 0, 17
                        balanceOf[address(cd[36])]++
                        ownerOf[cd[68]] = address(cd[36])
                        emit Transfer(address(cd[4]), address(cd[36]), cd[68]);
            else:
                if unknown_0x4f6ccce7(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x55f804b3(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0x4f6ccce7(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if cd[4] >= tokenByIndex.length:
                                revert with 0, 'ERC721Enumerable: global index out of bounds'
                            return tokenByIndex[cd[4]]
                        if unknown_0x507e094f(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return maxPerMint
                        if unknown_0x50f80d52(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return sub_50f80d52Address
                        require unknown_0x519db647(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return sub_519db647[cd[4]]
                    if uint32(call.func_hash) >> 224 != unknown_0x55f804b3(?????):
                        if uint32(call.func_hash) >> 224 != unknown_0x56aaeb92(?????):
                            if unknown_0x5c975abb(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return bool(stor17)
                            if unknown_0x61ee56f9(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return sub_4bd7ba59.length
                            require unknown_0x6352211e(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if not ownerOf[cd[4]]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            return ownerOf[cd[4]]
                        require not msg.value
                        require calldata.size - 4 >= 96
                        require cd[4] == address(cd[4])
                        if stor0 == 2:
                            revert with 0, 'ReentrancyGuard: reentrant call'
                        stor0 = 2
                        if cd[36] > !cd[68]:
                            revert with 0, 17
                        if cd[36] + cd[68] > sub_4bd7ba59.length:
                            idx = cd[36]
                            while idx < sub_4bd7ba59.length:
                                mem[0] = 26
                                mem[128] = 0x49df728c00000000000000000000000000000000000000000000000000000000
                                mem[132] = address(cd[4])
                                require ext_code.size(sub_4bd7ba59[idx])
                                call sub_4bd7ba59[idx].0x49df728c with:
                                     gas gas_remaining wei
                                    args address(cd[4])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if cd[36] > !cd[68]:
                                revert with 0, 17
                            idx = cd[36]
                            while idx < cd[36] + cd[68]:
                                if idx >= sub_4bd7ba59.length:
                                    revert with 0, 50
                                mem[0] = 26
                                mem[128] = 0x49df728c00000000000000000000000000000000000000000000000000000000
                                mem[132] = address(cd[4])
                                require ext_code.size(sub_4bd7ba59[idx])
                                call sub_4bd7ba59[idx].0x49df728c with:
                                     gas gas_remaining wei
                                    args address(cd[4])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        stor0 = 1
                    else:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] <= test266151307()
                        require calldata.size > cd[4] + 35
                        if ('cd', 4).length > test266151307():
                            revert with 0, 65
                        if ceil32(ceil32(('cd', 4).length)) + 129 < 128 or ceil32(ceil32(('cd', 4).length)) + 129 > test266151307():
                            revert with 0, 65
                        require cd[4] + ('cd', 4).length + 36 <= calldata.size
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if isLocked:
                            revert with 0, 'Locked: contract is locked.'
                        if bool(stor30.length):
                            if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                revert with 0, 34
                            if ('cd', 4).length:
                                stor30[].field_0 = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                            else:
                                stor30.length = 0
                                idx = 0
                                while (uint255(stor30.length) * 0.5) + 31 / 32 > idx:
                                    stor30[idx].field_0 = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor30.length) == stor30.length.field_1 < 32:
                                revert with 0, 34
                            if ('cd', 4).length:
                                stor30[].field_0 = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                            else:
                                stor30.length = 0
                                idx = 0
                                while stor30.length.field_1 + 31 / 32 > idx:
                                    stor30[idx].field_0 = 0
                                    idx = idx + 1
                                    continue 
                else:
                    if unknown_0x42842e0e(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0x31062623(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require cd[4] == address(cd[4])
                            require cd[36] == bool(cd[36])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            emit 0x38bf5dda: bool(cd[36]), bool(stor28[address(cd[4])]), address(cd[4])
                            stor28[address(cd[4])] = uint8(bool(cd[36]))
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0x36568abe(?????):
                                if uint32(call.func_hash) >> 224 != unknown_0x3ccfd60b(?????):
                                    require unknown_0x3f4ba83a(?????) == uint32(call.func_hash) >> 224
                                    require not msg.value
                                    if not roleAdmin[0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a][address(msg.sender)].field_0:
                                        revert with 0, 'ERC721PresetMinterPauserAutoId: must have pauser role to unpause'
                                    if not stor17:
                                        revert with 0, 'Pausable: not paused'
                                    stor17 = 0
                                    emit Unpaused(msg.sender);
                                else:
                                    require not msg.value
                                    if stor0 == 2:
                                        revert with 0, 'ReentrancyGuard: reentrant call'
                                    stor0 = 2
                                    require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
                                    delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x386d1eb6 with:
                                         gas gas_remaining wei
                                        args 4
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    stor0 = 1
                            else:
                                require not msg.value
                                require calldata.size - 4 >= 64
                                require cd[36] == address(cd[36])
                                if address(cd[36]) != msg.sender:
                                    revert with 0, 'AccessControl: can only renounce roles for self'
                                if roleAdmin[cd[4]][address(cd[36])].field_0:
                                    roleAdmin[cd[4]][address(cd[36])].field_0 = 0
                                    emit RoleRevoked(cd[4], address(cd[36]), msg.sender);
                                if roleMember[cd[4]][1][address(cd[36])].field_0:
                                    if roleMember[cd[4]][1][address(cd[36])].field_0 < 1:
                                        revert with 0, 17
                                    if roleMember[cd[4]].field_0 < 1:
                                        revert with 0, 17
                                    if roleMember[cd[4]].field_0 - 1 != roleMember[cd[4]][1][address(cd[36])].field_0 - 1:
                                        if roleMember[cd[4]].field_0 - 1 >= roleMember[cd[4]].field_0:
                                            revert with 0, 50
                                        if roleMember[cd[4]][1][address(cd[36])].field_0 - 1 >= roleMember[cd[4]].field_0:
                                            revert with 0, 50
                                        roleMember[cd[4]][roleMember[cd[4]][1][address(cd[36])].field_0].field_0 = roleMember[cd[4]][roleMember[cd[4]].field_0].field_0
                                        roleMember[cd[4]][1][roleMember[cd[4]][roleMember[cd[4]].field_0].field_0].field_0 = roleMember[cd[4]][1][address(cd[36])].field_0
                                    if not roleMember[cd[4]].field_0:
                                        revert with 0, 49
                                    roleMember[cd[4]][roleMember[cd[4]].field_0].field_0 = 0
                                    roleMember[cd[4]].field_0--
                                    roleMember[cd[4]][1][address(cd[36])].field_0 = 0
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0x42842e0e(?????):
                            if uint32(call.func_hash) >> 224 != unknown_0x42966c68(?????):
                                if uint32(call.func_hash) >> 224 != unknown_0x49df728c(?????):
                                    require unknown_0x4bd7ba59(?????) == uint32(call.func_hash) >> 224
                                    require not msg.value
                                    require calldata.size - 4 >= 32
                                    require cd[4] < sub_4bd7ba59.length
                                    return sub_4bd7ba59[cd[4]]
                                require not msg.value
                                require calldata.size - 4 >= 32
                                require cd[4] == address(cd[4])
                                if stor0 == 2:
                                    revert with 0, 'ReentrancyGuard: reentrant call'
                                stor0 = 2
                                require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
                                delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x6ec2a423 with:
                                     gas gas_remaining wei
                                    args 4, address(cd[4])
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                stor0 = 1
                            else:
                                require not msg.value
                                require calldata.size - 4 >= 32
                                if not ownerOf[cd[4]]:
                                    revert with 0, 'ERC721: operator query for nonexistent token'
                                if not ownerOf[cd[4]]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                if ownerOf[cd[4]] != msg.sender:
                                    if not ownerOf[cd[4]]:
                                        revert with 0, 'ERC721: approved query for nonexistent token'
                                    if approved[cd[4]] != msg.sender:
                                        if not stor28[address(msg.sender)]:
                                            if not stor12[stor9[cd[4]]][address(msg.sender)]:
                                                revert with 0, 'ERC721Burnable: caller is not owner nor approved'
                                if not ownerOf[cd[4]]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                if ownerOf[cd[4]]:
                                    if not ownerOf[cd[4]]:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    if balanceOf[stor9[cd[4]]] < 1:
                                        revert with 0, 17
                                    if balanceOf[stor9[cd[4]]] - 1 != stor14[cd[4]]:
                                        tokenOfOwnerByIndex[stor9[cd[4]]][stor14[cd[4]]] = tokenOfOwnerByIndex[stor9[cd[4]]][stor10[stor9[cd[4]]] - 1]
                                        stor14[stor13[stor9[cd[4]]][stor10[stor9[cd[4]]] - 1]] = stor14[cd[4]]
                                    stor14[cd[4]] = 0
                                    tokenOfOwnerByIndex[stor9[cd[4]]][stor10[stor9[cd[4]]] - 1] = 0
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor16[cd[4]] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor16[cd[4]]] = tokenByIndex[tokenByIndex.length]
                                stor16[stor15[stor15.length]] = stor16[cd[4]]
                                stor16[cd[4]] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[cd[4]] = 0
                                if not ownerOf[cd[4]]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[cd[4]], 0, cd[4]);
                                if balanceOf[stor9[cd[4]]] < 1:
                                    revert with 0, 17
                                balanceOf[stor9[cd[4]]]--
                                ownerOf[cd[4]] = 0
                                emit Transfer(ownerOf[cd[4]], 0, cd[4]);
                        else:
                            require not msg.value
                            require calldata.size - 4 >= 96
                            require cd[4] == address(cd[4])
                            require cd[36] == address(cd[36])
                            mem[128] = 0
                            if not ownerOf[cd[68]]:
                                revert with 0, 'ERC721: operator query for nonexistent token'
                            if not ownerOf[cd[68]]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            if ownerOf[cd[68]] != msg.sender:
                                if not ownerOf[cd[68]]:
                                    revert with 0, 'ERC721: approved query for nonexistent token'
                                if approved[cd[68]] != msg.sender:
                                    if not stor28[address(msg.sender)]:
                                        if not stor12[stor9[cd[68]]][address(msg.sender)]:
                                            revert with 0, 'ERC721: transfer caller is not owner nor approved'
                            if not ownerOf[cd[68]]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            if ownerOf[cd[68]] != address(cd[4]):
                                revert with 0, 'ERC721: transfer of token that is not own'
                            if not address(cd[36]):
                                revert with 0, 'ERC721: transfer to the zero address'
                            if not address(cd[4]):
                                stor16[cd[68]] = tokenByIndex.length
                                tokenByIndex.length++
                                tokenByIndex[tokenByIndex.length] = cd[68]
                            else:
                                if address(cd[4]) != address(cd[36]):
                                    if not address(cd[4]):
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    if balanceOf[address(cd[4])] < 1:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])] - 1 != stor14[cd[68]]:
                                        tokenOfOwnerByIndex[address(cd[4])][stor14[cd[68]]] = tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])] - 1]
                                        stor14[stor13[address(cd[4])][stor10[address(cd[4])] - 1]] = stor14[cd[68]]
                                    stor14[cd[68]] = 0
                                    tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])] - 1] = 0
                            if address(cd[36]):
                                if address(cd[36]) != address(cd[4]):
                                    if not address(cd[36]):
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(cd[36])][stor10[address(cd[36])]] = cd[68]
                                    stor14[cd[68]] = balanceOf[address(cd[36])]
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor16[cd[68]] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor16[cd[68]]] = tokenByIndex[tokenByIndex.length]
                                stor16[stor15[stor15.length]] = stor16[cd[68]]
                                stor16[cd[68]] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[cd[68]] = 0
                            if not ownerOf[cd[68]]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[cd[68]], 0, cd[68]);
                            if balanceOf[address(cd[4])] < 1:
                                revert with 0, 17
                            balanceOf[address(cd[4])]--
                            if balanceOf[address(cd[36])] > -2:
                                revert with 0, 17
                            balanceOf[address(cd[36])]++
                            ownerOf[cd[68]] = address(cd[36])
                            emit Transfer(address(cd[4]), address(cd[36]), cd[68]);
                            if ext_code.size(address(cd[36])):
                                mem[164] = msg.sender
                                mem[196] = address(cd[4])
                                mem[228] = cd[68]
                                mem[260] = 128
                                mem[292] = 0
                                mem[324 len 0] = None
                                require ext_code.size(address(cd[36]))
                                call address(cd[36]).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(cd[4]), cd[68], 128, 0
                                mem[160] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        else:
            if unknown_0xab62a884(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x9010d07c(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x753868e3(?????) <= uint32(call.func_hash) >> 224:
                        if unknown_0x753868e3(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if isLocked:
                                revert with 0, 'Locked: contract is locked.'
                            isLocked = 1
                        if unknown_0x8456cb59(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            if not roleAdmin[0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a][address(msg.sender)].field_0:
                                revert with 0, 'ERC721PresetMinterPauserAutoId: must have pauser role to pause'
                            if stor17:
                                revert with 0, 'Pausable: paused'
                            stor17 = 1
                            emit Paused(msg.sender);
                        if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return owner
                        require unknown_0x8f53cc89(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return sub_8f53cc89[cd[4]]
                    if unknown_0x6817c76c(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return mintPrice
                    if unknown_0x6a627842(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        revert with 0, 'The mint() function is not allowed.'
                    if unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        if not address(cd[4]):
                            revert with 0, 'ERC721: balance query for the zero address'
                        return balanceOf[address(cd[4])]
                    require unknown_0x715018a6(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    owner = 0
                    emit OwnershipTransferred(owner, 0);
                else:
                    if unknown_0x9bdedea5(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0x9010d07c(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            if cd[36] >= roleMember[cd[4]].field_0:
                                revert with 0, 50
                            return roleMember[cd[4]][cd[36]].field_0
                        if unknown_0x904e46e1(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == address(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if isLocked:
                                revert with 0, 'Locked: contract is locked.'
                            stor31 = address(cd[4])
                        if unknown_0x91d14854(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require cd[36] == address(cd[36])
                            return bool(roleAdmin[cd[4]][address(cd[36])].field_0)
                        require unknown_0x95d89b41(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        if bool(stor8.length):
                            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor8.length):
                                if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor8.length):
                                    if 31 < uint255(stor8.length) * 0.5:
                                        mem[160] = uint256(stor8.field_0)
                                        idx = 160
                                        s = 0
                                        while (uint255(stor8.length) * 0.5) + 128 > idx:
                                            mem[idx + 32] = stor8[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[160 len ceil32(uint255(stor8.length) * 0.5)])
                                    mem[160] = 256 * stor8.length.field_8
                            else:
                                if bool(stor8.length) == stor8.length.field_1 < 32:
                                    revert with 0, 34
                                if stor8.length.field_1:
                                    if 31 < stor8.length.field_1:
                                        mem[160] = uint256(stor8.field_0)
                                        idx = 160
                                        s = 0
                                        while stor8.length.field_1 + 128 > idx:
                                            mem[idx + 32] = stor8[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[160 len ceil32(uint255(stor8.length) * 0.5)])
                                    mem[160] = 256 * stor8.length.field_8
                            mem[ceil32(uint255(stor8.length) * 0.5) + 224 len ceil32(uint255(stor8.length) * 0.5)] = mem[160 len ceil32(uint255(stor8.length) * 0.5)]
                            if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
                                mem[(uint255(stor8.length) * 0.5) + ceil32(uint255(stor8.length) * 0.5) + 224] = 0
                            return Array(len=2 * Mask(256, -1, stor8.length), data=mem[160 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
                        if bool(stor8.length) == stor8.length.field_1 < 32:
                            revert with 0, 34
                        if bool(stor8.length):
                            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor8.length):
                                if 31 < uint255(stor8.length) * 0.5:
                                    mem[160] = uint256(stor8.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor8.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor8[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=stor8.length % 128, data=mem[160 len ceil32(stor8.length.field_1)])
                                mem[160] = 256 * stor8.length.field_8
                        else:
                            if bool(stor8.length) == stor8.length.field_1 < 32:
                                revert with 0, 34
                            if stor8.length.field_1:
                                if 31 < stor8.length.field_1:
                                    mem[160] = uint256(stor8.field_0)
                                    idx = 160
                                    s = 0
                                    while stor8.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor8[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=stor8.length % 128, data=mem[160 len ceil32(stor8.length.field_1)])
                                mem[160] = 256 * stor8.length.field_8
                        mem[ceil32(stor8.length.field_1) + 224 len ceil32(stor8.length.field_1)] = mem[160 len ceil32(stor8.length.field_1)]
                        if ceil32(stor8.length.field_1) > stor8.length.field_1:
                            mem[stor8.length.field_1 + ceil32(stor8.length.field_1) + 224] = 0
                        return Array(len=stor8.length % 128, data=mem[160 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 224 len 2 * ceil32(stor8.length.field_1)]), 
                    if uint32(call.func_hash) >> 224 != unknown_0x9bdedea5(?????):
                        if unknown_0xa217fddf(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return 0
                        if unknown_0xa22cb465(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require cd[4] == address(cd[4])
                            require cd[36] == bool(cd[36])
                            if msg.sender == address(cd[4]):
                                revert with 0, 'ERC721: approve to caller'
                            stor12[msg.sender][address(cd[4])] = uint8(bool(cd[36]))
                            emit ApprovalForAll(bool(cd[36]), msg.sender, address(cd[4]));
                        if unknown_0xa4e2d634(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return bool(isLocked)
                        require unknown_0xaaf6d56d(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        mem[64] = (32 * sub_14248c40.length) + 160
                        mem[128] = sub_14248c40.length
                        if not sub_14248c40.length:
                            mem[(32 * sub_14248c40.length) + 160] = 32
                            mem[(32 * sub_14248c40.length) + 192] = sub_14248c40.length
                            idx = 0
                            s = 160
                            t = (32 * sub_14248c40.length) + 224
                            while idx < sub_14248c40.length:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            return memory
                              from (32 * sub_14248c40.length) + 160
                               len (96 * sub_14248c40.length) + 64
                        mem[160] = address(sub_14248c40.field_0)
                        idx = 160
                        s = 0
                        while (32 * sub_14248c40.length) + 128 > idx:
                            mem[idx + 32] = sub_14248c40[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[(32 * sub_14248c40.length) + 160] = 32
                        mem[(32 * sub_14248c40.length) + 192] = sub_14248c40.length
                        idx = 0
                        s = 160
                        t = mem[64] + 64
                        while idx < sub_14248c40.length:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        return memory
                          from mem[64]
                           len (64 * sub_14248c40.length) + -mem[64] + 224
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] <= test266151307()
                    require cd[36] + 35 < calldata.size
                    if ('cd', 36).length > test266151307():
                        revert with 0, 65
                    if ceil32(32 * ('cd', 36).length) + 129 < 128 or ceil32(32 * ('cd', 36).length) + 129 > test266151307():
                        revert with 0, 65
                    mem[128] = ('cd', 36).length
                    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
                    idx = cd[36] + 36
                    s = 160
                    while idx < cd[36] + (32 * ('cd', 36).length) + 36:
                        mem[s] = cd[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if stor0 == 2:
                        revert with 0, 'ReentrancyGuard: reentrant call'
                    stor0 = 2
                    mem[ceil32(32 * ('cd', 36).length) + 129] = 0x3af5509c00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 36).length) + 133] = 4
                    require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
                    delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x3af5509c with:
                         gas gas_remaining wei
                        args 4, address(cd[4]), Array(len=('cd', 36).length, data=mem[160 len 32 * ('cd', 36).length])
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    stor0 = 1
            else:
                if unknown_0xd5abeb01(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0xe74bdd0a(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0xd5abeb01(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return maxSupply
                        if uint32(call.func_hash) >> 224 != unknown_0xd8a778e9(?????):
                            if unknown_0xe090656a(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return sub_14248c40.length
                            require unknown_0xe63ab1e9(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            return 0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] <= test266151307()
                        require cd[4] + 35 < calldata.size
                        if ('cd', 4).length > test266151307():
                            revert with 0, 65
                        if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                            revert with 0, 65
                        require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                        idx = cd[4] + 36
                        s = 160
                        while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                            require cd[idx] == address(cd[idx])
                            mem[s] = cd[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        sub_14248c40.length = ('cd', 4).length
                        if not ('cd', 4).length:
                            idx = 0
                            while sub_14248c40.length > idx:
                                sub_14248c40[idx].field_0 = 0
                                idx = idx + 1
                                continue 
                        else:
                            s = 0
                            idx = 160
                            while (32 * ('cd', 4).length) + 160 > idx:
                                sub_14248c40[s].field_0 = mem[idx + 12 len 20]
                                s = s + 1
                                idx = idx + 32
                                continue 
                            idx = Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5
                            while sub_14248c40.length > idx:
                                sub_14248c40[idx].field_0 = 0
                                idx = idx + 1
                                continue 
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0xe74bdd0a(?????):
                            if unknown_0xe985e9c5(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 64
                                require cd[4] == address(cd[4])
                                require cd[36] == address(cd[36])
                                if not stor28[address(cd[36])]:
                                    return bool(stor12[address(cd[4])][address(cd[36])])
                                return 1
                            if unknown_0xec342ad0(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return 10000
                            if unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 32
                                require cd[4] == address(cd[4])
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                if not address(cd[4]):
                                    revert with 0, 'Ownable: new owner is the zero address'
                                owner = address(cd[4])
                                emit OwnershipTransferred(owner, address(cd[4]));
                            else:
                                require unknown_0xfeec756c(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                require calldata.size - 4 >= 32
                                require cd[4] == address(cd[4])
                                if stor0 == 2:
                                    revert with 0, 'ReentrancyGuard: reentrant call'
                                stor0 = 2
                                require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
                                delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x1625d8ba with:
                                     gas gas_remaining wei
                                    args 4, address(cd[4])
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                stor0 = 1
                        else:
                            require not msg.value
                            require calldata.size - 4 >= 96
                            require cd[4] <= test266151307()
                            require cd[4] + 35 < calldata.size
                            if ('cd', 4).length > test266151307():
                                revert with 0, 65
                            if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                                revert with 0, 65
                            mem[128] = ('cd', 4).length
                            require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                            idx = cd[4] + 36
                            s = 160
                            while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                                mem[s] = cd[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            require cd[36] <= test266151307()
                            require cd[36] + 35 < calldata.size
                            if ('cd', 36).length > test266151307():
                                revert with 0, 65
                            if ceil32(32 * ('cd', 36).length) + 130 < 129 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 > test266151307():
                                revert with 0, 65
                            mem[ceil32(32 * ('cd', 4).length) + 129] = ('cd', 36).length
                            require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
                            idx = cd[36] + 36
                            s = ceil32(32 * ('cd', 4).length) + 161
                            while idx < cd[36] + (32 * ('cd', 36).length) + 36:
                                require cd[idx] == address(cd[idx])
                                mem[s] = cd[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            require cd[68] <= test266151307()
                            require cd[68] + 35 < calldata.size
                            if ('cd', 68).length > test266151307():
                                revert with 0, 65
                            if ceil32(32 * ('cd', 68).length) + 131 < 130 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 > test266151307():
                                revert with 0, 65
                            mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] = ('cd', 68).length
                            require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
                            idx = cd[68] + 36
                            s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                            while idx < cd[68] + (32 * ('cd', 68).length) + 36:
                                require cd[idx] == address(cd[idx])
                                mem[s] = cd[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not isMigrated:
                                if ('cd', 4).length != ('cd', 36).length:
                                    revert with 0, 'Mismatched array lengths.'
                                if ('cd', 4).length != ('cd', 68).length:
                                    revert with 0, 'Mismatched array lengths.'
                                idx = 0
                                while idx < ('cd', 4).length:
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                        revert with 0, 50
                                    _32782 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]:
                                        revert with 0, 50
                                    _32818 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162]
                                    if idx >= mem[128]:
                                        revert with 0, 50
                                    _33024 = mem[(32 * idx) + 160]
                                    _33025 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_33025] = 0
                                    if not ownerOf[_33024]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    if ownerOf[_33024] != address(_32782):
                                        revert with 0, 'ERC721: transfer of token that is not own'
                                    if not address(_32818):
                                        revert with 0, 'ERC721: transfer to the zero address'
                                    if not address(_32782):
                                        stor16[_33024] = tokenByIndex.length
                                        tokenByIndex.length++
                                        tokenByIndex[tokenByIndex.length] = _33024
                                        if address(_32818):
                                            if address(_32818) == address(_32782):
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                approved[_33024] = 0
                                                if not ownerOf[_33024]:
                                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                                emit Approval(ownerOf[_33024], 0, _33024);
                                                if balanceOf[address(_32782)] < 1:
                                                    revert with 0, 17
                                                balanceOf[address(_32782)]--
                                                if balanceOf[address(_32818)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_32818)]++
                                                mem[0] = _33024
                                                mem[32] = 9
                                                ownerOf[_33024] = address(_32818)
                                                emit Transfer(address(_32782), address(_32818), _33024);
                                                if ext_code.size(address(_32818)):
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = address(_32782)
                                                    mem[mem[64] + 68] = _33024
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_32818))
                                                    call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, address(_32782), _33024, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _37634 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_37634] == Mask(32, 224, mem[_37634])
                                                    if Mask(32, 224, mem[_37634]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                if not address(_32818):
                                                    revert with 0, 'ERC721: balance query for the zero address'
                                                tokenOfOwnerByIndex[address(_32818)][stor10[address(_32818)]] = _33024
                                                stor14[_33024] = balanceOf[address(_32818)]
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                approved[_33024] = 0
                                                if not ownerOf[_33024]:
                                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                                emit Approval(ownerOf[_33024], 0, _33024);
                                                if balanceOf[address(_32782)] < 1:
                                                    revert with 0, 17
                                                balanceOf[address(_32782)]--
                                                if balanceOf[address(_32818)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_32818)]++
                                                mem[0] = _33024
                                                mem[32] = 9
                                                ownerOf[_33024] = address(_32818)
                                                emit Transfer(address(_32782), address(_32818), _33024);
                                                if ext_code.size(address(_32818)):
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = address(_32782)
                                                    mem[mem[64] + 68] = _33024
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_32818))
                                                    call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, address(_32782), _33024, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _37636 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_37636] == Mask(32, 224, mem[_37636])
                                                    if Mask(32, 224, mem[_37636]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            if tokenByIndex.length < 1:
                                                revert with 0, 17
                                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                revert with 0, 50
                                            if stor16[_33024] >= tokenByIndex.length:
                                                revert with 0, 50
                                            tokenByIndex[stor16[_33024]] = tokenByIndex[tokenByIndex.length]
                                            stor16[stor15[stor15.length]] = stor16[_33024]
                                            stor16[_33024] = 0
                                            if not tokenByIndex.length:
                                                revert with 0, 49
                                            tokenByIndex[tokenByIndex.length] = 0
                                            tokenByIndex.length--
                                            if stor17:
                                                revert with 0, 'ERC721Pausable: token transfer while paused'
                                            approved[_33024] = 0
                                            if not ownerOf[_33024]:
                                                revert with 0, 'ERC721: owner query for nonexistent token'
                                            emit Approval(ownerOf[_33024], 0, _33024);
                                            if balanceOf[address(_32782)] < 1:
                                                revert with 0, 17
                                            balanceOf[address(_32782)]--
                                            if balanceOf[address(_32818)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(_32818)]++
                                            mem[0] = _33024
                                            mem[32] = 9
                                            ownerOf[_33024] = address(_32818)
                                            emit Transfer(address(_32782), address(_32818), _33024);
                                            if ext_code.size(address(_32818)):
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = address(_32782)
                                                mem[mem[64] + 68] = _33024
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(_32818))
                                                call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(_32782), _33024, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _37638 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_37638] == Mask(32, 224, mem[_37638])
                                                if Mask(32, 224, mem[_37638]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if address(_32782) == address(_32818):
                                            if address(_32818):
                                                if address(_32818) == address(_32782):
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33024] = 0
                                                    if not ownerOf[_33024]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33024], 0, _33024);
                                                    if balanceOf[address(_32782)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32782)]--
                                                    if balanceOf[address(_32818)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32818)]++
                                                    mem[0] = _33024
                                                    mem[32] = 9
                                                    ownerOf[_33024] = address(_32818)
                                                    emit Transfer(address(_32782), address(_32818), _33024);
                                                    if ext_code.size(address(_32818)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32782)
                                                        mem[mem[64] + 68] = _33024
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32818))
                                                        call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32782), _33024, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37616 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37616] == Mask(32, 224, mem[_37616])
                                                        if Mask(32, 224, mem[_37616]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                else:
                                                    if not address(_32818):
                                                        revert with 0, 'ERC721: balance query for the zero address'
                                                    tokenOfOwnerByIndex[address(_32818)][stor10[address(_32818)]] = _33024
                                                    stor14[_33024] = balanceOf[address(_32818)]
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33024] = 0
                                                    if not ownerOf[_33024]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33024], 0, _33024);
                                                    if balanceOf[address(_32782)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32782)]--
                                                    if balanceOf[address(_32818)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32818)]++
                                                    mem[0] = _33024
                                                    mem[32] = 9
                                                    ownerOf[_33024] = address(_32818)
                                                    emit Transfer(address(_32782), address(_32818), _33024);
                                                    if ext_code.size(address(_32818)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32782)
                                                        mem[mem[64] + 68] = _33024
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32818))
                                                        call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32782), _33024, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37618 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37618] == Mask(32, 224, mem[_37618])
                                                        if Mask(32, 224, mem[_37618]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                if tokenByIndex.length < 1:
                                                    revert with 0, 17
                                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                    revert with 0, 50
                                                if stor16[_33024] >= tokenByIndex.length:
                                                    revert with 0, 50
                                                tokenByIndex[stor16[_33024]] = tokenByIndex[tokenByIndex.length]
                                                stor16[stor15[stor15.length]] = stor16[_33024]
                                                stor16[_33024] = 0
                                                if not tokenByIndex.length:
                                                    revert with 0, 49
                                                tokenByIndex[tokenByIndex.length] = 0
                                                tokenByIndex.length--
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                approved[_33024] = 0
                                                if not ownerOf[_33024]:
                                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                                emit Approval(ownerOf[_33024], 0, _33024);
                                                if balanceOf[address(_32782)] < 1:
                                                    revert with 0, 17
                                                balanceOf[address(_32782)]--
                                                if balanceOf[address(_32818)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_32818)]++
                                                mem[0] = _33024
                                                mem[32] = 9
                                                ownerOf[_33024] = address(_32818)
                                                emit Transfer(address(_32782), address(_32818), _33024);
                                                if ext_code.size(address(_32818)):
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = address(_32782)
                                                    mem[mem[64] + 68] = _33024
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_32818))
                                                    call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, address(_32782), _33024, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _37620 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_37620] == Mask(32, 224, mem[_37620])
                                                    if Mask(32, 224, mem[_37620]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            if not address(_32782):
                                                revert with 0, 'ERC721: balance query for the zero address'
                                            if balanceOf[address(_32782)] < 1:
                                                revert with 0, 17
                                            if balanceOf[address(_32782)] - 1 == stor14[_33024]:
                                                stor14[_33024] = 0
                                                tokenOfOwnerByIndex[address(_32782)][stor10[address(_32782)] - 1] = 0
                                                if address(_32818):
                                                    if address(_32818) == address(_32782):
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33024] = 0
                                                        if not ownerOf[_33024]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33024], 0, _33024);
                                                        if balanceOf[address(_32782)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32782)]--
                                                        if balanceOf[address(_32818)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32818)]++
                                                        mem[0] = _33024
                                                        mem[32] = 9
                                                        ownerOf[_33024] = address(_32818)
                                                        emit Transfer(address(_32782), address(_32818), _33024);
                                                        if ext_code.size(address(_32818)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32782)
                                                            mem[mem[64] + 68] = _33024
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32818))
                                                            call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32782), _33024, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37622 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37622] == Mask(32, 224, mem[_37622])
                                                            if Mask(32, 224, mem[_37622]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    else:
                                                        if not address(_32818):
                                                            revert with 0, 'ERC721: balance query for the zero address'
                                                        tokenOfOwnerByIndex[address(_32818)][stor10[address(_32818)]] = _33024
                                                        stor14[_33024] = balanceOf[address(_32818)]
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33024] = 0
                                                        if not ownerOf[_33024]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33024], 0, _33024);
                                                        if balanceOf[address(_32782)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32782)]--
                                                        if balanceOf[address(_32818)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32818)]++
                                                        mem[0] = _33024
                                                        mem[32] = 9
                                                        ownerOf[_33024] = address(_32818)
                                                        emit Transfer(address(_32782), address(_32818), _33024);
                                                        if ext_code.size(address(_32818)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32782)
                                                            mem[mem[64] + 68] = _33024
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32818))
                                                            call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32782), _33024, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37624 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37624] == Mask(32, 224, mem[_37624])
                                                            if Mask(32, 224, mem[_37624]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                else:
                                                    if tokenByIndex.length < 1:
                                                        revert with 0, 17
                                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    if stor16[_33024] >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    tokenByIndex[stor16[_33024]] = tokenByIndex[tokenByIndex.length]
                                                    stor16[stor15[stor15.length]] = stor16[_33024]
                                                    stor16[_33024] = 0
                                                    if not tokenByIndex.length:
                                                        revert with 0, 49
                                                    tokenByIndex[tokenByIndex.length] = 0
                                                    tokenByIndex.length--
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33024] = 0
                                                    if not ownerOf[_33024]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33024], 0, _33024);
                                                    if balanceOf[address(_32782)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32782)]--
                                                    if balanceOf[address(_32818)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32818)]++
                                                    mem[0] = _33024
                                                    mem[32] = 9
                                                    ownerOf[_33024] = address(_32818)
                                                    emit Transfer(address(_32782), address(_32818), _33024);
                                                    if ext_code.size(address(_32818)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32782)
                                                        mem[mem[64] + 68] = _33024
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32818))
                                                        call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32782), _33024, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37626 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37626] == Mask(32, 224, mem[_37626])
                                                        if Mask(32, 224, mem[_37626]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                tokenOfOwnerByIndex[address(_32782)][stor14[_33024]] = tokenOfOwnerByIndex[address(_32782)][stor10[address(_32782)] - 1]
                                                stor14[stor13[address(_32782)][stor10[address(_32782)] - 1]] = stor14[_33024]
                                                stor14[_33024] = 0
                                                tokenOfOwnerByIndex[address(_32782)][stor10[address(_32782)] - 1] = 0
                                                if address(_32818):
                                                    if address(_32818) == address(_32782):
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33024] = 0
                                                        if not ownerOf[_33024]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33024], 0, _33024);
                                                        if balanceOf[address(_32782)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32782)]--
                                                        if balanceOf[address(_32818)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32818)]++
                                                        mem[0] = _33024
                                                        mem[32] = 9
                                                        ownerOf[_33024] = address(_32818)
                                                        emit Transfer(address(_32782), address(_32818), _33024);
                                                        if ext_code.size(address(_32818)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32782)
                                                            mem[mem[64] + 68] = _33024
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32818))
                                                            call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32782), _33024, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37628 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37628] == Mask(32, 224, mem[_37628])
                                                            if Mask(32, 224, mem[_37628]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    else:
                                                        if not address(_32818):
                                                            revert with 0, 'ERC721: balance query for the zero address'
                                                        tokenOfOwnerByIndex[address(_32818)][stor10[address(_32818)]] = _33024
                                                        stor14[_33024] = balanceOf[address(_32818)]
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33024] = 0
                                                        if not ownerOf[_33024]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33024], 0, _33024);
                                                        if balanceOf[address(_32782)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32782)]--
                                                        if balanceOf[address(_32818)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32818)]++
                                                        mem[0] = _33024
                                                        mem[32] = 9
                                                        ownerOf[_33024] = address(_32818)
                                                        emit Transfer(address(_32782), address(_32818), _33024);
                                                        if ext_code.size(address(_32818)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32782)
                                                            mem[mem[64] + 68] = _33024
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32818))
                                                            call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32782), _33024, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37630 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37630] == Mask(32, 224, mem[_37630])
                                                            if Mask(32, 224, mem[_37630]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                else:
                                                    if tokenByIndex.length < 1:
                                                        revert with 0, 17
                                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    if stor16[_33024] >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    tokenByIndex[stor16[_33024]] = tokenByIndex[tokenByIndex.length]
                                                    stor16[stor15[stor15.length]] = stor16[_33024]
                                                    stor16[_33024] = 0
                                                    if not tokenByIndex.length:
                                                        revert with 0, 49
                                                    tokenByIndex[tokenByIndex.length] = 0
                                                    tokenByIndex.length--
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33024] = 0
                                                    if not ownerOf[_33024]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33024], 0, _33024);
                                                    if balanceOf[address(_32782)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32782)]--
                                                    if balanceOf[address(_32818)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32818)]++
                                                    mem[0] = _33024
                                                    mem[32] = 9
                                                    ownerOf[_33024] = address(_32818)
                                                    emit Transfer(address(_32782), address(_32818), _33024);
                                                    if ext_code.size(address(_32818)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32782)
                                                        mem[mem[64] + 68] = _33024
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33025 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32818))
                                                        call address(_32818).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32782), _33024, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37632 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37632] == Mask(32, 224, mem[_37632])
                                                        if Mask(32, 224, mem[_37632]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if isMigrated:
                                    revert with 0, 'Invalid migration status.'
                                if ('cd', 4).length != ('cd', 36).length:
                                    revert with 0, 'Mismatched array lengths.'
                                if ('cd', 4).length != ('cd', 68).length:
                                    revert with 0, 'Mismatched array lengths.'
                                idx = 0
                                while idx < ('cd', 4).length:
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                        revert with 0, 50
                                    _32784 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]:
                                        revert with 0, 50
                                    _32820 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162]
                                    if idx >= mem[128]:
                                        revert with 0, 50
                                    _33026 = mem[(32 * idx) + 160]
                                    _33027 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_33027] = 0
                                    if not ownerOf[_33026]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    if ownerOf[_33026] != address(_32784):
                                        revert with 0, 'ERC721: transfer of token that is not own'
                                    if not address(_32820):
                                        revert with 0, 'ERC721: transfer to the zero address'
                                    if not address(_32784):
                                        stor16[_33026] = tokenByIndex.length
                                        tokenByIndex.length++
                                        tokenByIndex[tokenByIndex.length] = _33026
                                        if address(_32820):
                                            if address(_32820) == address(_32784):
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                approved[_33026] = 0
                                                if not ownerOf[_33026]:
                                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                                emit Approval(ownerOf[_33026], 0, _33026);
                                                if balanceOf[address(_32784)] < 1:
                                                    revert with 0, 17
                                                balanceOf[address(_32784)]--
                                                if balanceOf[address(_32820)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_32820)]++
                                                mem[0] = _33026
                                                mem[32] = 9
                                                ownerOf[_33026] = address(_32820)
                                                emit Transfer(address(_32784), address(_32820), _33026);
                                                if ext_code.size(address(_32820)):
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = address(_32784)
                                                    mem[mem[64] + 68] = _33026
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_32820))
                                                    call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, address(_32784), _33026, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _37658 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_37658] == Mask(32, 224, mem[_37658])
                                                    if Mask(32, 224, mem[_37658]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                if not address(_32820):
                                                    revert with 0, 'ERC721: balance query for the zero address'
                                                tokenOfOwnerByIndex[address(_32820)][stor10[address(_32820)]] = _33026
                                                stor14[_33026] = balanceOf[address(_32820)]
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                approved[_33026] = 0
                                                if not ownerOf[_33026]:
                                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                                emit Approval(ownerOf[_33026], 0, _33026);
                                                if balanceOf[address(_32784)] < 1:
                                                    revert with 0, 17
                                                balanceOf[address(_32784)]--
                                                if balanceOf[address(_32820)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_32820)]++
                                                mem[0] = _33026
                                                mem[32] = 9
                                                ownerOf[_33026] = address(_32820)
                                                emit Transfer(address(_32784), address(_32820), _33026);
                                                if ext_code.size(address(_32820)):
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = address(_32784)
                                                    mem[mem[64] + 68] = _33026
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_32820))
                                                    call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, address(_32784), _33026, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _37660 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_37660] == Mask(32, 224, mem[_37660])
                                                    if Mask(32, 224, mem[_37660]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            if tokenByIndex.length < 1:
                                                revert with 0, 17
                                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                revert with 0, 50
                                            if stor16[_33026] >= tokenByIndex.length:
                                                revert with 0, 50
                                            tokenByIndex[stor16[_33026]] = tokenByIndex[tokenByIndex.length]
                                            stor16[stor15[stor15.length]] = stor16[_33026]
                                            stor16[_33026] = 0
                                            if not tokenByIndex.length:
                                                revert with 0, 49
                                            tokenByIndex[tokenByIndex.length] = 0
                                            tokenByIndex.length--
                                            if stor17:
                                                revert with 0, 'ERC721Pausable: token transfer while paused'
                                            approved[_33026] = 0
                                            if not ownerOf[_33026]:
                                                revert with 0, 'ERC721: owner query for nonexistent token'
                                            emit Approval(ownerOf[_33026], 0, _33026);
                                            if balanceOf[address(_32784)] < 1:
                                                revert with 0, 17
                                            balanceOf[address(_32784)]--
                                            if balanceOf[address(_32820)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(_32820)]++
                                            mem[0] = _33026
                                            mem[32] = 9
                                            ownerOf[_33026] = address(_32820)
                                            emit Transfer(address(_32784), address(_32820), _33026);
                                            if ext_code.size(address(_32820)):
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = address(_32784)
                                                mem[mem[64] + 68] = _33026
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(_32820))
                                                call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(_32784), _33026, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _37662 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_37662] == Mask(32, 224, mem[_37662])
                                                if Mask(32, 224, mem[_37662]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if address(_32784) == address(_32820):
                                            if address(_32820):
                                                if address(_32820) == address(_32784):
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33026] = 0
                                                    if not ownerOf[_33026]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33026], 0, _33026);
                                                    if balanceOf[address(_32784)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32784)]--
                                                    if balanceOf[address(_32820)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32820)]++
                                                    mem[0] = _33026
                                                    mem[32] = 9
                                                    ownerOf[_33026] = address(_32820)
                                                    emit Transfer(address(_32784), address(_32820), _33026);
                                                    if ext_code.size(address(_32820)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32784)
                                                        mem[mem[64] + 68] = _33026
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32820))
                                                        call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32784), _33026, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37640 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37640] == Mask(32, 224, mem[_37640])
                                                        if Mask(32, 224, mem[_37640]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                else:
                                                    if not address(_32820):
                                                        revert with 0, 'ERC721: balance query for the zero address'
                                                    tokenOfOwnerByIndex[address(_32820)][stor10[address(_32820)]] = _33026
                                                    stor14[_33026] = balanceOf[address(_32820)]
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33026] = 0
                                                    if not ownerOf[_33026]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33026], 0, _33026);
                                                    if balanceOf[address(_32784)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32784)]--
                                                    if balanceOf[address(_32820)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32820)]++
                                                    mem[0] = _33026
                                                    mem[32] = 9
                                                    ownerOf[_33026] = address(_32820)
                                                    emit Transfer(address(_32784), address(_32820), _33026);
                                                    if ext_code.size(address(_32820)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32784)
                                                        mem[mem[64] + 68] = _33026
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32820))
                                                        call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32784), _33026, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37642 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37642] == Mask(32, 224, mem[_37642])
                                                        if Mask(32, 224, mem[_37642]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                if tokenByIndex.length < 1:
                                                    revert with 0, 17
                                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                    revert with 0, 50
                                                if stor16[_33026] >= tokenByIndex.length:
                                                    revert with 0, 50
                                                tokenByIndex[stor16[_33026]] = tokenByIndex[tokenByIndex.length]
                                                stor16[stor15[stor15.length]] = stor16[_33026]
                                                stor16[_33026] = 0
                                                if not tokenByIndex.length:
                                                    revert with 0, 49
                                                tokenByIndex[tokenByIndex.length] = 0
                                                tokenByIndex.length--
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                approved[_33026] = 0
                                                if not ownerOf[_33026]:
                                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                                emit Approval(ownerOf[_33026], 0, _33026);
                                                if balanceOf[address(_32784)] < 1:
                                                    revert with 0, 17
                                                balanceOf[address(_32784)]--
                                                if balanceOf[address(_32820)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_32820)]++
                                                mem[0] = _33026
                                                mem[32] = 9
                                                ownerOf[_33026] = address(_32820)
                                                emit Transfer(address(_32784), address(_32820), _33026);
                                                if ext_code.size(address(_32820)):
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = address(_32784)
                                                    mem[mem[64] + 68] = _33026
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_32820))
                                                    call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, address(_32784), _33026, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _37644 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_37644] == Mask(32, 224, mem[_37644])
                                                    if Mask(32, 224, mem[_37644]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            if not address(_32784):
                                                revert with 0, 'ERC721: balance query for the zero address'
                                            if balanceOf[address(_32784)] < 1:
                                                revert with 0, 17
                                            if balanceOf[address(_32784)] - 1 == stor14[_33026]:
                                                stor14[_33026] = 0
                                                tokenOfOwnerByIndex[address(_32784)][stor10[address(_32784)] - 1] = 0
                                                if address(_32820):
                                                    if address(_32820) == address(_32784):
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33026] = 0
                                                        if not ownerOf[_33026]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33026], 0, _33026);
                                                        if balanceOf[address(_32784)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32784)]--
                                                        if balanceOf[address(_32820)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32820)]++
                                                        mem[0] = _33026
                                                        mem[32] = 9
                                                        ownerOf[_33026] = address(_32820)
                                                        emit Transfer(address(_32784), address(_32820), _33026);
                                                        if ext_code.size(address(_32820)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32784)
                                                            mem[mem[64] + 68] = _33026
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32820))
                                                            call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32784), _33026, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37646 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37646] == Mask(32, 224, mem[_37646])
                                                            if Mask(32, 224, mem[_37646]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    else:
                                                        if not address(_32820):
                                                            revert with 0, 'ERC721: balance query for the zero address'
                                                        tokenOfOwnerByIndex[address(_32820)][stor10[address(_32820)]] = _33026
                                                        stor14[_33026] = balanceOf[address(_32820)]
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33026] = 0
                                                        if not ownerOf[_33026]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33026], 0, _33026);
                                                        if balanceOf[address(_32784)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32784)]--
                                                        if balanceOf[address(_32820)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32820)]++
                                                        mem[0] = _33026
                                                        mem[32] = 9
                                                        ownerOf[_33026] = address(_32820)
                                                        emit Transfer(address(_32784), address(_32820), _33026);
                                                        if ext_code.size(address(_32820)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32784)
                                                            mem[mem[64] + 68] = _33026
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32820))
                                                            call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32784), _33026, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37648 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37648] == Mask(32, 224, mem[_37648])
                                                            if Mask(32, 224, mem[_37648]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                else:
                                                    if tokenByIndex.length < 1:
                                                        revert with 0, 17
                                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    if stor16[_33026] >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    tokenByIndex[stor16[_33026]] = tokenByIndex[tokenByIndex.length]
                                                    stor16[stor15[stor15.length]] = stor16[_33026]
                                                    stor16[_33026] = 0
                                                    if not tokenByIndex.length:
                                                        revert with 0, 49
                                                    tokenByIndex[tokenByIndex.length] = 0
                                                    tokenByIndex.length--
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33026] = 0
                                                    if not ownerOf[_33026]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33026], 0, _33026);
                                                    if balanceOf[address(_32784)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32784)]--
                                                    if balanceOf[address(_32820)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32820)]++
                                                    mem[0] = _33026
                                                    mem[32] = 9
                                                    ownerOf[_33026] = address(_32820)
                                                    emit Transfer(address(_32784), address(_32820), _33026);
                                                    if ext_code.size(address(_32820)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32784)
                                                        mem[mem[64] + 68] = _33026
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32820))
                                                        call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32784), _33026, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37650 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37650] == Mask(32, 224, mem[_37650])
                                                        if Mask(32, 224, mem[_37650]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                tokenOfOwnerByIndex[address(_32784)][stor14[_33026]] = tokenOfOwnerByIndex[address(_32784)][stor10[address(_32784)] - 1]
                                                stor14[stor13[address(_32784)][stor10[address(_32784)] - 1]] = stor14[_33026]
                                                stor14[_33026] = 0
                                                tokenOfOwnerByIndex[address(_32784)][stor10[address(_32784)] - 1] = 0
                                                if address(_32820):
                                                    if address(_32820) == address(_32784):
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33026] = 0
                                                        if not ownerOf[_33026]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33026], 0, _33026);
                                                        if balanceOf[address(_32784)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32784)]--
                                                        if balanceOf[address(_32820)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32820)]++
                                                        mem[0] = _33026
                                                        mem[32] = 9
                                                        ownerOf[_33026] = address(_32820)
                                                        emit Transfer(address(_32784), address(_32820), _33026);
                                                        if ext_code.size(address(_32820)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32784)
                                                            mem[mem[64] + 68] = _33026
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32820))
                                                            call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32784), _33026, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37652 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37652] == Mask(32, 224, mem[_37652])
                                                            if Mask(32, 224, mem[_37652]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    else:
                                                        if not address(_32820):
                                                            revert with 0, 'ERC721: balance query for the zero address'
                                                        tokenOfOwnerByIndex[address(_32820)][stor10[address(_32820)]] = _33026
                                                        stor14[_33026] = balanceOf[address(_32820)]
                                                        if stor17:
                                                            revert with 0, 'ERC721Pausable: token transfer while paused'
                                                        approved[_33026] = 0
                                                        if not ownerOf[_33026]:
                                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                                        emit Approval(ownerOf[_33026], 0, _33026);
                                                        if balanceOf[address(_32784)] < 1:
                                                            revert with 0, 17
                                                        balanceOf[address(_32784)]--
                                                        if balanceOf[address(_32820)] > -2:
                                                            revert with 0, 17
                                                        balanceOf[address(_32820)]++
                                                        mem[0] = _33026
                                                        mem[32] = 9
                                                        ownerOf[_33026] = address(_32820)
                                                        emit Transfer(address(_32784), address(_32820), _33026);
                                                        if ext_code.size(address(_32820)):
                                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = address(_32784)
                                                            mem[mem[64] + 68] = _33026
                                                            mem[mem[64] + 100] = 128
                                                            mem[mem[64] + 132] = 0
                                                            s = 0
                                                            while s < 0:
                                                                mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                                s = s + 32
                                                                continue 
                                                            require ext_code.size(address(_32820))
                                                            call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, address(_32784), _33026, 128, 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                if not return_data.size:
                                                                    if not mem[96]:
                                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                if not return_data.size:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _37654 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_37654] == Mask(32, 224, mem[_37654])
                                                            if Mask(32, 224, mem[_37654]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                else:
                                                    if tokenByIndex.length < 1:
                                                        revert with 0, 17
                                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    if stor16[_33026] >= tokenByIndex.length:
                                                        revert with 0, 50
                                                    tokenByIndex[stor16[_33026]] = tokenByIndex[tokenByIndex.length]
                                                    stor16[stor15[stor15.length]] = stor16[_33026]
                                                    stor16[_33026] = 0
                                                    if not tokenByIndex.length:
                                                        revert with 0, 49
                                                    tokenByIndex[tokenByIndex.length] = 0
                                                    tokenByIndex.length--
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    approved[_33026] = 0
                                                    if not ownerOf[_33026]:
                                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                                    emit Approval(ownerOf[_33026], 0, _33026);
                                                    if balanceOf[address(_32784)] < 1:
                                                        revert with 0, 17
                                                    balanceOf[address(_32784)]--
                                                    if balanceOf[address(_32820)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_32820)]++
                                                    mem[0] = _33026
                                                    mem[32] = 9
                                                    ownerOf[_33026] = address(_32820)
                                                    emit Transfer(address(_32784), address(_32820), _33026);
                                                    if ext_code.size(address(_32820)):
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = address(_32784)
                                                        mem[mem[64] + 68] = _33026
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _33027 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_32820))
                                                        call address(_32820).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, address(_32784), _33026, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _37656 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_37656] == Mask(32, 224, mem[_37656])
                                                        if Mask(32, 224, mem[_37656]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if unknown_0xb88d4fde(?????) > uint32(call.func_hash) >> 224:
                        if uint32(call.func_hash) >> 224 != unknown_0xab62a884(?????):
                            if unknown_0xb06faf62(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return bool(isMigrated)
                            if unknown_0xb0e25d1f(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 64
                                require cd[4] <= test266151307()
                                require cd[4] + 35 < calldata.size
                                if ('cd', 4).length > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                                    revert with 0, 65
                                mem[128] = ('cd', 4).length
                                require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                                idx = cd[4] + 36
                                s = 160
                                while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                                    mem[s] = cd[idx]
                                    idx = idx + 32
                                    s = s + 32
                                    continue 
                                require cd[36] <= test266151307()
                                require cd[36] + 35 < calldata.size
                                if ('cd', 36).length > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * ('cd', 36).length) + 130 < 129 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 > test266151307():
                                    revert with 0, 65
                                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
                                mem[ceil32(32 * ('cd', 4).length) + 129] = ('cd', 36).length
                                require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
                                idx = cd[36] + 36
                                s = ceil32(32 * ('cd', 4).length) + 161
                                while idx < cd[36] + (32 * ('cd', 36).length) + 36:
                                    require cd[idx] == address(cd[idx])
                                    mem[s] = cd[idx]
                                    idx = idx + 32
                                    s = s + 32
                                    continue 
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                if not isMigrated:
                                    if ('cd', 4).length != ('cd', 36).length:
                                        revert with 0, 'Mismatched array lengths.'
                                    idx = 0
                                    while idx < ('cd', 4).length:
                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                            revert with 0, 50
                                        _27114 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]
                                        mem[32] = 23
                                        if sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]:
                                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]
                                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                revert with 0, 50
                                            _27558 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _27671 = mem[(32 * idx) + 160]
                                            _27854 = mem[64]
                                            mem[64] = mem[64] + 32
                                            mem[_27854] = 0
                                            if not address(_27558):
                                                revert with 0, 'ERC721: mint to the zero address'
                                            if ownerOf[_27671]:
                                                revert with 0, 'ERC721: token already minted'
                                            stor16[_27671] = tokenByIndex.length
                                            tokenByIndex.length++
                                            tokenByIndex[tokenByIndex.length] = _27671
                                            if address(_27558):
                                                if not address(_27558):
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_27558)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_27558)]++
                                                    mem[0] = _27671
                                                    mem[32] = 9
                                                    ownerOf[_27671] = address(_27558)
                                                    emit Transfer(0, address(_27558), _27671);
                                                    if not ext_code.size(address(_27558)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _30544 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_30544)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _27671
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _27854 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_27558))
                                                        call address(_27558).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _27671, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _33420 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_33420] == Mask(32, 224, mem[_33420])
                                                        if Mask(32, 224, mem[_33420]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _35188 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_35188)
                                                else:
                                                    if not address(_27558):
                                                        revert with 0, 'ERC721: balance query for the zero address'
                                                    tokenOfOwnerByIndex[address(_27558)][stor10[address(_27558)]] = _27671
                                                    stor14[_27671] = balanceOf[address(_27558)]
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_27558)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_27558)]++
                                                    mem[0] = _27671
                                                    mem[32] = 9
                                                    ownerOf[_27671] = address(_27558)
                                                    emit Transfer(0, address(_27558), _27671);
                                                    if not ext_code.size(address(_27558)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _30697 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_30697)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _27671
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _27854 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_27558))
                                                        call address(_27558).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _27671, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _33422 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_33422] == Mask(32, 224, mem[_33422])
                                                        if Mask(32, 224, mem[_33422]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _35192 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_35192)
                                            else:
                                                if tokenByIndex.length < 1:
                                                    revert with 0, 17
                                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                    revert with 0, 50
                                                if stor16[_27671] >= tokenByIndex.length:
                                                    revert with 0, 50
                                                tokenByIndex[stor16[_27671]] = tokenByIndex[tokenByIndex.length]
                                                stor16[stor15[stor15.length]] = stor16[_27671]
                                                stor16[_27671] = 0
                                                if not tokenByIndex.length:
                                                    revert with 0, 49
                                                tokenByIndex[tokenByIndex.length] = 0
                                                tokenByIndex.length--
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                if balanceOf[address(_27558)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_27558)]++
                                                mem[0] = _27671
                                                mem[32] = 9
                                                ownerOf[_27671] = address(_27558)
                                                emit Transfer(0, address(_27558), _27671);
                                                if not ext_code.size(address(_27558)):
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _30787 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_30787)
                                                else:
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = 0
                                                    mem[mem[64] + 68] = _27671
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _27854 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_27558))
                                                    call address(_27558).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, 0, _27671, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _33424 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_33424] == Mask(32, 224, mem[_33424])
                                                    if Mask(32, 224, mem[_33424]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _35196 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_35196)
                                        else:
                                            _27236 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            if 0 >= mem[_27236]:
                                                revert with 0, 50
                                            mem[_27236 + 32] = sub_50f80d52Address
                                            if 1 >= mem[_27236]:
                                                revert with 0, 50
                                            mem[_27236 + 64] = address(_27114)
                                            mem[_27236 + 96] = 2
                                            mem[64] = _27236 + 192
                                            mem[_27236 + 128] = 5000
                                            mem[_27236 + 160] = 5000
                                            mem[_27236 + 192 len 3487] = code.data[20530 len 3487]
                                            mem[_27236 + 3679] = this.address
                                            mem[_27236 + 3711] = 96
                                            mem[_27236 + 3775] = mem[_27236]
                                            s = 0
                                            t = _27236 + 32
                                            u = _27236 + 3807
                                            while s < mem[_27236]:
                                                mem[u] = mem[t + 12 len 20]
                                                s = s + 1
                                                t = t + 32
                                                u = u + 32
                                                continue 
                                            mem[_27236 + 3743] = (32 * mem[_27236]) + 128
                                            mem[_27236 + (32 * mem[_27236]) + 3807] = 2
                                            s = 0
                                            t = _27236 + (32 * mem[_27236]) + 3839
                                            u = _27236 + 128
                                            while s < 2:
                                                mem[t] = mem[u + 30 len 2]
                                                s = s + 1
                                                t = t + 32
                                                u = u + 32
                                                continue 
                                            create contract with 0 wei
                                                            code: mem[mem[64] len _27236 + (32 * mem[_27236]) + -mem[64] + 3903]
                                            if not create.new_address:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            sub_519db647[address(_27114)] = address(create.new_address)
                                            sub_4bd7ba59.length++
                                            stor57C3[stor26.length] = address(create.new_address)
                                            mem[mem[64]] = address(create.new_address)
                                            emit 0x709f7933: address(create.new_address), address(_27114)
                                            mem[0] = address(_27114)
                                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                revert with 0, 50
                                            _37546 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _37550 = mem[(32 * idx) + 160]
                                            _37664 = mem[64]
                                            mem[64] = mem[64] + 32
                                            mem[_37664] = 0
                                            if not address(_37546):
                                                revert with 0, 'ERC721: mint to the zero address'
                                            if ownerOf[_37550]:
                                                revert with 0, 'ERC721: token already minted'
                                            stor16[_37550] = tokenByIndex.length
                                            tokenByIndex.length++
                                            tokenByIndex[tokenByIndex.length] = _37550
                                            if address(_37546):
                                                if not address(_37546):
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_37546)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_37546)]++
                                                    mem[0] = _37550
                                                    mem[32] = 9
                                                    ownerOf[_37550] = address(_37546)
                                                    emit Transfer(0, address(_37546), _37550);
                                                    if not ext_code.size(address(_37546)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _38586 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_38586)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _37550
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _37664 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_37546))
                                                        call address(_37546).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _37550, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _39140 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_39140] == Mask(32, 224, mem[_39140])
                                                        if Mask(32, 224, mem[_39140]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _39380 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_39380)
                                                else:
                                                    if not address(_37546):
                                                        revert with 0, 'ERC721: balance query for the zero address'
                                                    tokenOfOwnerByIndex[address(_37546)][stor10[address(_37546)]] = _37550
                                                    stor14[_37550] = balanceOf[address(_37546)]
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_37546)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_37546)]++
                                                    mem[0] = _37550
                                                    mem[32] = 9
                                                    ownerOf[_37550] = address(_37546)
                                                    emit Transfer(0, address(_37546), _37550);
                                                    if not ext_code.size(address(_37546)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _38624 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_38624)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _37550
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _37664 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_37546))
                                                        call address(_37546).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _37550, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _39142 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_39142] == Mask(32, 224, mem[_39142])
                                                        if Mask(32, 224, mem[_39142]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _39384 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_39384)
                                            else:
                                                if tokenByIndex.length < 1:
                                                    revert with 0, 17
                                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                    revert with 0, 50
                                                if stor16[_37550] >= tokenByIndex.length:
                                                    revert with 0, 50
                                                tokenByIndex[stor16[_37550]] = tokenByIndex[tokenByIndex.length]
                                                stor16[stor15[stor15.length]] = stor16[_37550]
                                                stor16[_37550] = 0
                                                if not tokenByIndex.length:
                                                    revert with 0, 49
                                                tokenByIndex[tokenByIndex.length] = 0
                                                tokenByIndex.length--
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                if balanceOf[address(_37546)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_37546)]++
                                                mem[0] = _37550
                                                mem[32] = 9
                                                ownerOf[_37550] = address(_37546)
                                                emit Transfer(0, address(_37546), _37550);
                                                if not ext_code.size(address(_37546)):
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _38658 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_38658)
                                                else:
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = 0
                                                    mem[mem[64] + 68] = _37550
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _37664 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_37546))
                                                    call address(_37546).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, 0, _37550, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _39144 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_39144] == Mask(32, 224, mem[_39144])
                                                    if Mask(32, 224, mem[_39144]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _39388 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_39388)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if isMigrated:
                                        revert with 0, 'Invalid migration status.'
                                    if ('cd', 4).length != ('cd', 36).length:
                                        revert with 0, 'Mismatched array lengths.'
                                    idx = 0
                                    while idx < ('cd', 4).length:
                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                            revert with 0, 50
                                        _27115 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]
                                        mem[32] = 23
                                        if sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]:
                                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]
                                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                revert with 0, 50
                                            _27562 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _27673 = mem[(32 * idx) + 160]
                                            _27856 = mem[64]
                                            mem[64] = mem[64] + 32
                                            mem[_27856] = 0
                                            if not address(_27562):
                                                revert with 0, 'ERC721: mint to the zero address'
                                            if ownerOf[_27673]:
                                                revert with 0, 'ERC721: token already minted'
                                            stor16[_27673] = tokenByIndex.length
                                            tokenByIndex.length++
                                            tokenByIndex[tokenByIndex.length] = _27673
                                            if address(_27562):
                                                if not address(_27562):
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_27562)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_27562)]++
                                                    mem[0] = _27673
                                                    mem[32] = 9
                                                    ownerOf[_27673] = address(_27562)
                                                    emit Transfer(0, address(_27562), _27673);
                                                    if not ext_code.size(address(_27562)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _30548 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_30548)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _27673
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _27856 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_27562))
                                                        call address(_27562).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _27673, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _33427 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_33427] == Mask(32, 224, mem[_33427])
                                                        if Mask(32, 224, mem[_33427]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _35200 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_35200)
                                                else:
                                                    if not address(_27562):
                                                        revert with 0, 'ERC721: balance query for the zero address'
                                                    tokenOfOwnerByIndex[address(_27562)][stor10[address(_27562)]] = _27673
                                                    stor14[_27673] = balanceOf[address(_27562)]
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_27562)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_27562)]++
                                                    mem[0] = _27673
                                                    mem[32] = 9
                                                    ownerOf[_27673] = address(_27562)
                                                    emit Transfer(0, address(_27562), _27673);
                                                    if not ext_code.size(address(_27562)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _30704 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_30704)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _27673
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _27856 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_27562))
                                                        call address(_27562).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _27673, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _33429 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_33429] == Mask(32, 224, mem[_33429])
                                                        if Mask(32, 224, mem[_33429]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _35204 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_35204)
                                            else:
                                                if tokenByIndex.length < 1:
                                                    revert with 0, 17
                                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                    revert with 0, 50
                                                if stor16[_27673] >= tokenByIndex.length:
                                                    revert with 0, 50
                                                tokenByIndex[stor16[_27673]] = tokenByIndex[tokenByIndex.length]
                                                stor16[stor15[stor15.length]] = stor16[_27673]
                                                stor16[_27673] = 0
                                                if not tokenByIndex.length:
                                                    revert with 0, 49
                                                tokenByIndex[tokenByIndex.length] = 0
                                                tokenByIndex.length--
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                if balanceOf[address(_27562)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_27562)]++
                                                mem[0] = _27673
                                                mem[32] = 9
                                                ownerOf[_27673] = address(_27562)
                                                emit Transfer(0, address(_27562), _27673);
                                                if not ext_code.size(address(_27562)):
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _30796 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_30796)
                                                else:
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = 0
                                                    mem[mem[64] + 68] = _27673
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _27856 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_27562))
                                                    call address(_27562).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, 0, _27673, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _33431 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_33431] == Mask(32, 224, mem[_33431])
                                                    if Mask(32, 224, mem[_33431]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _35208 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_35208)
                                        else:
                                            _27239 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            if 0 >= mem[_27239]:
                                                revert with 0, 50
                                            mem[_27239 + 32] = sub_50f80d52Address
                                            if 1 >= mem[_27239]:
                                                revert with 0, 50
                                            mem[_27239 + 64] = address(_27115)
                                            mem[_27239 + 96] = 2
                                            mem[64] = _27239 + 192
                                            mem[_27239 + 128] = 5000
                                            mem[_27239 + 160] = 5000
                                            mem[_27239 + 192 len 3487] = code.data[20530 len 3487]
                                            mem[_27239 + 3679] = this.address
                                            mem[_27239 + 3711] = 96
                                            mem[_27239 + 3775] = mem[_27239]
                                            s = 0
                                            t = _27239 + 32
                                            u = _27239 + 3807
                                            while s < mem[_27239]:
                                                mem[u] = mem[t + 12 len 20]
                                                s = s + 1
                                                t = t + 32
                                                u = u + 32
                                                continue 
                                            mem[_27239 + 3743] = (32 * mem[_27239]) + 128
                                            mem[_27239 + (32 * mem[_27239]) + 3807] = 2
                                            s = 0
                                            t = _27239 + (32 * mem[_27239]) + 3839
                                            u = _27239 + 128
                                            while s < 2:
                                                mem[t] = mem[u + 30 len 2]
                                                s = s + 1
                                                t = t + 32
                                                u = u + 32
                                                continue 
                                            create contract with 0 wei
                                                            code: mem[mem[64] len _27239 + (32 * mem[_27239]) + -mem[64] + 3903]
                                            if not create.new_address:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            sub_519db647[address(_27115)] = address(create.new_address)
                                            sub_4bd7ba59.length++
                                            stor57C3[stor26.length] = address(create.new_address)
                                            mem[mem[64]] = address(create.new_address)
                                            emit 0x709f7933: address(create.new_address), address(_27115)
                                            mem[0] = address(_27115)
                                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                revert with 0, 50
                                            _37548 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _37551 = mem[(32 * idx) + 160]
                                            _37665 = mem[64]
                                            mem[64] = mem[64] + 32
                                            mem[_37665] = 0
                                            if not address(_37548):
                                                revert with 0, 'ERC721: mint to the zero address'
                                            if ownerOf[_37551]:
                                                revert with 0, 'ERC721: token already minted'
                                            stor16[_37551] = tokenByIndex.length
                                            tokenByIndex.length++
                                            tokenByIndex[tokenByIndex.length] = _37551
                                            if address(_37548):
                                                if not address(_37548):
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_37548)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_37548)]++
                                                    mem[0] = _37551
                                                    mem[32] = 9
                                                    ownerOf[_37551] = address(_37548)
                                                    emit Transfer(0, address(_37548), _37551);
                                                    if not ext_code.size(address(_37548)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _38590 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_38590)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _37551
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _37665 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_37548))
                                                        call address(_37548).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _37551, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _39146 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_39146] == Mask(32, 224, mem[_39146])
                                                        if Mask(32, 224, mem[_39146]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _39392 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_39392)
                                                else:
                                                    if not address(_37548):
                                                        revert with 0, 'ERC721: balance query for the zero address'
                                                    tokenOfOwnerByIndex[address(_37548)][stor10[address(_37548)]] = _37551
                                                    stor14[_37551] = balanceOf[address(_37548)]
                                                    if stor17:
                                                        revert with 0, 'ERC721Pausable: token transfer while paused'
                                                    if balanceOf[address(_37548)] > -2:
                                                        revert with 0, 17
                                                    balanceOf[address(_37548)]++
                                                    mem[0] = _37551
                                                    mem[32] = 9
                                                    ownerOf[_37551] = address(_37548)
                                                    emit Transfer(0, address(_37548), _37551);
                                                    if not ext_code.size(address(_37548)):
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _38630 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_38630)
                                                    else:
                                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 0
                                                        mem[mem[64] + 68] = _37551
                                                        mem[mem[64] + 100] = 128
                                                        mem[mem[64] + 132] = 0
                                                        s = 0
                                                        while s < 0:
                                                            mem[s + mem[64] + 164] = mem[s + _37665 + 32]
                                                            s = s + 32
                                                            continue 
                                                        require ext_code.size(address(_37548))
                                                        call address(_37548).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, 0, _37551, 128, 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            if not return_data.size:
                                                                if not mem[96]:
                                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            if not return_data.size:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _39148 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_39148] == Mask(32, 224, mem[_39148])
                                                        if Mask(32, 224, mem[_39148]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        if idx >= mem[128]:
                                                            revert with 0, 50
                                                        mem[0] = mem[(32 * idx) + 160]
                                                        mem[32] = 24
                                                        sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                            revert with 0, 50
                                                        _39396 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                        mem[mem[64]] = 1
                                                        emit 0xda2aa9ce: 1, address(_39396)
                                            else:
                                                if tokenByIndex.length < 1:
                                                    revert with 0, 17
                                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                                    revert with 0, 50
                                                if stor16[_37551] >= tokenByIndex.length:
                                                    revert with 0, 50
                                                tokenByIndex[stor16[_37551]] = tokenByIndex[tokenByIndex.length]
                                                stor16[stor15[stor15.length]] = stor16[_37551]
                                                stor16[_37551] = 0
                                                if not tokenByIndex.length:
                                                    revert with 0, 49
                                                tokenByIndex[tokenByIndex.length] = 0
                                                tokenByIndex.length--
                                                if stor17:
                                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                                if balanceOf[address(_37548)] > -2:
                                                    revert with 0, 17
                                                balanceOf[address(_37548)]++
                                                mem[0] = _37551
                                                mem[32] = 9
                                                ownerOf[_37551] = address(_37548)
                                                emit Transfer(0, address(_37548), _37551);
                                                if not ext_code.size(address(_37548)):
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _38666 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_38666)
                                                else:
                                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = 0
                                                    mem[mem[64] + 68] = _37551
                                                    mem[mem[64] + 100] = 128
                                                    mem[mem[64] + 132] = 0
                                                    s = 0
                                                    while s < 0:
                                                        mem[s + mem[64] + 164] = mem[s + _37665 + 32]
                                                        s = s + 32
                                                        continue 
                                                    require ext_code.size(address(_37548))
                                                    call address(_37548).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, 0, _37551, 128, 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        if not return_data.size:
                                                            if not mem[96]:
                                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        if not return_data.size:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _39150 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_39150] == Mask(32, 224, mem[_39150])
                                                    if Mask(32, 224, mem[_39150]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    if idx >= mem[128]:
                                                        revert with 0, 50
                                                    mem[0] = mem[(32 * idx) + 160]
                                                    mem[32] = 24
                                                    sub_24ebafb3[mem[(32 * idx) + 160]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 173 len 20]]
                                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 129]:
                                                        revert with 0, 50
                                                    _39400 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 161]
                                                    mem[mem[64]] = 1
                                                    emit 0xda2aa9ce: 1, address(_39400)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                            require unknown_0xb4e9f909(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            mem[0] = cd[4]
                            mem[32] = 24
                            mem[128] = 0x25c43cc400000000000000000000000000000000000000000000000000000000
                            require ext_code.size(sub_24ebafb3[cd[4]])
                            staticcall sub_24ebafb3[cd[4]].0x25c43cc4 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _185 = mem[128]
                            require mem[128] <= test266151307()
                            require return_data.size + 128 > mem[128] + 159
                            _226 = mem[mem[128] + 128]
                            if mem[mem[128] + 128] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[mem[128] + 128]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > test266151307():
                                revert with 0, 65
                            mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129
                            mem[ceil32(return_data.size) + 128] = mem[mem[128] + 128]
                            require _185 + (32 * _226) + 32 <= return_data.size
                            s = ceil32(return_data.size) + 160
                            idx = _185 + 160
                            while idx < _185 + (32 * _226) + 160:
                                require mem[idx] == mem[idx + 12 len 20]
                                mem[s] = mem[idx]
                                s = s + 32
                                idx = idx + 32
                                continue 
                            if 1 >= _226:
                                revert with 0, 50
                            mem[mem[64]] = mem[ceil32(return_data.size) + 204 len 20]
                            return memory
                              from mem[64]
                               len 32
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        if not isMigrated:
                            revert with 0, 'Invalid migration status.'
                        if not roleAdmin[0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6][address(msg.sender)].field_0:
                            revert with 0, 'Only minters can gift.'
                        if ownerOf[cd[36]]:
                            revert with 0, 'This token already has an owner.'
                        if cd[36] >= stor29:
                            revert with 0, 'This token cannot be gifted.'
                        if sub_519db647[address(cd[4])]:
                            mem[128] = 0
                            if not address(cd[4]):
                                revert with 0, 'ERC721: mint to the zero address'
                            if ownerOf[cd[36]]:
                                revert with 0, 'ERC721: token already minted'
                            stor16[cd[36]] = tokenByIndex.length
                            tokenByIndex.length++
                            tokenByIndex[tokenByIndex.length] = cd[36]
                            if address(cd[4]):
                                if address(cd[4]):
                                    if not address(cd[4]):
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])]] = cd[36]
                                    stor14[cd[36]] = balanceOf[address(cd[4])]
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor16[cd[36]] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor16[cd[36]]] = tokenByIndex[tokenByIndex.length]
                                stor16[stor15[stor15.length]] = stor16[cd[36]]
                                stor16[cd[36]] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            if balanceOf[address(cd[4])] > -2:
                                revert with 0, 17
                            balanceOf[address(cd[4])]++
                            ownerOf[cd[36]] = address(cd[4])
                            emit Transfer(0, address(cd[4]), cd[36]);
                            if ext_code.size(address(cd[4])):
                                mem[164] = msg.sender
                                mem[196] = 0
                                mem[228] = cd[36]
                                mem[260] = 128
                                mem[292] = 0
                                mem[324 len 0] = None
                                require ext_code.size(address(cd[4]))
                                call address(cd[4]).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, 0, cd[36], 128, 0
                                mem[160] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            mem[128] = 2
                            mem[160] = sub_50f80d52Address
                            mem[192] = address(cd[4])
                            mem[224] = 2
                            mem[256] = 5000
                            mem[288] = 5000
                            mem[320 len 3487] = code.data[20530 len 3487]
                            mem[3807] = this.address
                            mem[3839] = 96
                            mem[3903] = 2
                            idx = 0
                            s = 160
                            t = 3935
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[3871] = 192
                            mem[3999] = 2
                            idx = 0
                            s = 4031
                            t = 256
                            while idx < 2:
                                mem[s] = mem[t + 30 len 2]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            create contract with 0 wei
                                            code: code.data[20530 len 3487], address(this.address), 96, 192, 2, mem[3935 len 64], 2, mem[4031 len 64]
                            if not create.new_address:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_519db647[address(cd[4])] = address(create.new_address)
                            sub_4bd7ba59.length++
                            stor57C3[stor26.length] = address(create.new_address)
                            emit 0x709f7933: address(create.new_address), address(cd[4])
                            mem[320] = 0
                            if not address(cd[4]):
                                revert with 0, 'ERC721: mint to the zero address'
                            if ownerOf[cd[36]]:
                                revert with 0, 'ERC721: token already minted'
                            stor16[cd[36]] = tokenByIndex.length
                            tokenByIndex.length++
                            tokenByIndex[tokenByIndex.length] = cd[36]
                            if address(cd[4]):
                                if address(cd[4]):
                                    if not address(cd[4]):
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])]] = cd[36]
                                    stor14[cd[36]] = balanceOf[address(cd[4])]
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor16[cd[36]] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor16[cd[36]]] = tokenByIndex[tokenByIndex.length]
                                stor16[stor15[stor15.length]] = stor16[cd[36]]
                                stor16[cd[36]] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            if balanceOf[address(cd[4])] > -2:
                                revert with 0, 17
                            balanceOf[address(cd[4])]++
                            ownerOf[cd[36]] = address(cd[4])
                            emit Transfer(0, address(cd[4]), cd[36]);
                            if ext_code.size(address(cd[4])):
                                mem[356] = msg.sender
                                mem[388] = 0
                                mem[420] = cd[36]
                                mem[452] = 128
                                mem[484] = 0
                                mem[516 len 0] = None
                                require ext_code.size(address(cd[4]))
                                call address(cd[4]).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, 0, cd[36], 128, 0
                                mem[352] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        sub_24ebafb3[cd[36]] = sub_519db647[address(cd[4])]
                        emit 0xda2aa9ce: 1, address(cd[4])
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0xb88d4fde(?????):
                            if uint32(call.func_hash) >> 224 != unknown_0xc87b56dd(?????):
                                if unknown_0xca15c873(?????) == uint32(call.func_hash) >> 224:
                                    require not msg.value
                                    require calldata.size - 4 >= 32
                                    return roleMember[cd[4]].field_0
                                if unknown_0xd5391393(?????) == uint32(call.func_hash) >> 224:
                                    require not msg.value
                                    return 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6
                                require unknown_0xd547741f(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                require calldata.size - 4 >= 64
                                require cd[36] == address(cd[36])
                                if not roleAdmin[roleAdmin[cd[4]].field_256][address(msg.sender)].field_0:
                                    mem[160 len 42] = call.data[calldata.size len 42]
                                    idx = 41
                                    s = address(msg.sender)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= 42:
                                            revert with 0, 50
                                        mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if msg.sender + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    mem[256 len 66] = call.data[calldata.size len 66]
                                    idx = 65
                                    s = roleAdmin[cd[4]].field_256
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= 66:
                                            revert with 0, 50
                                        mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if roleAdmin[cd[4]].field_256 + 16384:
                                        revert with 0, 'Strings: hex length insufficient'
                                    revert with 0, 32, 148, 'AccessControl: account ', mem[192 len 42], 8297, mem[320 len 66], 0, 0 >> 928, 0
                                if roleAdmin[cd[4]][address(cd[36])].field_0:
                                    roleAdmin[cd[4]][address(cd[36])].field_0 = 0
                                    emit RoleRevoked(cd[4], address(cd[36]), msg.sender);
                                if roleMember[cd[4]][1][address(cd[36])].field_0:
                                    if roleMember[cd[4]][1][address(cd[36])].field_0 < 1:
                                        revert with 0, 17
                                    if roleMember[cd[4]].field_0 < 1:
                                        revert with 0, 17
                                    if roleMember[cd[4]].field_0 - 1 != roleMember[cd[4]][1][address(cd[36])].field_0 - 1:
                                        if roleMember[cd[4]].field_0 - 1 >= roleMember[cd[4]].field_0:
                                            revert with 0, 50
                                        if roleMember[cd[4]][1][address(cd[36])].field_0 - 1 >= roleMember[cd[4]].field_0:
                                            revert with 0, 50
                                        roleMember[cd[4]][roleMember[cd[4]][1][address(cd[36])].field_0].field_0 = roleMember[cd[4]][roleMember[cd[4]].field_0].field_0
                                        roleMember[cd[4]][1][roleMember[cd[4]][roleMember[cd[4]].field_0].field_0].field_0 = roleMember[cd[4]][1][address(cd[36])].field_0
                                    if not roleMember[cd[4]].field_0:
                                        revert with 0, 49
                                    roleMember[cd[4]][roleMember[cd[4]].field_0].field_0 = 0
                                    roleMember[cd[4]].field_0--
                                    roleMember[cd[4]][1][address(cd[36])].field_0 = 0
                            require not msg.value
                            require calldata.size - 4 >= 32
                            mem[0] = cd[4]
                            mem[32] = 9
                            if not ownerOf[cd[4]]:
                                revert with 0, 'This token id does not exist.'
                            if bool(stor30.length):
                                if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                    revert with 0, 34
                                if uint255(stor30.length) * 0.5 <= 0:
                                    return ''
                                if bool(stor30.length):
                                    if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[128] = uint255(stor30.length) * 0.5
                                    if bool(stor30.length):
                                        if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor30.length):
                                            if not stor31:
                                                if not cd[4]:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                        return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                    mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                                s = 0
                                                idx = cd[4]
                                                while idx:
                                                    if s == -1:
                                                        revert with 0, 17
                                                    s = s + 1
                                                    idx = idx / 10
                                                    continue 
                                                if s > test266151307():
                                                    revert with 0, 65
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                                if not s:
                                                    t = s
                                                    idx = cd[4]
                                                    while idx:
                                                        if t < 1:
                                                            revert with 0, 17
                                                        if 48 > !(idx % 10):
                                                            revert with 0, 17
                                                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                            revert with 0, 50
                                                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                        t = t - 1
                                                        idx = idx / 10
                                                        continue 
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                            _33676 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33676)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33676)]
                                                            if ceil32(_33676) > _33676:
                                                                mem[_33676 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33676) + 32], 
                                                        _33677 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33677)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33677)]
                                                        if ceil32(_33677) > _33677:
                                                            mem[_33677 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33677) + 32], 
                                                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33678 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33678)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33678)]
                                                        if ceil32(_33678) > _33678:
                                                            mem[_33678 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33678) + 32], 
                                                    _33679 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33679)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33679)]
                                                    if ceil32(_33679) > _33679:
                                                        mem[_33679 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33679) + 32], 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33680 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33680)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33680)]
                                                        if ceil32(_33680) > _33680:
                                                            mem[_33680 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33680) + 32], 
                                                    _33681 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33681)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33681)]
                                                    if ceil32(_33681) > _33681:
                                                        mem[_33681 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33681) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33682 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33682)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33682)]
                                                    if ceil32(_33682) > _33682:
                                                        mem[_33682 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33682) + 32], 
                                                _33683 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33683)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33683)]
                                                if ceil32(_33683) > _33683:
                                                    mem[_33683 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33683) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                            require ext_code.size(stor31)
                                            staticcall stor31.0xff74ef30 with:
                                                    gas gas_remaining wei
                                                   args cd[4]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                            require return_data.size >= 32
                                            _658 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                            require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                            require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                            _721 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                            if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                                revert with 0, 65
                                            if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                                revert with 0, 65
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _721
                                            require _658 + _721 + 32 <= return_data.size
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_721)] = mem[ceil32(uint255(stor30.length) * 0.5) + _658 + 192 len ceil32(_721)]
                                            if ceil32(_721) <= _721:
                                                _11891 = mem[64]
                                                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_721)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_721)]
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    if ceil32(_721) <= _721:
                                                        _27241 = mem[64]
                                                        mem[64] = _11891 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                        mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                        _27874 = mem[_27241]
                                                        mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27241]
                                                        mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27874)] = mem[_27241 + 32 len ceil32(_27874)]
                                                        if ceil32(_27874) > _27874:
                                                            mem[_27874 + _11891 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                        return 32, mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27874) + 32]
                                                    _27242 = mem[64]
                                                    mem[64] = _11891 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                    _27875 = mem[_27242]
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27242]
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27875)] = mem[_27242 + 32 len ceil32(_27875)]
                                                    if ceil32(_27875) > _27875:
                                                        mem[_27875 + _11891 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                    return 32, mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27875) + 32]
                                                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                                mem[_11891 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_721)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_721)]
                                                mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_721) <= _721:
                                                    _27243 = mem[64]
                                                    mem[64] = _11891 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                    _27876 = mem[_27243]
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27243]
                                                    mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27876)] = mem[_27243 + 32 len ceil32(_27876)]
                                                    if ceil32(_27876) > _27876:
                                                        mem[_27876 + _11891 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                    return 32, mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27876) + 32]
                                                _27244 = mem[64]
                                                mem[64] = _11891 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                _27877 = mem[_27244]
                                                mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27244]
                                                mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27877)] = mem[_27244 + 32 len ceil32(_27877)]
                                                if ceil32(_27877) > _27877:
                                                    mem[_27877 + _11891 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                return 32, mem[_11891 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27877) + 32]
                                            mem[_721 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                            _11892 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_721)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_721)]
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_721) <= _721:
                                                    _27245 = mem[64]
                                                    mem[64] = _11892 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                    mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                    _27878 = mem[_27245]
                                                    mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27245]
                                                    mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27878)] = mem[_27245 + 32 len ceil32(_27878)]
                                                    if ceil32(_27878) > _27878:
                                                        mem[_27878 + _11892 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                    return 32, mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27878) + 32]
                                                _27246 = mem[64]
                                                mem[64] = _11892 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                _27879 = mem[_27246]
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27246]
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27879)] = mem[_27246 + 32 len ceil32(_27879)]
                                                if ceil32(_27879) > _27879:
                                                    mem[_27879 + _11892 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                return 32, mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27879) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_11892 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_721)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_721)]
                                            mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_721) <= _721:
                                                _27247 = mem[64]
                                                mem[64] = _11892 + (uint255(stor30.length) * 0.5) + _721 + 37
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                                _27880 = mem[_27247]
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27247]
                                                mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27880)] = mem[_27247 + 32 len ceil32(_27880)]
                                                if ceil32(_27880) > _27880:
                                                    mem[_27880 + _11892 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                                return 32, mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27880) + 32]
                                            _27248 = mem[64]
                                            mem[64] = _11892 + (uint255(stor30.length) * 0.5) + _721 + 37
                                            mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 37] = 32
                                            _27881 = mem[_27248]
                                            mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69] = mem[_27248]
                                            mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 101 len ceil32(_27881)] = mem[_27248 + 32 len ceil32(_27881)]
                                            if ceil32(_27881) > _27881:
                                                mem[_27881 + _11892 + (uint255(stor30.length) * 0.5) + _721 + 101] = 0
                                            return 32, mem[_11892 + (uint255(stor30.length) * 0.5) + _721 + 69 len ceil32(_27881) + 32]
                                        if 31 >= uint255(stor30.length) * 0.5:
                                            mem[160] = 256 * stor30.length.field_8
                                            if not stor31:
                                                if not cd[4]:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                        return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                    mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                                s = 0
                                                idx = cd[4]
                                                while idx:
                                                    if s == -1:
                                                        revert with 0, 17
                                                    s = s + 1
                                                    idx = idx / 10
                                                    continue 
                                                if s > test266151307():
                                                    revert with 0, 65
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                                if not s:
                                                    t = s
                                                    idx = cd[4]
                                                    while idx:
                                                        if t < 1:
                                                            revert with 0, 17
                                                        if 48 > !(idx % 10):
                                                            revert with 0, 17
                                                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                            revert with 0, 50
                                                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                        t = t - 1
                                                        idx = idx / 10
                                                        continue 
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                            _33700 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33700)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33700)]
                                                            if ceil32(_33700) > _33700:
                                                                mem[_33700 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33700) + 32], 
                                                        _33701 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33701)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33701)]
                                                        if ceil32(_33701) > _33701:
                                                            mem[_33701 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33701) + 32], 
                                                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33702 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33702)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33702)]
                                                        if ceil32(_33702) > _33702:
                                                            mem[_33702 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33702) + 32], 
                                                    _33703 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33703)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33703)]
                                                    if ceil32(_33703) > _33703:
                                                        mem[_33703 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33703) + 32], 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33704 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33704)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33704)]
                                                        if ceil32(_33704) > _33704:
                                                            mem[_33704 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33704) + 32], 
                                                    _33705 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33705)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33705)]
                                                    if ceil32(_33705) > _33705:
                                                        mem[_33705 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33705) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33706 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33706)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33706)]
                                                    if ceil32(_33706) > _33706:
                                                        mem[_33706 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33706) + 32], 
                                                _33707 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33707)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33707)]
                                                if ceil32(_33707) > _33707:
                                                    mem[_33707 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33707) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                            require ext_code.size(stor31)
                                            staticcall stor31.0xff74ef30 with:
                                                    gas gas_remaining wei
                                                   args cd[4]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                            require return_data.size >= 32
                                            _724 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                            require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                            require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                            _799 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                            if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                                revert with 0, 65
                                            if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                                revert with 0, 65
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _799
                                            require _724 + _799 + 32 <= return_data.size
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_799)] = mem[ceil32(uint255(stor30.length) * 0.5) + _724 + 192 len ceil32(_799)]
                                            if ceil32(_799) <= _799:
                                                _11895 = mem[64]
                                                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_799)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_799)]
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    if ceil32(_799) <= _799:
                                                        _27255 = mem[64]
                                                        mem[64] = _11895 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                        mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                        _27906 = mem[_27255]
                                                        mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27255]
                                                        mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27906)] = mem[_27255 + 32 len ceil32(_27906)]
                                                        if ceil32(_27906) > _27906:
                                                            mem[_27906 + _11895 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                        return 32, mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27906) + 32]
                                                    _27256 = mem[64]
                                                    mem[64] = _11895 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                    _27907 = mem[_27256]
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27256]
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27907)] = mem[_27256 + 32 len ceil32(_27907)]
                                                    if ceil32(_27907) > _27907:
                                                        mem[_27907 + _11895 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                    return 32, mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27907) + 32]
                                                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                                mem[_11895 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_799)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_799)]
                                                mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_799) <= _799:
                                                    _27257 = mem[64]
                                                    mem[64] = _11895 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                    _27908 = mem[_27257]
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27257]
                                                    mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27908)] = mem[_27257 + 32 len ceil32(_27908)]
                                                    if ceil32(_27908) > _27908:
                                                        mem[_27908 + _11895 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                    return 32, mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27908) + 32]
                                                _27258 = mem[64]
                                                mem[64] = _11895 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                _27909 = mem[_27258]
                                                mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27258]
                                                mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27909)] = mem[_27258 + 32 len ceil32(_27909)]
                                                if ceil32(_27909) > _27909:
                                                    mem[_27909 + _11895 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                return 32, mem[_11895 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27909) + 32]
                                            mem[_799 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                            _11896 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_799)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_799)]
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_799) <= _799:
                                                    _27259 = mem[64]
                                                    mem[64] = _11896 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                    mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                    _27910 = mem[_27259]
                                                    mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27259]
                                                    mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27910)] = mem[_27259 + 32 len ceil32(_27910)]
                                                    if ceil32(_27910) > _27910:
                                                        mem[_27910 + _11896 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                    return 32, mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27910) + 32]
                                                _27260 = mem[64]
                                                mem[64] = _11896 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                _27911 = mem[_27260]
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27260]
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27911)] = mem[_27260 + 32 len ceil32(_27911)]
                                                if ceil32(_27911) > _27911:
                                                    mem[_27911 + _11896 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                return 32, mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27911) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_11896 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_799)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_799)]
                                            mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_799) <= _799:
                                                _27261 = mem[64]
                                                mem[64] = _11896 + (uint255(stor30.length) * 0.5) + _799 + 37
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                                _27912 = mem[_27261]
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27261]
                                                mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27912)] = mem[_27261 + 32 len ceil32(_27912)]
                                                if ceil32(_27912) > _27912:
                                                    mem[_27912 + _11896 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                                return 32, mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27912) + 32]
                                            _27262 = mem[64]
                                            mem[64] = _11896 + (uint255(stor30.length) * 0.5) + _799 + 37
                                            mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 37] = 32
                                            _27913 = mem[_27262]
                                            mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69] = mem[_27262]
                                            mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 101 len ceil32(_27913)] = mem[_27262 + 32 len ceil32(_27913)]
                                            if ceil32(_27913) > _27913:
                                                mem[_27913 + _11896 + (uint255(stor30.length) * 0.5) + _799 + 101] = 0
                                            return 32, mem[_11896 + (uint255(stor30.length) * 0.5) + _799 + 69 len ceil32(_27913) + 32]
                                        mem[0] = 30
                                        mem[160] = uint256(stor30.field_0)
                                        idx = 160
                                        s = 0
                                        while (uint255(stor30.length) * 0.5) + 128 > idx:
                                            mem[idx + 32] = stor30[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                    return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                            if not s:
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _37666 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37666)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37666)]
                                                        if ceil32(_37666) > _37666:
                                                            mem[_37666 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37666) + 32], 
                                                    _37667 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37667)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37667)]
                                                    if ceil32(_37667) > _37667:
                                                        mem[_37667 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37667) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _37668 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37668)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37668)]
                                                    if ceil32(_37668) > _37668:
                                                        mem[_37668 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37668) + 32], 
                                                _37669 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37669)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37669)]
                                                if ceil32(_37669) > _37669:
                                                    mem[_37669 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37669) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _37670 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37670)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37670)]
                                                    if ceil32(_37670) > _37670:
                                                        mem[_37670 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37670) + 32], 
                                                _37671 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37671)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37671)]
                                                if ceil32(_37671) > _37671:
                                                    mem[_37671 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37671) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _37672 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37672)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37672)]
                                                if ceil32(_37672) > _37672:
                                                    mem[_37672 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37672) + 32], 
                                            _37673 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37673)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37673)]
                                            if ceil32(_37673) > _37673:
                                                mem[_37673 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37673) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _12512 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _13480 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _13480
                                        require _12512 + _13480 + 32 <= return_data.size
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13480)] = mem[ceil32(uint255(stor30.length) * 0.5) + _12512 + 192 len ceil32(_13480)]
                                        if ceil32(_13480) <= _13480:
                                            _20873 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13480)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13480)]
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_13480) <= _13480:
                                                    _32836 = mem[64]
                                                    mem[64] = _20873 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                                    mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                                    _33684 = mem[_32836]
                                                    mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32836]
                                                    mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33684)] = mem[_32836 + 32 len ceil32(_33684)]
                                                    if ceil32(_33684) > _33684:
                                                        mem[_33684 + _20873 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                                    return 32, mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33684) + 32]
                                                _32837 = mem[64]
                                                mem[64] = _20873 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                                _33685 = mem[_32837]
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32837]
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33685)] = mem[_32837 + 32 len ceil32(_33685)]
                                                if ceil32(_33685) > _33685:
                                                    mem[_33685 + _20873 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                                return 32, mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33685) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_20873 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13480)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13480)]
                                            mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_13480) <= _13480:
                                                _32838 = mem[64]
                                                mem[64] = _20873 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                                _33686 = mem[_32838]
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32838]
                                                mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33686)] = mem[_32838 + 32 len ceil32(_33686)]
                                                if ceil32(_33686) > _33686:
                                                    mem[_33686 + _20873 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                                return 32, mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33686) + 32]
                                            _32839 = mem[64]
                                            mem[64] = _20873 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                            mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                            _33687 = mem[_32839]
                                            mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32839]
                                            mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33687)] = mem[_32839 + 32 len ceil32(_33687)]
                                            if ceil32(_33687) > _33687:
                                                mem[_33687 + _20873 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                            return 32, mem[_20873 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33687) + 32]
                                        mem[_13480 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                        _20874 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13480)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13480)]
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_13480) <= _13480:
                                                _32840 = mem[64]
                                                mem[64] = _20874 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                                mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                                _33688 = mem[_32840]
                                                mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32840]
                                                mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33688)] = mem[_32840 + 32 len ceil32(_33688)]
                                                if ceil32(_33688) > _33688:
                                                    mem[_33688 + _20874 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                                return 32, mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33688) + 32]
                                            _32841 = mem[64]
                                            mem[64] = _20874 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                            _33689 = mem[_32841]
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32841]
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33689)] = mem[_32841 + 32 len ceil32(_33689)]
                                            if ceil32(_33689) > _33689:
                                                mem[_33689 + _20874 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                            return 32, mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33689) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_20874 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13480)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13480)]
                                        mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13480) <= _13480:
                                            _32842 = mem[64]
                                            mem[64] = _20874 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                            _33690 = mem[_32842]
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32842]
                                            mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33690)] = mem[_32842 + 32 len ceil32(_33690)]
                                            if ceil32(_33690) > _33690:
                                                mem[_33690 + _20874 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                            return 32, mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33690) + 32]
                                        _32843 = mem[64]
                                        mem[64] = _20874 + (uint255(stor30.length) * 0.5) + _13480 + 37
                                        mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 37] = 32
                                        _33691 = mem[_32843]
                                        mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69] = mem[_32843]
                                        mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 101 len ceil32(_33691)] = mem[_32843 + 32 len ceil32(_33691)]
                                        if ceil32(_33691) > _33691:
                                            mem[_33691 + _20874 + (uint255(stor30.length) * 0.5) + _13480 + 101] = 0
                                        return 32, mem[_20874 + (uint255(stor30.length) * 0.5) + _13480 + 69 len ceil32(_33691) + 32]
                                    if bool(stor30.length) == stor30.length.field_1 < 32:
                                        revert with 0, 34
                                    if not stor30.length.field_1:
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                    return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                            if not s:
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33708 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33708)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33708)]
                                                        if ceil32(_33708) > _33708:
                                                            mem[_33708 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33708) + 32], 
                                                    _33709 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33709)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33709)]
                                                    if ceil32(_33709) > _33709:
                                                        mem[_33709 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33709) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33710 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33710)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33710)]
                                                    if ceil32(_33710) > _33710:
                                                        mem[_33710 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33710) + 32], 
                                                _33711 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33711)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33711)]
                                                if ceil32(_33711) > _33711:
                                                    mem[_33711 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33711) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33712 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33712)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33712)]
                                                    if ceil32(_33712) > _33712:
                                                        mem[_33712 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33712) + 32], 
                                                _33713 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33713)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33713)]
                                                if ceil32(_33713) > _33713:
                                                    mem[_33713 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33713) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33714 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33714)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33714)]
                                                if ceil32(_33714) > _33714:
                                                    mem[_33714 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33714) + 32], 
                                            _33715 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33715)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33715)]
                                            if ceil32(_33715) > _33715:
                                                mem[_33715 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33715) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _691 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _755 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _755
                                        require _691 + _755 + 32 <= return_data.size
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_755)] = mem[ceil32(uint255(stor30.length) * 0.5) + _691 + 192 len ceil32(_755)]
                                        if ceil32(_755) <= _755:
                                            _11897 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_755)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_755)]
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_755) <= _755:
                                                    _27263 = mem[64]
                                                    mem[64] = _11897 + (uint255(stor30.length) * 0.5) + _755 + 37
                                                    mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                                    _27922 = mem[_27263]
                                                    mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27263]
                                                    mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27922)] = mem[_27263 + 32 len ceil32(_27922)]
                                                    if ceil32(_27922) > _27922:
                                                        mem[_27922 + _11897 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                                    return 32, mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27922) + 32]
                                                _27264 = mem[64]
                                                mem[64] = _11897 + (uint255(stor30.length) * 0.5) + _755 + 37
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                                _27923 = mem[_27264]
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27264]
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27923)] = mem[_27264 + 32 len ceil32(_27923)]
                                                if ceil32(_27923) > _27923:
                                                    mem[_27923 + _11897 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                                return 32, mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27923) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_11897 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_755)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_755)]
                                            mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_755) <= _755:
                                                _27265 = mem[64]
                                                mem[64] = _11897 + (uint255(stor30.length) * 0.5) + _755 + 37
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                                _27924 = mem[_27265]
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27265]
                                                mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27924)] = mem[_27265 + 32 len ceil32(_27924)]
                                                if ceil32(_27924) > _27924:
                                                    mem[_27924 + _11897 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                                return 32, mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27924) + 32]
                                            _27266 = mem[64]
                                            mem[64] = _11897 + (uint255(stor30.length) * 0.5) + _755 + 37
                                            mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                            _27925 = mem[_27266]
                                            mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27266]
                                            mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27925)] = mem[_27266 + 32 len ceil32(_27925)]
                                            if ceil32(_27925) > _27925:
                                                mem[_27925 + _11897 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                            return 32, mem[_11897 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27925) + 32]
                                        mem[_755 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                        _11898 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_755)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_755)]
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_755) <= _755:
                                                _27267 = mem[64]
                                                mem[64] = _11898 + (uint255(stor30.length) * 0.5) + _755 + 37
                                                mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                                _27926 = mem[_27267]
                                                mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27267]
                                                mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27926)] = mem[_27267 + 32 len ceil32(_27926)]
                                                if ceil32(_27926) > _27926:
                                                    mem[_27926 + _11898 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                                return 32, mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27926) + 32]
                                            _27268 = mem[64]
                                            mem[64] = _11898 + (uint255(stor30.length) * 0.5) + _755 + 37
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                            _27927 = mem[_27268]
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27268]
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27927)] = mem[_27268 + 32 len ceil32(_27927)]
                                            if ceil32(_27927) > _27927:
                                                mem[_27927 + _11898 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                            return 32, mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27927) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_11898 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_755)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_755)]
                                        mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_755) <= _755:
                                            _27269 = mem[64]
                                            mem[64] = _11898 + (uint255(stor30.length) * 0.5) + _755 + 37
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                            _27928 = mem[_27269]
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27269]
                                            mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27928)] = mem[_27269 + 32 len ceil32(_27928)]
                                            if ceil32(_27928) > _27928:
                                                mem[_27928 + _11898 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                            return 32, mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27928) + 32]
                                        _27270 = mem[64]
                                        mem[64] = _11898 + (uint255(stor30.length) * 0.5) + _755 + 37
                                        mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 37] = 32
                                        _27929 = mem[_27270]
                                        mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69] = mem[_27270]
                                        mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 101 len ceil32(_27929)] = mem[_27270 + 32 len ceil32(_27929)]
                                        if ceil32(_27929) > _27929:
                                            mem[_27929 + _11898 + (uint255(stor30.length) * 0.5) + _755 + 101] = 0
                                        return 32, mem[_11898 + (uint255(stor30.length) * 0.5) + _755 + 69 len ceil32(_27929) + 32]
                                    if 31 >= stor30.length.field_1:
                                        mem[160] = 256 * stor30.length.field_8
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                    return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                            if not s:
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33732 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33732)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33732)]
                                                        if ceil32(_33732) > _33732:
                                                            mem[_33732 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33732) + 32], 
                                                    _33733 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33733)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33733)]
                                                    if ceil32(_33733) > _33733:
                                                        mem[_33733 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33733) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33734 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33734)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33734)]
                                                    if ceil32(_33734) > _33734:
                                                        mem[_33734 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33734) + 32], 
                                                _33735 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33735)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33735)]
                                                if ceil32(_33735) > _33735:
                                                    mem[_33735 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33735) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33736 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33736)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33736)]
                                                    if ceil32(_33736) > _33736:
                                                        mem[_33736 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33736) + 32], 
                                                _33737 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33737)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33737)]
                                                if ceil32(_33737) > _33737:
                                                    mem[_33737 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33737) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33738 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33738)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33738)]
                                                if ceil32(_33738) > _33738:
                                                    mem[_33738 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33738) + 32], 
                                            _33739 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33739)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33739)]
                                            if ceil32(_33739) > _33739:
                                                mem[_33739 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33739) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _758 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _838 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _838
                                        require _758 + _838 + 32 <= return_data.size
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_838)] = mem[ceil32(uint255(stor30.length) * 0.5) + _758 + 192 len ceil32(_838)]
                                        if ceil32(_838) <= _838:
                                            _11901 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_838)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_838)]
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_838) <= _838:
                                                    _27277 = mem[64]
                                                    mem[64] = _11901 + (uint255(stor30.length) * 0.5) + _838 + 37
                                                    mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                                    _27954 = mem[_27277]
                                                    mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27277]
                                                    mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27954)] = mem[_27277 + 32 len ceil32(_27954)]
                                                    if ceil32(_27954) > _27954:
                                                        mem[_27954 + _11901 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                                    return 32, mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27954) + 32]
                                                _27278 = mem[64]
                                                mem[64] = _11901 + (uint255(stor30.length) * 0.5) + _838 + 37
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                                _27955 = mem[_27278]
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27278]
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27955)] = mem[_27278 + 32 len ceil32(_27955)]
                                                if ceil32(_27955) > _27955:
                                                    mem[_27955 + _11901 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                                return 32, mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27955) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_11901 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_838)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_838)]
                                            mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_838) <= _838:
                                                _27279 = mem[64]
                                                mem[64] = _11901 + (uint255(stor30.length) * 0.5) + _838 + 37
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                                _27956 = mem[_27279]
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27279]
                                                mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27956)] = mem[_27279 + 32 len ceil32(_27956)]
                                                if ceil32(_27956) > _27956:
                                                    mem[_27956 + _11901 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                                return 32, mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27956) + 32]
                                            _27280 = mem[64]
                                            mem[64] = _11901 + (uint255(stor30.length) * 0.5) + _838 + 37
                                            mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                            _27957 = mem[_27280]
                                            mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27280]
                                            mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27957)] = mem[_27280 + 32 len ceil32(_27957)]
                                            if ceil32(_27957) > _27957:
                                                mem[_27957 + _11901 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                            return 32, mem[_11901 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27957) + 32]
                                        mem[_838 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                        _11902 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_838)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_838)]
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_838) <= _838:
                                                _27281 = mem[64]
                                                mem[64] = _11902 + (uint255(stor30.length) * 0.5) + _838 + 37
                                                mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                                _27958 = mem[_27281]
                                                mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27281]
                                                mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27958)] = mem[_27281 + 32 len ceil32(_27958)]
                                                if ceil32(_27958) > _27958:
                                                    mem[_27958 + _11902 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                                return 32, mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27958) + 32]
                                            _27282 = mem[64]
                                            mem[64] = _11902 + (uint255(stor30.length) * 0.5) + _838 + 37
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                            _27959 = mem[_27282]
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27282]
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27959)] = mem[_27282 + 32 len ceil32(_27959)]
                                            if ceil32(_27959) > _27959:
                                                mem[_27959 + _11902 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                            return 32, mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27959) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_11902 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_838)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_838)]
                                        mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_838) <= _838:
                                            _27283 = mem[64]
                                            mem[64] = _11902 + (uint255(stor30.length) * 0.5) + _838 + 37
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                            _27960 = mem[_27283]
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27283]
                                            mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27960)] = mem[_27283 + 32 len ceil32(_27960)]
                                            if ceil32(_27960) > _27960:
                                                mem[_27960 + _11902 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                            return 32, mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27960) + 32]
                                        _27284 = mem[64]
                                        mem[64] = _11902 + (uint255(stor30.length) * 0.5) + _838 + 37
                                        mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 37] = 32
                                        _27961 = mem[_27284]
                                        mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69] = mem[_27284]
                                        mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 101 len ceil32(_27961)] = mem[_27284 + 32 len ceil32(_27961)]
                                        if ceil32(_27961) > _27961:
                                            mem[_27961 + _11902 + (uint255(stor30.length) * 0.5) + _838 + 101] = 0
                                        return 32, mem[_11902 + (uint255(stor30.length) * 0.5) + _838 + 69 len ceil32(_27961) + 32]
                                    mem[0] = 30
                                    mem[160] = uint256(stor30.field_0)
                                    idx = 160
                                    s = 0
                                    while stor30.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor30[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                            mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                        if not s:
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _37674 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37674)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37674)]
                                                    if ceil32(_37674) > _37674:
                                                        mem[_37674 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37674) + 32], 
                                                _37675 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37675)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37675)]
                                                if ceil32(_37675) > _37675:
                                                    mem[_37675 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37675) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _37676 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37676)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37676)]
                                                if ceil32(_37676) > _37676:
                                                    mem[_37676 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37676) + 32], 
                                            _37677 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37677)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37677)]
                                            if ceil32(_37677) > _37677:
                                                mem[_37677 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37677) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _37678 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37678)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37678)]
                                                if ceil32(_37678) > _37678:
                                                    mem[_37678 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37678) + 32], 
                                            _37679 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37679)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37679)]
                                            if ceil32(_37679) > _37679:
                                                mem[_37679 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37679) + 32], 
                                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            _37680 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37680)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37680)]
                                            if ceil32(_37680) > _37680:
                                                mem[_37680 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37680) + 32], 
                                        _37681 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37681)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37681)]
                                        if ceil32(_37681) > _37681:
                                            mem[_37681 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37681) + 32], 
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _12522 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _13489 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _13489
                                    require _12522 + _13489 + 32 <= return_data.size
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13489)] = mem[ceil32(uint255(stor30.length) * 0.5) + _12522 + 192 len ceil32(_13489)]
                                    if ceil32(_13489) <= _13489:
                                        _20887 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13489)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13489)]
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_13489) <= _13489:
                                                _32860 = mem[64]
                                                mem[64] = _20887 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                                mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                                _33716 = mem[_32860]
                                                mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32860]
                                                mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33716)] = mem[_32860 + 32 len ceil32(_33716)]
                                                if ceil32(_33716) > _33716:
                                                    mem[_33716 + _20887 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                                return 32, mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33716) + 32]
                                            _32861 = mem[64]
                                            mem[64] = _20887 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                            _33717 = mem[_32861]
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32861]
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33717)] = mem[_32861 + 32 len ceil32(_33717)]
                                            if ceil32(_33717) > _33717:
                                                mem[_33717 + _20887 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                            return 32, mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33717) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_20887 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13489)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13489)]
                                        mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13489) <= _13489:
                                            _32862 = mem[64]
                                            mem[64] = _20887 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                            _33718 = mem[_32862]
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32862]
                                            mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33718)] = mem[_32862 + 32 len ceil32(_33718)]
                                            if ceil32(_33718) > _33718:
                                                mem[_33718 + _20887 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                            return 32, mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33718) + 32]
                                        _32863 = mem[64]
                                        mem[64] = _20887 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                        mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                        _33719 = mem[_32863]
                                        mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32863]
                                        mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33719)] = mem[_32863 + 32 len ceil32(_33719)]
                                        if ceil32(_33719) > _33719:
                                            mem[_33719 + _20887 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                        return 32, mem[_20887 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33719) + 32]
                                    mem[_13489 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                    _20888 = mem[64]
                                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13489)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13489)]
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13489) <= _13489:
                                            _32864 = mem[64]
                                            mem[64] = _20888 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                            mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                            _33720 = mem[_32864]
                                            mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32864]
                                            mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33720)] = mem[_32864 + 32 len ceil32(_33720)]
                                            if ceil32(_33720) > _33720:
                                                mem[_33720 + _20888 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                            return 32, mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33720) + 32]
                                        _32865 = mem[64]
                                        mem[64] = _20888 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                        _33721 = mem[_32865]
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32865]
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33721)] = mem[_32865 + 32 len ceil32(_33721)]
                                        if ceil32(_33721) > _33721:
                                            mem[_33721 + _20888 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                        return 32, mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33721) + 32]
                                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                    mem[_20888 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13489)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13489)]
                                    mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13489) <= _13489:
                                        _32866 = mem[64]
                                        mem[64] = _20888 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                        _33722 = mem[_32866]
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32866]
                                        mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33722)] = mem[_32866 + 32 len ceil32(_33722)]
                                        if ceil32(_33722) > _33722:
                                            mem[_33722 + _20888 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                        return 32, mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33722) + 32]
                                    _32867 = mem[64]
                                    mem[64] = _20888 + (uint255(stor30.length) * 0.5) + _13489 + 37
                                    mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 37] = 32
                                    _33723 = mem[_32867]
                                    mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69] = mem[_32867]
                                    mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 101 len ceil32(_33723)] = mem[_32867 + 32 len ceil32(_33723)]
                                    if ceil32(_33723) > _33723:
                                        mem[_33723 + _20888 + (uint255(stor30.length) * 0.5) + _13489 + 101] = 0
                                    return 32, mem[_20888 + (uint255(stor30.length) * 0.5) + _13489 + 69 len ceil32(_33723) + 32]
                                if bool(stor30.length) == stor30.length.field_1 < 32:
                                    revert with 0, 34
                                mem[128] = stor30.length.field_1
                                if bool(stor30.length):
                                    if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor30.length):
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                                if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                    mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                                return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(stor30.length.field_1) + 160] = s
                                            if s:
                                                mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                                mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                        mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _697 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _760 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        require _697 + _760 + 32 <= return_data.size
                                        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_760)] = mem[ceil32(stor30.length.field_1) + _697 + 192 len ceil32(_760)]
                                        if ceil32(_760) <= _760:
                                            _11903 = mem[64]
                                            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                                _20778 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                                mem[mem[64] + stor30.length.field_1 + _20778 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_20778) <= _20778:
                                                    _27285 = mem[64]
                                                    mem[64] = mem[64] + stor30.length.field_1 + _20778 + 37
                                                    mem[_11903 + stor30.length.field_1 + _20778 + 37] = 32
                                                    _27970 = mem[_27285]
                                                    mem[_11903 + stor30.length.field_1 + _20778 + 69] = mem[_27285]
                                                    mem[_11903 + stor30.length.field_1 + _20778 + 101 len ceil32(_27970)] = mem[_27285 + 32 len ceil32(_27970)]
                                                    if ceil32(_27970) > _27970:
                                                        mem[_27970 + _11903 + stor30.length.field_1 + _20778 + 101] = 0
                                                    return 32, mem[_11903 + stor30.length.field_1 + _20778 + 69 len ceil32(_27970) + 32]
                                                _27286 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20778 + 37
                                                mem[_11903 + stor30.length.field_1 + _20778 + 37] = 32
                                                _27971 = mem[_27286]
                                                mem[_11903 + stor30.length.field_1 + _20778 + 69] = mem[_27286]
                                                mem[_11903 + stor30.length.field_1 + _20778 + 101 len ceil32(_27971)] = mem[_27286 + 32 len ceil32(_27971)]
                                                if ceil32(_27971) > _27971:
                                                    mem[_27971 + _11903 + stor30.length.field_1 + _20778 + 101] = 0
                                                return 32, mem[_11903 + stor30.length.field_1 + _20778 + 69 len ceil32(_27971) + 32]
                                            mem[stor30.length.field_1 + mem[64] + 32] = 0
                                            _20779 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20779 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20779) <= _20779:
                                                _27287 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20779 + 37
                                                mem[_11903 + stor30.length.field_1 + _20779 + 37] = 32
                                                _27972 = mem[_27287]
                                                mem[_11903 + stor30.length.field_1 + _20779 + 69] = mem[_27287]
                                                mem[_11903 + stor30.length.field_1 + _20779 + 101 len ceil32(_27972)] = mem[_27287 + 32 len ceil32(_27972)]
                                                if ceil32(_27972) > _27972:
                                                    mem[_27972 + _11903 + stor30.length.field_1 + _20779 + 101] = 0
                                                return 32, mem[_11903 + stor30.length.field_1 + _20779 + 69 len ceil32(_27972) + 32]
                                            _27288 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20779 + 37
                                            mem[_11903 + stor30.length.field_1 + _20779 + 37] = 32
                                            _27973 = mem[_27288]
                                            mem[_11903 + stor30.length.field_1 + _20779 + 69] = mem[_27288]
                                            mem[_11903 + stor30.length.field_1 + _20779 + 101 len ceil32(_27973)] = mem[_27288 + 32 len ceil32(_27973)]
                                            if ceil32(_27973) > _27973:
                                                mem[_27973 + _11903 + stor30.length.field_1 + _20779 + 101] = 0
                                            return 32, mem[_11903 + stor30.length.field_1 + _20779 + 69 len ceil32(_27973) + 32]
                                        mem[_760 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                        _11904 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            _20780 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20780 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20780) <= _20780:
                                                _27289 = mem[64]
                                                mem[64] = _11904 + stor30.length.field_1 + _20780 + 37
                                                mem[_11904 + stor30.length.field_1 + _20780 + 37] = 32
                                                _27974 = mem[_27289]
                                                mem[_11904 + stor30.length.field_1 + _20780 + 69] = mem[_27289]
                                                mem[_11904 + stor30.length.field_1 + _20780 + 101 len ceil32(_27974)] = mem[_27289 + 32 len ceil32(_27974)]
                                                if ceil32(_27974) > _27974:
                                                    mem[_27974 + _11904 + stor30.length.field_1 + _20780 + 101] = 0
                                                return 32, mem[_11904 + stor30.length.field_1 + _20780 + 69 len ceil32(_27974) + 32]
                                            _27290 = mem[64]
                                            mem[64] = _11904 + stor30.length.field_1 + _20780 + 37
                                            mem[_11904 + stor30.length.field_1 + _20780 + 37] = 32
                                            _27975 = mem[_27290]
                                            mem[_11904 + stor30.length.field_1 + _20780 + 69] = mem[_27290]
                                            mem[_11904 + stor30.length.field_1 + _20780 + 101 len ceil32(_27975)] = mem[_27290 + 32 len ceil32(_27975)]
                                            if ceil32(_27975) > _27975:
                                                mem[_27975 + _11904 + stor30.length.field_1 + _20780 + 101] = 0
                                            return 32, mem[_11904 + stor30.length.field_1 + _20780 + 69 len ceil32(_27975) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        _20781 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20781 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20781) <= _20781:
                                            _27291 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20781 + 37
                                            mem[_11904 + stor30.length.field_1 + _20781 + 37] = 32
                                            _27976 = mem[_27291]
                                            mem[_11904 + stor30.length.field_1 + _20781 + 69] = mem[_27291]
                                            mem[_11904 + stor30.length.field_1 + _20781 + 101 len ceil32(_27976)] = mem[_27291 + 32 len ceil32(_27976)]
                                            if ceil32(_27976) > _27976:
                                                mem[_27976 + _11904 + stor30.length.field_1 + _20781 + 101] = 0
                                            return 32, mem[_11904 + stor30.length.field_1 + _20781 + 69 len ceil32(_27976) + 32]
                                        _27292 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20781 + 37
                                        mem[_11904 + stor30.length.field_1 + _20781 + 37] = 32
                                        _27977 = mem[_27292]
                                        mem[_11904 + stor30.length.field_1 + _20781 + 69] = mem[_27292]
                                        mem[_11904 + stor30.length.field_1 + _20781 + 101 len ceil32(_27977)] = mem[_27292 + 32 len ceil32(_27977)]
                                        if ceil32(_27977) > _27977:
                                            mem[_27977 + _11904 + stor30.length.field_1 + _20781 + 101] = 0
                                        return 32, mem[_11904 + stor30.length.field_1 + _20781 + 69 len ceil32(_27977) + 32]
                                    if 31 >= uint255(stor30.length) * 0.5:
                                        mem[160] = 256 * stor30.length.field_8
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                                if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                    mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                                return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(stor30.length.field_1) + 160] = s
                                            if s:
                                                mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                                mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                        mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _763 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _842 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        require _763 + _842 + 32 <= return_data.size
                                        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_842)] = mem[ceil32(stor30.length.field_1) + _763 + 192 len ceil32(_842)]
                                        if ceil32(_842) <= _842:
                                            _11907 = mem[64]
                                            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                                _20786 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                                mem[mem[64] + stor30.length.field_1 + _20786 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_20786) <= _20786:
                                                    _27299 = mem[64]
                                                    mem[64] = mem[64] + stor30.length.field_1 + _20786 + 37
                                                    mem[_11907 + stor30.length.field_1 + _20786 + 37] = 32
                                                    _28002 = mem[_27299]
                                                    mem[_11907 + stor30.length.field_1 + _20786 + 69] = mem[_27299]
                                                    mem[_11907 + stor30.length.field_1 + _20786 + 101 len ceil32(_28002)] = mem[_27299 + 32 len ceil32(_28002)]
                                                    if ceil32(_28002) > _28002:
                                                        mem[_28002 + _11907 + stor30.length.field_1 + _20786 + 101] = 0
                                                    return 32, mem[_11907 + stor30.length.field_1 + _20786 + 69 len ceil32(_28002) + 32]
                                                _27300 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20786 + 37
                                                mem[_11907 + stor30.length.field_1 + _20786 + 37] = 32
                                                _28003 = mem[_27300]
                                                mem[_11907 + stor30.length.field_1 + _20786 + 69] = mem[_27300]
                                                mem[_11907 + stor30.length.field_1 + _20786 + 101 len ceil32(_28003)] = mem[_27300 + 32 len ceil32(_28003)]
                                                if ceil32(_28003) > _28003:
                                                    mem[_28003 + _11907 + stor30.length.field_1 + _20786 + 101] = 0
                                                return 32, mem[_11907 + stor30.length.field_1 + _20786 + 69 len ceil32(_28003) + 32]
                                            mem[stor30.length.field_1 + mem[64] + 32] = 0
                                            _20787 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20787 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20787) <= _20787:
                                                _27301 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20787 + 37
                                                mem[_11907 + stor30.length.field_1 + _20787 + 37] = 32
                                                _28004 = mem[_27301]
                                                mem[_11907 + stor30.length.field_1 + _20787 + 69] = mem[_27301]
                                                mem[_11907 + stor30.length.field_1 + _20787 + 101 len ceil32(_28004)] = mem[_27301 + 32 len ceil32(_28004)]
                                                if ceil32(_28004) > _28004:
                                                    mem[_28004 + _11907 + stor30.length.field_1 + _20787 + 101] = 0
                                                return 32, mem[_11907 + stor30.length.field_1 + _20787 + 69 len ceil32(_28004) + 32]
                                            _27302 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20787 + 37
                                            mem[_11907 + stor30.length.field_1 + _20787 + 37] = 32
                                            _28005 = mem[_27302]
                                            mem[_11907 + stor30.length.field_1 + _20787 + 69] = mem[_27302]
                                            mem[_11907 + stor30.length.field_1 + _20787 + 101 len ceil32(_28005)] = mem[_27302 + 32 len ceil32(_28005)]
                                            if ceil32(_28005) > _28005:
                                                mem[_28005 + _11907 + stor30.length.field_1 + _20787 + 101] = 0
                                            return 32, mem[_11907 + stor30.length.field_1 + _20787 + 69 len ceil32(_28005) + 32]
                                        mem[_842 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                        _11908 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            _20788 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20788 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20788) <= _20788:
                                                _27303 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20788 + 37
                                                mem[_11908 + stor30.length.field_1 + _20788 + 37] = 32
                                                _28006 = mem[_27303]
                                                mem[_11908 + stor30.length.field_1 + _20788 + 69] = mem[_27303]
                                                mem[_11908 + stor30.length.field_1 + _20788 + 101 len ceil32(_28006)] = mem[_27303 + 32 len ceil32(_28006)]
                                                if ceil32(_28006) > _28006:
                                                    mem[_28006 + _11908 + stor30.length.field_1 + _20788 + 101] = 0
                                                return 32, mem[_11908 + stor30.length.field_1 + _20788 + 69 len ceil32(_28006) + 32]
                                            _27304 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20788 + 37
                                            mem[_11908 + stor30.length.field_1 + _20788 + 37] = 32
                                            _28007 = mem[_27304]
                                            mem[_11908 + stor30.length.field_1 + _20788 + 69] = mem[_27304]
                                            mem[_11908 + stor30.length.field_1 + _20788 + 101 len ceil32(_28007)] = mem[_27304 + 32 len ceil32(_28007)]
                                            if ceil32(_28007) > _28007:
                                                mem[_28007 + _11908 + stor30.length.field_1 + _20788 + 101] = 0
                                            return 32, mem[_11908 + stor30.length.field_1 + _20788 + 69 len ceil32(_28007) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        _20789 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20789 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20789) <= _20789:
                                            _27305 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20789 + 37
                                            mem[_11908 + stor30.length.field_1 + _20789 + 37] = 32
                                            _28008 = mem[_27305]
                                            mem[_11908 + stor30.length.field_1 + _20789 + 69] = mem[_27305]
                                            mem[_11908 + stor30.length.field_1 + _20789 + 101 len ceil32(_28008)] = mem[_27305 + 32 len ceil32(_28008)]
                                            if ceil32(_28008) > _28008:
                                                mem[_28008 + _11908 + stor30.length.field_1 + _20789 + 101] = 0
                                            return 32, mem[_11908 + stor30.length.field_1 + _20789 + 69 len ceil32(_28008) + 32]
                                        _27306 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20789 + 37
                                        mem[_11908 + stor30.length.field_1 + _20789 + 37] = 32
                                        _28009 = mem[_27306]
                                        mem[_11908 + stor30.length.field_1 + _20789 + 69] = mem[_27306]
                                        mem[_11908 + stor30.length.field_1 + _20789 + 101 len ceil32(_28009)] = mem[_27306 + 32 len ceil32(_28009)]
                                        if ceil32(_28009) > _28009:
                                            mem[_28009 + _11908 + stor30.length.field_1 + _20789 + 101] = 0
                                        return 32, mem[_11908 + stor30.length.field_1 + _20789 + 69 len ceil32(_28009) + 32]
                                    mem[0] = 30
                                    mem[160] = uint256(stor30.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor30.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor30[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(stor30.length.field_1) + 160] = s
                                        if s:
                                            mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                            mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _12532 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _13498 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    require _12532 + _13498 + 32 <= return_data.size
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13498)] = mem[ceil32(stor30.length.field_1) + _12532 + 192 len ceil32(_13498)]
                                    if ceil32(_13498) <= _13498:
                                        _20901 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13498)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13498)]
                                            mem[mem[64] + stor30.length.field_1 + _13498 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_13498) <= _13498:
                                                _32884 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                                mem[_20901 + stor30.length.field_1 + _13498 + 37] = 32
                                                _33748 = mem[_32884]
                                                mem[_20901 + stor30.length.field_1 + _13498 + 69] = mem[_32884]
                                                mem[_20901 + stor30.length.field_1 + _13498 + 101 len ceil32(_33748)] = mem[_32884 + 32 len ceil32(_33748)]
                                                if ceil32(_33748) > _33748:
                                                    mem[_33748 + _20901 + stor30.length.field_1 + _13498 + 101] = 0
                                                return 32, mem[_20901 + stor30.length.field_1 + _13498 + 69 len ceil32(_33748) + 32]
                                            _32885 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                            mem[_20901 + stor30.length.field_1 + _13498 + 37] = 32
                                            _33749 = mem[_32885]
                                            mem[_20901 + stor30.length.field_1 + _13498 + 69] = mem[_32885]
                                            mem[_20901 + stor30.length.field_1 + _13498 + 101 len ceil32(_33749)] = mem[_32885 + 32 len ceil32(_33749)]
                                            if ceil32(_33749) > _33749:
                                                mem[_33749 + _20901 + stor30.length.field_1 + _13498 + 101] = 0
                                            return 32, mem[_20901 + stor30.length.field_1 + _13498 + 69 len ceil32(_33749) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13498)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13498)]
                                        mem[mem[64] + stor30.length.field_1 + _13498 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13498) <= _13498:
                                            _32886 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                            mem[_20901 + stor30.length.field_1 + _13498 + 37] = 32
                                            _33750 = mem[_32886]
                                            mem[_20901 + stor30.length.field_1 + _13498 + 69] = mem[_32886]
                                            mem[_20901 + stor30.length.field_1 + _13498 + 101 len ceil32(_33750)] = mem[_32886 + 32 len ceil32(_33750)]
                                            if ceil32(_33750) > _33750:
                                                mem[_33750 + _20901 + stor30.length.field_1 + _13498 + 101] = 0
                                            return 32, mem[_20901 + stor30.length.field_1 + _13498 + 69 len ceil32(_33750) + 32]
                                        _32887 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                        mem[_20901 + stor30.length.field_1 + _13498 + 37] = 32
                                        _33751 = mem[_32887]
                                        mem[_20901 + stor30.length.field_1 + _13498 + 69] = mem[_32887]
                                        mem[_20901 + stor30.length.field_1 + _13498 + 101 len ceil32(_33751)] = mem[_32887 + 32 len ceil32(_33751)]
                                        if ceil32(_33751) > _33751:
                                            mem[_33751 + _20901 + stor30.length.field_1 + _13498 + 101] = 0
                                        return 32, mem[_20901 + stor30.length.field_1 + _13498 + 69 len ceil32(_33751) + 32]
                                    mem[_13498 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                    _20902 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13498)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13498)]
                                        mem[mem[64] + stor30.length.field_1 + _13498 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13498) <= _13498:
                                            _32888 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                            mem[_20902 + stor30.length.field_1 + _13498 + 37] = 32
                                            _33752 = mem[_32888]
                                            mem[_20902 + stor30.length.field_1 + _13498 + 69] = mem[_32888]
                                            mem[_20902 + stor30.length.field_1 + _13498 + 101 len ceil32(_33752)] = mem[_32888 + 32 len ceil32(_33752)]
                                            if ceil32(_33752) > _33752:
                                                mem[_33752 + _20902 + stor30.length.field_1 + _13498 + 101] = 0
                                            return 32, mem[_20902 + stor30.length.field_1 + _13498 + 69 len ceil32(_33752) + 32]
                                        _32889 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                        mem[_20902 + stor30.length.field_1 + _13498 + 37] = 32
                                        _33753 = mem[_32889]
                                        mem[_20902 + stor30.length.field_1 + _13498 + 69] = mem[_32889]
                                        mem[_20902 + stor30.length.field_1 + _13498 + 101 len ceil32(_33753)] = mem[_32889 + 32 len ceil32(_33753)]
                                        if ceil32(_33753) > _33753:
                                            mem[_33753 + _20902 + stor30.length.field_1 + _13498 + 101] = 0
                                        return 32, mem[_20902 + stor30.length.field_1 + _13498 + 69 len ceil32(_33753) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13498)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13498)]
                                    mem[mem[64] + stor30.length.field_1 + _13498 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13498) <= _13498:
                                        _32890 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                        mem[_20902 + stor30.length.field_1 + _13498 + 37] = 32
                                        _33754 = mem[_32890]
                                        mem[_20902 + stor30.length.field_1 + _13498 + 69] = mem[_32890]
                                        mem[_20902 + stor30.length.field_1 + _13498 + 101 len ceil32(_33754)] = mem[_32890 + 32 len ceil32(_33754)]
                                        if ceil32(_33754) > _33754:
                                            mem[_33754 + _20902 + stor30.length.field_1 + _13498 + 101] = 0
                                        return 32, mem[_20902 + stor30.length.field_1 + _13498 + 69 len ceil32(_33754) + 32]
                                    _32891 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13498 + 37
                                    mem[_20902 + stor30.length.field_1 + _13498 + 37] = 32
                                    _33755 = mem[_32891]
                                    mem[_20902 + stor30.length.field_1 + _13498 + 69] = mem[_32891]
                                    mem[_20902 + stor30.length.field_1 + _13498 + 101 len ceil32(_33755)] = mem[_32891 + 32 len ceil32(_33755)]
                                    if ceil32(_33755) > _33755:
                                        mem[_33755 + _20902 + stor30.length.field_1 + _13498 + 101] = 0
                                    return 32, mem[_20902 + stor30.length.field_1 + _13498 + 69 len ceil32(_33755) + 32]
                                if bool(stor30.length) == stor30.length.field_1 < 32:
                                    revert with 0, 34
                                if not stor30.length.field_1:
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(stor30.length.field_1) + 160] = s
                                        if s:
                                            mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                            mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _728 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _802 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    require _728 + _802 + 32 <= return_data.size
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_802)] = mem[ceil32(stor30.length.field_1) + _728 + 192 len ceil32(_802)]
                                    if ceil32(_802) <= _802:
                                        _11909 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            _20792 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20792 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20792) <= _20792:
                                                _27307 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20792 + 37
                                                mem[_11909 + stor30.length.field_1 + _20792 + 37] = 32
                                                _28018 = mem[_27307]
                                                mem[_11909 + stor30.length.field_1 + _20792 + 69] = mem[_27307]
                                                mem[_11909 + stor30.length.field_1 + _20792 + 101 len ceil32(_28018)] = mem[_27307 + 32 len ceil32(_28018)]
                                                if ceil32(_28018) > _28018:
                                                    mem[_28018 + _11909 + stor30.length.field_1 + _20792 + 101] = 0
                                                return 32, mem[_11909 + stor30.length.field_1 + _20792 + 69 len ceil32(_28018) + 32]
                                            _27308 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20792 + 37
                                            mem[_11909 + stor30.length.field_1 + _20792 + 37] = 32
                                            _28019 = mem[_27308]
                                            mem[_11909 + stor30.length.field_1 + _20792 + 69] = mem[_27308]
                                            mem[_11909 + stor30.length.field_1 + _20792 + 101 len ceil32(_28019)] = mem[_27308 + 32 len ceil32(_28019)]
                                            if ceil32(_28019) > _28019:
                                                mem[_28019 + _11909 + stor30.length.field_1 + _20792 + 101] = 0
                                            return 32, mem[_11909 + stor30.length.field_1 + _20792 + 69 len ceil32(_28019) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        _20793 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20793 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20793) <= _20793:
                                            _27309 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20793 + 37
                                            mem[_11909 + stor30.length.field_1 + _20793 + 37] = 32
                                            _28020 = mem[_27309]
                                            mem[_11909 + stor30.length.field_1 + _20793 + 69] = mem[_27309]
                                            mem[_11909 + stor30.length.field_1 + _20793 + 101 len ceil32(_28020)] = mem[_27309 + 32 len ceil32(_28020)]
                                            if ceil32(_28020) > _28020:
                                                mem[_28020 + _11909 + stor30.length.field_1 + _20793 + 101] = 0
                                            return 32, mem[_11909 + stor30.length.field_1 + _20793 + 69 len ceil32(_28020) + 32]
                                        _27310 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20793 + 37
                                        mem[_11909 + stor30.length.field_1 + _20793 + 37] = 32
                                        _28021 = mem[_27310]
                                        mem[_11909 + stor30.length.field_1 + _20793 + 69] = mem[_27310]
                                        mem[_11909 + stor30.length.field_1 + _20793 + 101 len ceil32(_28021)] = mem[_27310 + 32 len ceil32(_28021)]
                                        if ceil32(_28021) > _28021:
                                            mem[_28021 + _11909 + stor30.length.field_1 + _20793 + 101] = 0
                                        return 32, mem[_11909 + stor30.length.field_1 + _20793 + 69 len ceil32(_28021) + 32]
                                    mem[_802 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                    _11910 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        _20794 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20794 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20794) <= _20794:
                                            _27311 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20794 + 37
                                            mem[_11910 + stor30.length.field_1 + _20794 + 37] = 32
                                            _28022 = mem[_27311]
                                            mem[_11910 + stor30.length.field_1 + _20794 + 69] = mem[_27311]
                                            mem[_11910 + stor30.length.field_1 + _20794 + 101 len ceil32(_28022)] = mem[_27311 + 32 len ceil32(_28022)]
                                            if ceil32(_28022) > _28022:
                                                mem[_28022 + _11910 + stor30.length.field_1 + _20794 + 101] = 0
                                            return 32, mem[_11910 + stor30.length.field_1 + _20794 + 69 len ceil32(_28022) + 32]
                                        _27312 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20794 + 37
                                        mem[_11910 + stor30.length.field_1 + _20794 + 37] = 32
                                        _28023 = mem[_27312]
                                        mem[_11910 + stor30.length.field_1 + _20794 + 69] = mem[_27312]
                                        mem[_11910 + stor30.length.field_1 + _20794 + 101 len ceil32(_28023)] = mem[_27312 + 32 len ceil32(_28023)]
                                        if ceil32(_28023) > _28023:
                                            mem[_28023 + _11910 + stor30.length.field_1 + _20794 + 101] = 0
                                        return 32, mem[_11910 + stor30.length.field_1 + _20794 + 69 len ceil32(_28023) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    _20795 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20795 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20795) <= _20795:
                                        _27313 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20795 + 37
                                        mem[_11910 + stor30.length.field_1 + _20795 + 37] = 32
                                        _28024 = mem[_27313]
                                        mem[_11910 + stor30.length.field_1 + _20795 + 69] = mem[_27313]
                                        mem[_11910 + stor30.length.field_1 + _20795 + 101 len ceil32(_28024)] = mem[_27313 + 32 len ceil32(_28024)]
                                        if ceil32(_28024) > _28024:
                                            mem[_28024 + _11910 + stor30.length.field_1 + _20795 + 101] = 0
                                        return 32, mem[_11910 + stor30.length.field_1 + _20795 + 69 len ceil32(_28024) + 32]
                                    _27314 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20795 + 37
                                    mem[_11910 + stor30.length.field_1 + _20795 + 37] = 32
                                    _28025 = mem[_27314]
                                    mem[_11910 + stor30.length.field_1 + _20795 + 69] = mem[_27314]
                                    mem[_11910 + stor30.length.field_1 + _20795 + 101 len ceil32(_28025)] = mem[_27314 + 32 len ceil32(_28025)]
                                    if ceil32(_28025) > _28025:
                                        mem[_28025 + _11910 + stor30.length.field_1 + _20795 + 101] = 0
                                    return 32, mem[_11910 + stor30.length.field_1 + _20795 + 69 len ceil32(_28025) + 32]
                                if 31 >= stor30.length.field_1:
                                    mem[160] = 256 * stor30.length.field_8
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(stor30.length.field_1) + 160] = s
                                        if s:
                                            mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                            mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _805 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _893 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    require _805 + _893 + 32 <= return_data.size
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_893)] = mem[ceil32(stor30.length.field_1) + _805 + 192 len ceil32(_893)]
                                    if ceil32(_893) <= _893:
                                        _11913 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            _20800 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20800 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20800) <= _20800:
                                                _27321 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20800 + 37
                                                mem[_11913 + stor30.length.field_1 + _20800 + 37] = 32
                                                _28050 = mem[_27321]
                                                mem[_11913 + stor30.length.field_1 + _20800 + 69] = mem[_27321]
                                                mem[_11913 + stor30.length.field_1 + _20800 + 101 len ceil32(_28050)] = mem[_27321 + 32 len ceil32(_28050)]
                                                if ceil32(_28050) > _28050:
                                                    mem[_28050 + _11913 + stor30.length.field_1 + _20800 + 101] = 0
                                                return 32, mem[_11913 + stor30.length.field_1 + _20800 + 69 len ceil32(_28050) + 32]
                                            _27322 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20800 + 37
                                            mem[_11913 + stor30.length.field_1 + _20800 + 37] = 32
                                            _28051 = mem[_27322]
                                            mem[_11913 + stor30.length.field_1 + _20800 + 69] = mem[_27322]
                                            mem[_11913 + stor30.length.field_1 + _20800 + 101 len ceil32(_28051)] = mem[_27322 + 32 len ceil32(_28051)]
                                            if ceil32(_28051) > _28051:
                                                mem[_28051 + _11913 + stor30.length.field_1 + _20800 + 101] = 0
                                            return 32, mem[_11913 + stor30.length.field_1 + _20800 + 69 len ceil32(_28051) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        _20801 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20801 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20801) <= _20801:
                                            _27323 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20801 + 37
                                            mem[_11913 + stor30.length.field_1 + _20801 + 37] = 32
                                            _28052 = mem[_27323]
                                            mem[_11913 + stor30.length.field_1 + _20801 + 69] = mem[_27323]
                                            mem[_11913 + stor30.length.field_1 + _20801 + 101 len ceil32(_28052)] = mem[_27323 + 32 len ceil32(_28052)]
                                            if ceil32(_28052) > _28052:
                                                mem[_28052 + _11913 + stor30.length.field_1 + _20801 + 101] = 0
                                            return 32, mem[_11913 + stor30.length.field_1 + _20801 + 69 len ceil32(_28052) + 32]
                                        _27324 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20801 + 37
                                        mem[_11913 + stor30.length.field_1 + _20801 + 37] = 32
                                        _28053 = mem[_27324]
                                        mem[_11913 + stor30.length.field_1 + _20801 + 69] = mem[_27324]
                                        mem[_11913 + stor30.length.field_1 + _20801 + 101 len ceil32(_28053)] = mem[_27324 + 32 len ceil32(_28053)]
                                        if ceil32(_28053) > _28053:
                                            mem[_28053 + _11913 + stor30.length.field_1 + _20801 + 101] = 0
                                        return 32, mem[_11913 + stor30.length.field_1 + _20801 + 69 len ceil32(_28053) + 32]
                                    mem[_893 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                    _11914 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        _20802 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20802 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20802) <= _20802:
                                            _27325 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20802 + 37
                                            mem[_11914 + stor30.length.field_1 + _20802 + 37] = 32
                                            _28054 = mem[_27325]
                                            mem[_11914 + stor30.length.field_1 + _20802 + 69] = mem[_27325]
                                            mem[_11914 + stor30.length.field_1 + _20802 + 101 len ceil32(_28054)] = mem[_27325 + 32 len ceil32(_28054)]
                                            if ceil32(_28054) > _28054:
                                                mem[_28054 + _11914 + stor30.length.field_1 + _20802 + 101] = 0
                                            return 32, mem[_11914 + stor30.length.field_1 + _20802 + 69 len ceil32(_28054) + 32]
                                        _27326 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20802 + 37
                                        mem[_11914 + stor30.length.field_1 + _20802 + 37] = 32
                                        _28055 = mem[_27326]
                                        mem[_11914 + stor30.length.field_1 + _20802 + 69] = mem[_27326]
                                        mem[_11914 + stor30.length.field_1 + _20802 + 101 len ceil32(_28055)] = mem[_27326 + 32 len ceil32(_28055)]
                                        if ceil32(_28055) > _28055:
                                            mem[_28055 + _11914 + stor30.length.field_1 + _20802 + 101] = 0
                                        return 32, mem[_11914 + stor30.length.field_1 + _20802 + 69 len ceil32(_28055) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    _20803 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20803 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20803) <= _20803:
                                        _27327 = mem[64]
                                        mem[64] = _11914 + stor30.length.field_1 + _20803 + 37
                                        mem[_11914 + stor30.length.field_1 + _20803 + 37] = 32
                                        _28056 = mem[_27327]
                                        mem[_11914 + stor30.length.field_1 + _20803 + 69] = mem[_27327]
                                        mem[_11914 + stor30.length.field_1 + _20803 + 101 len ceil32(_28056)] = mem[_27327 + 32 len ceil32(_28056)]
                                        if ceil32(_28056) > _28056:
                                            mem[_28056 + _11914 + stor30.length.field_1 + _20803 + 101] = 0
                                        return 32, mem[_11914 + stor30.length.field_1 + _20803 + 69 len ceil32(_28056) + 32]
                                    _27328 = mem[64]
                                    mem[64] = _11914 + stor30.length.field_1 + _20803 + 37
                                    mem[_11914 + stor30.length.field_1 + _20803 + 37] = 32
                                    _28057 = mem[_27328]
                                    mem[_11914 + stor30.length.field_1 + _20803 + 69] = mem[_27328]
                                    mem[_11914 + stor30.length.field_1 + _20803 + 101 len ceil32(_28057)] = mem[_27328 + 32 len ceil32(_28057)]
                                    if ceil32(_28057) > _28057:
                                        mem[_28057 + _11914 + stor30.length.field_1 + _20803 + 101] = 0
                                    return 32, mem[_11914 + stor30.length.field_1 + _20803 + 69 len ceil32(_28057) + 32]
                                mem[0] = 30
                                mem[160] = uint256(stor30.field_0)
                                idx = 160
                                s = 0
                                while stor30.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor30[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if not stor31:
                                    if not cd[4]:
                                        mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                            mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                    s = 0
                                    idx = cd[4]
                                    while idx:
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        idx = idx / 10
                                        continue 
                                    if s > test266151307():
                                        revert with 0, 65
                                    mem[ceil32(stor30.length.field_1) + 160] = s
                                    if s:
                                        mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                    t = s
                                    idx = cd[4]
                                    while idx:
                                        if t < 1:
                                            revert with 0, 17
                                        if 48 > !(idx % 10):
                                            revert with 0, 17
                                        if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                            revert with 0, 50
                                        mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                        t = t - 1
                                        idx = idx / 10
                                        continue 
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                        mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                    if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                    return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) + 32], 
                                mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                require ext_code.size(stor31)
                                staticcall stor31.0xff74ef30 with:
                                        gas gas_remaining wei
                                       args cd[4]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                _12542 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                _13507 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                    revert with 0, 65
                                if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                    revert with 0, 65
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                require _12542 + _13507 + 32 <= return_data.size
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13507)] = mem[ceil32(stor30.length.field_1) + _12542 + 192 len ceil32(_13507)]
                                if ceil32(_13507) <= _13507:
                                    _20915 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13507)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13507)]
                                        mem[mem[64] + stor30.length.field_1 + _13507 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13507) <= _13507:
                                            _32908 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                            mem[_20915 + stor30.length.field_1 + _13507 + 37] = 32
                                            _33780 = mem[_32908]
                                            mem[_20915 + stor30.length.field_1 + _13507 + 69] = mem[_32908]
                                            mem[_20915 + stor30.length.field_1 + _13507 + 101 len ceil32(_33780)] = mem[_32908 + 32 len ceil32(_33780)]
                                            if ceil32(_33780) > _33780:
                                                mem[_33780 + _20915 + stor30.length.field_1 + _13507 + 101] = 0
                                            return 32, mem[_20915 + stor30.length.field_1 + _13507 + 69 len ceil32(_33780) + 32]
                                        _32909 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                        mem[_20915 + stor30.length.field_1 + _13507 + 37] = 32
                                        _33781 = mem[_32909]
                                        mem[_20915 + stor30.length.field_1 + _13507 + 69] = mem[_32909]
                                        mem[_20915 + stor30.length.field_1 + _13507 + 101 len ceil32(_33781)] = mem[_32909 + 32 len ceil32(_33781)]
                                        if ceil32(_33781) > _33781:
                                            mem[_33781 + _20915 + stor30.length.field_1 + _13507 + 101] = 0
                                        return 32, mem[_20915 + stor30.length.field_1 + _13507 + 69 len ceil32(_33781) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13507)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13507)]
                                    mem[mem[64] + stor30.length.field_1 + _13507 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13507) <= _13507:
                                        _32910 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                        mem[_20915 + stor30.length.field_1 + _13507 + 37] = 32
                                        _33782 = mem[_32910]
                                        mem[_20915 + stor30.length.field_1 + _13507 + 69] = mem[_32910]
                                        mem[_20915 + stor30.length.field_1 + _13507 + 101 len ceil32(_33782)] = mem[_32910 + 32 len ceil32(_33782)]
                                        if ceil32(_33782) > _33782:
                                            mem[_33782 + _20915 + stor30.length.field_1 + _13507 + 101] = 0
                                        return 32, mem[_20915 + stor30.length.field_1 + _13507 + 69 len ceil32(_33782) + 32]
                                    _32911 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                    mem[_20915 + stor30.length.field_1 + _13507 + 37] = 32
                                    _33783 = mem[_32911]
                                    mem[_20915 + stor30.length.field_1 + _13507 + 69] = mem[_32911]
                                    mem[_20915 + stor30.length.field_1 + _13507 + 101 len ceil32(_33783)] = mem[_32911 + 32 len ceil32(_33783)]
                                    if ceil32(_33783) > _33783:
                                        mem[_33783 + _20915 + stor30.length.field_1 + _13507 + 101] = 0
                                    return 32, mem[_20915 + stor30.length.field_1 + _13507 + 69 len ceil32(_33783) + 32]
                                mem[_13507 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                _20916 = mem[64]
                                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13507)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13507)]
                                    mem[mem[64] + stor30.length.field_1 + _13507 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13507) <= _13507:
                                        _32912 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                        mem[_20916 + stor30.length.field_1 + _13507 + 37] = 32
                                        _33784 = mem[_32912]
                                        mem[_20916 + stor30.length.field_1 + _13507 + 69] = mem[_32912]
                                        mem[_20916 + stor30.length.field_1 + _13507 + 101 len ceil32(_33784)] = mem[_32912 + 32 len ceil32(_33784)]
                                        if ceil32(_33784) > _33784:
                                            mem[_33784 + _20916 + stor30.length.field_1 + _13507 + 101] = 0
                                        return 32, mem[_20916 + stor30.length.field_1 + _13507 + 69 len ceil32(_33784) + 32]
                                    _32913 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                    mem[_20916 + stor30.length.field_1 + _13507 + 37] = 32
                                    _33785 = mem[_32913]
                                    mem[_20916 + stor30.length.field_1 + _13507 + 69] = mem[_32913]
                                    mem[_20916 + stor30.length.field_1 + _13507 + 101 len ceil32(_33785)] = mem[_32913 + 32 len ceil32(_33785)]
                                    if ceil32(_33785) > _33785:
                                        mem[_33785 + _20916 + stor30.length.field_1 + _13507 + 101] = 0
                                    return 32, mem[_20916 + stor30.length.field_1 + _13507 + 69 len ceil32(_33785) + 32]
                                mem[stor30.length.field_1 + mem[64] + 32] = 0
                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13507)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13507)]
                                mem[mem[64] + stor30.length.field_1 + _13507 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_13507) <= _13507:
                                    _32914 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                    mem[_20916 + stor30.length.field_1 + _13507 + 37] = 32
                                    _33786 = mem[_32914]
                                    mem[_20916 + stor30.length.field_1 + _13507 + 69] = mem[_32914]
                                    mem[_20916 + stor30.length.field_1 + _13507 + 101 len ceil32(_33786)] = mem[_32914 + 32 len ceil32(_33786)]
                                    if ceil32(_33786) > _33786:
                                        mem[_33786 + _20916 + stor30.length.field_1 + _13507 + 101] = 0
                                    return 32, mem[_20916 + stor30.length.field_1 + _13507 + 69 len ceil32(_33786) + 32]
                                _32915 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _13507 + 37
                                mem[_20916 + stor30.length.field_1 + _13507 + 37] = 32
                                _33787 = mem[_32915]
                                mem[_20916 + stor30.length.field_1 + _13507 + 69] = mem[_32915]
                                mem[_20916 + stor30.length.field_1 + _13507 + 101 len ceil32(_33787)] = mem[_32915 + 32 len ceil32(_33787)]
                                if ceil32(_33787) > _33787:
                                    mem[_33787 + _20916 + stor30.length.field_1 + _13507 + 101] = 0
                                return 32, mem[_20916 + stor30.length.field_1 + _13507 + 69 len ceil32(_33787) + 32]
                            if bool(stor30.length) == stor30.length.field_1 < 32:
                                revert with 0, 34
                            if stor30.length.field_1 <= 0:
                                return ''
                            if bool(stor30.length):
                                if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                    revert with 0, 34
                                mem[128] = uint255(stor30.length) * 0.5
                                if bool(stor30.length):
                                    if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor30.length):
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                    return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                            if not s:
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33804 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33804)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33804)]
                                                        if ceil32(_33804) > _33804:
                                                            mem[_33804 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33804) + 32], 
                                                    _33805 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33805)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33805)]
                                                    if ceil32(_33805) > _33805:
                                                        mem[_33805 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33805) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33806 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33806)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33806)]
                                                    if ceil32(_33806) > _33806:
                                                        mem[_33806 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33806) + 32], 
                                                _33807 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33807)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33807)]
                                                if ceil32(_33807) > _33807:
                                                    mem[_33807 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33807) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33808 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33808)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33808)]
                                                    if ceil32(_33808) > _33808:
                                                        mem[_33808 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33808) + 32], 
                                                _33809 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33809)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33809)]
                                                if ceil32(_33809) > _33809:
                                                    mem[_33809 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33809) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33810 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33810)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33810)]
                                                if ceil32(_33810) > _33810:
                                                    mem[_33810 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33810) + 32], 
                                            _33811 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33811)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33811)]
                                            if ceil32(_33811) > _33811:
                                                mem[_33811 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33811) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _703 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _766 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _766
                                        require _703 + _766 + 32 <= return_data.size
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_766)] = mem[ceil32(uint255(stor30.length) * 0.5) + _703 + 192 len ceil32(_766)]
                                        if ceil32(_766) <= _766:
                                            _11915 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_766)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_766)]
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_766) <= _766:
                                                    _27329 = mem[64]
                                                    mem[64] = _11915 + (uint255(stor30.length) * 0.5) + _766 + 37
                                                    mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                                    _28066 = mem[_27329]
                                                    mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27329]
                                                    mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28066)] = mem[_27329 + 32 len ceil32(_28066)]
                                                    if ceil32(_28066) > _28066:
                                                        mem[_28066 + _11915 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                                    return 32, mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28066) + 32]
                                                _27330 = mem[64]
                                                mem[64] = _11915 + (uint255(stor30.length) * 0.5) + _766 + 37
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                                _28067 = mem[_27330]
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27330]
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28067)] = mem[_27330 + 32 len ceil32(_28067)]
                                                if ceil32(_28067) > _28067:
                                                    mem[_28067 + _11915 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                                return 32, mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28067) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_11915 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_766)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_766)]
                                            mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_766) <= _766:
                                                _27331 = mem[64]
                                                mem[64] = _11915 + (uint255(stor30.length) * 0.5) + _766 + 37
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                                _28068 = mem[_27331]
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27331]
                                                mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28068)] = mem[_27331 + 32 len ceil32(_28068)]
                                                if ceil32(_28068) > _28068:
                                                    mem[_28068 + _11915 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                                return 32, mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28068) + 32]
                                            _27332 = mem[64]
                                            mem[64] = _11915 + (uint255(stor30.length) * 0.5) + _766 + 37
                                            mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                            _28069 = mem[_27332]
                                            mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27332]
                                            mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28069)] = mem[_27332 + 32 len ceil32(_28069)]
                                            if ceil32(_28069) > _28069:
                                                mem[_28069 + _11915 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                            return 32, mem[_11915 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28069) + 32]
                                        mem[_766 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                        _11916 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_766)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_766)]
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_766) <= _766:
                                                _27333 = mem[64]
                                                mem[64] = _11916 + (uint255(stor30.length) * 0.5) + _766 + 37
                                                mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                                _28070 = mem[_27333]
                                                mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27333]
                                                mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28070)] = mem[_27333 + 32 len ceil32(_28070)]
                                                if ceil32(_28070) > _28070:
                                                    mem[_28070 + _11916 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                                return 32, mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28070) + 32]
                                            _27334 = mem[64]
                                            mem[64] = _11916 + (uint255(stor30.length) * 0.5) + _766 + 37
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                            _28071 = mem[_27334]
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27334]
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28071)] = mem[_27334 + 32 len ceil32(_28071)]
                                            if ceil32(_28071) > _28071:
                                                mem[_28071 + _11916 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                            return 32, mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28071) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_11916 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_766)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_766)]
                                        mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_766) <= _766:
                                            _27335 = mem[64]
                                            mem[64] = _11916 + (uint255(stor30.length) * 0.5) + _766 + 37
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                            _28072 = mem[_27335]
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27335]
                                            mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28072)] = mem[_27335 + 32 len ceil32(_28072)]
                                            if ceil32(_28072) > _28072:
                                                mem[_28072 + _11916 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                            return 32, mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28072) + 32]
                                        _27336 = mem[64]
                                        mem[64] = _11916 + (uint255(stor30.length) * 0.5) + _766 + 37
                                        mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 37] = 32
                                        _28073 = mem[_27336]
                                        mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69] = mem[_27336]
                                        mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 101 len ceil32(_28073)] = mem[_27336 + 32 len ceil32(_28073)]
                                        if ceil32(_28073) > _28073:
                                            mem[_28073 + _11916 + (uint255(stor30.length) * 0.5) + _766 + 101] = 0
                                        return 32, mem[_11916 + (uint255(stor30.length) * 0.5) + _766 + 69 len ceil32(_28073) + 32]
                                    if 31 >= uint255(stor30.length) * 0.5:
                                        mem[160] = 256 * stor30.length.field_8
                                        if not stor31:
                                            if not cd[4]:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                    return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                                mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                            s = 0
                                            idx = cd[4]
                                            while idx:
                                                if s == -1:
                                                    revert with 0, 17
                                                s = s + 1
                                                idx = idx / 10
                                                continue 
                                            if s > test266151307():
                                                revert with 0, 65
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                            if not s:
                                                t = s
                                                idx = cd[4]
                                                while idx:
                                                    if t < 1:
                                                        revert with 0, 17
                                                    if 48 > !(idx % 10):
                                                        revert with 0, 17
                                                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        revert with 0, 50
                                                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                    t = t - 1
                                                    idx = idx / 10
                                                    continue 
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                        _33828 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33828)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33828)]
                                                        if ceil32(_33828) > _33828:
                                                            mem[_33828 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33828) + 32], 
                                                    _33829 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33829)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33829)]
                                                    if ceil32(_33829) > _33829:
                                                        mem[_33829 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33829) + 32], 
                                                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33830 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33830)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33830)]
                                                    if ceil32(_33830) > _33830:
                                                        mem[_33830 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33830) + 32], 
                                                _33831 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33831)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33831)]
                                                if ceil32(_33831) > _33831:
                                                    mem[_33831 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33831) + 32], 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33832 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33832)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33832)]
                                                    if ceil32(_33832) > _33832:
                                                        mem[_33832 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33832) + 32], 
                                                _33833 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33833)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33833)]
                                                if ceil32(_33833) > _33833:
                                                    mem[_33833 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33833) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33834 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33834)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33834)]
                                                if ceil32(_33834) > _33834:
                                                    mem[_33834 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33834) + 32], 
                                            _33835 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33835)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33835)]
                                            if ceil32(_33835) > _33835:
                                                mem[_33835 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33835) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                        require ext_code.size(stor31)
                                        staticcall stor31.0xff74ef30 with:
                                                gas gas_remaining wei
                                               args cd[4]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        _769 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                        require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                        require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                        _847 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                        if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                            revert with 0, 65
                                        if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _847
                                        require _769 + _847 + 32 <= return_data.size
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_847)] = mem[ceil32(uint255(stor30.length) * 0.5) + _769 + 192 len ceil32(_847)]
                                        if ceil32(_847) <= _847:
                                            _11919 = mem[64]
                                            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_847)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_847)]
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                if ceil32(_847) <= _847:
                                                    _27343 = mem[64]
                                                    mem[64] = _11919 + (uint255(stor30.length) * 0.5) + _847 + 37
                                                    mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                                    _28098 = mem[_27343]
                                                    mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27343]
                                                    mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28098)] = mem[_27343 + 32 len ceil32(_28098)]
                                                    if ceil32(_28098) > _28098:
                                                        mem[_28098 + _11919 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                                    return 32, mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28098) + 32]
                                                _27344 = mem[64]
                                                mem[64] = _11919 + (uint255(stor30.length) * 0.5) + _847 + 37
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                                _28099 = mem[_27344]
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27344]
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28099)] = mem[_27344 + 32 len ceil32(_28099)]
                                                if ceil32(_28099) > _28099:
                                                    mem[_28099 + _11919 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                                return 32, mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28099) + 32]
                                            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                            mem[_11919 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_847)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_847)]
                                            mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_847) <= _847:
                                                _27345 = mem[64]
                                                mem[64] = _11919 + (uint255(stor30.length) * 0.5) + _847 + 37
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                                _28100 = mem[_27345]
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27345]
                                                mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28100)] = mem[_27345 + 32 len ceil32(_28100)]
                                                if ceil32(_28100) > _28100:
                                                    mem[_28100 + _11919 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                                return 32, mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28100) + 32]
                                            _27346 = mem[64]
                                            mem[64] = _11919 + (uint255(stor30.length) * 0.5) + _847 + 37
                                            mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                            _28101 = mem[_27346]
                                            mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27346]
                                            mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28101)] = mem[_27346 + 32 len ceil32(_28101)]
                                            if ceil32(_28101) > _28101:
                                                mem[_28101 + _11919 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                            return 32, mem[_11919 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28101) + 32]
                                        mem[_847 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                        _11920 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_847)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_847)]
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_847) <= _847:
                                                _27347 = mem[64]
                                                mem[64] = _11920 + (uint255(stor30.length) * 0.5) + _847 + 37
                                                mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                                _28102 = mem[_27347]
                                                mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27347]
                                                mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28102)] = mem[_27347 + 32 len ceil32(_28102)]
                                                if ceil32(_28102) > _28102:
                                                    mem[_28102 + _11920 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                                return 32, mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28102) + 32]
                                            _27348 = mem[64]
                                            mem[64] = _11920 + (uint255(stor30.length) * 0.5) + _847 + 37
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                            _28103 = mem[_27348]
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27348]
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28103)] = mem[_27348 + 32 len ceil32(_28103)]
                                            if ceil32(_28103) > _28103:
                                                mem[_28103 + _11920 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                            return 32, mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28103) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_11920 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_847)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_847)]
                                        mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_847) <= _847:
                                            _27349 = mem[64]
                                            mem[64] = _11920 + (uint255(stor30.length) * 0.5) + _847 + 37
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                            _28104 = mem[_27349]
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27349]
                                            mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28104)] = mem[_27349 + 32 len ceil32(_28104)]
                                            if ceil32(_28104) > _28104:
                                                mem[_28104 + _11920 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                            return 32, mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28104) + 32]
                                        _27350 = mem[64]
                                        mem[64] = _11920 + (uint255(stor30.length) * 0.5) + _847 + 37
                                        mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 37] = 32
                                        _28105 = mem[_27350]
                                        mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69] = mem[_27350]
                                        mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 101 len ceil32(_28105)] = mem[_27350 + 32 len ceil32(_28105)]
                                        if ceil32(_28105) > _28105:
                                            mem[_28105 + _11920 + (uint255(stor30.length) * 0.5) + _847 + 101] = 0
                                        return 32, mem[_11920 + (uint255(stor30.length) * 0.5) + _847 + 69 len ceil32(_28105) + 32]
                                    mem[0] = 30
                                    mem[160] = uint256(stor30.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor30.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor30[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                            mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                        if not s:
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _37698 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37698)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37698)]
                                                    if ceil32(_37698) > _37698:
                                                        mem[_37698 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37698) + 32], 
                                                _37699 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37699)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37699)]
                                                if ceil32(_37699) > _37699:
                                                    mem[_37699 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37699) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _37700 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37700)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37700)]
                                                if ceil32(_37700) > _37700:
                                                    mem[_37700 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37700) + 32], 
                                            _37701 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37701)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37701)]
                                            if ceil32(_37701) > _37701:
                                                mem[_37701 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37701) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _37702 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37702)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37702)]
                                                if ceil32(_37702) > _37702:
                                                    mem[_37702 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37702) + 32], 
                                            _37703 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37703)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37703)]
                                            if ceil32(_37703) > _37703:
                                                mem[_37703 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37703) + 32], 
                                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            _37704 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37704)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37704)]
                                            if ceil32(_37704) > _37704:
                                                mem[_37704 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37704) + 32], 
                                        _37705 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37705)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37705)]
                                        if ceil32(_37705) > _37705:
                                            mem[_37705 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37705) + 32], 
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _12552 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _13516 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _13516
                                    require _12552 + _13516 + 32 <= return_data.size
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13516)] = mem[ceil32(uint255(stor30.length) * 0.5) + _12552 + 192 len ceil32(_13516)]
                                    if ceil32(_13516) <= _13516:
                                        _20929 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13516)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13516)]
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_13516) <= _13516:
                                                _32932 = mem[64]
                                                mem[64] = _20929 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                                mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                                _33812 = mem[_32932]
                                                mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32932]
                                                mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33812)] = mem[_32932 + 32 len ceil32(_33812)]
                                                if ceil32(_33812) > _33812:
                                                    mem[_33812 + _20929 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                                return 32, mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33812) + 32]
                                            _32933 = mem[64]
                                            mem[64] = _20929 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                            _33813 = mem[_32933]
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32933]
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33813)] = mem[_32933 + 32 len ceil32(_33813)]
                                            if ceil32(_33813) > _33813:
                                                mem[_33813 + _20929 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                            return 32, mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33813) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_20929 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13516)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13516)]
                                        mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13516) <= _13516:
                                            _32934 = mem[64]
                                            mem[64] = _20929 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                            _33814 = mem[_32934]
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32934]
                                            mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33814)] = mem[_32934 + 32 len ceil32(_33814)]
                                            if ceil32(_33814) > _33814:
                                                mem[_33814 + _20929 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                            return 32, mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33814) + 32]
                                        _32935 = mem[64]
                                        mem[64] = _20929 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                        mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                        _33815 = mem[_32935]
                                        mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32935]
                                        mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33815)] = mem[_32935 + 32 len ceil32(_33815)]
                                        if ceil32(_33815) > _33815:
                                            mem[_33815 + _20929 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                        return 32, mem[_20929 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33815) + 32]
                                    mem[_13516 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                    _20930 = mem[64]
                                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13516)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13516)]
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13516) <= _13516:
                                            _32936 = mem[64]
                                            mem[64] = _20930 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                            mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                            _33816 = mem[_32936]
                                            mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32936]
                                            mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33816)] = mem[_32936 + 32 len ceil32(_33816)]
                                            if ceil32(_33816) > _33816:
                                                mem[_33816 + _20930 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                            return 32, mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33816) + 32]
                                        _32937 = mem[64]
                                        mem[64] = _20930 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                        _33817 = mem[_32937]
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32937]
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33817)] = mem[_32937 + 32 len ceil32(_33817)]
                                        if ceil32(_33817) > _33817:
                                            mem[_33817 + _20930 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                        return 32, mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33817) + 32]
                                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                    mem[_20930 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13516)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13516)]
                                    mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13516) <= _13516:
                                        _32938 = mem[64]
                                        mem[64] = _20930 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                        _33818 = mem[_32938]
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32938]
                                        mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33818)] = mem[_32938 + 32 len ceil32(_33818)]
                                        if ceil32(_33818) > _33818:
                                            mem[_33818 + _20930 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                        return 32, mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33818) + 32]
                                    _32939 = mem[64]
                                    mem[64] = _20930 + (uint255(stor30.length) * 0.5) + _13516 + 37
                                    mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 37] = 32
                                    _33819 = mem[_32939]
                                    mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69] = mem[_32939]
                                    mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 101 len ceil32(_33819)] = mem[_32939 + 32 len ceil32(_33819)]
                                    if ceil32(_33819) > _33819:
                                        mem[_33819 + _20930 + (uint255(stor30.length) * 0.5) + _13516 + 101] = 0
                                    return 32, mem[_20930 + (uint255(stor30.length) * 0.5) + _13516 + 69 len ceil32(_33819) + 32]
                                if bool(stor30.length) == stor30.length.field_1 < 32:
                                    revert with 0, 34
                                if not stor30.length.field_1:
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                            mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                        if not s:
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33836 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33836)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33836)]
                                                    if ceil32(_33836) > _33836:
                                                        mem[_33836 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33836) + 32], 
                                                _33837 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33837)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33837)]
                                                if ceil32(_33837) > _33837:
                                                    mem[_33837 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33837) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33838 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33838)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33838)]
                                                if ceil32(_33838) > _33838:
                                                    mem[_33838 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33838) + 32], 
                                            _33839 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33839)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33839)]
                                            if ceil32(_33839) > _33839:
                                                mem[_33839 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33839) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33840 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33840)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33840)]
                                                if ceil32(_33840) > _33840:
                                                    mem[_33840 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33840) + 32], 
                                            _33841 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33841)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33841)]
                                            if ceil32(_33841) > _33841:
                                                mem[_33841 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33841) + 32], 
                                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            _33842 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33842)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33842)]
                                            if ceil32(_33842) > _33842:
                                                mem[_33842 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33842) + 32], 
                                        _33843 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33843)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33843)]
                                        if ceil32(_33843) > _33843:
                                            mem[_33843 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33843) + 32], 
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _735 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _808 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _808
                                    require _735 + _808 + 32 <= return_data.size
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_808)] = mem[ceil32(uint255(stor30.length) * 0.5) + _735 + 192 len ceil32(_808)]
                                    if ceil32(_808) <= _808:
                                        _11921 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_808)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_808)]
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_808) <= _808:
                                                _27351 = mem[64]
                                                mem[64] = _11921 + (uint255(stor30.length) * 0.5) + _808 + 37
                                                mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                                _28114 = mem[_27351]
                                                mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27351]
                                                mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28114)] = mem[_27351 + 32 len ceil32(_28114)]
                                                if ceil32(_28114) > _28114:
                                                    mem[_28114 + _11921 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                                return 32, mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28114) + 32]
                                            _27352 = mem[64]
                                            mem[64] = _11921 + (uint255(stor30.length) * 0.5) + _808 + 37
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                            _28115 = mem[_27352]
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27352]
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28115)] = mem[_27352 + 32 len ceil32(_28115)]
                                            if ceil32(_28115) > _28115:
                                                mem[_28115 + _11921 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                            return 32, mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28115) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_11921 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_808)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_808)]
                                        mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_808) <= _808:
                                            _27353 = mem[64]
                                            mem[64] = _11921 + (uint255(stor30.length) * 0.5) + _808 + 37
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                            _28116 = mem[_27353]
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27353]
                                            mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28116)] = mem[_27353 + 32 len ceil32(_28116)]
                                            if ceil32(_28116) > _28116:
                                                mem[_28116 + _11921 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                            return 32, mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28116) + 32]
                                        _27354 = mem[64]
                                        mem[64] = _11921 + (uint255(stor30.length) * 0.5) + _808 + 37
                                        mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                        _28117 = mem[_27354]
                                        mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27354]
                                        mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28117)] = mem[_27354 + 32 len ceil32(_28117)]
                                        if ceil32(_28117) > _28117:
                                            mem[_28117 + _11921 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                        return 32, mem[_11921 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28117) + 32]
                                    mem[_808 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                    _11922 = mem[64]
                                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_808)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_808)]
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_808) <= _808:
                                            _27355 = mem[64]
                                            mem[64] = _11922 + (uint255(stor30.length) * 0.5) + _808 + 37
                                            mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                            _28118 = mem[_27355]
                                            mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27355]
                                            mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28118)] = mem[_27355 + 32 len ceil32(_28118)]
                                            if ceil32(_28118) > _28118:
                                                mem[_28118 + _11922 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                            return 32, mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28118) + 32]
                                        _27356 = mem[64]
                                        mem[64] = _11922 + (uint255(stor30.length) * 0.5) + _808 + 37
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                        _28119 = mem[_27356]
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27356]
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28119)] = mem[_27356 + 32 len ceil32(_28119)]
                                        if ceil32(_28119) > _28119:
                                            mem[_28119 + _11922 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                        return 32, mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28119) + 32]
                                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                    mem[_11922 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_808)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_808)]
                                    mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_808) <= _808:
                                        _27357 = mem[64]
                                        mem[64] = _11922 + (uint255(stor30.length) * 0.5) + _808 + 37
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                        _28120 = mem[_27357]
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27357]
                                        mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28120)] = mem[_27357 + 32 len ceil32(_28120)]
                                        if ceil32(_28120) > _28120:
                                            mem[_28120 + _11922 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                        return 32, mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28120) + 32]
                                    _27358 = mem[64]
                                    mem[64] = _11922 + (uint255(stor30.length) * 0.5) + _808 + 37
                                    mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 37] = 32
                                    _28121 = mem[_27358]
                                    mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69] = mem[_27358]
                                    mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 101 len ceil32(_28121)] = mem[_27358 + 32 len ceil32(_28121)]
                                    if ceil32(_28121) > _28121:
                                        mem[_28121 + _11922 + (uint255(stor30.length) * 0.5) + _808 + 101] = 0
                                    return 32, mem[_11922 + (uint255(stor30.length) * 0.5) + _808 + 69 len ceil32(_28121) + 32]
                                if 31 >= stor30.length.field_1:
                                    mem[160] = 256 * stor30.length.field_8
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                                return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                            mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                        if not s:
                                            t = s
                                            idx = cd[4]
                                            while idx:
                                                if t < 1:
                                                    revert with 0, 17
                                                if 48 > !(idx % 10):
                                                    revert with 0, 17
                                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    revert with 0, 50
                                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                                t = t - 1
                                                idx = idx / 10
                                                continue 
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                    _33860 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33860)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33860)]
                                                    if ceil32(_33860) > _33860:
                                                        mem[_33860 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33860) + 32], 
                                                _33861 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33861)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33861)]
                                                if ceil32(_33861) > _33861:
                                                    mem[_33861 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33861) + 32], 
                                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33862 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33862)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33862)]
                                                if ceil32(_33862) > _33862:
                                                    mem[_33862 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33862) + 32], 
                                            _33863 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33863)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33863)]
                                            if ceil32(_33863) > _33863:
                                                mem[_33863 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33863) + 32], 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _33864 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33864)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33864)]
                                                if ceil32(_33864) > _33864:
                                                    mem[_33864 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33864) + 32], 
                                            _33865 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33865)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33865)]
                                            if ceil32(_33865) > _33865:
                                                mem[_33865 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33865) + 32], 
                                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            _33866 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33866)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33866)]
                                            if ceil32(_33866) > _33866:
                                                mem[_33866 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33866) + 32], 
                                        _33867 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_33867)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_33867)]
                                        if ceil32(_33867) > _33867:
                                            mem[_33867 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_33867) + 32], 
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _811 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _898 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _898
                                    require _811 + _898 + 32 <= return_data.size
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_898)] = mem[ceil32(uint255(stor30.length) * 0.5) + _811 + 192 len ceil32(_898)]
                                    if ceil32(_898) <= _898:
                                        _11925 = mem[64]
                                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_898)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_898)]
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_898) <= _898:
                                                _27365 = mem[64]
                                                mem[64] = _11925 + (uint255(stor30.length) * 0.5) + _898 + 37
                                                mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                                _28146 = mem[_27365]
                                                mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27365]
                                                mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28146)] = mem[_27365 + 32 len ceil32(_28146)]
                                                if ceil32(_28146) > _28146:
                                                    mem[_28146 + _11925 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                                return 32, mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28146) + 32]
                                            _27366 = mem[64]
                                            mem[64] = _11925 + (uint255(stor30.length) * 0.5) + _898 + 37
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                            _28147 = mem[_27366]
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27366]
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28147)] = mem[_27366 + 32 len ceil32(_28147)]
                                            if ceil32(_28147) > _28147:
                                                mem[_28147 + _11925 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                            return 32, mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28147) + 32]
                                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                        mem[_11925 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_898)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_898)]
                                        mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_898) <= _898:
                                            _27367 = mem[64]
                                            mem[64] = _11925 + (uint255(stor30.length) * 0.5) + _898 + 37
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                            _28148 = mem[_27367]
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27367]
                                            mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28148)] = mem[_27367 + 32 len ceil32(_28148)]
                                            if ceil32(_28148) > _28148:
                                                mem[_28148 + _11925 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                            return 32, mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28148) + 32]
                                        _27368 = mem[64]
                                        mem[64] = _11925 + (uint255(stor30.length) * 0.5) + _898 + 37
                                        mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                        _28149 = mem[_27368]
                                        mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27368]
                                        mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28149)] = mem[_27368 + 32 len ceil32(_28149)]
                                        if ceil32(_28149) > _28149:
                                            mem[_28149 + _11925 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                        return 32, mem[_11925 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28149) + 32]
                                    mem[_898 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                    _11926 = mem[64]
                                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_898)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_898)]
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_898) <= _898:
                                            _27369 = mem[64]
                                            mem[64] = _11926 + (uint255(stor30.length) * 0.5) + _898 + 37
                                            mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                            _28150 = mem[_27369]
                                            mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27369]
                                            mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28150)] = mem[_27369 + 32 len ceil32(_28150)]
                                            if ceil32(_28150) > _28150:
                                                mem[_28150 + _11926 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                            return 32, mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28150) + 32]
                                        _27370 = mem[64]
                                        mem[64] = _11926 + (uint255(stor30.length) * 0.5) + _898 + 37
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                        _28151 = mem[_27370]
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27370]
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28151)] = mem[_27370 + 32 len ceil32(_28151)]
                                        if ceil32(_28151) > _28151:
                                            mem[_28151 + _11926 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                        return 32, mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28151) + 32]
                                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                    mem[_11926 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_898)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_898)]
                                    mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_898) <= _898:
                                        _27371 = mem[64]
                                        mem[64] = _11926 + (uint255(stor30.length) * 0.5) + _898 + 37
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                        _28152 = mem[_27371]
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27371]
                                        mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28152)] = mem[_27371 + 32 len ceil32(_28152)]
                                        if ceil32(_28152) > _28152:
                                            mem[_28152 + _11926 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                        return 32, mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28152) + 32]
                                    _27372 = mem[64]
                                    mem[64] = _11926 + (uint255(stor30.length) * 0.5) + _898 + 37
                                    mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 37] = 32
                                    _28153 = mem[_27372]
                                    mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69] = mem[_27372]
                                    mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 101 len ceil32(_28153)] = mem[_27372 + 32 len ceil32(_28153)]
                                    if ceil32(_28153) > _28153:
                                        mem[_28153 + _11926 + (uint255(stor30.length) * 0.5) + _898 + 101] = 0
                                    return 32, mem[_11926 + (uint255(stor30.length) * 0.5) + _898 + 69 len ceil32(_28153) + 32]
                                mem[0] = 30
                                mem[160] = uint256(stor30.field_0)
                                idx = 160
                                s = 0
                                while stor30.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor30[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if not stor31:
                                    if not cd[4]:
                                        mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = 32
                                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = mem[ceil32(uint255(stor30.length) * 0.5) + 224]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])] = mem[ceil32(uint255(stor30.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 224]:
                                            return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 224], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224])]), 
                                        mem[mem[ceil32(uint255(stor30.length) * 0.5) + 224] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 326] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 224]) + 32], 
                                    s = 0
                                    idx = cd[4]
                                    while idx:
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        idx = idx / 10
                                        continue 
                                    if s > test266151307():
                                        revert with 0, 65
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 160] = s
                                    if not s:
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                                _37706 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37706)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37706)]
                                                if ceil32(_37706) > _37706:
                                                    mem[_37706 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37706) + 32], 
                                            _37707 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37707)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37707)]
                                            if ceil32(_37707) > _37707:
                                                mem[_37707 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37707) + 32], 
                                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            _37708 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37708)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37708)]
                                            if ceil32(_37708) > _37708:
                                                mem[_37708 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37708) + 32], 
                                        _37709 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37709)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37709)]
                                        if ceil32(_37709) > _37709:
                                            mem[_37709 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37709) + 32], 
                                    mem[ceil32(uint255(stor30.length) * 0.5) + 192 len s] = call.data[calldata.size len s]
                                    t = s
                                    idx = cd[4]
                                    while idx:
                                        if t < 1:
                                            revert with 0, 17
                                        if 48 > !(idx % 10):
                                            revert with 0, 17
                                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            revert with 0, 50
                                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                        t = t - 1
                                        idx = idx / 10
                                        continue 
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                            _37710 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37710)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37710)]
                                            if ceil32(_37710) > _37710:
                                                mem[_37710 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37710) + 32], 
                                        _37711 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37711)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37711)]
                                        if ceil32(_37711) > _37711:
                                            mem[_37711 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37711) + 32], 
                                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224] = 0
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])] = mem[ceil32(uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160])]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 229] = 32
                                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 160]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 160]:
                                        _37712 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37712)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37712)]
                                        if ceil32(_37712) > _37712:
                                            mem[_37712 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37712) + 32], 
                                    _37713 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293 len ceil32(_37713)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 224 len ceil32(_37713)]
                                    if ceil32(_37713) > _37713:
                                        mem[_37713 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 293] = 0
                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160] + 261 len ceil32(_37713) + 32], 
                                mem[ceil32(uint255(stor30.length) * 0.5) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(uint255(stor30.length) * 0.5) + 164] = cd[4]
                                require ext_code.size(stor31)
                                staticcall stor31.0xff74ef30 with:
                                        gas gas_remaining wei
                                       args cd[4]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(uint255(stor30.length) * 0.5) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                _12562 = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                require mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 160 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                _13525 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                    revert with 0, 65
                                if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                    revert with 0, 65
                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = _13525
                                require _12562 + _13525 + 32 <= return_data.size
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13525)] = mem[ceil32(uint255(stor30.length) * 0.5) + _12562 + 192 len ceil32(_13525)]
                                if ceil32(_13525) <= _13525:
                                    _20943 = mem[64]
                                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13525)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13525)]
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13525) <= _13525:
                                            _32956 = mem[64]
                                            mem[64] = _20943 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                            mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                            _33844 = mem[_32956]
                                            mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32956]
                                            mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33844)] = mem[_32956 + 32 len ceil32(_33844)]
                                            if ceil32(_33844) > _33844:
                                                mem[_33844 + _20943 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                            return 32, mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33844) + 32]
                                        _32957 = mem[64]
                                        mem[64] = _20943 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                        _33845 = mem[_32957]
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32957]
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33845)] = mem[_32957 + 32 len ceil32(_33845)]
                                        if ceil32(_33845) > _33845:
                                            mem[_33845 + _20943 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                        return 32, mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33845) + 32]
                                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                    mem[_20943 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13525)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13525)]
                                    mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13525) <= _13525:
                                        _32958 = mem[64]
                                        mem[64] = _20943 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                        _33846 = mem[_32958]
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32958]
                                        mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33846)] = mem[_32958 + 32 len ceil32(_33846)]
                                        if ceil32(_33846) > _33846:
                                            mem[_33846 + _20943 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                        return 32, mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33846) + 32]
                                    _32959 = mem[64]
                                    mem[64] = _20943 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                    mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                    _33847 = mem[_32959]
                                    mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32959]
                                    mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33847)] = mem[_32959 + 32 len ceil32(_33847)]
                                    if ceil32(_33847) > _33847:
                                        mem[_33847 + _20943 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                    return 32, mem[_20943 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33847) + 32]
                                mem[_13525 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192] = 0
                                _20944 = mem[64]
                                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[160 len ceil32(uint255(stor30.length) * 0.5)]
                                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13525)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13525)]
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13525) <= _13525:
                                        _32960 = mem[64]
                                        mem[64] = _20944 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                        mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                        _33848 = mem[_32960]
                                        mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32960]
                                        mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33848)] = mem[_32960 + 32 len ceil32(_33848)]
                                        if ceil32(_33848) > _33848:
                                            mem[_33848 + _20944 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                        return 32, mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33848) + 32]
                                    _32961 = mem[64]
                                    mem[64] = _20944 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                    _33849 = mem[_32961]
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32961]
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33849)] = mem[_32961 + 32 len ceil32(_33849)]
                                    if ceil32(_33849) > _33849:
                                        mem[_33849 + _20944 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                    return 32, mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33849) + 32]
                                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                                mem[_20944 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_13525)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 192 len ceil32(_13525)]
                                mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_13525) <= _13525:
                                    _32962 = mem[64]
                                    mem[64] = _20944 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                    _33850 = mem[_32962]
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32962]
                                    mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33850)] = mem[_32962 + 32 len ceil32(_33850)]
                                    if ceil32(_33850) > _33850:
                                        mem[_33850 + _20944 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                    return 32, mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33850) + 32]
                                _32963 = mem[64]
                                mem[64] = _20944 + (uint255(stor30.length) * 0.5) + _13525 + 37
                                mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 37] = 32
                                _33851 = mem[_32963]
                                mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69] = mem[_32963]
                                mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 101 len ceil32(_33851)] = mem[_32963 + 32 len ceil32(_33851)]
                                if ceil32(_33851) > _33851:
                                    mem[_33851 + _20944 + (uint255(stor30.length) * 0.5) + _13525 + 101] = 0
                                return 32, mem[_20944 + (uint255(stor30.length) * 0.5) + _13525 + 69 len ceil32(_33851) + 32]
                            if bool(stor30.length) == stor30.length.field_1 < 32:
                                revert with 0, 34
                            mem[128] = stor30.length.field_1
                            if bool(stor30.length):
                                if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor30.length):
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(stor30.length.field_1) + 160] = s
                                        if s:
                                            mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                            mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _741 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _813 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    require _741 + _813 + 32 <= return_data.size
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_813)] = mem[ceil32(stor30.length.field_1) + _741 + 192 len ceil32(_813)]
                                    if ceil32(_813) <= _813:
                                        _11927 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            _20834 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20834 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20834) <= _20834:
                                                _27373 = mem[64]
                                                mem[64] = mem[64] + stor30.length.field_1 + _20834 + 37
                                                mem[_11927 + stor30.length.field_1 + _20834 + 37] = 32
                                                _28162 = mem[_27373]
                                                mem[_11927 + stor30.length.field_1 + _20834 + 69] = mem[_27373]
                                                mem[_11927 + stor30.length.field_1 + _20834 + 101 len ceil32(_28162)] = mem[_27373 + 32 len ceil32(_28162)]
                                                if ceil32(_28162) > _28162:
                                                    mem[_28162 + _11927 + stor30.length.field_1 + _20834 + 101] = 0
                                                return 32, mem[_11927 + stor30.length.field_1 + _20834 + 69 len ceil32(_28162) + 32]
                                            _27374 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20834 + 37
                                            mem[_11927 + stor30.length.field_1 + _20834 + 37] = 32
                                            _28163 = mem[_27374]
                                            mem[_11927 + stor30.length.field_1 + _20834 + 69] = mem[_27374]
                                            mem[_11927 + stor30.length.field_1 + _20834 + 101 len ceil32(_28163)] = mem[_27374 + 32 len ceil32(_28163)]
                                            if ceil32(_28163) > _28163:
                                                mem[_28163 + _11927 + stor30.length.field_1 + _20834 + 101] = 0
                                            return 32, mem[_11927 + stor30.length.field_1 + _20834 + 69 len ceil32(_28163) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        _20835 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20835 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20835) <= _20835:
                                            _27375 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20835 + 37
                                            mem[_11927 + stor30.length.field_1 + _20835 + 37] = 32
                                            _28164 = mem[_27375]
                                            mem[_11927 + stor30.length.field_1 + _20835 + 69] = mem[_27375]
                                            mem[_11927 + stor30.length.field_1 + _20835 + 101 len ceil32(_28164)] = mem[_27375 + 32 len ceil32(_28164)]
                                            if ceil32(_28164) > _28164:
                                                mem[_28164 + _11927 + stor30.length.field_1 + _20835 + 101] = 0
                                            return 32, mem[_11927 + stor30.length.field_1 + _20835 + 69 len ceil32(_28164) + 32]
                                        _27376 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20835 + 37
                                        mem[_11927 + stor30.length.field_1 + _20835 + 37] = 32
                                        _28165 = mem[_27376]
                                        mem[_11927 + stor30.length.field_1 + _20835 + 69] = mem[_27376]
                                        mem[_11927 + stor30.length.field_1 + _20835 + 101 len ceil32(_28165)] = mem[_27376 + 32 len ceil32(_28165)]
                                        if ceil32(_28165) > _28165:
                                            mem[_28165 + _11927 + stor30.length.field_1 + _20835 + 101] = 0
                                        return 32, mem[_11927 + stor30.length.field_1 + _20835 + 69 len ceil32(_28165) + 32]
                                    mem[_813 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                    _11928 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        _20836 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20836 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20836) <= _20836:
                                            _27377 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20836 + 37
                                            mem[_11928 + stor30.length.field_1 + _20836 + 37] = 32
                                            _28166 = mem[_27377]
                                            mem[_11928 + stor30.length.field_1 + _20836 + 69] = mem[_27377]
                                            mem[_11928 + stor30.length.field_1 + _20836 + 101 len ceil32(_28166)] = mem[_27377 + 32 len ceil32(_28166)]
                                            if ceil32(_28166) > _28166:
                                                mem[_28166 + _11928 + stor30.length.field_1 + _20836 + 101] = 0
                                            return 32, mem[_11928 + stor30.length.field_1 + _20836 + 69 len ceil32(_28166) + 32]
                                        _27378 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20836 + 37
                                        mem[_11928 + stor30.length.field_1 + _20836 + 37] = 32
                                        _28167 = mem[_27378]
                                        mem[_11928 + stor30.length.field_1 + _20836 + 69] = mem[_27378]
                                        mem[_11928 + stor30.length.field_1 + _20836 + 101 len ceil32(_28167)] = mem[_27378 + 32 len ceil32(_28167)]
                                        if ceil32(_28167) > _28167:
                                            mem[_28167 + _11928 + stor30.length.field_1 + _20836 + 101] = 0
                                        return 32, mem[_11928 + stor30.length.field_1 + _20836 + 69 len ceil32(_28167) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    _20837 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20837 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20837) <= _20837:
                                        _27379 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20837 + 37
                                        mem[_11928 + stor30.length.field_1 + _20837 + 37] = 32
                                        _28168 = mem[_27379]
                                        mem[_11928 + stor30.length.field_1 + _20837 + 69] = mem[_27379]
                                        mem[_11928 + stor30.length.field_1 + _20837 + 101 len ceil32(_28168)] = mem[_27379 + 32 len ceil32(_28168)]
                                        if ceil32(_28168) > _28168:
                                            mem[_28168 + _11928 + stor30.length.field_1 + _20837 + 101] = 0
                                        return 32, mem[_11928 + stor30.length.field_1 + _20837 + 69 len ceil32(_28168) + 32]
                                    _27380 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20837 + 37
                                    mem[_11928 + stor30.length.field_1 + _20837 + 37] = 32
                                    _28169 = mem[_27380]
                                    mem[_11928 + stor30.length.field_1 + _20837 + 69] = mem[_27380]
                                    mem[_11928 + stor30.length.field_1 + _20837 + 101 len ceil32(_28169)] = mem[_27380 + 32 len ceil32(_28169)]
                                    if ceil32(_28169) > _28169:
                                        mem[_28169 + _11928 + stor30.length.field_1 + _20837 + 101] = 0
                                    return 32, mem[_11928 + stor30.length.field_1 + _20837 + 69 len ceil32(_28169) + 32]
                                if 31 >= uint255(stor30.length) * 0.5:
                                    mem[160] = 256 * stor30.length.field_8
                                    if not stor31:
                                        if not cd[4]:
                                            mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                            if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                                mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                            return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                        s = 0
                                        idx = cd[4]
                                        while idx:
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            idx = idx / 10
                                            continue 
                                        if s > test266151307():
                                            revert with 0, 65
                                        mem[ceil32(stor30.length.field_1) + 160] = s
                                        if s:
                                            mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                        t = s
                                        idx = cd[4]
                                        while idx:
                                            if t < 1:
                                                revert with 0, 17
                                            if 48 > !(idx % 10):
                                                revert with 0, 17
                                            if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                                revert with 0, 50
                                            mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                            t = t - 1
                                            idx = idx / 10
                                            continue 
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                            mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                    require ext_code.size(stor31)
                                    staticcall stor31.0xff74ef30 with:
                                            gas gas_remaining wei
                                           args cd[4]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    _816 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                    require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                    require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                    _902 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                        revert with 0, 65
                                    if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                    require _816 + _902 + 32 <= return_data.size
                                    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_902)] = mem[ceil32(stor30.length.field_1) + _816 + 192 len ceil32(_902)]
                                    if ceil32(_902) <= _902:
                                        _11931 = mem[64]
                                        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                            _20842 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                            mem[mem[64] + stor30.length.field_1 + _20842 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                            if ceil32(_20842) <= _20842:
                                                _27387 = mem[64]
                                                mem[64] = _11931 + stor30.length.field_1 + _20842 + 37
                                                mem[_11931 + stor30.length.field_1 + _20842 + 37] = 32
                                                _28194 = mem[_27387]
                                                mem[_11931 + stor30.length.field_1 + _20842 + 69] = mem[_27387]
                                                mem[_11931 + stor30.length.field_1 + _20842 + 101 len ceil32(_28194)] = mem[_27387 + 32 len ceil32(_28194)]
                                                if ceil32(_28194) > _28194:
                                                    mem[_28194 + _11931 + stor30.length.field_1 + _20842 + 101] = 0
                                                return 32, mem[_11931 + stor30.length.field_1 + _20842 + 69 len ceil32(_28194) + 32]
                                            _27388 = mem[64]
                                            mem[64] = _11931 + stor30.length.field_1 + _20842 + 37
                                            mem[_11931 + stor30.length.field_1 + _20842 + 37] = 32
                                            _28195 = mem[_27388]
                                            mem[_11931 + stor30.length.field_1 + _20842 + 69] = mem[_27388]
                                            mem[_11931 + stor30.length.field_1 + _20842 + 101 len ceil32(_28195)] = mem[_27388 + 32 len ceil32(_28195)]
                                            if ceil32(_28195) > _28195:
                                                mem[_28195 + _11931 + stor30.length.field_1 + _20842 + 101] = 0
                                            return 32, mem[_11931 + stor30.length.field_1 + _20842 + 69 len ceil32(_28195) + 32]
                                        mem[stor30.length.field_1 + mem[64] + 32] = 0
                                        _20843 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20843 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20843) <= _20843:
                                            _27389 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20843 + 37
                                            mem[_11931 + stor30.length.field_1 + _20843 + 37] = 32
                                            _28196 = mem[_27389]
                                            mem[_11931 + stor30.length.field_1 + _20843 + 69] = mem[_27389]
                                            mem[_11931 + stor30.length.field_1 + _20843 + 101 len ceil32(_28196)] = mem[_27389 + 32 len ceil32(_28196)]
                                            if ceil32(_28196) > _28196:
                                                mem[_28196 + _11931 + stor30.length.field_1 + _20843 + 101] = 0
                                            return 32, mem[_11931 + stor30.length.field_1 + _20843 + 69 len ceil32(_28196) + 32]
                                        _27390 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20843 + 37
                                        mem[_11931 + stor30.length.field_1 + _20843 + 37] = 32
                                        _28197 = mem[_27390]
                                        mem[_11931 + stor30.length.field_1 + _20843 + 69] = mem[_27390]
                                        mem[_11931 + stor30.length.field_1 + _20843 + 101 len ceil32(_28197)] = mem[_27390 + 32 len ceil32(_28197)]
                                        if ceil32(_28197) > _28197:
                                            mem[_28197 + _11931 + stor30.length.field_1 + _20843 + 101] = 0
                                        return 32, mem[_11931 + stor30.length.field_1 + _20843 + 69 len ceil32(_28197) + 32]
                                    mem[_902 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                    _11932 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        _20844 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20844 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20844) <= _20844:
                                            _27391 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20844 + 37
                                            mem[_11932 + stor30.length.field_1 + _20844 + 37] = 32
                                            _28198 = mem[_27391]
                                            mem[_11932 + stor30.length.field_1 + _20844 + 69] = mem[_27391]
                                            mem[_11932 + stor30.length.field_1 + _20844 + 101 len ceil32(_28198)] = mem[_27391 + 32 len ceil32(_28198)]
                                            if ceil32(_28198) > _28198:
                                                mem[_28198 + _11932 + stor30.length.field_1 + _20844 + 101] = 0
                                            return 32, mem[_11932 + stor30.length.field_1 + _20844 + 69 len ceil32(_28198) + 32]
                                        _27392 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20844 + 37
                                        mem[_11932 + stor30.length.field_1 + _20844 + 37] = 32
                                        _28199 = mem[_27392]
                                        mem[_11932 + stor30.length.field_1 + _20844 + 69] = mem[_27392]
                                        mem[_11932 + stor30.length.field_1 + _20844 + 101 len ceil32(_28199)] = mem[_27392 + 32 len ceil32(_28199)]
                                        if ceil32(_28199) > _28199:
                                            mem[_28199 + _11932 + stor30.length.field_1 + _20844 + 101] = 0
                                        return 32, mem[_11932 + stor30.length.field_1 + _20844 + 69 len ceil32(_28199) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    _20845 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20845 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20845) <= _20845:
                                        _27393 = mem[64]
                                        mem[64] = _11932 + stor30.length.field_1 + _20845 + 37
                                        mem[_11932 + stor30.length.field_1 + _20845 + 37] = 32
                                        _28200 = mem[_27393]
                                        mem[_11932 + stor30.length.field_1 + _20845 + 69] = mem[_27393]
                                        mem[_11932 + stor30.length.field_1 + _20845 + 101 len ceil32(_28200)] = mem[_27393 + 32 len ceil32(_28200)]
                                        if ceil32(_28200) > _28200:
                                            mem[_28200 + _11932 + stor30.length.field_1 + _20845 + 101] = 0
                                        return 32, mem[_11932 + stor30.length.field_1 + _20845 + 69 len ceil32(_28200) + 32]
                                    _27394 = mem[64]
                                    mem[64] = _11932 + stor30.length.field_1 + _20845 + 37
                                    mem[_11932 + stor30.length.field_1 + _20845 + 37] = 32
                                    _28201 = mem[_27394]
                                    mem[_11932 + stor30.length.field_1 + _20845 + 69] = mem[_27394]
                                    mem[_11932 + stor30.length.field_1 + _20845 + 101 len ceil32(_28201)] = mem[_27394 + 32 len ceil32(_28201)]
                                    if ceil32(_28201) > _28201:
                                        mem[_28201 + _11932 + stor30.length.field_1 + _20845 + 101] = 0
                                    return 32, mem[_11932 + stor30.length.field_1 + _20845 + 69 len ceil32(_28201) + 32]
                                mem[0] = 30
                                mem[160] = uint256(stor30.field_0)
                                idx = 160
                                s = 0
                                while (uint255(stor30.length) * 0.5) + 128 > idx:
                                    mem[idx + 32] = stor30[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if not stor31:
                                    if not cd[4]:
                                        mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                            mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                    s = 0
                                    idx = cd[4]
                                    while idx:
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        idx = idx / 10
                                        continue 
                                    if s > test266151307():
                                        revert with 0, 65
                                    mem[ceil32(stor30.length.field_1) + 160] = s
                                    if s:
                                        mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                    t = s
                                    idx = cd[4]
                                    while idx:
                                        if t < 1:
                                            revert with 0, 17
                                        if 48 > !(idx % 10):
                                            revert with 0, 17
                                        if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                            revert with 0, 50
                                        mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                        t = t - 1
                                        idx = idx / 10
                                        continue 
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                        mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                    if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                    return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) + 32], 
                                mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                require ext_code.size(stor31)
                                staticcall stor31.0xff74ef30 with:
                                        gas gas_remaining wei
                                       args cd[4]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                _12572 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                _13534 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                    revert with 0, 65
                                if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                    revert with 0, 65
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                require _12572 + _13534 + 32 <= return_data.size
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13534)] = mem[ceil32(stor30.length.field_1) + _12572 + 192 len ceil32(_13534)]
                                if ceil32(_13534) <= _13534:
                                    _20957 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13534)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13534)]
                                        mem[mem[64] + stor30.length.field_1 + _13534 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_13534) <= _13534:
                                            _32980 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                            mem[_20957 + stor30.length.field_1 + _13534 + 37] = 32
                                            _33876 = mem[_32980]
                                            mem[_20957 + stor30.length.field_1 + _13534 + 69] = mem[_32980]
                                            mem[_20957 + stor30.length.field_1 + _13534 + 101 len ceil32(_33876)] = mem[_32980 + 32 len ceil32(_33876)]
                                            if ceil32(_33876) > _33876:
                                                mem[_33876 + _20957 + stor30.length.field_1 + _13534 + 101] = 0
                                            return 32, mem[_20957 + stor30.length.field_1 + _13534 + 69 len ceil32(_33876) + 32]
                                        _32981 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                        mem[_20957 + stor30.length.field_1 + _13534 + 37] = 32
                                        _33877 = mem[_32981]
                                        mem[_20957 + stor30.length.field_1 + _13534 + 69] = mem[_32981]
                                        mem[_20957 + stor30.length.field_1 + _13534 + 101 len ceil32(_33877)] = mem[_32981 + 32 len ceil32(_33877)]
                                        if ceil32(_33877) > _33877:
                                            mem[_33877 + _20957 + stor30.length.field_1 + _13534 + 101] = 0
                                        return 32, mem[_20957 + stor30.length.field_1 + _13534 + 69 len ceil32(_33877) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13534)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13534)]
                                    mem[mem[64] + stor30.length.field_1 + _13534 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13534) <= _13534:
                                        _32982 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                        mem[_20957 + stor30.length.field_1 + _13534 + 37] = 32
                                        _33878 = mem[_32982]
                                        mem[_20957 + stor30.length.field_1 + _13534 + 69] = mem[_32982]
                                        mem[_20957 + stor30.length.field_1 + _13534 + 101 len ceil32(_33878)] = mem[_32982 + 32 len ceil32(_33878)]
                                        if ceil32(_33878) > _33878:
                                            mem[_33878 + _20957 + stor30.length.field_1 + _13534 + 101] = 0
                                        return 32, mem[_20957 + stor30.length.field_1 + _13534 + 69 len ceil32(_33878) + 32]
                                    _32983 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                    mem[_20957 + stor30.length.field_1 + _13534 + 37] = 32
                                    _33879 = mem[_32983]
                                    mem[_20957 + stor30.length.field_1 + _13534 + 69] = mem[_32983]
                                    mem[_20957 + stor30.length.field_1 + _13534 + 101 len ceil32(_33879)] = mem[_32983 + 32 len ceil32(_33879)]
                                    if ceil32(_33879) > _33879:
                                        mem[_33879 + _20957 + stor30.length.field_1 + _13534 + 101] = 0
                                    return 32, mem[_20957 + stor30.length.field_1 + _13534 + 69 len ceil32(_33879) + 32]
                                mem[_13534 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                _20958 = mem[64]
                                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13534)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13534)]
                                    mem[mem[64] + stor30.length.field_1 + _13534 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13534) <= _13534:
                                        _32984 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                        mem[_20958 + stor30.length.field_1 + _13534 + 37] = 32
                                        _33880 = mem[_32984]
                                        mem[_20958 + stor30.length.field_1 + _13534 + 69] = mem[_32984]
                                        mem[_20958 + stor30.length.field_1 + _13534 + 101 len ceil32(_33880)] = mem[_32984 + 32 len ceil32(_33880)]
                                        if ceil32(_33880) > _33880:
                                            mem[_33880 + _20958 + stor30.length.field_1 + _13534 + 101] = 0
                                        return 32, mem[_20958 + stor30.length.field_1 + _13534 + 69 len ceil32(_33880) + 32]
                                    _32985 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                    mem[_20958 + stor30.length.field_1 + _13534 + 37] = 32
                                    _33881 = mem[_32985]
                                    mem[_20958 + stor30.length.field_1 + _13534 + 69] = mem[_32985]
                                    mem[_20958 + stor30.length.field_1 + _13534 + 101 len ceil32(_33881)] = mem[_32985 + 32 len ceil32(_33881)]
                                    if ceil32(_33881) > _33881:
                                        mem[_33881 + _20958 + stor30.length.field_1 + _13534 + 101] = 0
                                    return 32, mem[_20958 + stor30.length.field_1 + _13534 + 69 len ceil32(_33881) + 32]
                                mem[stor30.length.field_1 + mem[64] + 32] = 0
                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13534)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13534)]
                                mem[mem[64] + stor30.length.field_1 + _13534 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_13534) <= _13534:
                                    _32986 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                    mem[_20958 + stor30.length.field_1 + _13534 + 37] = 32
                                    _33882 = mem[_32986]
                                    mem[_20958 + stor30.length.field_1 + _13534 + 69] = mem[_32986]
                                    mem[_20958 + stor30.length.field_1 + _13534 + 101 len ceil32(_33882)] = mem[_32986 + 32 len ceil32(_33882)]
                                    if ceil32(_33882) > _33882:
                                        mem[_33882 + _20958 + stor30.length.field_1 + _13534 + 101] = 0
                                    return 32, mem[_20958 + stor30.length.field_1 + _13534 + 69 len ceil32(_33882) + 32]
                                _32987 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _13534 + 37
                                mem[_20958 + stor30.length.field_1 + _13534 + 37] = 32
                                _33883 = mem[_32987]
                                mem[_20958 + stor30.length.field_1 + _13534 + 69] = mem[_32987]
                                mem[_20958 + stor30.length.field_1 + _13534 + 101 len ceil32(_33883)] = mem[_32987 + 32 len ceil32(_33883)]
                                if ceil32(_33883) > _33883:
                                    mem[_33883 + _20958 + stor30.length.field_1 + _13534 + 101] = 0
                                return 32, mem[_20958 + stor30.length.field_1 + _13534 + 69 len ceil32(_33883) + 32]
                            if bool(stor30.length) == stor30.length.field_1 < 32:
                                revert with 0, 34
                            if not stor30.length.field_1:
                                if not stor31:
                                    if not cd[4]:
                                        mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                            mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                    s = 0
                                    idx = cd[4]
                                    while idx:
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        idx = idx / 10
                                        continue 
                                    if s > test266151307():
                                        revert with 0, 65
                                    mem[ceil32(stor30.length.field_1) + 160] = s
                                    if s:
                                        mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                    t = s
                                    idx = cd[4]
                                    while idx:
                                        if t < 1:
                                            revert with 0, 17
                                        if 48 > !(idx % 10):
                                            revert with 0, 17
                                        if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                            revert with 0, 50
                                        mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                        t = t - 1
                                        idx = idx / 10
                                        continue 
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                        mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                    if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                        mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                    return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                require ext_code.size(stor31)
                                staticcall stor31.0xff74ef30 with:
                                        gas gas_remaining wei
                                       args cd[4]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                _773 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                _850 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                    revert with 0, 65
                                if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                    revert with 0, 65
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                require _773 + _850 + 32 <= return_data.size
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_850)] = mem[ceil32(stor30.length.field_1) + _773 + 192 len ceil32(_850)]
                                if ceil32(_850) <= _850:
                                    _11933 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        _20848 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20848 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20848) <= _20848:
                                            _27395 = mem[64]
                                            mem[64] = _11933 + stor30.length.field_1 + _20848 + 37
                                            mem[_11933 + stor30.length.field_1 + _20848 + 37] = 32
                                            _28210 = mem[_27395]
                                            mem[_11933 + stor30.length.field_1 + _20848 + 69] = mem[_27395]
                                            mem[_11933 + stor30.length.field_1 + _20848 + 101 len ceil32(_28210)] = mem[_27395 + 32 len ceil32(_28210)]
                                            if ceil32(_28210) > _28210:
                                                mem[_28210 + _11933 + stor30.length.field_1 + _20848 + 101] = 0
                                            return 32, mem[_11933 + stor30.length.field_1 + _20848 + 69 len ceil32(_28210) + 32]
                                        _27396 = mem[64]
                                        mem[64] = _11933 + stor30.length.field_1 + _20848 + 37
                                        mem[_11933 + stor30.length.field_1 + _20848 + 37] = 32
                                        _28211 = mem[_27396]
                                        mem[_11933 + stor30.length.field_1 + _20848 + 69] = mem[_27396]
                                        mem[_11933 + stor30.length.field_1 + _20848 + 101 len ceil32(_28211)] = mem[_27396 + 32 len ceil32(_28211)]
                                        if ceil32(_28211) > _28211:
                                            mem[_28211 + _11933 + stor30.length.field_1 + _20848 + 101] = 0
                                        return 32, mem[_11933 + stor30.length.field_1 + _20848 + 69 len ceil32(_28211) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    _20849 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20849 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20849) <= _20849:
                                        _27397 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20849 + 37
                                        mem[_11933 + stor30.length.field_1 + _20849 + 37] = 32
                                        _28212 = mem[_27397]
                                        mem[_11933 + stor30.length.field_1 + _20849 + 69] = mem[_27397]
                                        mem[_11933 + stor30.length.field_1 + _20849 + 101 len ceil32(_28212)] = mem[_27397 + 32 len ceil32(_28212)]
                                        if ceil32(_28212) > _28212:
                                            mem[_28212 + _11933 + stor30.length.field_1 + _20849 + 101] = 0
                                        return 32, mem[_11933 + stor30.length.field_1 + _20849 + 69 len ceil32(_28212) + 32]
                                    _27398 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20849 + 37
                                    mem[_11933 + stor30.length.field_1 + _20849 + 37] = 32
                                    _28213 = mem[_27398]
                                    mem[_11933 + stor30.length.field_1 + _20849 + 69] = mem[_27398]
                                    mem[_11933 + stor30.length.field_1 + _20849 + 101 len ceil32(_28213)] = mem[_27398 + 32 len ceil32(_28213)]
                                    if ceil32(_28213) > _28213:
                                        mem[_28213 + _11933 + stor30.length.field_1 + _20849 + 101] = 0
                                    return 32, mem[_11933 + stor30.length.field_1 + _20849 + 69 len ceil32(_28213) + 32]
                                mem[_850 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                _11934 = mem[64]
                                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                    _20850 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20850 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20850) <= _20850:
                                        _27399 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20850 + 37
                                        mem[_11934 + stor30.length.field_1 + _20850 + 37] = 32
                                        _28214 = mem[_27399]
                                        mem[_11934 + stor30.length.field_1 + _20850 + 69] = mem[_27399]
                                        mem[_11934 + stor30.length.field_1 + _20850 + 101 len ceil32(_28214)] = mem[_27399 + 32 len ceil32(_28214)]
                                        if ceil32(_28214) > _28214:
                                            mem[_28214 + _11934 + stor30.length.field_1 + _20850 + 101] = 0
                                        return 32, mem[_11934 + stor30.length.field_1 + _20850 + 69 len ceil32(_28214) + 32]
                                    _27400 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20850 + 37
                                    mem[_11934 + stor30.length.field_1 + _20850 + 37] = 32
                                    _28215 = mem[_27400]
                                    mem[_11934 + stor30.length.field_1 + _20850 + 69] = mem[_27400]
                                    mem[_11934 + stor30.length.field_1 + _20850 + 101 len ceil32(_28215)] = mem[_27400 + 32 len ceil32(_28215)]
                                    if ceil32(_28215) > _28215:
                                        mem[_28215 + _11934 + stor30.length.field_1 + _20850 + 101] = 0
                                    return 32, mem[_11934 + stor30.length.field_1 + _20850 + 69 len ceil32(_28215) + 32]
                                mem[stor30.length.field_1 + mem[64] + 32] = 0
                                _20851 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                mem[mem[64] + stor30.length.field_1 + _20851 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_20851) <= _20851:
                                    _27401 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20851 + 37
                                    mem[_11934 + stor30.length.field_1 + _20851 + 37] = 32
                                    _28216 = mem[_27401]
                                    mem[_11934 + stor30.length.field_1 + _20851 + 69] = mem[_27401]
                                    mem[_11934 + stor30.length.field_1 + _20851 + 101 len ceil32(_28216)] = mem[_27401 + 32 len ceil32(_28216)]
                                    if ceil32(_28216) > _28216:
                                        mem[_28216 + _11934 + stor30.length.field_1 + _20851 + 101] = 0
                                    return 32, mem[_11934 + stor30.length.field_1 + _20851 + 69 len ceil32(_28216) + 32]
                                _27402 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _20851 + 37
                                mem[_11934 + stor30.length.field_1 + _20851 + 37] = 32
                                _28217 = mem[_27402]
                                mem[_11934 + stor30.length.field_1 + _20851 + 69] = mem[_27402]
                                mem[_11934 + stor30.length.field_1 + _20851 + 101 len ceil32(_28217)] = mem[_27402 + 32 len ceil32(_28217)]
                                if ceil32(_28217) > _28217:
                                    mem[_28217 + _11934 + stor30.length.field_1 + _20851 + 101] = 0
                                return 32, mem[_11934 + stor30.length.field_1 + _20851 + 69 len ceil32(_28217) + 32]
                            if 31 >= stor30.length.field_1:
                                mem[160] = 256 * stor30.length.field_8
                                if not stor31:
                                    if not cd[4]:
                                        mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                        if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                            mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                        return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                    s = 0
                                    idx = cd[4]
                                    while idx:
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        idx = idx / 10
                                        continue 
                                    if s > test266151307():
                                        revert with 0, 65
                                    mem[ceil32(stor30.length.field_1) + 160] = s
                                    if s:
                                        mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                    t = s
                                    idx = cd[4]
                                    while idx:
                                        if t < 1:
                                            revert with 0, 17
                                        if 48 > !(idx % 10):
                                            revert with 0, 17
                                        if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                            revert with 0, 50
                                        mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                        t = t - 1
                                        idx = idx / 10
                                        continue 
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                        mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                    if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                    return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) + 32], 
                                mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                                require ext_code.size(stor31)
                                staticcall stor31.0xff74ef30 with:
                                        gas gas_remaining wei
                                       args cd[4]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                _853 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                                require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                                require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                                _942 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                    revert with 0, 65
                                if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                    revert with 0, 65
                                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                                require _853 + _942 + 32 <= return_data.size
                                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_942)] = mem[ceil32(stor30.length.field_1) + _853 + 192 len ceil32(_942)]
                                if ceil32(_942) <= _942:
                                    _11937 = mem[64]
                                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                        _20856 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                        mem[mem[64] + stor30.length.field_1 + _20856 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                        if ceil32(_20856) <= _20856:
                                            _27409 = mem[64]
                                            mem[64] = mem[64] + stor30.length.field_1 + _20856 + 37
                                            mem[_11937 + stor30.length.field_1 + _20856 + 37] = 32
                                            _28242 = mem[_27409]
                                            mem[_11937 + stor30.length.field_1 + _20856 + 69] = mem[_27409]
                                            mem[_11937 + stor30.length.field_1 + _20856 + 101 len ceil32(_28242)] = mem[_27409 + 32 len ceil32(_28242)]
                                            if ceil32(_28242) > _28242:
                                                mem[_28242 + _11937 + stor30.length.field_1 + _20856 + 101] = 0
                                            return 32, mem[_11937 + stor30.length.field_1 + _20856 + 69 len ceil32(_28242) + 32]
                                        _27410 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20856 + 37
                                        mem[_11937 + stor30.length.field_1 + _20856 + 37] = 32
                                        _28243 = mem[_27410]
                                        mem[_11937 + stor30.length.field_1 + _20856 + 69] = mem[_27410]
                                        mem[_11937 + stor30.length.field_1 + _20856 + 101 len ceil32(_28243)] = mem[_27410 + 32 len ceil32(_28243)]
                                        if ceil32(_28243) > _28243:
                                            mem[_28243 + _11937 + stor30.length.field_1 + _20856 + 101] = 0
                                        return 32, mem[_11937 + stor30.length.field_1 + _20856 + 69 len ceil32(_28243) + 32]
                                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                                    _20857 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20857 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20857) <= _20857:
                                        _27411 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20857 + 37
                                        mem[_11937 + stor30.length.field_1 + _20857 + 37] = 32
                                        _28244 = mem[_27411]
                                        mem[_11937 + stor30.length.field_1 + _20857 + 69] = mem[_27411]
                                        mem[_11937 + stor30.length.field_1 + _20857 + 101 len ceil32(_28244)] = mem[_27411 + 32 len ceil32(_28244)]
                                        if ceil32(_28244) > _28244:
                                            mem[_28244 + _11937 + stor30.length.field_1 + _20857 + 101] = 0
                                        return 32, mem[_11937 + stor30.length.field_1 + _20857 + 69 len ceil32(_28244) + 32]
                                    _27412 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20857 + 37
                                    mem[_11937 + stor30.length.field_1 + _20857 + 37] = 32
                                    _28245 = mem[_27412]
                                    mem[_11937 + stor30.length.field_1 + _20857 + 69] = mem[_27412]
                                    mem[_11937 + stor30.length.field_1 + _20857 + 101 len ceil32(_28245)] = mem[_27412 + 32 len ceil32(_28245)]
                                    if ceil32(_28245) > _28245:
                                        mem[_28245 + _11937 + stor30.length.field_1 + _20857 + 101] = 0
                                    return 32, mem[_11937 + stor30.length.field_1 + _20857 + 69 len ceil32(_28245) + 32]
                                mem[_942 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                                _11938 = mem[64]
                                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                    _20858 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                    mem[mem[64] + stor30.length.field_1 + _20858 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_20858) <= _20858:
                                        _27413 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _20858 + 37
                                        mem[_11938 + stor30.length.field_1 + _20858 + 37] = 32
                                        _28246 = mem[_27413]
                                        mem[_11938 + stor30.length.field_1 + _20858 + 69] = mem[_27413]
                                        mem[_11938 + stor30.length.field_1 + _20858 + 101 len ceil32(_28246)] = mem[_27413 + 32 len ceil32(_28246)]
                                        if ceil32(_28246) > _28246:
                                            mem[_28246 + _11938 + stor30.length.field_1 + _20858 + 101] = 0
                                        return 32, mem[_11938 + stor30.length.field_1 + _20858 + 69 len ceil32(_28246) + 32]
                                    _27414 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20858 + 37
                                    mem[_11938 + stor30.length.field_1 + _20858 + 37] = 32
                                    _28247 = mem[_27414]
                                    mem[_11938 + stor30.length.field_1 + _20858 + 69] = mem[_27414]
                                    mem[_11938 + stor30.length.field_1 + _20858 + 101 len ceil32(_28247)] = mem[_27414 + 32 len ceil32(_28247)]
                                    if ceil32(_28247) > _28247:
                                        mem[_28247 + _11938 + stor30.length.field_1 + _20858 + 101] = 0
                                    return 32, mem[_11938 + stor30.length.field_1 + _20858 + 69 len ceil32(_28247) + 32]
                                mem[stor30.length.field_1 + mem[64] + 32] = 0
                                _20859 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160]
                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160])]
                                mem[mem[64] + stor30.length.field_1 + _20859 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_20859) <= _20859:
                                    _27415 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _20859 + 37
                                    mem[_11938 + stor30.length.field_1 + _20859 + 37] = 32
                                    _28248 = mem[_27415]
                                    mem[_11938 + stor30.length.field_1 + _20859 + 69] = mem[_27415]
                                    mem[_11938 + stor30.length.field_1 + _20859 + 101 len ceil32(_28248)] = mem[_27415 + 32 len ceil32(_28248)]
                                    if ceil32(_28248) > _28248:
                                        mem[_28248 + _11938 + stor30.length.field_1 + _20859 + 101] = 0
                                    return 32, mem[_11938 + stor30.length.field_1 + _20859 + 69 len ceil32(_28248) + 32]
                                _27416 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _20859 + 37
                                mem[_11938 + stor30.length.field_1 + _20859 + 37] = 32
                                _28249 = mem[_27416]
                                mem[_11938 + stor30.length.field_1 + _20859 + 69] = mem[_27416]
                                mem[_11938 + stor30.length.field_1 + _20859 + 101 len ceil32(_28249)] = mem[_27416 + 32 len ceil32(_28249)]
                                if ceil32(_28249) > _28249:
                                    mem[_28249 + _11938 + stor30.length.field_1 + _20859 + 101] = 0
                                return 32, mem[_11938 + stor30.length.field_1 + _20859 + 69 len ceil32(_28249) + 32]
                            mem[0] = 30
                            mem[160] = uint256(stor30.field_0)
                            idx = 160
                            s = 0
                            while stor30.length.field_1 + 128 > idx:
                                mem[idx + 32] = stor30[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if not stor31:
                                if not cd[4]:
                                    mem[ceil32(stor30.length.field_1) + 256 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 256] = 0x3000000000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 257] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = 32
                                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = mem[ceil32(stor30.length.field_1) + 224]
                                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])] = mem[ceil32(stor30.length.field_1) + 256 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]
                                    if ceil32(mem[ceil32(stor30.length.field_1) + 224]) > mem[ceil32(stor30.length.field_1) + 224]:
                                        mem[mem[ceil32(stor30.length.field_1) + 224] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 326] = 0
                                    return Array(len=mem[ceil32(stor30.length.field_1) + 224], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 326 len ceil32(mem[ceil32(stor30.length.field_1) + 224])]), 
                                s = 0
                                idx = cd[4]
                                while idx:
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    idx = idx / 10
                                    continue 
                                if s > test266151307():
                                    revert with 0, 65
                                mem[ceil32(stor30.length.field_1) + 160] = s
                                if s:
                                    mem[ceil32(stor30.length.field_1) + 192 len s] = call.data[calldata.size len s]
                                t = s
                                idx = cd[4]
                                while idx:
                                    if t < 1:
                                        revert with 0, 17
                                    if 48 > !(idx % 10):
                                        revert with 0, 17
                                    if t - 1 >= mem[ceil32(stor30.length.field_1) + 160]:
                                        revert with 0, 50
                                    mem[t + ceil32(stor30.length.field_1) + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                    t = t - 1
                                    idx = idx / 10
                                    continue 
                                mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                if ceil32(stor30.length.field_1) > stor30.length.field_1:
                                    mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 224] = 0
                                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 160])] = mem[ceil32(stor30.length.field_1) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 160])]
                                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 224] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 229] = 32
                                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 261] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]
                                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]
                                if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 192]:
                                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 192] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293] = 0
                                return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 192], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 160] + 293 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 192])]), 
                            mem[ceil32(stor30.length.field_1) + 160] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                            mem[ceil32(stor30.length.field_1) + 164] = cd[4]
                            require ext_code.size(stor31)
                            staticcall stor31.0xff74ef30 with:
                                    gas gas_remaining wei
                                   args cd[4]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(stor30.length.field_1) + 160 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160
                            require return_data.size >= 32
                            _12582 = mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32
                            require mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                            require ceil32(stor30.length.field_1) + return_data.size + 160 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 191
                            _13543 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                            if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160] > test266151307():
                                revert with 0, 65
                            if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161 > test266151307():
                                revert with 0, 65
                            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160])) + 161
                            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 160 len 4], Mask(224, 32, cd[4]) >> 32 + 160]
                            require _12582 + _13543 + 32 <= return_data.size
                            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13543)] = mem[ceil32(stor30.length.field_1) + _12582 + 192 len ceil32(_13543)]
                            if ceil32(_13543) <= _13543:
                                _20971 = mem[64]
                                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13543)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13543)]
                                    mem[mem[64] + stor30.length.field_1 + _13543 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                    if ceil32(_13543) <= _13543:
                                        _33004 = mem[64]
                                        mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                        mem[_20971 + stor30.length.field_1 + _13543 + 37] = 32
                                        _33908 = mem[_33004]
                                        mem[_20971 + stor30.length.field_1 + _13543 + 69] = mem[_33004]
                                        mem[_20971 + stor30.length.field_1 + _13543 + 101 len ceil32(_33908)] = mem[_33004 + 32 len ceil32(_33908)]
                                        if ceil32(_33908) > _33908:
                                            mem[_33908 + _20971 + stor30.length.field_1 + _13543 + 101] = 0
                                        return 32, mem[_20971 + stor30.length.field_1 + _13543 + 69 len ceil32(_33908) + 32]
                                    _33005 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                    mem[_20971 + stor30.length.field_1 + _13543 + 37] = 32
                                    _33909 = mem[_33005]
                                    mem[_20971 + stor30.length.field_1 + _13543 + 69] = mem[_33005]
                                    mem[_20971 + stor30.length.field_1 + _13543 + 101 len ceil32(_33909)] = mem[_33005 + 32 len ceil32(_33909)]
                                    if ceil32(_33909) > _33909:
                                        mem[_33909 + _20971 + stor30.length.field_1 + _13543 + 101] = 0
                                    return 32, mem[_20971 + stor30.length.field_1 + _13543 + 69 len ceil32(_33909) + 32]
                                mem[stor30.length.field_1 + mem[64] + 32] = 0
                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13543)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13543)]
                                mem[mem[64] + stor30.length.field_1 + _13543 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_13543) <= _13543:
                                    _33006 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                    mem[_20971 + stor30.length.field_1 + _13543 + 37] = 32
                                    _33910 = mem[_33006]
                                    mem[_20971 + stor30.length.field_1 + _13543 + 69] = mem[_33006]
                                    mem[_20971 + stor30.length.field_1 + _13543 + 101 len ceil32(_33910)] = mem[_33006 + 32 len ceil32(_33910)]
                                    if ceil32(_33910) > _33910:
                                        mem[_33910 + _20971 + stor30.length.field_1 + _13543 + 101] = 0
                                    return 32, mem[_20971 + stor30.length.field_1 + _13543 + 69 len ceil32(_33910) + 32]
                                _33007 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                mem[_20971 + stor30.length.field_1 + _13543 + 37] = 32
                                _33911 = mem[_33007]
                                mem[_20971 + stor30.length.field_1 + _13543 + 69] = mem[_33007]
                                mem[_20971 + stor30.length.field_1 + _13543 + 101 len ceil32(_33911)] = mem[_33007 + 32 len ceil32(_33911)]
                                if ceil32(_33911) > _33911:
                                    mem[_33911 + _20971 + stor30.length.field_1 + _13543 + 101] = 0
                                return 32, mem[_20971 + stor30.length.field_1 + _13543 + 69 len ceil32(_33911) + 32]
                            mem[_13543 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192] = 0
                            _20972 = mem[64]
                            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[160 len ceil32(stor30.length.field_1)]
                            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13543)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13543)]
                                mem[mem[64] + stor30.length.field_1 + _13543 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                if ceil32(_13543) <= _13543:
                                    _33008 = mem[64]
                                    mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                    mem[_20972 + stor30.length.field_1 + _13543 + 37] = 32
                                    _33912 = mem[_33008]
                                    mem[_20972 + stor30.length.field_1 + _13543 + 69] = mem[_33008]
                                    mem[_20972 + stor30.length.field_1 + _13543 + 101 len ceil32(_33912)] = mem[_33008 + 32 len ceil32(_33912)]
                                    if ceil32(_33912) > _33912:
                                        mem[_33912 + _20972 + stor30.length.field_1 + _13543 + 101] = 0
                                    return 32, mem[_20972 + stor30.length.field_1 + _13543 + 69 len ceil32(_33912) + 32]
                                _33009 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                mem[_20972 + stor30.length.field_1 + _13543 + 37] = 32
                                _33913 = mem[_33009]
                                mem[_20972 + stor30.length.field_1 + _13543 + 69] = mem[_33009]
                                mem[_20972 + stor30.length.field_1 + _13543 + 101 len ceil32(_33913)] = mem[_33009 + 32 len ceil32(_33913)]
                                if ceil32(_33913) > _33913:
                                    mem[_33913 + _20972 + stor30.length.field_1 + _13543 + 101] = 0
                                return 32, mem[_20972 + stor30.length.field_1 + _13543 + 69 len ceil32(_33913) + 32]
                            mem[stor30.length.field_1 + mem[64] + 32] = 0
                            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_13543)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 192 len ceil32(_13543)]
                            mem[mem[64] + stor30.length.field_1 + _13543 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            if ceil32(_13543) <= _13543:
                                _33010 = mem[64]
                                mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                                mem[_20972 + stor30.length.field_1 + _13543 + 37] = 32
                                _33914 = mem[_33010]
                                mem[_20972 + stor30.length.field_1 + _13543 + 69] = mem[_33010]
                                mem[_20972 + stor30.length.field_1 + _13543 + 101 len ceil32(_33914)] = mem[_33010 + 32 len ceil32(_33914)]
                                if ceil32(_33914) > _33914:
                                    mem[_33914 + _20972 + stor30.length.field_1 + _13543 + 101] = 0
                                return 32, mem[_20972 + stor30.length.field_1 + _13543 + 69 len ceil32(_33914) + 32]
                            _33011 = mem[64]
                            mem[64] = mem[64] + stor30.length.field_1 + _13543 + 37
                            mem[_20972 + stor30.length.field_1 + _13543 + 37] = 32
                            _33915 = mem[_33011]
                            mem[_20972 + stor30.length.field_1 + _13543 + 69] = mem[_33011]
                            mem[_20972 + stor30.length.field_1 + _13543 + 101 len ceil32(_33915)] = mem[_33011 + 32 len ceil32(_33915)]
                            if ceil32(_33915) > _33915:
                                mem[_33915 + _20972 + stor30.length.field_1 + _13543 + 101] = 0
                            return 32, mem[_20972 + stor30.length.field_1 + _13543 + 69 len ceil32(_33915) + 32]
                        require not msg.value
                        require calldata.size - 4 >= 128
                        require cd[4] == address(cd[4])
                        require cd[36] == address(cd[36])
                        require cd[100] <= test266151307()
                        require calldata.size > cd[100] + 35
                        if ('cd', 100).length > test266151307():
                            revert with 0, 65
                        if ceil32(ceil32(('cd', 100).length)) + 129 < 128 or ceil32(ceil32(('cd', 100).length)) + 129 > test266151307():
                            revert with 0, 65
                        mem[128] = ('cd', 100).length
                        require cd[100] + ('cd', 100).length + 36 <= calldata.size
                        mem[160 len ('cd', 100).length] = call.data[cd[100] + 36 len ('cd', 100).length]
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: operator query for nonexistent token'
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        if ownerOf[cd[68]] != msg.sender:
                            if not ownerOf[cd[68]]:
                                revert with 0, 'ERC721: approved query for nonexistent token'
                            if approved[cd[68]] != msg.sender:
                                if not stor28[address(msg.sender)]:
                                    if not stor12[stor9[cd[68]]][address(msg.sender)]:
                                        revert with 0, 'ERC721: transfer caller is not owner nor approved'
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        if ownerOf[cd[68]] != address(cd[4]):
                            revert with 0, 'ERC721: transfer of token that is not own'
                        if not address(cd[36]):
                            revert with 0, 'ERC721: transfer to the zero address'
                        if not address(cd[4]):
                            stor16[cd[68]] = tokenByIndex.length
                            tokenByIndex.length++
                            tokenByIndex[tokenByIndex.length] = cd[68]
                        else:
                            if address(cd[4]) != address(cd[36]):
                                if not address(cd[4]):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                if balanceOf[address(cd[4])] < 1:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])] - 1 != stor14[cd[68]]:
                                    tokenOfOwnerByIndex[address(cd[4])][stor14[cd[68]]] = tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])] - 1]
                                    stor14[stor13[address(cd[4])][stor10[address(cd[4])] - 1]] = stor14[cd[68]]
                                stor14[cd[68]] = 0
                                tokenOfOwnerByIndex[address(cd[4])][stor10[address(cd[4])] - 1] = 0
                        if address(cd[36]):
                            if address(cd[36]) != address(cd[4]):
                                if not address(cd[36]):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(cd[36])][stor10[address(cd[36])]] = cd[68]
                                stor14[cd[68]] = balanceOf[address(cd[36])]
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor16[cd[68]] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor16[cd[68]]] = tokenByIndex[tokenByIndex.length]
                            stor16[stor15[stor15.length]] = stor16[cd[68]]
                            stor16[cd[68]] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[cd[68]] = 0
                        if not ownerOf[cd[68]]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[cd[68]], 0, cd[68]);
                        if balanceOf[address(cd[4])] < 1:
                            revert with 0, 17
                        balanceOf[address(cd[4])]--
                        if balanceOf[address(cd[36])] > -2:
                            revert with 0, 17
                        balanceOf[address(cd[36])]++
                        ownerOf[cd[68]] = address(cd[36])
                        emit Transfer(address(cd[4]), address(cd[36]), cd[68]);
                        if ext_code.size(address(cd[36])):
                            mem[ceil32(ceil32(('cd', 100).length)) + 133] = msg.sender
                            mem[ceil32(ceil32(('cd', 100).length)) + 165] = address(cd[4])
                            mem[ceil32(ceil32(('cd', 100).length)) + 197] = cd[68]
                            mem[ceil32(ceil32(('cd', 100).length)) + 229] = 128
                            mem[ceil32(ceil32(('cd', 100).length)) + 261] = ('cd', 100).length
                            mem[ceil32(ceil32(('cd', 100).length)) + 293 len ceil32(('cd', 100).length)] = call.data[cd[100] + 36 len ('cd', 100).length], Mask(8 * ceil32(('cd', 100).length) - ('cd', 100).length, -(8 * ceil32(('cd', 100).length) + -ceil32(ceil32(('cd', 100).length)) + 27) + 256, msg.sender) >> -(8 * ceil32(('cd', 100).length) + -ceil32(ceil32(('cd', 100).length)) + 27) + 256
                            if ceil32(('cd', 100).length) > ('cd', 100).length:
                                mem[('cd', 100).length + ceil32(ceil32(('cd', 100).length)) + 293] = 0
                            require ext_code.size(address(cd[36]))
                            call address(cd[36]).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(cd[4]), cd[68], Array(len=('cd', 100).length, data=call.data[cd[100] + 36 len ('cd', 100).length])
                            mem[ceil32(ceil32(('cd', 100).length)) + 129] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function lockContract() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isLocked:
        revert with 0, 'Locked: contract is locked.'
    isLocked = 1
}

function mint(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The mint() function is not allowed.'
}

function migrationComplete() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isMigrated:
        if isMigrated:
            revert with 0, 'Invalid migration status.'
    isMigrated = 1
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not stor28[address(arg2)]:
        return bool(stor12[address(arg1)][address(arg2)])
    return 1
}

function sub_904e46e1(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isLocked:
        revert with 0, 'Locked: contract is locked.'
    stor31 = address(arg1)
}

function royaltyInfo(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if not ownerOf[arg1]:
        revert with 0, 'This token id does not exist.'
    if arg2 and stor1 > -1 / arg2:
        revert with 0, 17
    return sub_24ebafb3[arg1], arg2 * stor1 / 10000
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor12[msg.sender][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function sub_31062623(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit 0x38bf5dda: bool(arg2), bool(stor28[address(arg1)]), address(arg1)
    stor28[address(arg1)] = uint8(bool(arg2))
}

function setMaxSupply(uint16 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isLocked:
        revert with 0, 'Locked: contract is locked.'
    if arg1 > maxSupply:
        revert with 0, 'Invalid supply.'
    maxSupply = arg1
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function pause() {
    if not roleAdmin[0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a][address(msg.sender)].field_0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'ERC721PresetMinterPauserAutoId: must have pauser role to pause'
    if stor17:
        revert with 0, 'Pausable: paused'
    stor17 = 1
    emit Paused(msg.sender);
}

function withdraw() {
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
    delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x386d1eb6 with:
         gas gas_remaining wei
        args 4
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    stor0 = 1
}

function unpause() {
    if not roleAdmin[0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a][address(msg.sender)].field_0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'ERC721PresetMinterPauserAutoId: must have pauser role to unpause'
    if not stor17:
        revert with 0, 'Pausable: not paused'
    stor17 = 0
    emit Unpaused(msg.sender);
}

function sub_21492351(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isMigrated:
        if isMigrated:
            revert with 0, 'Invalid migration status.'
    if not ownerOf[arg1]:
        revert with 0, 'This token id does not exist.'
    if 1 > !arg1:
        revert with 0, 17
    if ownerOf[arg1 + 1]:
        revert with 0, 'Invalid initial supply.'
    stor29 = arg1
}

function withdrawTokens(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
    delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x6ec2a423 with:
         gas gas_remaining wei
        args 4, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    stor0 = 1
}

function updateRecipient(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
    delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x1625d8ba with:
         gas gas_remaining wei
        args 4, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    stor0 = 1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor28[address(msg.sender)]:
            if not stor12[stor9[arg2]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x2a55205a00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if Mask(32, 224, arg1) != 0x1ffc9a700000000000000000000000000000000000000000000000000000000:
        if 0x780e9d6300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
            return True
        if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
            return True
        if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
            return True
        if 0x5a05180f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
            return True
        if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
            return True
        if 0x2a55205a00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
            return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function sub_aaf6d56d(?) {
    mem[64] = (32 * sub_14248c40.length) + 128
    mem[96] = sub_14248c40.length
    if not sub_14248c40.length:
        mem[(32 * sub_14248c40.length) + 128] = 32
        mem[(32 * sub_14248c40.length) + 160] = sub_14248c40.length
        idx = 0
        s = 128
        t = (32 * sub_14248c40.length) + 192
        while idx < sub_14248c40.length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * sub_14248c40.length) + 128
           len (96 * sub_14248c40.length) + 64
    mem[128] = address(sub_14248c40.field_0)
    idx = 128
    s = 0
    while (32 * sub_14248c40.length) + 96 > idx:
        mem[idx + 32] = sub_14248c40[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * sub_14248c40.length) + 128] = 32
    mem[(32 * sub_14248c40.length) + 160] = sub_14248c40.length
    idx = 0
    s = 128
    t = mem[64] + 64
    while idx < sub_14248c40.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * sub_14248c40.length) + -mem[64] + 192
}

function sub_9bdedea5(?) {
    require calldata.size - 4 >= 64
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = cd[36] + 36
    s = 128
    while idx < cd[36] + (32 * ('cd', 36).length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    mem[ceil32(32 * ('cd', 36).length) + 97] = 0x3af5509c00000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * ('cd', 36).length) + 101] = 4
    require ext_code.size(0x267b3c094d58875d0be4611c9c62180117f43da7)
    delegate 0x267b3c094d58875d0be4611c9c62180117f43da7.0x3af5509c with:
         gas gas_remaining wei
        args 4, address(cd[4]), Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length])
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    stor0 = 1
}

function sub_d8a778e9(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_14248c40.length = ('cd', 4).length
    if not ('cd', 4).length:
        idx = 0
        while sub_14248c40.length > idx:
            sub_14248c40[idx].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * ('cd', 4).length) + 128 > idx:
            sub_14248c40[s].field_0 = mem[idx + 12 len 20]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5
        while sub_14248c40.length > idx:
            sub_14248c40[idx].field_0 = 0
            idx = idx + 1
            continue 
}

function setBaseURI(string arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require calldata.size > arg1 + 35
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if isLocked:
        revert with 0, 'Locked: contract is locked.'
    if bool(stor30.length):
        if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
            revert with 0, 34
        if arg1.length:
            stor30[].field_0 = Array(len=arg1.length, data=arg1[all])
        else:
            stor30.length = 0
            idx = 0
            while (uint255(stor30.length) * 0.5) + 31 / 32 > idx:
                stor30[idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor30.length) == stor30.length.field_1 < 32:
            revert with 0, 34
        if arg1.length:
            stor30[].field_0 = Array(len=arg1.length, data=arg1[all])
        else:
            stor30.length = 0
            idx = 0
            while stor30.length.field_1 + 31 / 32 > idx:
                stor30[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function renounceRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg2 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
    if roleAdmin[arg1][address(arg2)].field_0:
        roleAdmin[arg1][address(arg2)].field_0 = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
    if roleMember[arg1][1][address(arg2)].field_0:
        if roleMember[arg1][1][address(arg2)].field_0 < 1:
            revert with 0, 17
        if roleMember[arg1].field_0 < 1:
            revert with 0, 17
        if roleMember[arg1].field_0 - 1 != roleMember[arg1][1][address(arg2)].field_0 - 1:
            if roleMember[arg1].field_0 - 1 >= roleMember[arg1].field_0:
                revert with 0, 50
            if roleMember[arg1][1][address(arg2)].field_0 - 1 >= roleMember[arg1].field_0:
                revert with 0, 50
            roleMember[arg1][roleMember[arg1][1][address(arg2)].field_0].field_0 = roleMember[arg1][roleMember[arg1].field_0].field_0
            roleMember[arg1][1][roleMember[arg1][roleMember[arg1].field_0].field_0].field_0 = roleMember[arg1][1][address(arg2)].field_0
        if not roleMember[arg1].field_0:
            revert with 0, 49
        roleMember[arg1][roleMember[arg1].field_0].field_0 = 0
        roleMember[arg1].field_0--
        roleMember[arg1][1][address(arg2)].field_0 = 0
}

function sub_b4e9f909(?) {
    require calldata.size - 4 >= 32
    mem[0] = arg1
    mem[32] = 24
    mem[96] = 0x25c43cc400000000000000000000000000000000000000000000000000000000
    require ext_code.size(sub_24ebafb3[arg1])
    staticcall sub_24ebafb3[arg1].0x25c43cc4 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    _5 = mem[96]
    require mem[96] <= test266151307()
    require return_data.size + 96 > mem[96] + 127
    _6 = mem[mem[96] + 96]
    if mem[mem[96] + 96] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[mem[96] + 96]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
    mem[ceil32(return_data.size) + 96] = _6
    require _5 + (32 * _6) + 32 <= return_data.size
    s = ceil32(return_data.size) + 128
    idx = _5 + 128
    while idx < _5 + (32 * _6) + 128:
        require mem[idx] == mem[idx + 12 len 20]
        mem[s] = mem[idx]
        s = s + 32
        idx = idx + 32
        continue 
    if 1 >= _6:
        revert with 0, 50
    mem[mem[64]] = mem[ceil32(return_data.size) + 172 len 20]
    return memory
      from mem[64]
       len 32
}

function sub_56aaeb92(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    if arg2 > !arg3:
        revert with 0, 17
    if arg2 + arg3 > sub_4bd7ba59.length:
        idx = arg2
        while idx < sub_4bd7ba59.length:
            mem[0] = 26
            mem[96] = 0x49df728c00000000000000000000000000000000000000000000000000000000
            mem[100] = address(arg1)
            require ext_code.size(sub_4bd7ba59[idx])
            call sub_4bd7ba59[idx].0x49df728c with:
                 gas gas_remaining wei
                args address(arg1)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        if arg2 > !arg3:
            revert with 0, 17
        idx = arg2
        while idx < arg2 + arg3:
            if idx >= sub_4bd7ba59.length:
                revert with 0, 50
            mem[0] = 26
            mem[96] = 0x49df728c00000000000000000000000000000000000000000000000000000000
            mem[100] = address(arg1)
            require ext_code.size(sub_4bd7ba59[idx])
            call sub_4bd7ba59[idx].0x49df728c with:
                 gas gas_remaining wei
                args address(arg1)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    stor0 = 1
}

function grantRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if not roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        s = roleAdmin[arg1].field_256
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if roleAdmin[arg1].field_256 + 16384:
            revert with 0, 'Strings: hex length insufficient'
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if not roleAdmin[arg1][address(arg2)].field_0:
        roleAdmin[arg1][address(arg2)].field_0 = 1
        emit RoleGranted(arg1, arg2, msg.sender);
    if not roleMember[arg1][1][address(arg2)].field_0:
        roleMember[arg1].field_0++
        roleMember[arg1][roleMember[arg1].field_0].field_0 = arg2
        roleMember[arg1][roleMember[arg1].field_0].field_160 = 0
        roleMember[arg1][1][address(arg2)].field_0 = roleMember[arg1].field_0
}

function revokeRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if not roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        s = roleAdmin[arg1].field_256
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if roleAdmin[arg1].field_256 + 16384:
            revert with 0, 'Strings: hex length insufficient'
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if roleAdmin[arg1][address(arg2)].field_0:
        roleAdmin[arg1][address(arg2)].field_0 = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
    if roleMember[arg1][1][address(arg2)].field_0:
        if roleMember[arg1][1][address(arg2)].field_0 < 1:
            revert with 0, 17
        if roleMember[arg1].field_0 < 1:
            revert with 0, 17
        if roleMember[arg1].field_0 - 1 != roleMember[arg1][1][address(arg2)].field_0 - 1:
            if roleMember[arg1].field_0 - 1 >= roleMember[arg1].field_0:
                revert with 0, 50
            if roleMember[arg1][1][address(arg2)].field_0 - 1 >= roleMember[arg1].field_0:
                revert with 0, 50
            roleMember[arg1][roleMember[arg1][1][address(arg2)].field_0].field_0 = roleMember[arg1][roleMember[arg1].field_0].field_0
            roleMember[arg1][1][roleMember[arg1][roleMember[arg1].field_0].field_0].field_0 = roleMember[arg1][1][address(arg2)].field_0
        if not roleMember[arg1].field_0:
            revert with 0, 49
        roleMember[arg1][roleMember[arg1].field_0].field_0 = 0
        roleMember[arg1].field_0--
        roleMember[arg1][1][address(arg2)].field_0 = 0
}

function burn(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1] != msg.sender:
        if not ownerOf[arg1]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg1] != msg.sender:
            if not stor28[address(msg.sender)]:
                if not stor12[stor9[arg1]][address(msg.sender)]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Burnable: caller is not owner nor approved'
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1]:
        if not ownerOf[arg1]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
        if balanceOf[stor9[arg1]] < 1:
            revert with 0, 17
        if balanceOf[stor9[arg1]] - 1 != stor14[arg1]:
            tokenOfOwnerByIndex[stor9[arg1]][stor14[arg1]] = tokenOfOwnerByIndex[stor9[arg1]][stor10[stor9[arg1]] - 1]
            stor14[stor13[stor9[arg1]][stor10[stor9[arg1]] - 1]] = stor14[arg1]
        stor14[arg1] = 0
        tokenOfOwnerByIndex[stor9[arg1]][stor10[stor9[arg1]] - 1] = 0
    if tokenByIndex.length < 1:
        revert with 0, 17
    if tokenByIndex.length - 1 >= tokenByIndex.length:
        revert with 0, 50
    if stor16[arg1] >= tokenByIndex.length:
        revert with 0, 50
    tokenByIndex[stor16[arg1]] = tokenByIndex[tokenByIndex.length]
    stor16[stor15[stor15.length]] = stor16[arg1]
    stor16[arg1] = 0
    if not tokenByIndex.length:
        revert with 0, 49
    tokenByIndex[tokenByIndex.length] = 0
    tokenByIndex.length--
    if stor17:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Pausable: token transfer while paused'
    approved[arg1] = 0
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg1], 0, arg1);
    if balanceOf[stor9[arg1]] < 1:
        revert with 0, 17
    balanceOf[stor9[arg1]]--
    ownerOf[arg1] = 0
    emit Transfer(ownerOf[arg1], 0, arg1);
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor28[address(msg.sender)]:
                if not stor12[stor9[arg3]][address(msg.sender)]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer of token that is not own'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if not arg1:
        stor16[arg3] = tokenByIndex.length
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = arg3
    else:
        if arg1 != arg2:
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            if balanceOf[address(arg1)] - 1 != stor14[arg3]:
                tokenOfOwnerByIndex[address(arg1)][stor14[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor10[address(arg1)] - 1]
                stor14[stor13[address(arg1)][stor10[address(arg1)] - 1]] = stor14[arg3]
            stor14[arg3] = 0
            tokenOfOwnerByIndex[address(arg1)][stor10[address(arg1)] - 1] = 0
    if arg2:
        if arg2 != arg1:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg2)][stor10[address(arg2)]] = arg3
            stor14[arg3] = balanceOf[address(arg2)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor16[arg3] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor16[arg3]] = tokenByIndex[tokenByIndex.length]
        stor16[stor15[stor15.length]] = stor16[arg3]
        stor16[arg3] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    if stor17:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Pausable: token transfer while paused'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
}

function name() {
    if bool(stor7.length):
        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor7.length):
            if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor7.length):
                if 31 < uint255(stor7.length) * 0.5:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor7.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)])
                mem[128] = 256 * stor7.length.field_8
        else:
            if bool(stor7.length) == stor7.length.field_1 < 32:
                revert with 0, 34
            if stor7.length.field_1:
                if 31 < stor7.length.field_1:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)])
                mem[128] = 256 * stor7.length.field_8
        mem[ceil32(uint255(stor7.length) * 0.5) + 192 len ceil32(uint255(stor7.length) * 0.5)] = mem[128 len ceil32(uint255(stor7.length) * 0.5)]
        if ceil32(uint255(stor7.length) * 0.5) > uint255(stor7.length) * 0.5:
            mem[(uint255(stor7.length) * 0.5) + ceil32(uint255(stor7.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)], mem[(2 * ceil32(uint255(stor7.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor7.length) * 0.5)]), 
    if bool(stor7.length) == stor7.length.field_1 < 32:
        revert with 0, 34
    if bool(stor7.length):
        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor7.length):
            if 31 < uint255(stor7.length) * 0.5:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while (uint255(stor7.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    else:
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if stor7.length.field_1:
            if 31 < stor7.length.field_1:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    mem[ceil32(stor7.length.field_1) + 192 len ceil32(stor7.length.field_1)] = mem[128 len ceil32(stor7.length.field_1)]
    if ceil32(stor7.length.field_1) > stor7.length.field_1:
        mem[stor7.length.field_1 + ceil32(stor7.length.field_1) + 192] = 0
    return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 192 len 2 * ceil32(stor7.length.field_1)]), 
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor28[address(msg.sender)]:
                if not stor12[stor9[arg3]][address(msg.sender)]:
                    revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer of token that is not own'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if not arg1:
        stor16[arg3] = tokenByIndex.length
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = arg3
    else:
        if arg1 != arg2:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            if balanceOf[address(arg1)] - 1 != stor14[arg3]:
                tokenOfOwnerByIndex[address(arg1)][stor14[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor10[address(arg1)] - 1]
                stor14[stor13[address(arg1)][stor10[address(arg1)] - 1]] = stor14[arg3]
            stor14[arg3] = 0
            tokenOfOwnerByIndex[address(arg1)][stor10[address(arg1)] - 1] = 0
    if arg2:
        if arg2 != arg1:
            if not arg2:
                revert with 0, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg2)][stor10[address(arg2)]] = arg3
            stor14[arg3] = balanceOf[address(arg2)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor16[arg3] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor16[arg3]] = tokenByIndex[tokenByIndex.length]
        stor16[stor15[stor15.length]] = stor16[arg3]
        stor16[arg3] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    if stor17:
        revert with 0, 'ERC721Pausable: token transfer while paused'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
        if not ext_call.success:
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function symbol() {
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor8.length):
                if 31 < uint255(stor8.length) * 0.5:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor8.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(uint255(stor8.length) * 0.5) + 192 len ceil32(uint255(stor8.length) * 0.5)] = mem[128 len ceil32(uint255(stor8.length) * 0.5)]
        if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
            mem[(uint255(stor8.length) * 0.5) + ceil32(uint255(stor8.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor8.length):
            if 31 < uint255(stor8.length) * 0.5:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while (uint255(stor8.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[stor8.length.field_1 + ceil32(stor8.length.field_1) + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function sub_ab62a884(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if not isMigrated:
        revert with 0, 'Invalid migration status.'
    if not roleAdmin[0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6][address(msg.sender)].field_0:
        revert with 0, 'Only minters can gift.'
    if ownerOf[arg2]:
        revert with 0, 'This token already has an owner.'
    if arg2 >= stor29:
        revert with 0, 'This token cannot be gifted.'
    if sub_519db647[address(arg1)]:
        if not address(arg1):
            revert with 0, 'ERC721: mint to the zero address'
        if ownerOf[arg2]:
            revert with 0, 'ERC721: token already minted'
        stor16[arg2] = tokenByIndex.length
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = arg2
        if address(arg1):
            if address(arg1):
                if not address(arg1):
                    revert with 0, 'ERC721: balance query for the zero address'
                tokenOfOwnerByIndex[address(arg1)][stor10[address(arg1)]] = arg2
                stor14[arg2] = balanceOf[address(arg1)]
        else:
            if tokenByIndex.length < 1:
                revert with 0, 17
            if tokenByIndex.length - 1 >= tokenByIndex.length:
                revert with 0, 50
            if stor16[arg2] >= tokenByIndex.length:
                revert with 0, 50
            tokenByIndex[stor16[arg2]] = tokenByIndex[tokenByIndex.length]
            stor16[stor15[stor15.length]] = stor16[arg2]
            stor16[arg2] = 0
            if not tokenByIndex.length:
                revert with 0, 49
            tokenByIndex[tokenByIndex.length] = 0
            tokenByIndex.length--
        if stor17:
            revert with 0, 'ERC721Pausable: token transfer while paused'
        if balanceOf[address(arg1)] > -2:
            revert with 0, 17
        balanceOf[address(arg1)]++
        ownerOf[arg2] = address(arg1)
        emit Transfer(0, address(arg1), arg2);
        if ext_code.size(address(arg1)):
            require ext_code.size(address(arg1))
            call address(arg1).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, uint32(msg.sender), 0, arg2, 128, 0
            if not ext_call.success:
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
    else:
        mem[128] = sub_50f80d52Address
        mem[160] = address(arg1)
        mem[192] = 2
        mem[224] = 5000
        mem[256] = 5000
        mem[288 len 3487] = code.data[20530 len 3487]
        idx = 0
        s = 128
        t = 3903
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        idx = 0
        s = 3999
        t = 224
        while idx < 2:
            mem[s] = mem[t + 30 len 2]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        create contract with 0 wei
                        code: code.data[20530 len 3487], address(this.address), 96, 192, 2, mem[3903 len 64], 2, mem[3999 len 64]
        if not create.new_address:
            revert with ext_call.return_data[0 len return_data.size]
        sub_519db647[address(arg1)] = address(create.new_address)
        sub_4bd7ba59.length++
        stor57C3[stor26.length] = address(create.new_address)
        emit 0x709f7933: address(create.new_address), address(arg1)
        if not address(arg1):
            revert with 0, 'ERC721: mint to the zero address'
        if ownerOf[arg2]:
            revert with 0, 'ERC721: token already minted'
        stor16[arg2] = tokenByIndex.length
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = arg2
        if address(arg1):
            if address(arg1):
                if not address(arg1):
                    revert with 0, 'ERC721: balance query for the zero address'
                tokenOfOwnerByIndex[address(arg1)][stor10[address(arg1)]] = arg2
                stor14[arg2] = balanceOf[address(arg1)]
        else:
            if tokenByIndex.length < 1:
                revert with 0, 17
            if tokenByIndex.length - 1 >= tokenByIndex.length:
                revert with 0, 50
            if stor16[arg2] >= tokenByIndex.length:
                revert with 0, 50
            tokenByIndex[stor16[arg2]] = tokenByIndex[tokenByIndex.length]
            stor16[stor15[stor15.length]] = stor16[arg2]
            stor16[arg2] = 0
            if not tokenByIndex.length:
                revert with 0, 49
            tokenByIndex[tokenByIndex.length] = 0
            tokenByIndex.length--
        if stor17:
            revert with 0, 'ERC721Pausable: token transfer while paused'
        if balanceOf[address(arg1)] > -2:
            revert with 0, 17
        balanceOf[address(arg1)]++
        ownerOf[arg2] = address(arg1)
        emit Transfer(0, address(arg1), arg2);
        if ext_code.size(address(arg1)):
            require ext_code.size(address(arg1))
            call address(arg1).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                 gas gas_remaining wei
                args msg.sender, 0, arg2, 128, 0
            if not ext_call.success:
                if not return_data.size:
                    revert with stor22
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
    sub_24ebafb3[arg2] = sub_519db647[address(arg1)]
    emit 0xda2aa9ce: 1, address(arg1)
}

function sub_25e8b88f(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if not isMigrated:
        revert with 0, 'Invalid migration status.'
    if maxPerMint < uint8(arg1):
        revert with 0, 'Too many for one transaction.'
    if mintPrice and uint8(arg1) > -1 / mintPrice:
        revert with 0, 17
    if mintPrice * uint8(arg1) != msg.value:
        revert with 0, 'The value != minting price.'
    if stor29 > !uint8(arg1):
        revert with 0, 17
    if maxSupply < stor29 + uint8(arg1):
        revert with 0, 'There are not this many tokens.'
    if sub_519db647[address(msg.sender)]:
        mem[0] = msg.sender
        mem[32] = 23
        idx = 0
        while uint8(idx) < uint8(arg1):
            stor29++
            _325 = mem[64]
            mem[64] = mem[64] + 32
            mem[_325] = 0
            if not msg.sender:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[stor29]:
                revert with 0, 'ERC721: token already minted'
            stor16[stor29] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = stor29
            if msg.sender:
                if not msg.sender:
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = stor29
                    mem[32] = 9
                    ownerOf[stor29] = msg.sender
                    emit Transfer(0, msg.sender, stor29);
                    if ext_code.size(msg.sender):
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = stor29
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _325 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, stor29, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _638 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_638] == Mask(32, 224, mem[_638])
                        if Mask(32, 224, mem[_638]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    if not msg.sender:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(msg.sender)][stor10[address(msg.sender)]] = stor29
                    stor14[stor29] = balanceOf[address(msg.sender)]
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = stor29
                    mem[32] = 9
                    ownerOf[stor29] = msg.sender
                    emit Transfer(0, msg.sender, stor29);
                    if ext_code.size(msg.sender):
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = stor29
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _325 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, stor29, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _640 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_640] == Mask(32, 224, mem[_640])
                        if Mask(32, 224, mem[_640]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor16[stor29] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor16[stor29]] = tokenByIndex[tokenByIndex.length]
                stor16[stor15[stor15.length]] = stor16[stor29]
                stor16[stor29] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
                if stor17:
                    revert with 0, 'ERC721Pausable: token transfer while paused'
                if balanceOf[address(msg.sender)] > -2:
                    revert with 0, 17
                balanceOf[address(msg.sender)]++
                mem[0] = stor29
                mem[32] = 9
                ownerOf[stor29] = msg.sender
                emit Transfer(0, msg.sender, stor29);
                if ext_code.size(msg.sender):
                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = stor29
                    mem[mem[64] + 100] = 128
                    mem[mem[64] + 132] = 0
                    s = 0
                    while s < 0:
                        mem[s + mem[64] + 164] = mem[s + _325 + 32]
                        s = s + 32
                        continue 
                    require ext_code.size(msg.sender)
                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args msg.sender, 0, stor29, 128, 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        if not return_data.size:
                            if not mem[96]:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with memory
                              from 128
                               len mem[96]
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    _642 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_642] == Mask(32, 224, mem[_642])
                    if Mask(32, 224, mem[_642]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            mem[0] = stor29
            mem[32] = 24
            sub_24ebafb3[stor29] = sub_519db647[msg.sender]
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
    else:
        mem[96] = 2
        mem[128] = sub_50f80d52Address
        mem[160] = msg.sender
        mem[192] = 2
        mem[64] = 288
        mem[224] = 5000
        mem[256] = 5000
        mem[288 len 3487] = code.data[20530 len 3487]
        mem[3775] = this.address
        mem[3807] = 96
        mem[3871] = 2
        idx = 0
        s = 128
        t = 3903
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[3839] = 192
        mem[3967] = 2
        idx = 0
        s = 3999
        t = 224
        while idx < 2:
            mem[s] = mem[t + 30 len 2]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        create contract with 0 wei
                        code: code.data[20530 len 3487], address(this.address), 96, 192, 2, mem[3903 len 64], 2, mem[3999 len 64]
        if not create.new_address:
            revert with ext_call.return_data[0 len return_data.size]
        sub_519db647[address(msg.sender)] = address(create.new_address)
        sub_4bd7ba59.length++
        stor57C3[stor26.length] = address(create.new_address)
        mem[288] = address(create.new_address)
        emit 0x709f7933: address(create.new_address), msg.sender
        mem[0] = msg.sender
        mem[32] = 23
        idx = 0
        while uint8(idx) < uint8(arg1):
            stor29++
            _877 = mem[64]
            mem[64] = mem[64] + 32
            mem[_877] = 0
            if not msg.sender:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[stor29]:
                revert with 0, 'ERC721: token already minted'
            stor16[stor29] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = stor29
            if msg.sender:
                if not msg.sender:
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = stor29
                    mem[32] = 9
                    ownerOf[stor29] = msg.sender
                    emit Transfer(0, msg.sender, stor29);
                    if ext_code.size(msg.sender):
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = stor29
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _877 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, stor29, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _1031 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1031] == Mask(32, 224, mem[_1031])
                        if Mask(32, 224, mem[_1031]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    if not msg.sender:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(msg.sender)][stor10[address(msg.sender)]] = stor29
                    stor14[stor29] = balanceOf[address(msg.sender)]
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(msg.sender)] > -2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)]++
                    mem[0] = stor29
                    mem[32] = 9
                    ownerOf[stor29] = msg.sender
                    emit Transfer(0, msg.sender, stor29);
                    if ext_code.size(msg.sender):
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = stor29
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _877 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(msg.sender)
                        call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, stor29, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _1033 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1033] == Mask(32, 224, mem[_1033])
                        if Mask(32, 224, mem[_1033]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor16[stor29] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor16[stor29]] = tokenByIndex[tokenByIndex.length]
                stor16[stor15[stor15.length]] = stor16[stor29]
                stor16[stor29] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
                if stor17:
                    revert with 0, 'ERC721Pausable: token transfer while paused'
                if balanceOf[address(msg.sender)] > -2:
                    revert with 0, 17
                balanceOf[address(msg.sender)]++
                mem[0] = stor29
                mem[32] = 9
                ownerOf[stor29] = msg.sender
                emit Transfer(0, msg.sender, stor29);
                if ext_code.size(msg.sender):
                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = stor29
                    mem[mem[64] + 100] = 128
                    mem[mem[64] + 132] = 0
                    s = 0
                    while s < 0:
                        mem[s + mem[64] + 164] = mem[s + _877 + 32]
                        s = s + 32
                        continue 
                    require ext_code.size(msg.sender)
                    call msg.sender.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args msg.sender, 0, stor29, 128, 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        if not return_data.size:
                            if not mem[96]:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with memory
                              from 128
                               len mem[96]
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    _1035 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1035] == Mask(32, 224, mem[_1035])
                    if Mask(32, 224, mem[_1035]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            mem[0] = stor29
            mem[32] = 24
            sub_24ebafb3[stor29] = sub_519db647[msg.sender]
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
    emit 0xda2aa9ce: uint8(arg1), msg.sender
}

function sub_b0e25d1f(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = cd[36] + 36
    s = ceil32(32 * ('cd', 4).length) + 129
    while idx < cd[36] + (32 * ('cd', 36).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not isMigrated:
        if ('cd', 4).length != ('cd', 36).length:
            revert with 0, 'Mismatched array lengths.'
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2822 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]
            mem[32] = 23
            if sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]:
                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _2836 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[96]:
                    revert with 0, 50
                _2844 = mem[(32 * idx) + 128]
                _2848 = mem[64]
                mem[64] = mem[64] + 32
                mem[_2848] = 0
                if not address(_2836):
                    revert with 0, 'ERC721: mint to the zero address'
                if ownerOf[_2844]:
                    revert with 0, 'ERC721: token already minted'
                stor16[_2844] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = _2844
                if address(_2836):
                    if not address(_2836):
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_2836)] > -2:
                            revert with 0, 17
                        balanceOf[address(_2836)]++
                        mem[0] = _2844
                        mem[32] = 9
                        ownerOf[_2844] = address(_2836)
                        emit Transfer(0, address(_2836), _2844);
                        if not ext_code.size(address(_2836)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _2980 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_2980)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _2844
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _2848 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_2836))
                            call address(_2836).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _2844, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _3776 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3776] == Mask(32, 224, mem[_3776])
                            if Mask(32, 224, mem[_3776]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4040 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4040)
                    else:
                        if not address(_2836):
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(_2836)][stor10[address(_2836)]] = _2844
                        stor14[_2844] = balanceOf[address(_2836)]
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_2836)] > -2:
                            revert with 0, 17
                        balanceOf[address(_2836)]++
                        mem[0] = _2844
                        mem[32] = 9
                        ownerOf[_2844] = address(_2836)
                        emit Transfer(0, address(_2836), _2844);
                        if not ext_code.size(address(_2836)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _3046 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_3046)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _2844
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _2848 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_2836))
                            call address(_2836).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _2844, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _3778 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3778] == Mask(32, 224, mem[_3778])
                            if Mask(32, 224, mem[_3778]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4044 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4044)
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor16[_2844] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor16[_2844]] = tokenByIndex[tokenByIndex.length]
                    stor16[stor15[stor15.length]] = stor16[_2844]
                    stor16[_2844] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(_2836)] > -2:
                        revert with 0, 17
                    balanceOf[address(_2836)]++
                    mem[0] = _2844
                    mem[32] = 9
                    ownerOf[_2844] = address(_2836)
                    emit Transfer(0, address(_2836), _2844);
                    if not ext_code.size(address(_2836)):
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _3088 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_3088)
                    else:
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = _2844
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _2848 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(address(_2836))
                        call address(_2836).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, _2844, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _3780 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3780] == Mask(32, 224, mem[_3780])
                        if Mask(32, 224, mem[_3780]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _4048 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_4048)
            else:
                _2827 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_2827]:
                    revert with 0, 50
                mem[_2827 + 32] = sub_50f80d52Address
                if 1 >= mem[_2827]:
                    revert with 0, 50
                mem[_2827 + 64] = address(_2822)
                mem[_2827 + 96] = 2
                mem[64] = _2827 + 192
                mem[_2827 + 128] = 5000
                mem[_2827 + 160] = 5000
                mem[_2827 + 192 len 3487] = code.data[20530 len 3487]
                mem[_2827 + 3679] = this.address
                mem[_2827 + 3711] = 96
                mem[_2827 + 3775] = mem[_2827]
                s = 0
                t = _2827 + 32
                u = _2827 + 3807
                while s < mem[_2827]:
                    mem[u] = mem[t + 12 len 20]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                mem[_2827 + 3743] = (32 * mem[_2827]) + 128
                mem[_2827 + (32 * mem[_2827]) + 3807] = 2
                s = 0
                t = _2827 + (32 * mem[_2827]) + 3839
                u = _2827 + 128
                while s < 2:
                    mem[t] = mem[u + 30 len 2]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                create contract with 0 wei
                                code: mem[mem[64] len _2827 + (32 * mem[_2827]) + -mem[64] + 3903]
                if not create.new_address:
                    revert with ext_call.return_data[0 len return_data.size]
                sub_519db647[address(_2822)] = address(create.new_address)
                sub_4bd7ba59.length++
                stor57C3[stor26.length] = address(create.new_address)
                mem[mem[64]] = address(create.new_address)
                emit 0x709f7933: address(create.new_address), address(_2822)
                mem[0] = address(_2822)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _4510 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[96]:
                    revert with 0, 50
                _4514 = mem[(32 * idx) + 128]
                _4516 = mem[64]
                mem[64] = mem[64] + 32
                mem[_4516] = 0
                if not address(_4510):
                    revert with 0, 'ERC721: mint to the zero address'
                if ownerOf[_4514]:
                    revert with 0, 'ERC721: token already minted'
                stor16[_4514] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = _4514
                if address(_4510):
                    if not address(_4510):
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_4510)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4510)]++
                        mem[0] = _4514
                        mem[32] = 9
                        ownerOf[_4514] = address(_4510)
                        emit Transfer(0, address(_4510), _4514);
                        if not ext_code.size(address(_4510)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4606 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4606)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _4514
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4516 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4510))
                            call address(_4510).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _4514, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _4968 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4968] == Mask(32, 224, mem[_4968])
                            if Mask(32, 224, mem[_4968]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _5208 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_5208)
                    else:
                        if not address(_4510):
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(_4510)][stor10[address(_4510)]] = _4514
                        stor14[_4514] = balanceOf[address(_4510)]
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_4510)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4510)]++
                        mem[0] = _4514
                        mem[32] = 9
                        ownerOf[_4514] = address(_4510)
                        emit Transfer(0, address(_4510), _4514);
                        if not ext_code.size(address(_4510)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4644 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4644)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _4514
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4516 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4510))
                            call address(_4510).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _4514, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _4970 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4970] == Mask(32, 224, mem[_4970])
                            if Mask(32, 224, mem[_4970]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _5212 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_5212)
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor16[_4514] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor16[_4514]] = tokenByIndex[tokenByIndex.length]
                    stor16[stor15[stor15.length]] = stor16[_4514]
                    stor16[_4514] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(_4510)] > -2:
                        revert with 0, 17
                    balanceOf[address(_4510)]++
                    mem[0] = _4514
                    mem[32] = 9
                    ownerOf[_4514] = address(_4510)
                    emit Transfer(0, address(_4510), _4514);
                    if not ext_code.size(address(_4510)):
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _4678 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_4678)
                    else:
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = _4514
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _4516 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(address(_4510))
                        call address(_4510).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, _4514, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _4972 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4972] == Mask(32, 224, mem[_4972])
                        if Mask(32, 224, mem[_4972]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _5216 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_5216)
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        if isMigrated:
            revert with 0, 'Invalid migration status.'
        if ('cd', 4).length != ('cd', 36).length:
            revert with 0, 'Mismatched array lengths.'
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2823 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]
            mem[32] = 23
            if sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]:
                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _2840 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[96]:
                    revert with 0, 50
                _2846 = mem[(32 * idx) + 128]
                _2850 = mem[64]
                mem[64] = mem[64] + 32
                mem[_2850] = 0
                if not address(_2840):
                    revert with 0, 'ERC721: mint to the zero address'
                if ownerOf[_2846]:
                    revert with 0, 'ERC721: token already minted'
                stor16[_2846] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = _2846
                if address(_2840):
                    if not address(_2840):
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_2840)] > -2:
                            revert with 0, 17
                        balanceOf[address(_2840)]++
                        mem[0] = _2846
                        mem[32] = 9
                        ownerOf[_2846] = address(_2840)
                        emit Transfer(0, address(_2840), _2846);
                        if not ext_code.size(address(_2840)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _2984 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_2984)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _2846
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _2850 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_2840))
                            call address(_2840).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _2846, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _3783 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3783] == Mask(32, 224, mem[_3783])
                            if Mask(32, 224, mem[_3783]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4052 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4052)
                    else:
                        if not address(_2840):
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(_2840)][stor10[address(_2840)]] = _2846
                        stor14[_2846] = balanceOf[address(_2840)]
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_2840)] > -2:
                            revert with 0, 17
                        balanceOf[address(_2840)]++
                        mem[0] = _2846
                        mem[32] = 9
                        ownerOf[_2846] = address(_2840)
                        emit Transfer(0, address(_2840), _2846);
                        if not ext_code.size(address(_2840)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _3053 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_3053)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _2846
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _2850 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_2840))
                            call address(_2840).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _2846, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _3785 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3785] == Mask(32, 224, mem[_3785])
                            if Mask(32, 224, mem[_3785]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4056 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4056)
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor16[_2846] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor16[_2846]] = tokenByIndex[tokenByIndex.length]
                    stor16[stor15[stor15.length]] = stor16[_2846]
                    stor16[_2846] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(_2840)] > -2:
                        revert with 0, 17
                    balanceOf[address(_2840)]++
                    mem[0] = _2846
                    mem[32] = 9
                    ownerOf[_2846] = address(_2840)
                    emit Transfer(0, address(_2840), _2846);
                    if not ext_code.size(address(_2840)):
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _3097 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_3097)
                    else:
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = _2846
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _2850 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(address(_2840))
                        call address(_2840).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, _2846, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _3787 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3787] == Mask(32, 224, mem[_3787])
                        if Mask(32, 224, mem[_3787]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _4060 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_4060)
            else:
                _2830 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_2830]:
                    revert with 0, 50
                mem[_2830 + 32] = sub_50f80d52Address
                if 1 >= mem[_2830]:
                    revert with 0, 50
                mem[_2830 + 64] = address(_2823)
                mem[_2830 + 96] = 2
                mem[64] = _2830 + 192
                mem[_2830 + 128] = 5000
                mem[_2830 + 160] = 5000
                mem[_2830 + 192 len 3487] = code.data[20530 len 3487]
                mem[_2830 + 3679] = this.address
                mem[_2830 + 3711] = 96
                mem[_2830 + 3775] = mem[_2830]
                s = 0
                t = _2830 + 32
                u = _2830 + 3807
                while s < mem[_2830]:
                    mem[u] = mem[t + 12 len 20]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                mem[_2830 + 3743] = (32 * mem[_2830]) + 128
                mem[_2830 + (32 * mem[_2830]) + 3807] = 2
                s = 0
                t = _2830 + (32 * mem[_2830]) + 3839
                u = _2830 + 128
                while s < 2:
                    mem[t] = mem[u + 30 len 2]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                create contract with 0 wei
                                code: mem[mem[64] len _2830 + (32 * mem[_2830]) + -mem[64] + 3903]
                if not create.new_address:
                    revert with ext_call.return_data[0 len return_data.size]
                sub_519db647[address(_2823)] = address(create.new_address)
                sub_4bd7ba59.length++
                stor57C3[stor26.length] = address(create.new_address)
                mem[mem[64]] = address(create.new_address)
                emit 0x709f7933: address(create.new_address), address(_2823)
                mem[0] = address(_2823)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _4512 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[96]:
                    revert with 0, 50
                _4515 = mem[(32 * idx) + 128]
                _4517 = mem[64]
                mem[64] = mem[64] + 32
                mem[_4517] = 0
                if not address(_4512):
                    revert with 0, 'ERC721: mint to the zero address'
                if ownerOf[_4515]:
                    revert with 0, 'ERC721: token already minted'
                stor16[_4515] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = _4515
                if address(_4512):
                    if not address(_4512):
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_4512)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4512)]++
                        mem[0] = _4515
                        mem[32] = 9
                        ownerOf[_4515] = address(_4512)
                        emit Transfer(0, address(_4512), _4515);
                        if not ext_code.size(address(_4512)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4610 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4610)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _4515
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4517 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4512))
                            call address(_4512).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _4515, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _4974 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4974] == Mask(32, 224, mem[_4974])
                            if Mask(32, 224, mem[_4974]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _5220 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_5220)
                    else:
                        if not address(_4512):
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(_4512)][stor10[address(_4512)]] = _4515
                        stor14[_4515] = balanceOf[address(_4512)]
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        if balanceOf[address(_4512)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4512)]++
                        mem[0] = _4515
                        mem[32] = 9
                        ownerOf[_4515] = address(_4512)
                        emit Transfer(0, address(_4512), _4515);
                        if not ext_code.size(address(_4512)):
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _4650 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_4650)
                        else:
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = _4515
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4517 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4512))
                            call address(_4512).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, 0, _4515, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _4976 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4976] == Mask(32, 224, mem[_4976])
                            if Mask(32, 224, mem[_4976]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            if idx >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 128]
                            mem[32] = 24
                            sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            _5224 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[mem[64]] = 1
                            emit 0xda2aa9ce: 1, address(_5224)
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor16[_4515] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor16[_4515]] = tokenByIndex[tokenByIndex.length]
                    stor16[stor15[stor15.length]] = stor16[_4515]
                    stor16[_4515] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    if balanceOf[address(_4512)] > -2:
                        revert with 0, 17
                    balanceOf[address(_4512)]++
                    mem[0] = _4515
                    mem[32] = 9
                    ownerOf[_4515] = address(_4512)
                    emit Transfer(0, address(_4512), _4515);
                    if not ext_code.size(address(_4512)):
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _4686 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_4686)
                    else:
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = _4515
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _4517 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(address(_4512))
                        call address(_4512).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, 0, _4515, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _4978 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4978] == Mask(32, 224, mem[_4978])
                        if Mask(32, 224, mem[_4978]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 128]
                        mem[32] = 24
                        sub_24ebafb3[mem[(32 * idx) + 128]] = sub_519db647[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 141 len 20]]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        _5228 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[mem[64]] = 1
                        emit 0xda2aa9ce: 1, address(_5228)
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
}

function sub_e74bdd0a(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = cd[36] + 36
    s = ceil32(32 * ('cd', 4).length) + 129
    while idx < cd[36] + (32 * ('cd', 36).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = cd[68] + 36
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < cd[68] + (32 * ('cd', 68).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not isMigrated:
        if ('cd', 4).length != ('cd', 36).length:
            revert with 0, 'Mismatched array lengths.'
        if ('cd', 4).length != ('cd', 68).length:
            revert with 0, 'Mismatched array lengths.'
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _4843 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                revert with 0, 50
            _4847 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
            if idx >= mem[96]:
                revert with 0, 50
            _4851 = mem[(32 * idx) + 128]
            _4852 = mem[64]
            mem[64] = mem[64] + 32
            mem[_4852] = 0
            if not ownerOf[_4851]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[_4851] != address(_4843):
                revert with 0, 'ERC721: transfer of token that is not own'
            if not address(_4847):
                revert with 0, 'ERC721: transfer to the zero address'
            if not address(_4843):
                stor16[_4851] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = _4851
                if address(_4847):
                    if address(_4847) == address(_4843):
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[_4851] = 0
                        if not ownerOf[_4851]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[_4851], 0, _4851);
                        if balanceOf[address(_4843)] < 1:
                            revert with 0, 17
                        balanceOf[address(_4843)]--
                        if balanceOf[address(_4847)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4847)]++
                        mem[0] = _4851
                        mem[32] = 9
                        ownerOf[_4851] = address(_4847)
                        emit Transfer(address(_4843), address(_4847), _4851);
                        if ext_code.size(address(_4847)):
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = address(_4843)
                            mem[mem[64] + 68] = _4851
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4847))
                            call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(_4843), _4851, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _6117 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_6117] == Mask(32, 224, mem[_6117])
                            if Mask(32, 224, mem[_6117]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if not address(_4847):
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(_4847)][stor10[address(_4847)]] = _4851
                        stor14[_4851] = balanceOf[address(_4847)]
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[_4851] = 0
                        if not ownerOf[_4851]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[_4851], 0, _4851);
                        if balanceOf[address(_4843)] < 1:
                            revert with 0, 17
                        balanceOf[address(_4843)]--
                        if balanceOf[address(_4847)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4847)]++
                        mem[0] = _4851
                        mem[32] = 9
                        ownerOf[_4851] = address(_4847)
                        emit Transfer(address(_4843), address(_4847), _4851);
                        if ext_code.size(address(_4847)):
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = address(_4843)
                            mem[mem[64] + 68] = _4851
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4847))
                            call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(_4843), _4851, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _6119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_6119] == Mask(32, 224, mem[_6119])
                            if Mask(32, 224, mem[_6119]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor16[_4851] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor16[_4851]] = tokenByIndex[tokenByIndex.length]
                    stor16[stor15[stor15.length]] = stor16[_4851]
                    stor16[_4851] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    approved[_4851] = 0
                    if not ownerOf[_4851]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    emit Approval(ownerOf[_4851], 0, _4851);
                    if balanceOf[address(_4843)] < 1:
                        revert with 0, 17
                    balanceOf[address(_4843)]--
                    if balanceOf[address(_4847)] > -2:
                        revert with 0, 17
                    balanceOf[address(_4847)]++
                    mem[0] = _4851
                    mem[32] = 9
                    ownerOf[_4851] = address(_4847)
                    emit Transfer(address(_4843), address(_4847), _4851);
                    if ext_code.size(address(_4847)):
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = address(_4843)
                        mem[mem[64] + 68] = _4851
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(address(_4847))
                        call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, address(_4843), _4851, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _6121 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_6121] == Mask(32, 224, mem[_6121])
                        if Mask(32, 224, mem[_6121]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                if address(_4843) == address(_4847):
                    if address(_4847):
                        if address(_4847) == address(_4843):
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4851] = 0
                            if not ownerOf[_4851]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4851], 0, _4851);
                            if balanceOf[address(_4843)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4843)]--
                            if balanceOf[address(_4847)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4847)]++
                            mem[0] = _4851
                            mem[32] = 9
                            ownerOf[_4851] = address(_4847)
                            emit Transfer(address(_4843), address(_4847), _4851);
                            if ext_code.size(address(_4847)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4843)
                                mem[mem[64] + 68] = _4851
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4847))
                                call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4843), _4851, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6099 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6099] == Mask(32, 224, mem[_6099])
                                if Mask(32, 224, mem[_6099]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not address(_4847):
                                revert with 0, 'ERC721: balance query for the zero address'
                            tokenOfOwnerByIndex[address(_4847)][stor10[address(_4847)]] = _4851
                            stor14[_4851] = balanceOf[address(_4847)]
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4851] = 0
                            if not ownerOf[_4851]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4851], 0, _4851);
                            if balanceOf[address(_4843)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4843)]--
                            if balanceOf[address(_4847)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4847)]++
                            mem[0] = _4851
                            mem[32] = 9
                            ownerOf[_4851] = address(_4847)
                            emit Transfer(address(_4843), address(_4847), _4851);
                            if ext_code.size(address(_4847)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4843)
                                mem[mem[64] + 68] = _4851
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4847))
                                call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4843), _4851, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6101 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6101] == Mask(32, 224, mem[_6101])
                                if Mask(32, 224, mem[_6101]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if tokenByIndex.length < 1:
                            revert with 0, 17
                        if tokenByIndex.length - 1 >= tokenByIndex.length:
                            revert with 0, 50
                        if stor16[_4851] >= tokenByIndex.length:
                            revert with 0, 50
                        tokenByIndex[stor16[_4851]] = tokenByIndex[tokenByIndex.length]
                        stor16[stor15[stor15.length]] = stor16[_4851]
                        stor16[_4851] = 0
                        if not tokenByIndex.length:
                            revert with 0, 49
                        tokenByIndex[tokenByIndex.length] = 0
                        tokenByIndex.length--
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[_4851] = 0
                        if not ownerOf[_4851]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[_4851], 0, _4851);
                        if balanceOf[address(_4843)] < 1:
                            revert with 0, 17
                        balanceOf[address(_4843)]--
                        if balanceOf[address(_4847)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4847)]++
                        mem[0] = _4851
                        mem[32] = 9
                        ownerOf[_4851] = address(_4847)
                        emit Transfer(address(_4843), address(_4847), _4851);
                        if ext_code.size(address(_4847)):
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = address(_4843)
                            mem[mem[64] + 68] = _4851
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4847))
                            call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(_4843), _4851, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _6103 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_6103] == Mask(32, 224, mem[_6103])
                            if Mask(32, 224, mem[_6103]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    if not address(_4843):
                        revert with 0, 'ERC721: balance query for the zero address'
                    if balanceOf[address(_4843)] < 1:
                        revert with 0, 17
                    if balanceOf[address(_4843)] - 1 == stor14[_4851]:
                        stor14[_4851] = 0
                        tokenOfOwnerByIndex[address(_4843)][stor10[address(_4843)] - 1] = 0
                        if address(_4847):
                            if address(_4847) == address(_4843):
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4851] = 0
                                if not ownerOf[_4851]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4851], 0, _4851);
                                if balanceOf[address(_4843)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4843)]--
                                if balanceOf[address(_4847)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4847)]++
                                mem[0] = _4851
                                mem[32] = 9
                                ownerOf[_4851] = address(_4847)
                                emit Transfer(address(_4843), address(_4847), _4851);
                                if ext_code.size(address(_4847)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4843)
                                    mem[mem[64] + 68] = _4851
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4847))
                                    call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4843), _4851, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6105 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6105] == Mask(32, 224, mem[_6105])
                                    if Mask(32, 224, mem[_6105]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not address(_4847):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(_4847)][stor10[address(_4847)]] = _4851
                                stor14[_4851] = balanceOf[address(_4847)]
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4851] = 0
                                if not ownerOf[_4851]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4851], 0, _4851);
                                if balanceOf[address(_4843)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4843)]--
                                if balanceOf[address(_4847)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4847)]++
                                mem[0] = _4851
                                mem[32] = 9
                                ownerOf[_4851] = address(_4847)
                                emit Transfer(address(_4843), address(_4847), _4851);
                                if ext_code.size(address(_4847)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4843)
                                    mem[mem[64] + 68] = _4851
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4847))
                                    call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4843), _4851, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6107 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6107] == Mask(32, 224, mem[_6107])
                                    if Mask(32, 224, mem[_6107]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor16[_4851] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor16[_4851]] = tokenByIndex[tokenByIndex.length]
                            stor16[stor15[stor15.length]] = stor16[_4851]
                            stor16[_4851] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4851] = 0
                            if not ownerOf[_4851]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4851], 0, _4851);
                            if balanceOf[address(_4843)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4843)]--
                            if balanceOf[address(_4847)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4847)]++
                            mem[0] = _4851
                            mem[32] = 9
                            ownerOf[_4851] = address(_4847)
                            emit Transfer(address(_4843), address(_4847), _4851);
                            if ext_code.size(address(_4847)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4843)
                                mem[mem[64] + 68] = _4851
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4847))
                                call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4843), _4851, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6109 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6109] == Mask(32, 224, mem[_6109])
                                if Mask(32, 224, mem[_6109]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        tokenOfOwnerByIndex[address(_4843)][stor14[_4851]] = tokenOfOwnerByIndex[address(_4843)][stor10[address(_4843)] - 1]
                        stor14[stor13[address(_4843)][stor10[address(_4843)] - 1]] = stor14[_4851]
                        stor14[_4851] = 0
                        tokenOfOwnerByIndex[address(_4843)][stor10[address(_4843)] - 1] = 0
                        if address(_4847):
                            if address(_4847) == address(_4843):
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4851] = 0
                                if not ownerOf[_4851]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4851], 0, _4851);
                                if balanceOf[address(_4843)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4843)]--
                                if balanceOf[address(_4847)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4847)]++
                                mem[0] = _4851
                                mem[32] = 9
                                ownerOf[_4851] = address(_4847)
                                emit Transfer(address(_4843), address(_4847), _4851);
                                if ext_code.size(address(_4847)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4843)
                                    mem[mem[64] + 68] = _4851
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4847))
                                    call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4843), _4851, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6111 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6111] == Mask(32, 224, mem[_6111])
                                    if Mask(32, 224, mem[_6111]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not address(_4847):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(_4847)][stor10[address(_4847)]] = _4851
                                stor14[_4851] = balanceOf[address(_4847)]
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4851] = 0
                                if not ownerOf[_4851]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4851], 0, _4851);
                                if balanceOf[address(_4843)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4843)]--
                                if balanceOf[address(_4847)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4847)]++
                                mem[0] = _4851
                                mem[32] = 9
                                ownerOf[_4851] = address(_4847)
                                emit Transfer(address(_4843), address(_4847), _4851);
                                if ext_code.size(address(_4847)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4843)
                                    mem[mem[64] + 68] = _4851
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4847))
                                    call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4843), _4851, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6113 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6113] == Mask(32, 224, mem[_6113])
                                    if Mask(32, 224, mem[_6113]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor16[_4851] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor16[_4851]] = tokenByIndex[tokenByIndex.length]
                            stor16[stor15[stor15.length]] = stor16[_4851]
                            stor16[_4851] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4851] = 0
                            if not ownerOf[_4851]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4851], 0, _4851);
                            if balanceOf[address(_4843)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4843)]--
                            if balanceOf[address(_4847)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4847)]++
                            mem[0] = _4851
                            mem[32] = 9
                            ownerOf[_4851] = address(_4847)
                            emit Transfer(address(_4843), address(_4847), _4851);
                            if ext_code.size(address(_4847)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4843)
                                mem[mem[64] + 68] = _4851
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4852 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4847))
                                call address(_4847).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4843), _4851, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6115 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6115] == Mask(32, 224, mem[_6115])
                                if Mask(32, 224, mem[_6115]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        if isMigrated:
            revert with 0, 'Invalid migration status.'
        if ('cd', 4).length != ('cd', 36).length:
            revert with 0, 'Mismatched array lengths.'
        if ('cd', 4).length != ('cd', 68).length:
            revert with 0, 'Mismatched array lengths.'
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _4845 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                revert with 0, 50
            _4849 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
            if idx >= mem[96]:
                revert with 0, 50
            _4853 = mem[(32 * idx) + 128]
            _4854 = mem[64]
            mem[64] = mem[64] + 32
            mem[_4854] = 0
            if not ownerOf[_4853]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[_4853] != address(_4845):
                revert with 0, 'ERC721: transfer of token that is not own'
            if not address(_4849):
                revert with 0, 'ERC721: transfer to the zero address'
            if not address(_4845):
                stor16[_4853] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = _4853
                if address(_4849):
                    if address(_4849) == address(_4845):
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[_4853] = 0
                        if not ownerOf[_4853]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[_4853], 0, _4853);
                        if balanceOf[address(_4845)] < 1:
                            revert with 0, 17
                        balanceOf[address(_4845)]--
                        if balanceOf[address(_4849)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4849)]++
                        mem[0] = _4853
                        mem[32] = 9
                        ownerOf[_4853] = address(_4849)
                        emit Transfer(address(_4845), address(_4849), _4853);
                        if ext_code.size(address(_4849)):
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = address(_4845)
                            mem[mem[64] + 68] = _4853
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4849))
                            call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(_4845), _4853, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _6141 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_6141] == Mask(32, 224, mem[_6141])
                            if Mask(32, 224, mem[_6141]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if not address(_4849):
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(_4849)][stor10[address(_4849)]] = _4853
                        stor14[_4853] = balanceOf[address(_4849)]
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[_4853] = 0
                        if not ownerOf[_4853]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[_4853], 0, _4853);
                        if balanceOf[address(_4845)] < 1:
                            revert with 0, 17
                        balanceOf[address(_4845)]--
                        if balanceOf[address(_4849)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4849)]++
                        mem[0] = _4853
                        mem[32] = 9
                        ownerOf[_4853] = address(_4849)
                        emit Transfer(address(_4845), address(_4849), _4853);
                        if ext_code.size(address(_4849)):
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = address(_4845)
                            mem[mem[64] + 68] = _4853
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4849))
                            call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(_4845), _4853, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _6143 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_6143] == Mask(32, 224, mem[_6143])
                            if Mask(32, 224, mem[_6143]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor16[_4853] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor16[_4853]] = tokenByIndex[tokenByIndex.length]
                    stor16[stor15[stor15.length]] = stor16[_4853]
                    stor16[_4853] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                    if stor17:
                        revert with 0, 'ERC721Pausable: token transfer while paused'
                    approved[_4853] = 0
                    if not ownerOf[_4853]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    emit Approval(ownerOf[_4853], 0, _4853);
                    if balanceOf[address(_4845)] < 1:
                        revert with 0, 17
                    balanceOf[address(_4845)]--
                    if balanceOf[address(_4849)] > -2:
                        revert with 0, 17
                    balanceOf[address(_4849)]++
                    mem[0] = _4853
                    mem[32] = 9
                    ownerOf[_4853] = address(_4849)
                    emit Transfer(address(_4845), address(_4849), _4853);
                    if ext_code.size(address(_4849)):
                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = address(_4845)
                        mem[mem[64] + 68] = _4853
                        mem[mem[64] + 100] = 128
                        mem[mem[64] + 132] = 0
                        s = 0
                        while s < 0:
                            mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                            s = s + 32
                            continue 
                        require ext_code.size(address(_4849))
                        call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args msg.sender, address(_4845), _4853, 128, 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            if not return_data.size:
                                if not mem[96]:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with memory
                                  from 128
                                   len mem[96]
                            if not return_data.size:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with ext_call.return_data[0 len return_data.size]
                        _6145 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_6145] == Mask(32, 224, mem[_6145])
                        if Mask(32, 224, mem[_6145]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                if address(_4845) == address(_4849):
                    if address(_4849):
                        if address(_4849) == address(_4845):
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4853] = 0
                            if not ownerOf[_4853]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4853], 0, _4853);
                            if balanceOf[address(_4845)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4845)]--
                            if balanceOf[address(_4849)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4849)]++
                            mem[0] = _4853
                            mem[32] = 9
                            ownerOf[_4853] = address(_4849)
                            emit Transfer(address(_4845), address(_4849), _4853);
                            if ext_code.size(address(_4849)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4845)
                                mem[mem[64] + 68] = _4853
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4849))
                                call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4845), _4853, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6123 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6123] == Mask(32, 224, mem[_6123])
                                if Mask(32, 224, mem[_6123]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not address(_4849):
                                revert with 0, 'ERC721: balance query for the zero address'
                            tokenOfOwnerByIndex[address(_4849)][stor10[address(_4849)]] = _4853
                            stor14[_4853] = balanceOf[address(_4849)]
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4853] = 0
                            if not ownerOf[_4853]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4853], 0, _4853);
                            if balanceOf[address(_4845)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4845)]--
                            if balanceOf[address(_4849)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4849)]++
                            mem[0] = _4853
                            mem[32] = 9
                            ownerOf[_4853] = address(_4849)
                            emit Transfer(address(_4845), address(_4849), _4853);
                            if ext_code.size(address(_4849)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4845)
                                mem[mem[64] + 68] = _4853
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4849))
                                call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4845), _4853, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6125 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6125] == Mask(32, 224, mem[_6125])
                                if Mask(32, 224, mem[_6125]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if tokenByIndex.length < 1:
                            revert with 0, 17
                        if tokenByIndex.length - 1 >= tokenByIndex.length:
                            revert with 0, 50
                        if stor16[_4853] >= tokenByIndex.length:
                            revert with 0, 50
                        tokenByIndex[stor16[_4853]] = tokenByIndex[tokenByIndex.length]
                        stor16[stor15[stor15.length]] = stor16[_4853]
                        stor16[_4853] = 0
                        if not tokenByIndex.length:
                            revert with 0, 49
                        tokenByIndex[tokenByIndex.length] = 0
                        tokenByIndex.length--
                        if stor17:
                            revert with 0, 'ERC721Pausable: token transfer while paused'
                        approved[_4853] = 0
                        if not ownerOf[_4853]:
                            revert with 0, 'ERC721: owner query for nonexistent token'
                        emit Approval(ownerOf[_4853], 0, _4853);
                        if balanceOf[address(_4845)] < 1:
                            revert with 0, 17
                        balanceOf[address(_4845)]--
                        if balanceOf[address(_4849)] > -2:
                            revert with 0, 17
                        balanceOf[address(_4849)]++
                        mem[0] = _4853
                        mem[32] = 9
                        ownerOf[_4853] = address(_4849)
                        emit Transfer(address(_4845), address(_4849), _4853);
                        if ext_code.size(address(_4849)):
                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = address(_4845)
                            mem[mem[64] + 68] = _4853
                            mem[mem[64] + 100] = 128
                            mem[mem[64] + 132] = 0
                            s = 0
                            while s < 0:
                                mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(_4849))
                            call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args msg.sender, address(_4845), _4853, 128, 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                if not return_data.size:
                                    if not mem[96]:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with memory
                                      from 128
                                       len mem[96]
                                if not return_data.size:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                revert with ext_call.return_data[0 len return_data.size]
                            _6127 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_6127] == Mask(32, 224, mem[_6127])
                            if Mask(32, 224, mem[_6127]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    if not address(_4845):
                        revert with 0, 'ERC721: balance query for the zero address'
                    if balanceOf[address(_4845)] < 1:
                        revert with 0, 17
                    if balanceOf[address(_4845)] - 1 == stor14[_4853]:
                        stor14[_4853] = 0
                        tokenOfOwnerByIndex[address(_4845)][stor10[address(_4845)] - 1] = 0
                        if address(_4849):
                            if address(_4849) == address(_4845):
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4853] = 0
                                if not ownerOf[_4853]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4853], 0, _4853);
                                if balanceOf[address(_4845)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4845)]--
                                if balanceOf[address(_4849)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4849)]++
                                mem[0] = _4853
                                mem[32] = 9
                                ownerOf[_4853] = address(_4849)
                                emit Transfer(address(_4845), address(_4849), _4853);
                                if ext_code.size(address(_4849)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4845)
                                    mem[mem[64] + 68] = _4853
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4849))
                                    call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4845), _4853, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6129 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6129] == Mask(32, 224, mem[_6129])
                                    if Mask(32, 224, mem[_6129]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not address(_4849):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(_4849)][stor10[address(_4849)]] = _4853
                                stor14[_4853] = balanceOf[address(_4849)]
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4853] = 0
                                if not ownerOf[_4853]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4853], 0, _4853);
                                if balanceOf[address(_4845)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4845)]--
                                if balanceOf[address(_4849)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4849)]++
                                mem[0] = _4853
                                mem[32] = 9
                                ownerOf[_4853] = address(_4849)
                                emit Transfer(address(_4845), address(_4849), _4853);
                                if ext_code.size(address(_4849)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4845)
                                    mem[mem[64] + 68] = _4853
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4849))
                                    call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4845), _4853, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6131 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6131] == Mask(32, 224, mem[_6131])
                                    if Mask(32, 224, mem[_6131]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor16[_4853] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor16[_4853]] = tokenByIndex[tokenByIndex.length]
                            stor16[stor15[stor15.length]] = stor16[_4853]
                            stor16[_4853] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4853] = 0
                            if not ownerOf[_4853]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4853], 0, _4853);
                            if balanceOf[address(_4845)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4845)]--
                            if balanceOf[address(_4849)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4849)]++
                            mem[0] = _4853
                            mem[32] = 9
                            ownerOf[_4853] = address(_4849)
                            emit Transfer(address(_4845), address(_4849), _4853);
                            if ext_code.size(address(_4849)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4845)
                                mem[mem[64] + 68] = _4853
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4849))
                                call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4845), _4853, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6133 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6133] == Mask(32, 224, mem[_6133])
                                if Mask(32, 224, mem[_6133]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        tokenOfOwnerByIndex[address(_4845)][stor14[_4853]] = tokenOfOwnerByIndex[address(_4845)][stor10[address(_4845)] - 1]
                        stor14[stor13[address(_4845)][stor10[address(_4845)] - 1]] = stor14[_4853]
                        stor14[_4853] = 0
                        tokenOfOwnerByIndex[address(_4845)][stor10[address(_4845)] - 1] = 0
                        if address(_4849):
                            if address(_4849) == address(_4845):
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4853] = 0
                                if not ownerOf[_4853]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4853], 0, _4853);
                                if balanceOf[address(_4845)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4845)]--
                                if balanceOf[address(_4849)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4849)]++
                                mem[0] = _4853
                                mem[32] = 9
                                ownerOf[_4853] = address(_4849)
                                emit Transfer(address(_4845), address(_4849), _4853);
                                if ext_code.size(address(_4849)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4845)
                                    mem[mem[64] + 68] = _4853
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4849))
                                    call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4845), _4853, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6135 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6135] == Mask(32, 224, mem[_6135])
                                    if Mask(32, 224, mem[_6135]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not address(_4849):
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(_4849)][stor10[address(_4849)]] = _4853
                                stor14[_4853] = balanceOf[address(_4849)]
                                if stor17:
                                    revert with 0, 'ERC721Pausable: token transfer while paused'
                                approved[_4853] = 0
                                if not ownerOf[_4853]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[_4853], 0, _4853);
                                if balanceOf[address(_4845)] < 1:
                                    revert with 0, 17
                                balanceOf[address(_4845)]--
                                if balanceOf[address(_4849)] > -2:
                                    revert with 0, 17
                                balanceOf[address(_4849)]++
                                mem[0] = _4853
                                mem[32] = 9
                                ownerOf[_4853] = address(_4849)
                                emit Transfer(address(_4845), address(_4849), _4853);
                                if ext_code.size(address(_4849)):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = address(_4845)
                                    mem[mem[64] + 68] = _4853
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(_4849))
                                    call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(_4845), _4853, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6137 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6137] == Mask(32, 224, mem[_6137])
                                    if Mask(32, 224, mem[_6137]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor16[_4853] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor16[_4853]] = tokenByIndex[tokenByIndex.length]
                            stor16[stor15[stor15.length]] = stor16[_4853]
                            stor16[_4853] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            if stor17:
                                revert with 0, 'ERC721Pausable: token transfer while paused'
                            approved[_4853] = 0
                            if not ownerOf[_4853]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[_4853], 0, _4853);
                            if balanceOf[address(_4845)] < 1:
                                revert with 0, 17
                            balanceOf[address(_4845)]--
                            if balanceOf[address(_4849)] > -2:
                                revert with 0, 17
                            balanceOf[address(_4849)]++
                            mem[0] = _4853
                            mem[32] = 9
                            ownerOf[_4853] = address(_4849)
                            emit Transfer(address(_4845), address(_4849), _4853);
                            if ext_code.size(address(_4849)):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = address(_4845)
                                mem[mem[64] + 68] = _4853
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = 0
                                s = 0
                                while s < 0:
                                    mem[s + mem[64] + 164] = mem[s + _4854 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(address(_4849))
                                call address(_4849).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(_4845), _4853, 128, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    if not return_data.size:
                                        if not mem[96]:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    if not return_data.size:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6139 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_6139] == Mask(32, 224, mem[_6139])
                                if Mask(32, 224, mem[_6139]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
}

function tokenURI(uint256 arg1) {
    require calldata.size - 4 >= 32
    mem[0] = arg1
    mem[32] = 9
    if not ownerOf[arg1]:
        revert with 0, 'This token id does not exist.'
    if bool(stor30.length):
        if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
            revert with 0, 34
        if uint255(stor30.length) * 0.5 <= 0:
            return ''
        if bool(stor30.length):
            if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                revert with 0, 34
            mem[96] = uint255(stor30.length) * 0.5
            if bool(stor30.length):
                if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor30.length):
                    if not stor31:
                        if not arg1:
                            mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                                return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                            mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                        s = 0
                        idx = arg1
                        while idx:
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            idx = idx / 10
                            continue 
                        if s > test266151307():
                            revert with 0, 65
                        mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                        if not s:
                            t = s
                            idx = arg1
                            while idx:
                                if t < 1:
                                    revert with 0, 17
                                if 48 > !(idx % 10):
                                    revert with 0, 17
                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                    revert with 0, 50
                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                t = t - 1
                                idx = idx / 10
                                continue 
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                    _13578 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13578)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13578)]
                                    if ceil32(_13578) > _13578:
                                        mem[_13578 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13578) + 32], 
                                _13579 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13579)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13579)]
                                if ceil32(_13579) > _13579:
                                    mem[_13579 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13579) + 32], 
                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13580 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13580)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13580)]
                                if ceil32(_13580) > _13580:
                                    mem[_13580 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13580) + 32], 
                            _13581 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13581)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13581)]
                            if ceil32(_13581) > _13581:
                                mem[_13581 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13581) + 32], 
                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13582 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13582)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13582)]
                                if ceil32(_13582) > _13582:
                                    mem[_13582 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13582) + 32], 
                            _13583 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13583)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13583)]
                            if ceil32(_13583) > _13583:
                                mem[_13583 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13583) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13584 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13584)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13584)]
                            if ceil32(_13584) > _13584:
                                mem[_13584 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13584) + 32], 
                        _13585 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13585)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13585)]
                        if ceil32(_13585) > _13585:
                            mem[_13585 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13585) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                    require ext_code.size(stor31)
                    staticcall stor31.0xff74ef30 with:
                            gas gas_remaining wei
                           args arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    _60 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                    require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                    require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                    _101 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                    if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _101
                    require _60 + _101 + 32 <= return_data.size
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_101)] = mem[ceil32(uint255(stor30.length) * 0.5) + _60 + 160 len ceil32(_101)]
                    if ceil32(_101) <= _101:
                        _2534 = mem[64]
                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_101)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_101)]
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            if ceil32(_101) <= _101:
                                _9706 = mem[64]
                                mem[64] = _2534 + (uint255(stor30.length) * 0.5) + _101 + 37
                                mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                                _10282 = mem[_9706]
                                mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9706]
                                mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10282)] = mem[_9706 + 32 len ceil32(_10282)]
                                if ceil32(_10282) > _10282:
                                    mem[_10282 + _2534 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                                return 32, mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10282) + 32]
                            _9707 = mem[64]
                            mem[64] = _2534 + (uint255(stor30.length) * 0.5) + _101 + 37
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                            _10283 = mem[_9707]
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9707]
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10283)] = mem[_9707 + 32 len ceil32(_10283)]
                            if ceil32(_10283) > _10283:
                                mem[_10283 + _2534 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                            return 32, mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10283) + 32]
                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                        mem[_2534 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_101)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_101)]
                        mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_101) <= _101:
                            _9708 = mem[64]
                            mem[64] = _2534 + (uint255(stor30.length) * 0.5) + _101 + 37
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                            _10284 = mem[_9708]
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9708]
                            mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10284)] = mem[_9708 + 32 len ceil32(_10284)]
                            if ceil32(_10284) > _10284:
                                mem[_10284 + _2534 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                            return 32, mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10284) + 32]
                        _9709 = mem[64]
                        mem[64] = _2534 + (uint255(stor30.length) * 0.5) + _101 + 37
                        mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                        _10285 = mem[_9709]
                        mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9709]
                        mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10285)] = mem[_9709 + 32 len ceil32(_10285)]
                        if ceil32(_10285) > _10285:
                            mem[_10285 + _2534 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                        return 32, mem[_2534 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10285) + 32]
                    mem[_101 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                    _2535 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_101)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_101)]
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_101) <= _101:
                            _9710 = mem[64]
                            mem[64] = _2535 + (uint255(stor30.length) * 0.5) + _101 + 37
                            mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                            _10286 = mem[_9710]
                            mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9710]
                            mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10286)] = mem[_9710 + 32 len ceil32(_10286)]
                            if ceil32(_10286) > _10286:
                                mem[_10286 + _2535 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                            return 32, mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10286) + 32]
                        _9711 = mem[64]
                        mem[64] = _2535 + (uint255(stor30.length) * 0.5) + _101 + 37
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                        _10287 = mem[_9711]
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9711]
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10287)] = mem[_9711 + 32 len ceil32(_10287)]
                        if ceil32(_10287) > _10287:
                            mem[_10287 + _2535 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                        return 32, mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10287) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_2535 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_101)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_101)]
                    mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_101) <= _101:
                        _9712 = mem[64]
                        mem[64] = _2535 + (uint255(stor30.length) * 0.5) + _101 + 37
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                        _10288 = mem[_9712]
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9712]
                        mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10288)] = mem[_9712 + 32 len ceil32(_10288)]
                        if ceil32(_10288) > _10288:
                            mem[_10288 + _2535 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                        return 32, mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10288) + 32]
                    _9713 = mem[64]
                    mem[64] = _2535 + (uint255(stor30.length) * 0.5) + _101 + 37
                    mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 37] = 32
                    _10289 = mem[_9713]
                    mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69] = mem[_9713]
                    mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 101 len ceil32(_10289)] = mem[_9713 + 32 len ceil32(_10289)]
                    if ceil32(_10289) > _10289:
                        mem[_10289 + _2535 + (uint255(stor30.length) * 0.5) + _101 + 101] = 0
                    return 32, mem[_2535 + (uint255(stor30.length) * 0.5) + _101 + 69 len ceil32(_10289) + 32]
                if 31 >= uint255(stor30.length) * 0.5:
                    mem[128] = 256 * stor30.length.field_8
                    if not stor31:
                        if not arg1:
                            mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                            mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                                return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                            mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                        s = 0
                        idx = arg1
                        while idx:
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            idx = idx / 10
                            continue 
                        if s > test266151307():
                            revert with 0, 65
                        mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                        if not s:
                            t = s
                            idx = arg1
                            while idx:
                                if t < 1:
                                    revert with 0, 17
                                if 48 > !(idx % 10):
                                    revert with 0, 17
                                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                    revert with 0, 50
                                mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                                t = t - 1
                                idx = idx / 10
                                continue 
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                    _13602 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13602)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13602)]
                                    if ceil32(_13602) > _13602:
                                        mem[_13602 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13602) + 32], 
                                _13603 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13603)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13603)]
                                if ceil32(_13603) > _13603:
                                    mem[_13603 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13603) + 32], 
                            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13604 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13604)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13604)]
                                if ceil32(_13604) > _13604:
                                    mem[_13604 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13604) + 32], 
                            _13605 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13605)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13605)]
                            if ceil32(_13605) > _13605:
                                mem[_13605 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13605) + 32], 
                        mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13606 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13606)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13606)]
                                if ceil32(_13606) > _13606:
                                    mem[_13606 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13606) + 32], 
                            _13607 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13607)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13607)]
                            if ceil32(_13607) > _13607:
                                mem[_13607 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13607) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13608 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13608)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13608)]
                            if ceil32(_13608) > _13608:
                                mem[_13608 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13608) + 32], 
                        _13609 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13609)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13609)]
                        if ceil32(_13609) > _13609:
                            mem[_13609 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13609) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                    require ext_code.size(stor31)
                    staticcall stor31.0xff74ef30 with:
                            gas gas_remaining wei
                           args arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    _104 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                    require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                    require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                    _155 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                    if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _155
                    require _104 + _155 + 32 <= return_data.size
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_155)] = mem[ceil32(uint255(stor30.length) * 0.5) + _104 + 160 len ceil32(_155)]
                    if ceil32(_155) <= _155:
                        _2538 = mem[64]
                        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_155)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_155)]
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            if ceil32(_155) <= _155:
                                _9720 = mem[64]
                                mem[64] = _2538 + (uint255(stor30.length) * 0.5) + _155 + 37
                                mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                                _10314 = mem[_9720]
                                mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9720]
                                mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10314)] = mem[_9720 + 32 len ceil32(_10314)]
                                if ceil32(_10314) > _10314:
                                    mem[_10314 + _2538 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                                return 32, mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10314) + 32]
                            _9721 = mem[64]
                            mem[64] = _2538 + (uint255(stor30.length) * 0.5) + _155 + 37
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                            _10315 = mem[_9721]
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9721]
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10315)] = mem[_9721 + 32 len ceil32(_10315)]
                            if ceil32(_10315) > _10315:
                                mem[_10315 + _2538 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                            return 32, mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10315) + 32]
                        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                        mem[_2538 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_155)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_155)]
                        mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_155) <= _155:
                            _9722 = mem[64]
                            mem[64] = _2538 + (uint255(stor30.length) * 0.5) + _155 + 37
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                            _10316 = mem[_9722]
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9722]
                            mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10316)] = mem[_9722 + 32 len ceil32(_10316)]
                            if ceil32(_10316) > _10316:
                                mem[_10316 + _2538 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                            return 32, mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10316) + 32]
                        _9723 = mem[64]
                        mem[64] = _2538 + (uint255(stor30.length) * 0.5) + _155 + 37
                        mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                        _10317 = mem[_9723]
                        mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9723]
                        mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10317)] = mem[_9723 + 32 len ceil32(_10317)]
                        if ceil32(_10317) > _10317:
                            mem[_10317 + _2538 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                        return 32, mem[_2538 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10317) + 32]
                    mem[_155 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                    _2539 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_155)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_155)]
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_155) <= _155:
                            _9724 = mem[64]
                            mem[64] = _2539 + (uint255(stor30.length) * 0.5) + _155 + 37
                            mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                            _10318 = mem[_9724]
                            mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9724]
                            mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10318)] = mem[_9724 + 32 len ceil32(_10318)]
                            if ceil32(_10318) > _10318:
                                mem[_10318 + _2539 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                            return 32, mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10318) + 32]
                        _9725 = mem[64]
                        mem[64] = _2539 + (uint255(stor30.length) * 0.5) + _155 + 37
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                        _10319 = mem[_9725]
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9725]
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10319)] = mem[_9725 + 32 len ceil32(_10319)]
                        if ceil32(_10319) > _10319:
                            mem[_10319 + _2539 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                        return 32, mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10319) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_2539 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_155)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_155)]
                    mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_155) <= _155:
                        _9726 = mem[64]
                        mem[64] = _2539 + (uint255(stor30.length) * 0.5) + _155 + 37
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                        _10320 = mem[_9726]
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9726]
                        mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10320)] = mem[_9726 + 32 len ceil32(_10320)]
                        if ceil32(_10320) > _10320:
                            mem[_10320 + _2539 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                        return 32, mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10320) + 32]
                    _9727 = mem[64]
                    mem[64] = _2539 + (uint255(stor30.length) * 0.5) + _155 + 37
                    mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 37] = 32
                    _10321 = mem[_9727]
                    mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69] = mem[_9727]
                    mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 101 len ceil32(_10321)] = mem[_9727 + 32 len ceil32(_10321)]
                    if ceil32(_10321) > _10321:
                        mem[_10321 + _2539 + (uint255(stor30.length) * 0.5) + _155 + 101] = 0
                    return 32, mem[_2539 + (uint255(stor30.length) * 0.5) + _155 + 69 len ceil32(_10321) + 32]
                mem[0] = 30
                mem[128] = uint256(stor30.field_0)
                idx = 128
                s = 0
                while (uint255(stor30.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor30[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if not stor31:
                    if not arg1:
                        mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                            return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                        mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _15466 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15466)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15466)]
                                if ceil32(_15466) > _15466:
                                    mem[_15466 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15466) + 32], 
                            _15467 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15467)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15467)]
                            if ceil32(_15467) > _15467:
                                mem[_15467 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15467) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _15468 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15468)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15468)]
                            if ceil32(_15468) > _15468:
                                mem[_15468 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15468) + 32], 
                        _15469 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15469)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15469)]
                        if ceil32(_15469) > _15469:
                            mem[_15469 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15469) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _15470 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15470)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15470)]
                            if ceil32(_15470) > _15470:
                                mem[_15470 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15470) + 32], 
                        _15471 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15471)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15471)]
                        if ceil32(_15471) > _15471:
                            mem[_15471 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15471) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _15472 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15472)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15472)]
                        if ceil32(_15472) > _15472:
                            mem[_15472 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15472) + 32], 
                    _15473 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15473)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15473)]
                    if ceil32(_15473) > _15473:
                        mem[_15473 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15473) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _2686 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _2854 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _2854
                require _2686 + _2854 + 32 <= return_data.size
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2854)] = mem[ceil32(uint255(stor30.length) * 0.5) + _2686 + 160 len ceil32(_2854)]
                if ceil32(_2854) <= _2854:
                    _5984 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2854)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2854)]
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_2854) <= _2854:
                            _12850 = mem[64]
                            mem[64] = _5984 + (uint255(stor30.length) * 0.5) + _2854 + 37
                            mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                            _13586 = mem[_12850]
                            mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12850]
                            mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13586)] = mem[_12850 + 32 len ceil32(_13586)]
                            if ceil32(_13586) > _13586:
                                mem[_13586 + _5984 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                            return 32, mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13586) + 32]
                        _12851 = mem[64]
                        mem[64] = _5984 + (uint255(stor30.length) * 0.5) + _2854 + 37
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                        _13587 = mem[_12851]
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12851]
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13587)] = mem[_12851 + 32 len ceil32(_13587)]
                        if ceil32(_13587) > _13587:
                            mem[_13587 + _5984 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                        return 32, mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13587) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_5984 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2854)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2854)]
                    mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_2854) <= _2854:
                        _12852 = mem[64]
                        mem[64] = _5984 + (uint255(stor30.length) * 0.5) + _2854 + 37
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                        _13588 = mem[_12852]
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12852]
                        mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13588)] = mem[_12852 + 32 len ceil32(_13588)]
                        if ceil32(_13588) > _13588:
                            mem[_13588 + _5984 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                        return 32, mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13588) + 32]
                    _12853 = mem[64]
                    mem[64] = _5984 + (uint255(stor30.length) * 0.5) + _2854 + 37
                    mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                    _13589 = mem[_12853]
                    mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12853]
                    mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13589)] = mem[_12853 + 32 len ceil32(_13589)]
                    if ceil32(_13589) > _13589:
                        mem[_13589 + _5984 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                    return 32, mem[_5984 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13589) + 32]
                mem[_2854 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                _5985 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2854)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2854)]
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_2854) <= _2854:
                        _12854 = mem[64]
                        mem[64] = _5985 + (uint255(stor30.length) * 0.5) + _2854 + 37
                        mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                        _13590 = mem[_12854]
                        mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12854]
                        mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13590)] = mem[_12854 + 32 len ceil32(_13590)]
                        if ceil32(_13590) > _13590:
                            mem[_13590 + _5985 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                        return 32, mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13590) + 32]
                    _12855 = mem[64]
                    mem[64] = _5985 + (uint255(stor30.length) * 0.5) + _2854 + 37
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                    _13591 = mem[_12855]
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12855]
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13591)] = mem[_12855 + 32 len ceil32(_13591)]
                    if ceil32(_13591) > _13591:
                        mem[_13591 + _5985 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                    return 32, mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13591) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_5985 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2854)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2854)]
                mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2854) <= _2854:
                    _12856 = mem[64]
                    mem[64] = _5985 + (uint255(stor30.length) * 0.5) + _2854 + 37
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                    _13592 = mem[_12856]
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12856]
                    mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13592)] = mem[_12856 + 32 len ceil32(_13592)]
                    if ceil32(_13592) > _13592:
                        mem[_13592 + _5985 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                    return 32, mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13592) + 32]
                _12857 = mem[64]
                mem[64] = _5985 + (uint255(stor30.length) * 0.5) + _2854 + 37
                mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 37] = 32
                _13593 = mem[_12857]
                mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69] = mem[_12857]
                mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 101 len ceil32(_13593)] = mem[_12857 + 32 len ceil32(_13593)]
                if ceil32(_13593) > _13593:
                    mem[_13593 + _5985 + (uint255(stor30.length) * 0.5) + _2854 + 101] = 0
                return 32, mem[_5985 + (uint255(stor30.length) * 0.5) + _2854 + 69 len ceil32(_13593) + 32]
            if bool(stor30.length) == stor30.length.field_1 < 32:
                revert with 0, 34
            if not stor30.length.field_1:
                if not stor31:
                    if not arg1:
                        mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                            return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                        mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13610 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13610)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13610)]
                                if ceil32(_13610) > _13610:
                                    mem[_13610 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13610) + 32], 
                            _13611 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13611)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13611)]
                            if ceil32(_13611) > _13611:
                                mem[_13611 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13611) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13612 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13612)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13612)]
                            if ceil32(_13612) > _13612:
                                mem[_13612 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13612) + 32], 
                        _13613 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13613)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13613)]
                        if ceil32(_13613) > _13613:
                            mem[_13613 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13613) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13614 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13614)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13614)]
                            if ceil32(_13614) > _13614:
                                mem[_13614 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13614) + 32], 
                        _13615 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13615)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13615)]
                        if ceil32(_13615) > _13615:
                            mem[_13615 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13615) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13616 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13616)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13616)]
                        if ceil32(_13616) > _13616:
                            mem[_13616 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13616) + 32], 
                    _13617 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13617)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13617)]
                    if ceil32(_13617) > _13617:
                        mem[_13617 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13617) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _79 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _128 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _128
                require _79 + _128 + 32 <= return_data.size
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_128)] = mem[ceil32(uint255(stor30.length) * 0.5) + _79 + 160 len ceil32(_128)]
                if ceil32(_128) <= _128:
                    _2540 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_128)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_128)]
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_128) <= _128:
                            _9728 = mem[64]
                            mem[64] = _2540 + (uint255(stor30.length) * 0.5) + _128 + 37
                            mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                            _10330 = mem[_9728]
                            mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9728]
                            mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10330)] = mem[_9728 + 32 len ceil32(_10330)]
                            if ceil32(_10330) > _10330:
                                mem[_10330 + _2540 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                            return 32, mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10330) + 32]
                        _9729 = mem[64]
                        mem[64] = _2540 + (uint255(stor30.length) * 0.5) + _128 + 37
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                        _10331 = mem[_9729]
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9729]
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10331)] = mem[_9729 + 32 len ceil32(_10331)]
                        if ceil32(_10331) > _10331:
                            mem[_10331 + _2540 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                        return 32, mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10331) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_2540 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_128)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_128)]
                    mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_128) <= _128:
                        _9730 = mem[64]
                        mem[64] = _2540 + (uint255(stor30.length) * 0.5) + _128 + 37
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                        _10332 = mem[_9730]
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9730]
                        mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10332)] = mem[_9730 + 32 len ceil32(_10332)]
                        if ceil32(_10332) > _10332:
                            mem[_10332 + _2540 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                        return 32, mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10332) + 32]
                    _9731 = mem[64]
                    mem[64] = _2540 + (uint255(stor30.length) * 0.5) + _128 + 37
                    mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                    _10333 = mem[_9731]
                    mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9731]
                    mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10333)] = mem[_9731 + 32 len ceil32(_10333)]
                    if ceil32(_10333) > _10333:
                        mem[_10333 + _2540 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                    return 32, mem[_2540 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10333) + 32]
                mem[_128 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                _2541 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_128)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_128)]
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_128) <= _128:
                        _9732 = mem[64]
                        mem[64] = _2541 + (uint255(stor30.length) * 0.5) + _128 + 37
                        mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                        _10334 = mem[_9732]
                        mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9732]
                        mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10334)] = mem[_9732 + 32 len ceil32(_10334)]
                        if ceil32(_10334) > _10334:
                            mem[_10334 + _2541 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                        return 32, mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10334) + 32]
                    _9733 = mem[64]
                    mem[64] = _2541 + (uint255(stor30.length) * 0.5) + _128 + 37
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                    _10335 = mem[_9733]
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9733]
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10335)] = mem[_9733 + 32 len ceil32(_10335)]
                    if ceil32(_10335) > _10335:
                        mem[_10335 + _2541 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                    return 32, mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10335) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_2541 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_128)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_128)]
                mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_128) <= _128:
                    _9734 = mem[64]
                    mem[64] = _2541 + (uint255(stor30.length) * 0.5) + _128 + 37
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                    _10336 = mem[_9734]
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9734]
                    mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10336)] = mem[_9734 + 32 len ceil32(_10336)]
                    if ceil32(_10336) > _10336:
                        mem[_10336 + _2541 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                    return 32, mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10336) + 32]
                _9735 = mem[64]
                mem[64] = _2541 + (uint255(stor30.length) * 0.5) + _128 + 37
                mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 37] = 32
                _10337 = mem[_9735]
                mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69] = mem[_9735]
                mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 101 len ceil32(_10337)] = mem[_9735 + 32 len ceil32(_10337)]
                if ceil32(_10337) > _10337:
                    mem[_10337 + _2541 + (uint255(stor30.length) * 0.5) + _128 + 101] = 0
                return 32, mem[_2541 + (uint255(stor30.length) * 0.5) + _128 + 69 len ceil32(_10337) + 32]
            if 31 >= stor30.length.field_1:
                mem[128] = 256 * stor30.length.field_8
                if not stor31:
                    if not arg1:
                        mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                            return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                        mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13634 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13634)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13634)]
                                if ceil32(_13634) > _13634:
                                    mem[_13634 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13634) + 32], 
                            _13635 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13635)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13635)]
                            if ceil32(_13635) > _13635:
                                mem[_13635 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13635) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13636 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13636)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13636)]
                            if ceil32(_13636) > _13636:
                                mem[_13636 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13636) + 32], 
                        _13637 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13637)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13637)]
                        if ceil32(_13637) > _13637:
                            mem[_13637 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13637) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13638 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13638)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13638)]
                            if ceil32(_13638) > _13638:
                                mem[_13638 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13638) + 32], 
                        _13639 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13639)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13639)]
                        if ceil32(_13639) > _13639:
                            mem[_13639 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13639) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13640 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13640)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13640)]
                        if ceil32(_13640) > _13640:
                            mem[_13640 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13640) + 32], 
                    _13641 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13641)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13641)]
                    if ceil32(_13641) > _13641:
                        mem[_13641 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13641) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _131 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _179 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _179
                require _131 + _179 + 32 <= return_data.size
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_179)] = mem[ceil32(uint255(stor30.length) * 0.5) + _131 + 160 len ceil32(_179)]
                if ceil32(_179) <= _179:
                    _2544 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_179)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_179)]
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_179) <= _179:
                            _9742 = mem[64]
                            mem[64] = _2544 + (uint255(stor30.length) * 0.5) + _179 + 37
                            mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                            _10362 = mem[_9742]
                            mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9742]
                            mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10362)] = mem[_9742 + 32 len ceil32(_10362)]
                            if ceil32(_10362) > _10362:
                                mem[_10362 + _2544 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                            return 32, mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10362) + 32]
                        _9743 = mem[64]
                        mem[64] = _2544 + (uint255(stor30.length) * 0.5) + _179 + 37
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                        _10363 = mem[_9743]
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9743]
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10363)] = mem[_9743 + 32 len ceil32(_10363)]
                        if ceil32(_10363) > _10363:
                            mem[_10363 + _2544 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                        return 32, mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10363) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_2544 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_179)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_179)]
                    mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_179) <= _179:
                        _9744 = mem[64]
                        mem[64] = _2544 + (uint255(stor30.length) * 0.5) + _179 + 37
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                        _10364 = mem[_9744]
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9744]
                        mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10364)] = mem[_9744 + 32 len ceil32(_10364)]
                        if ceil32(_10364) > _10364:
                            mem[_10364 + _2544 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                        return 32, mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10364) + 32]
                    _9745 = mem[64]
                    mem[64] = _2544 + (uint255(stor30.length) * 0.5) + _179 + 37
                    mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                    _10365 = mem[_9745]
                    mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9745]
                    mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10365)] = mem[_9745 + 32 len ceil32(_10365)]
                    if ceil32(_10365) > _10365:
                        mem[_10365 + _2544 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                    return 32, mem[_2544 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10365) + 32]
                mem[_179 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                _2545 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_179)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_179)]
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_179) <= _179:
                        _9746 = mem[64]
                        mem[64] = _2545 + (uint255(stor30.length) * 0.5) + _179 + 37
                        mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                        _10366 = mem[_9746]
                        mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9746]
                        mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10366)] = mem[_9746 + 32 len ceil32(_10366)]
                        if ceil32(_10366) > _10366:
                            mem[_10366 + _2545 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                        return 32, mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10366) + 32]
                    _9747 = mem[64]
                    mem[64] = _2545 + (uint255(stor30.length) * 0.5) + _179 + 37
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                    _10367 = mem[_9747]
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9747]
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10367)] = mem[_9747 + 32 len ceil32(_10367)]
                    if ceil32(_10367) > _10367:
                        mem[_10367 + _2545 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                    return 32, mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10367) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_2545 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_179)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_179)]
                mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_179) <= _179:
                    _9748 = mem[64]
                    mem[64] = _2545 + (uint255(stor30.length) * 0.5) + _179 + 37
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                    _10368 = mem[_9748]
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9748]
                    mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10368)] = mem[_9748 + 32 len ceil32(_10368)]
                    if ceil32(_10368) > _10368:
                        mem[_10368 + _2545 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                    return 32, mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10368) + 32]
                _9749 = mem[64]
                mem[64] = _2545 + (uint255(stor30.length) * 0.5) + _179 + 37
                mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 37] = 32
                _10369 = mem[_9749]
                mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69] = mem[_9749]
                mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 101 len ceil32(_10369)] = mem[_9749 + 32 len ceil32(_10369)]
                if ceil32(_10369) > _10369:
                    mem[_10369 + _2545 + (uint255(stor30.length) * 0.5) + _179 + 101] = 0
                return 32, mem[_2545 + (uint255(stor30.length) * 0.5) + _179 + 69 len ceil32(_10369) + 32]
            mem[0] = 30
            mem[128] = uint256(stor30.field_0)
            idx = 128
            s = 0
            while stor30.length.field_1 + 96 > idx:
                mem[idx + 32] = stor30[s].field_256
                idx = idx + 32
                s = s + 1
                continue 
            if not stor31:
                if not arg1:
                    mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                        return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                    mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _15474 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15474)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15474)]
                            if ceil32(_15474) > _15474:
                                mem[_15474 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15474) + 32], 
                        _15475 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15475)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15475)]
                        if ceil32(_15475) > _15475:
                            mem[_15475 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15475) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _15476 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15476)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15476)]
                        if ceil32(_15476) > _15476:
                            mem[_15476 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15476) + 32], 
                    _15477 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15477)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15477)]
                    if ceil32(_15477) > _15477:
                        mem[_15477 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15477) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _15478 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15478)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15478)]
                        if ceil32(_15478) > _15478:
                            mem[_15478 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15478) + 32], 
                    _15479 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15479)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15479)]
                    if ceil32(_15479) > _15479:
                        mem[_15479 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15479) + 32], 
                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    _15480 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15480)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15480)]
                    if ceil32(_15480) > _15480:
                        mem[_15480 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15480) + 32], 
                _15481 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15481)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15481)]
                if ceil32(_15481) > _15481:
                    mem[_15481 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15481) + 32], 
            mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _2696 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _2863 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _2863
            require _2696 + _2863 + 32 <= return_data.size
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2863)] = mem[ceil32(uint255(stor30.length) * 0.5) + _2696 + 160 len ceil32(_2863)]
            if ceil32(_2863) <= _2863:
                _5998 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2863)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2863)]
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_2863) <= _2863:
                        _12874 = mem[64]
                        mem[64] = _5998 + (uint255(stor30.length) * 0.5) + _2863 + 37
                        mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                        _13618 = mem[_12874]
                        mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12874]
                        mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13618)] = mem[_12874 + 32 len ceil32(_13618)]
                        if ceil32(_13618) > _13618:
                            mem[_13618 + _5998 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                        return 32, mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13618) + 32]
                    _12875 = mem[64]
                    mem[64] = _5998 + (uint255(stor30.length) * 0.5) + _2863 + 37
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                    _13619 = mem[_12875]
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12875]
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13619)] = mem[_12875 + 32 len ceil32(_13619)]
                    if ceil32(_13619) > _13619:
                        mem[_13619 + _5998 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                    return 32, mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13619) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_5998 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2863)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2863)]
                mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2863) <= _2863:
                    _12876 = mem[64]
                    mem[64] = _5998 + (uint255(stor30.length) * 0.5) + _2863 + 37
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                    _13620 = mem[_12876]
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12876]
                    mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13620)] = mem[_12876 + 32 len ceil32(_13620)]
                    if ceil32(_13620) > _13620:
                        mem[_13620 + _5998 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                    return 32, mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13620) + 32]
                _12877 = mem[64]
                mem[64] = _5998 + (uint255(stor30.length) * 0.5) + _2863 + 37
                mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                _13621 = mem[_12877]
                mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12877]
                mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13621)] = mem[_12877 + 32 len ceil32(_13621)]
                if ceil32(_13621) > _13621:
                    mem[_13621 + _5998 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                return 32, mem[_5998 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13621) + 32]
            mem[_2863 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
            _5999 = mem[64]
            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2863)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2863)]
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2863) <= _2863:
                    _12878 = mem[64]
                    mem[64] = _5999 + (uint255(stor30.length) * 0.5) + _2863 + 37
                    mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                    _13622 = mem[_12878]
                    mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12878]
                    mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13622)] = mem[_12878 + 32 len ceil32(_13622)]
                    if ceil32(_13622) > _13622:
                        mem[_13622 + _5999 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                    return 32, mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13622) + 32]
                _12879 = mem[64]
                mem[64] = _5999 + (uint255(stor30.length) * 0.5) + _2863 + 37
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                _13623 = mem[_12879]
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12879]
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13623)] = mem[_12879 + 32 len ceil32(_13623)]
                if ceil32(_13623) > _13623:
                    mem[_13623 + _5999 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                return 32, mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13623) + 32]
            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
            mem[_5999 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2863)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2863)]
            mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2863) <= _2863:
                _12880 = mem[64]
                mem[64] = _5999 + (uint255(stor30.length) * 0.5) + _2863 + 37
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
                _13624 = mem[_12880]
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12880]
                mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13624)] = mem[_12880 + 32 len ceil32(_13624)]
                if ceil32(_13624) > _13624:
                    mem[_13624 + _5999 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
                return 32, mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13624) + 32]
            _12881 = mem[64]
            mem[64] = _5999 + (uint255(stor30.length) * 0.5) + _2863 + 37
            mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 37] = 32
            _13625 = mem[_12881]
            mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69] = mem[_12881]
            mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 101 len ceil32(_13625)] = mem[_12881 + 32 len ceil32(_13625)]
            if ceil32(_13625) > _13625:
                mem[_13625 + _5999 + (uint255(stor30.length) * 0.5) + _2863 + 101] = 0
            return 32, mem[_5999 + (uint255(stor30.length) * 0.5) + _2863 + 69 len ceil32(_13625) + 32]
        if bool(stor30.length) == stor30.length.field_1 < 32:
            revert with 0, 34
        mem[96] = stor30.length.field_1
        if bool(stor30.length):
            if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor30.length):
                if not stor31:
                    if not arg1:
                        mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                        if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                            return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                        mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                        return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(stor30.length.field_1) + 128] = s
                    if s:
                        mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    if ceil32(stor30.length.field_1) > stor30.length.field_1:
                        mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) + 32], 
                mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _85 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _133 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                require _85 + _133 + 32 <= return_data.size
                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_133)] = mem[ceil32(stor30.length.field_1) + _85 + 160 len ceil32(_133)]
                if ceil32(_133) <= _133:
                    _2546 = mem[64]
                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                        _5894 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                        mem[mem[64] + stor30.length.field_1 + _5894 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_5894) <= _5894:
                            _9750 = mem[64]
                            mem[64] = mem[64] + stor30.length.field_1 + _5894 + 37
                            mem[_2546 + stor30.length.field_1 + _5894 + 37] = 32
                            _10378 = mem[_9750]
                            mem[_2546 + stor30.length.field_1 + _5894 + 69] = mem[_9750]
                            mem[_2546 + stor30.length.field_1 + _5894 + 101 len ceil32(_10378)] = mem[_9750 + 32 len ceil32(_10378)]
                            if ceil32(_10378) > _10378:
                                mem[_10378 + _2546 + stor30.length.field_1 + _5894 + 101] = 0
                            return 32, mem[_2546 + stor30.length.field_1 + _5894 + 69 len ceil32(_10378) + 32]
                        _9751 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5894 + 37
                        mem[_2546 + stor30.length.field_1 + _5894 + 37] = 32
                        _10379 = mem[_9751]
                        mem[_2546 + stor30.length.field_1 + _5894 + 69] = mem[_9751]
                        mem[_2546 + stor30.length.field_1 + _5894 + 101 len ceil32(_10379)] = mem[_9751 + 32 len ceil32(_10379)]
                        if ceil32(_10379) > _10379:
                            mem[_10379 + _2546 + stor30.length.field_1 + _5894 + 101] = 0
                        return 32, mem[_2546 + stor30.length.field_1 + _5894 + 69 len ceil32(_10379) + 32]
                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                    _5895 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5895 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5895) <= _5895:
                        _9752 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5895 + 37
                        mem[_2546 + stor30.length.field_1 + _5895 + 37] = 32
                        _10380 = mem[_9752]
                        mem[_2546 + stor30.length.field_1 + _5895 + 69] = mem[_9752]
                        mem[_2546 + stor30.length.field_1 + _5895 + 101 len ceil32(_10380)] = mem[_9752 + 32 len ceil32(_10380)]
                        if ceil32(_10380) > _10380:
                            mem[_10380 + _2546 + stor30.length.field_1 + _5895 + 101] = 0
                        return 32, mem[_2546 + stor30.length.field_1 + _5895 + 69 len ceil32(_10380) + 32]
                    _9753 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5895 + 37
                    mem[_2546 + stor30.length.field_1 + _5895 + 37] = 32
                    _10381 = mem[_9753]
                    mem[_2546 + stor30.length.field_1 + _5895 + 69] = mem[_9753]
                    mem[_2546 + stor30.length.field_1 + _5895 + 101 len ceil32(_10381)] = mem[_9753 + 32 len ceil32(_10381)]
                    if ceil32(_10381) > _10381:
                        mem[_10381 + _2546 + stor30.length.field_1 + _5895 + 101] = 0
                    return 32, mem[_2546 + stor30.length.field_1 + _5895 + 69 len ceil32(_10381) + 32]
                mem[_133 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
                _2547 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    _5896 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5896 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5896) <= _5896:
                        _9754 = mem[64]
                        mem[64] = _2547 + stor30.length.field_1 + _5896 + 37
                        mem[_2547 + stor30.length.field_1 + _5896 + 37] = 32
                        _10382 = mem[_9754]
                        mem[_2547 + stor30.length.field_1 + _5896 + 69] = mem[_9754]
                        mem[_2547 + stor30.length.field_1 + _5896 + 101 len ceil32(_10382)] = mem[_9754 + 32 len ceil32(_10382)]
                        if ceil32(_10382) > _10382:
                            mem[_10382 + _2547 + stor30.length.field_1 + _5896 + 101] = 0
                        return 32, mem[_2547 + stor30.length.field_1 + _5896 + 69 len ceil32(_10382) + 32]
                    _9755 = mem[64]
                    mem[64] = _2547 + stor30.length.field_1 + _5896 + 37
                    mem[_2547 + stor30.length.field_1 + _5896 + 37] = 32
                    _10383 = mem[_9755]
                    mem[_2547 + stor30.length.field_1 + _5896 + 69] = mem[_9755]
                    mem[_2547 + stor30.length.field_1 + _5896 + 101 len ceil32(_10383)] = mem[_9755 + 32 len ceil32(_10383)]
                    if ceil32(_10383) > _10383:
                        mem[_10383 + _2547 + stor30.length.field_1 + _5896 + 101] = 0
                    return 32, mem[_2547 + stor30.length.field_1 + _5896 + 69 len ceil32(_10383) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                _5897 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5897 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5897) <= _5897:
                    _9756 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5897 + 37
                    mem[_2547 + stor30.length.field_1 + _5897 + 37] = 32
                    _10384 = mem[_9756]
                    mem[_2547 + stor30.length.field_1 + _5897 + 69] = mem[_9756]
                    mem[_2547 + stor30.length.field_1 + _5897 + 101 len ceil32(_10384)] = mem[_9756 + 32 len ceil32(_10384)]
                    if ceil32(_10384) > _10384:
                        mem[_10384 + _2547 + stor30.length.field_1 + _5897 + 101] = 0
                    return 32, mem[_2547 + stor30.length.field_1 + _5897 + 69 len ceil32(_10384) + 32]
                _9757 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5897 + 37
                mem[_2547 + stor30.length.field_1 + _5897 + 37] = 32
                _10385 = mem[_9757]
                mem[_2547 + stor30.length.field_1 + _5897 + 69] = mem[_9757]
                mem[_2547 + stor30.length.field_1 + _5897 + 101 len ceil32(_10385)] = mem[_9757 + 32 len ceil32(_10385)]
                if ceil32(_10385) > _10385:
                    mem[_10385 + _2547 + stor30.length.field_1 + _5897 + 101] = 0
                return 32, mem[_2547 + stor30.length.field_1 + _5897 + 69 len ceil32(_10385) + 32]
            if 31 >= uint255(stor30.length) * 0.5:
                mem[128] = 256 * stor30.length.field_8
                if not stor31:
                    if not arg1:
                        mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                        mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                        if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                            return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                        mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                        return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(stor30.length.field_1) + 128] = s
                    if s:
                        mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    if ceil32(stor30.length.field_1) > stor30.length.field_1:
                        mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                    mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) + 32], 
                mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _136 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _183 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                require _136 + _183 + 32 <= return_data.size
                mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_183)] = mem[ceil32(stor30.length.field_1) + _136 + 160 len ceil32(_183)]
                if ceil32(_183) <= _183:
                    _2550 = mem[64]
                    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                        _5902 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                        mem[mem[64] + stor30.length.field_1 + _5902 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_5902) <= _5902:
                            _9764 = mem[64]
                            mem[64] = _2550 + stor30.length.field_1 + _5902 + 37
                            mem[_2550 + stor30.length.field_1 + _5902 + 37] = 32
                            _10410 = mem[_9764]
                            mem[_2550 + stor30.length.field_1 + _5902 + 69] = mem[_9764]
                            mem[_2550 + stor30.length.field_1 + _5902 + 101 len ceil32(_10410)] = mem[_9764 + 32 len ceil32(_10410)]
                            if ceil32(_10410) > _10410:
                                mem[_10410 + _2550 + stor30.length.field_1 + _5902 + 101] = 0
                            return 32, mem[_2550 + stor30.length.field_1 + _5902 + 69 len ceil32(_10410) + 32]
                        _9765 = mem[64]
                        mem[64] = _2550 + stor30.length.field_1 + _5902 + 37
                        mem[_2550 + stor30.length.field_1 + _5902 + 37] = 32
                        _10411 = mem[_9765]
                        mem[_2550 + stor30.length.field_1 + _5902 + 69] = mem[_9765]
                        mem[_2550 + stor30.length.field_1 + _5902 + 101 len ceil32(_10411)] = mem[_9765 + 32 len ceil32(_10411)]
                        if ceil32(_10411) > _10411:
                            mem[_10411 + _2550 + stor30.length.field_1 + _5902 + 101] = 0
                        return 32, mem[_2550 + stor30.length.field_1 + _5902 + 69 len ceil32(_10411) + 32]
                    mem[stor30.length.field_1 + mem[64] + 32] = 0
                    _5903 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5903 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5903) <= _5903:
                        _9766 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5903 + 37
                        mem[_2550 + stor30.length.field_1 + _5903 + 37] = 32
                        _10412 = mem[_9766]
                        mem[_2550 + stor30.length.field_1 + _5903 + 69] = mem[_9766]
                        mem[_2550 + stor30.length.field_1 + _5903 + 101 len ceil32(_10412)] = mem[_9766 + 32 len ceil32(_10412)]
                        if ceil32(_10412) > _10412:
                            mem[_10412 + _2550 + stor30.length.field_1 + _5903 + 101] = 0
                        return 32, mem[_2550 + stor30.length.field_1 + _5903 + 69 len ceil32(_10412) + 32]
                    _9767 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5903 + 37
                    mem[_2550 + stor30.length.field_1 + _5903 + 37] = 32
                    _10413 = mem[_9767]
                    mem[_2550 + stor30.length.field_1 + _5903 + 69] = mem[_9767]
                    mem[_2550 + stor30.length.field_1 + _5903 + 101 len ceil32(_10413)] = mem[_9767 + 32 len ceil32(_10413)]
                    if ceil32(_10413) > _10413:
                        mem[_10413 + _2550 + stor30.length.field_1 + _5903 + 101] = 0
                    return 32, mem[_2550 + stor30.length.field_1 + _5903 + 69 len ceil32(_10413) + 32]
                mem[_183 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
                _2551 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    _5904 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5904 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5904) <= _5904:
                        _9768 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5904 + 37
                        mem[_2551 + stor30.length.field_1 + _5904 + 37] = 32
                        _10414 = mem[_9768]
                        mem[_2551 + stor30.length.field_1 + _5904 + 69] = mem[_9768]
                        mem[_2551 + stor30.length.field_1 + _5904 + 101 len ceil32(_10414)] = mem[_9768 + 32 len ceil32(_10414)]
                        if ceil32(_10414) > _10414:
                            mem[_10414 + _2551 + stor30.length.field_1 + _5904 + 101] = 0
                        return 32, mem[_2551 + stor30.length.field_1 + _5904 + 69 len ceil32(_10414) + 32]
                    _9769 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5904 + 37
                    mem[_2551 + stor30.length.field_1 + _5904 + 37] = 32
                    _10415 = mem[_9769]
                    mem[_2551 + stor30.length.field_1 + _5904 + 69] = mem[_9769]
                    mem[_2551 + stor30.length.field_1 + _5904 + 101 len ceil32(_10415)] = mem[_9769 + 32 len ceil32(_10415)]
                    if ceil32(_10415) > _10415:
                        mem[_10415 + _2551 + stor30.length.field_1 + _5904 + 101] = 0
                    return 32, mem[_2551 + stor30.length.field_1 + _5904 + 69 len ceil32(_10415) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                _5905 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5905 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5905) <= _5905:
                    _9770 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5905 + 37
                    mem[_2551 + stor30.length.field_1 + _5905 + 37] = 32
                    _10416 = mem[_9770]
                    mem[_2551 + stor30.length.field_1 + _5905 + 69] = mem[_9770]
                    mem[_2551 + stor30.length.field_1 + _5905 + 101 len ceil32(_10416)] = mem[_9770 + 32 len ceil32(_10416)]
                    if ceil32(_10416) > _10416:
                        mem[_10416 + _2551 + stor30.length.field_1 + _5905 + 101] = 0
                    return 32, mem[_2551 + stor30.length.field_1 + _5905 + 69 len ceil32(_10416) + 32]
                _9771 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5905 + 37
                mem[_2551 + stor30.length.field_1 + _5905 + 37] = 32
                _10417 = mem[_9771]
                mem[_2551 + stor30.length.field_1 + _5905 + 69] = mem[_9771]
                mem[_2551 + stor30.length.field_1 + _5905 + 101 len ceil32(_10417)] = mem[_9771 + 32 len ceil32(_10417)]
                if ceil32(_10417) > _10417:
                    mem[_10417 + _2551 + stor30.length.field_1 + _5905 + 101] = 0
                return 32, mem[_2551 + stor30.length.field_1 + _5905 + 69 len ceil32(_10417) + 32]
            mem[0] = 30
            mem[128] = uint256(stor30.field_0)
            idx = 128
            s = 0
            while (uint255(stor30.length) * 0.5) + 96 > idx:
                mem[idx + 32] = stor30[s].field_256
                idx = idx + 32
                s = s + 1
                continue 
            if not stor31:
                if not arg1:
                    mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                    mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(stor30.length.field_1) + 128] = s
                if s:
                    mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) > stor30.length.field_1:
                    mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
            mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _2706 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _2872 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            require _2706 + _2872 + 32 <= return_data.size
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2872)] = mem[ceil32(stor30.length.field_1) + _2706 + 160 len ceil32(_2872)]
            if ceil32(_2872) <= _2872:
                _6012 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2872)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2872)]
                    mem[mem[64] + stor30.length.field_1 + _2872 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_2872) <= _2872:
                        _12898 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                        mem[_6012 + stor30.length.field_1 + _2872 + 37] = 32
                        _13650 = mem[_12898]
                        mem[_6012 + stor30.length.field_1 + _2872 + 69] = mem[_12898]
                        mem[_6012 + stor30.length.field_1 + _2872 + 101 len ceil32(_13650)] = mem[_12898 + 32 len ceil32(_13650)]
                        if ceil32(_13650) > _13650:
                            mem[_13650 + _6012 + stor30.length.field_1 + _2872 + 101] = 0
                        return 32, mem[_6012 + stor30.length.field_1 + _2872 + 69 len ceil32(_13650) + 32]
                    _12899 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                    mem[_6012 + stor30.length.field_1 + _2872 + 37] = 32
                    _13651 = mem[_12899]
                    mem[_6012 + stor30.length.field_1 + _2872 + 69] = mem[_12899]
                    mem[_6012 + stor30.length.field_1 + _2872 + 101 len ceil32(_13651)] = mem[_12899 + 32 len ceil32(_13651)]
                    if ceil32(_13651) > _13651:
                        mem[_13651 + _6012 + stor30.length.field_1 + _2872 + 101] = 0
                    return 32, mem[_6012 + stor30.length.field_1 + _2872 + 69 len ceil32(_13651) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2872)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2872)]
                mem[mem[64] + stor30.length.field_1 + _2872 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2872) <= _2872:
                    _12900 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                    mem[_6012 + stor30.length.field_1 + _2872 + 37] = 32
                    _13652 = mem[_12900]
                    mem[_6012 + stor30.length.field_1 + _2872 + 69] = mem[_12900]
                    mem[_6012 + stor30.length.field_1 + _2872 + 101 len ceil32(_13652)] = mem[_12900 + 32 len ceil32(_13652)]
                    if ceil32(_13652) > _13652:
                        mem[_13652 + _6012 + stor30.length.field_1 + _2872 + 101] = 0
                    return 32, mem[_6012 + stor30.length.field_1 + _2872 + 69 len ceil32(_13652) + 32]
                _12901 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                mem[_6012 + stor30.length.field_1 + _2872 + 37] = 32
                _13653 = mem[_12901]
                mem[_6012 + stor30.length.field_1 + _2872 + 69] = mem[_12901]
                mem[_6012 + stor30.length.field_1 + _2872 + 101 len ceil32(_13653)] = mem[_12901 + 32 len ceil32(_13653)]
                if ceil32(_13653) > _13653:
                    mem[_13653 + _6012 + stor30.length.field_1 + _2872 + 101] = 0
                return 32, mem[_6012 + stor30.length.field_1 + _2872 + 69 len ceil32(_13653) + 32]
            mem[_2872 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
            _6013 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2872)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2872)]
                mem[mem[64] + stor30.length.field_1 + _2872 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2872) <= _2872:
                    _12902 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                    mem[_6013 + stor30.length.field_1 + _2872 + 37] = 32
                    _13654 = mem[_12902]
                    mem[_6013 + stor30.length.field_1 + _2872 + 69] = mem[_12902]
                    mem[_6013 + stor30.length.field_1 + _2872 + 101 len ceil32(_13654)] = mem[_12902 + 32 len ceil32(_13654)]
                    if ceil32(_13654) > _13654:
                        mem[_13654 + _6013 + stor30.length.field_1 + _2872 + 101] = 0
                    return 32, mem[_6013 + stor30.length.field_1 + _2872 + 69 len ceil32(_13654) + 32]
                _12903 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                mem[_6013 + stor30.length.field_1 + _2872 + 37] = 32
                _13655 = mem[_12903]
                mem[_6013 + stor30.length.field_1 + _2872 + 69] = mem[_12903]
                mem[_6013 + stor30.length.field_1 + _2872 + 101 len ceil32(_13655)] = mem[_12903 + 32 len ceil32(_13655)]
                if ceil32(_13655) > _13655:
                    mem[_13655 + _6013 + stor30.length.field_1 + _2872 + 101] = 0
                return 32, mem[_6013 + stor30.length.field_1 + _2872 + 69 len ceil32(_13655) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2872)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2872)]
            mem[mem[64] + stor30.length.field_1 + _2872 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2872) <= _2872:
                _12904 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
                mem[_6013 + stor30.length.field_1 + _2872 + 37] = 32
                _13656 = mem[_12904]
                mem[_6013 + stor30.length.field_1 + _2872 + 69] = mem[_12904]
                mem[_6013 + stor30.length.field_1 + _2872 + 101 len ceil32(_13656)] = mem[_12904 + 32 len ceil32(_13656)]
                if ceil32(_13656) > _13656:
                    mem[_13656 + _6013 + stor30.length.field_1 + _2872 + 101] = 0
                return 32, mem[_6013 + stor30.length.field_1 + _2872 + 69 len ceil32(_13656) + 32]
            _12905 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2872 + 37
            mem[_6013 + stor30.length.field_1 + _2872 + 37] = 32
            _13657 = mem[_12905]
            mem[_6013 + stor30.length.field_1 + _2872 + 69] = mem[_12905]
            mem[_6013 + stor30.length.field_1 + _2872 + 101 len ceil32(_13657)] = mem[_12905 + 32 len ceil32(_13657)]
            if ceil32(_13657) > _13657:
                mem[_13657 + _6013 + stor30.length.field_1 + _2872 + 101] = 0
            return 32, mem[_6013 + stor30.length.field_1 + _2872 + 69 len ceil32(_13657) + 32]
        if bool(stor30.length) == stor30.length.field_1 < 32:
            revert with 0, 34
        if not stor30.length.field_1:
            if not stor31:
                if not arg1:
                    mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                    mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(stor30.length.field_1) + 128] = s
                if s:
                    mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) > stor30.length.field_1:
                    mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                    return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) + 32], 
            mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _108 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _158 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            require _108 + _158 + 32 <= return_data.size
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_158)] = mem[ceil32(stor30.length.field_1) + _108 + 160 len ceil32(_158)]
            if ceil32(_158) <= _158:
                _2552 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    _5908 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5908 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5908) <= _5908:
                        _9772 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5908 + 37
                        mem[_2552 + stor30.length.field_1 + _5908 + 37] = 32
                        _10426 = mem[_9772]
                        mem[_2552 + stor30.length.field_1 + _5908 + 69] = mem[_9772]
                        mem[_2552 + stor30.length.field_1 + _5908 + 101 len ceil32(_10426)] = mem[_9772 + 32 len ceil32(_10426)]
                        if ceil32(_10426) > _10426:
                            mem[_10426 + _2552 + stor30.length.field_1 + _5908 + 101] = 0
                        return 32, mem[_2552 + stor30.length.field_1 + _5908 + 69 len ceil32(_10426) + 32]
                    _9773 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5908 + 37
                    mem[_2552 + stor30.length.field_1 + _5908 + 37] = 32
                    _10427 = mem[_9773]
                    mem[_2552 + stor30.length.field_1 + _5908 + 69] = mem[_9773]
                    mem[_2552 + stor30.length.field_1 + _5908 + 101 len ceil32(_10427)] = mem[_9773 + 32 len ceil32(_10427)]
                    if ceil32(_10427) > _10427:
                        mem[_10427 + _2552 + stor30.length.field_1 + _5908 + 101] = 0
                    return 32, mem[_2552 + stor30.length.field_1 + _5908 + 69 len ceil32(_10427) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                _5909 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5909 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5909) <= _5909:
                    _9774 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5909 + 37
                    mem[_2552 + stor30.length.field_1 + _5909 + 37] = 32
                    _10428 = mem[_9774]
                    mem[_2552 + stor30.length.field_1 + _5909 + 69] = mem[_9774]
                    mem[_2552 + stor30.length.field_1 + _5909 + 101 len ceil32(_10428)] = mem[_9774 + 32 len ceil32(_10428)]
                    if ceil32(_10428) > _10428:
                        mem[_10428 + _2552 + stor30.length.field_1 + _5909 + 101] = 0
                    return 32, mem[_2552 + stor30.length.field_1 + _5909 + 69 len ceil32(_10428) + 32]
                _9775 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5909 + 37
                mem[_2552 + stor30.length.field_1 + _5909 + 37] = 32
                _10429 = mem[_9775]
                mem[_2552 + stor30.length.field_1 + _5909 + 69] = mem[_9775]
                mem[_2552 + stor30.length.field_1 + _5909 + 101 len ceil32(_10429)] = mem[_9775 + 32 len ceil32(_10429)]
                if ceil32(_10429) > _10429:
                    mem[_10429 + _2552 + stor30.length.field_1 + _5909 + 101] = 0
                return 32, mem[_2552 + stor30.length.field_1 + _5909 + 69 len ceil32(_10429) + 32]
            mem[_158 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
            _2553 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                _5910 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5910 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5910) <= _5910:
                    _9776 = mem[64]
                    mem[64] = _2553 + stor30.length.field_1 + _5910 + 37
                    mem[_2553 + stor30.length.field_1 + _5910 + 37] = 32
                    _10430 = mem[_9776]
                    mem[_2553 + stor30.length.field_1 + _5910 + 69] = mem[_9776]
                    mem[_2553 + stor30.length.field_1 + _5910 + 101 len ceil32(_10430)] = mem[_9776 + 32 len ceil32(_10430)]
                    if ceil32(_10430) > _10430:
                        mem[_10430 + _2553 + stor30.length.field_1 + _5910 + 101] = 0
                    return 32, mem[_2553 + stor30.length.field_1 + _5910 + 69 len ceil32(_10430) + 32]
                _9777 = mem[64]
                mem[64] = _2553 + stor30.length.field_1 + _5910 + 37
                mem[_2553 + stor30.length.field_1 + _5910 + 37] = 32
                _10431 = mem[_9777]
                mem[_2553 + stor30.length.field_1 + _5910 + 69] = mem[_9777]
                mem[_2553 + stor30.length.field_1 + _5910 + 101 len ceil32(_10431)] = mem[_9777 + 32 len ceil32(_10431)]
                if ceil32(_10431) > _10431:
                    mem[_10431 + _2553 + stor30.length.field_1 + _5910 + 101] = 0
                return 32, mem[_2553 + stor30.length.field_1 + _5910 + 69 len ceil32(_10431) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            _5911 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5911 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5911) <= _5911:
                _9778 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5911 + 37
                mem[_2553 + stor30.length.field_1 + _5911 + 37] = 32
                _10432 = mem[_9778]
                mem[_2553 + stor30.length.field_1 + _5911 + 69] = mem[_9778]
                mem[_2553 + stor30.length.field_1 + _5911 + 101 len ceil32(_10432)] = mem[_9778 + 32 len ceil32(_10432)]
                if ceil32(_10432) > _10432:
                    mem[_10432 + _2553 + stor30.length.field_1 + _5911 + 101] = 0
                return 32, mem[_2553 + stor30.length.field_1 + _5911 + 69 len ceil32(_10432) + 32]
            _9779 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5911 + 37
            mem[_2553 + stor30.length.field_1 + _5911 + 37] = 32
            _10433 = mem[_9779]
            mem[_2553 + stor30.length.field_1 + _5911 + 69] = mem[_9779]
            mem[_2553 + stor30.length.field_1 + _5911 + 101 len ceil32(_10433)] = mem[_9779 + 32 len ceil32(_10433)]
            if ceil32(_10433) > _10433:
                mem[_10433 + _2553 + stor30.length.field_1 + _5911 + 101] = 0
            return 32, mem[_2553 + stor30.length.field_1 + _5911 + 69 len ceil32(_10433) + 32]
        if 31 >= stor30.length.field_1:
            mem[128] = 256 * stor30.length.field_8
            if not stor31:
                if not arg1:
                    mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                    mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(stor30.length.field_1) + 128] = s
                if s:
                    mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) > stor30.length.field_1:
                    mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
            mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _161 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _206 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            require _161 + _206 + 32 <= return_data.size
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_206)] = mem[ceil32(stor30.length.field_1) + _161 + 160 len ceil32(_206)]
            if ceil32(_206) <= _206:
                _2556 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    _5916 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5916 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5916) <= _5916:
                        _9786 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5916 + 37
                        mem[_2556 + stor30.length.field_1 + _5916 + 37] = 32
                        _10458 = mem[_9786]
                        mem[_2556 + stor30.length.field_1 + _5916 + 69] = mem[_9786]
                        mem[_2556 + stor30.length.field_1 + _5916 + 101 len ceil32(_10458)] = mem[_9786 + 32 len ceil32(_10458)]
                        if ceil32(_10458) > _10458:
                            mem[_10458 + _2556 + stor30.length.field_1 + _5916 + 101] = 0
                        return 32, mem[_2556 + stor30.length.field_1 + _5916 + 69 len ceil32(_10458) + 32]
                    _9787 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5916 + 37
                    mem[_2556 + stor30.length.field_1 + _5916 + 37] = 32
                    _10459 = mem[_9787]
                    mem[_2556 + stor30.length.field_1 + _5916 + 69] = mem[_9787]
                    mem[_2556 + stor30.length.field_1 + _5916 + 101 len ceil32(_10459)] = mem[_9787 + 32 len ceil32(_10459)]
                    if ceil32(_10459) > _10459:
                        mem[_10459 + _2556 + stor30.length.field_1 + _5916 + 101] = 0
                    return 32, mem[_2556 + stor30.length.field_1 + _5916 + 69 len ceil32(_10459) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                _5917 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5917 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5917) <= _5917:
                    _9788 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5917 + 37
                    mem[_2556 + stor30.length.field_1 + _5917 + 37] = 32
                    _10460 = mem[_9788]
                    mem[_2556 + stor30.length.field_1 + _5917 + 69] = mem[_9788]
                    mem[_2556 + stor30.length.field_1 + _5917 + 101 len ceil32(_10460)] = mem[_9788 + 32 len ceil32(_10460)]
                    if ceil32(_10460) > _10460:
                        mem[_10460 + _2556 + stor30.length.field_1 + _5917 + 101] = 0
                    return 32, mem[_2556 + stor30.length.field_1 + _5917 + 69 len ceil32(_10460) + 32]
                _9789 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5917 + 37
                mem[_2556 + stor30.length.field_1 + _5917 + 37] = 32
                _10461 = mem[_9789]
                mem[_2556 + stor30.length.field_1 + _5917 + 69] = mem[_9789]
                mem[_2556 + stor30.length.field_1 + _5917 + 101 len ceil32(_10461)] = mem[_9789 + 32 len ceil32(_10461)]
                if ceil32(_10461) > _10461:
                    mem[_10461 + _2556 + stor30.length.field_1 + _5917 + 101] = 0
                return 32, mem[_2556 + stor30.length.field_1 + _5917 + 69 len ceil32(_10461) + 32]
            mem[_206 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
            _2557 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                _5918 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5918 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5918) <= _5918:
                    _9790 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5918 + 37
                    mem[_2557 + stor30.length.field_1 + _5918 + 37] = 32
                    _10462 = mem[_9790]
                    mem[_2557 + stor30.length.field_1 + _5918 + 69] = mem[_9790]
                    mem[_2557 + stor30.length.field_1 + _5918 + 101 len ceil32(_10462)] = mem[_9790 + 32 len ceil32(_10462)]
                    if ceil32(_10462) > _10462:
                        mem[_10462 + _2557 + stor30.length.field_1 + _5918 + 101] = 0
                    return 32, mem[_2557 + stor30.length.field_1 + _5918 + 69 len ceil32(_10462) + 32]
                _9791 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5918 + 37
                mem[_2557 + stor30.length.field_1 + _5918 + 37] = 32
                _10463 = mem[_9791]
                mem[_2557 + stor30.length.field_1 + _5918 + 69] = mem[_9791]
                mem[_2557 + stor30.length.field_1 + _5918 + 101 len ceil32(_10463)] = mem[_9791 + 32 len ceil32(_10463)]
                if ceil32(_10463) > _10463:
                    mem[_10463 + _2557 + stor30.length.field_1 + _5918 + 101] = 0
                return 32, mem[_2557 + stor30.length.field_1 + _5918 + 69 len ceil32(_10463) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            _5919 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5919 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5919) <= _5919:
                _9792 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5919 + 37
                mem[_2557 + stor30.length.field_1 + _5919 + 37] = 32
                _10464 = mem[_9792]
                mem[_2557 + stor30.length.field_1 + _5919 + 69] = mem[_9792]
                mem[_2557 + stor30.length.field_1 + _5919 + 101 len ceil32(_10464)] = mem[_9792 + 32 len ceil32(_10464)]
                if ceil32(_10464) > _10464:
                    mem[_10464 + _2557 + stor30.length.field_1 + _5919 + 101] = 0
                return 32, mem[_2557 + stor30.length.field_1 + _5919 + 69 len ceil32(_10464) + 32]
            _9793 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5919 + 37
            mem[_2557 + stor30.length.field_1 + _5919 + 37] = 32
            _10465 = mem[_9793]
            mem[_2557 + stor30.length.field_1 + _5919 + 69] = mem[_9793]
            mem[_2557 + stor30.length.field_1 + _5919 + 101 len ceil32(_10465)] = mem[_9793 + 32 len ceil32(_10465)]
            if ceil32(_10465) > _10465:
                mem[_10465 + _2557 + stor30.length.field_1 + _5919 + 101] = 0
            return 32, mem[_2557 + stor30.length.field_1 + _5919 + 69 len ceil32(_10465) + 32]
        mem[0] = 30
        mem[128] = uint256(stor30.field_0)
        idx = 128
        s = 0
        while stor30.length.field_1 + 96 > idx:
            mem[idx + 32] = stor30[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        if not stor31:
            if not arg1:
                mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                    return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 0, 65
            mem[ceil32(stor30.length.field_1) + 128] = s
            if s:
                mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                    revert with 0, 50
                mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) > stor30.length.field_1:
                mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
            return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
        mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
        mem[ceil32(stor30.length.field_1) + 132] = arg1
        require ext_code.size(stor31)
        staticcall stor31.0xff74ef30 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
        require return_data.size >= 32
        _2716 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
        require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
        _2881 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        require _2716 + _2881 + 32 <= return_data.size
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2881)] = mem[ceil32(stor30.length.field_1) + _2716 + 160 len ceil32(_2881)]
        if ceil32(_2881) <= _2881:
            _6026 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2881)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2881)]
                mem[mem[64] + stor30.length.field_1 + _2881 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2881) <= _2881:
                    _12922 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
                    mem[_6026 + stor30.length.field_1 + _2881 + 37] = 32
                    _13682 = mem[_12922]
                    mem[_6026 + stor30.length.field_1 + _2881 + 69] = mem[_12922]
                    mem[_6026 + stor30.length.field_1 + _2881 + 101 len ceil32(_13682)] = mem[_12922 + 32 len ceil32(_13682)]
                    if ceil32(_13682) > _13682:
                        mem[_13682 + _6026 + stor30.length.field_1 + _2881 + 101] = 0
                    return 32, mem[_6026 + stor30.length.field_1 + _2881 + 69 len ceil32(_13682) + 32]
                _12923 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
                mem[_6026 + stor30.length.field_1 + _2881 + 37] = 32
                _13683 = mem[_12923]
                mem[_6026 + stor30.length.field_1 + _2881 + 69] = mem[_12923]
                mem[_6026 + stor30.length.field_1 + _2881 + 101 len ceil32(_13683)] = mem[_12923 + 32 len ceil32(_13683)]
                if ceil32(_13683) > _13683:
                    mem[_13683 + _6026 + stor30.length.field_1 + _2881 + 101] = 0
                return 32, mem[_6026 + stor30.length.field_1 + _2881 + 69 len ceil32(_13683) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2881)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2881)]
            mem[mem[64] + stor30.length.field_1 + _2881 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2881) <= _2881:
                _12924 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
                mem[_6026 + stor30.length.field_1 + _2881 + 37] = 32
                _13684 = mem[_12924]
                mem[_6026 + stor30.length.field_1 + _2881 + 69] = mem[_12924]
                mem[_6026 + stor30.length.field_1 + _2881 + 101 len ceil32(_13684)] = mem[_12924 + 32 len ceil32(_13684)]
                if ceil32(_13684) > _13684:
                    mem[_13684 + _6026 + stor30.length.field_1 + _2881 + 101] = 0
                return 32, mem[_6026 + stor30.length.field_1 + _2881 + 69 len ceil32(_13684) + 32]
            _12925 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
            mem[_6026 + stor30.length.field_1 + _2881 + 37] = 32
            _13685 = mem[_12925]
            mem[_6026 + stor30.length.field_1 + _2881 + 69] = mem[_12925]
            mem[_6026 + stor30.length.field_1 + _2881 + 101 len ceil32(_13685)] = mem[_12925 + 32 len ceil32(_13685)]
            if ceil32(_13685) > _13685:
                mem[_13685 + _6026 + stor30.length.field_1 + _2881 + 101] = 0
            return 32, mem[_6026 + stor30.length.field_1 + _2881 + 69 len ceil32(_13685) + 32]
        mem[_2881 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
        _6027 = mem[64]
        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2881)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2881)]
            mem[mem[64] + stor30.length.field_1 + _2881 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2881) <= _2881:
                _12926 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
                mem[_6027 + stor30.length.field_1 + _2881 + 37] = 32
                _13686 = mem[_12926]
                mem[_6027 + stor30.length.field_1 + _2881 + 69] = mem[_12926]
                mem[_6027 + stor30.length.field_1 + _2881 + 101 len ceil32(_13686)] = mem[_12926 + 32 len ceil32(_13686)]
                if ceil32(_13686) > _13686:
                    mem[_13686 + _6027 + stor30.length.field_1 + _2881 + 101] = 0
                return 32, mem[_6027 + stor30.length.field_1 + _2881 + 69 len ceil32(_13686) + 32]
            _12927 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
            mem[_6027 + stor30.length.field_1 + _2881 + 37] = 32
            _13687 = mem[_12927]
            mem[_6027 + stor30.length.field_1 + _2881 + 69] = mem[_12927]
            mem[_6027 + stor30.length.field_1 + _2881 + 101 len ceil32(_13687)] = mem[_12927 + 32 len ceil32(_13687)]
            if ceil32(_13687) > _13687:
                mem[_13687 + _6027 + stor30.length.field_1 + _2881 + 101] = 0
            return 32, mem[_6027 + stor30.length.field_1 + _2881 + 69 len ceil32(_13687) + 32]
        mem[stor30.length.field_1 + mem[64] + 32] = 0
        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2881)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2881)]
        mem[mem[64] + stor30.length.field_1 + _2881 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_2881) <= _2881:
            _12928 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
            mem[_6027 + stor30.length.field_1 + _2881 + 37] = 32
            _13688 = mem[_12928]
            mem[_6027 + stor30.length.field_1 + _2881 + 69] = mem[_12928]
            mem[_6027 + stor30.length.field_1 + _2881 + 101 len ceil32(_13688)] = mem[_12928 + 32 len ceil32(_13688)]
            if ceil32(_13688) > _13688:
                mem[_13688 + _6027 + stor30.length.field_1 + _2881 + 101] = 0
            return 32, mem[_6027 + stor30.length.field_1 + _2881 + 69 len ceil32(_13688) + 32]
        _12929 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _2881 + 37
        mem[_6027 + stor30.length.field_1 + _2881 + 37] = 32
        _13689 = mem[_12929]
        mem[_6027 + stor30.length.field_1 + _2881 + 69] = mem[_12929]
        mem[_6027 + stor30.length.field_1 + _2881 + 101 len ceil32(_13689)] = mem[_12929 + 32 len ceil32(_13689)]
        if ceil32(_13689) > _13689:
            mem[_13689 + _6027 + stor30.length.field_1 + _2881 + 101] = 0
        return 32, mem[_6027 + stor30.length.field_1 + _2881 + 69 len ceil32(_13689) + 32]
    if bool(stor30.length) == stor30.length.field_1 < 32:
        revert with 0, 34
    if stor30.length.field_1 <= 0:
        return ''
    if bool(stor30.length):
        if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
            revert with 0, 34
        mem[96] = uint255(stor30.length) * 0.5
        if bool(stor30.length):
            if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor30.length):
                if not stor31:
                    if not arg1:
                        mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                            return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                        mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13706 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13706)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13706)]
                                if ceil32(_13706) > _13706:
                                    mem[_13706 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13706) + 32], 
                            _13707 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13707)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13707)]
                            if ceil32(_13707) > _13707:
                                mem[_13707 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13707) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13708 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13708)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13708)]
                            if ceil32(_13708) > _13708:
                                mem[_13708 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13708) + 32], 
                        _13709 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13709)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13709)]
                        if ceil32(_13709) > _13709:
                            mem[_13709 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13709) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13710 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13710)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13710)]
                            if ceil32(_13710) > _13710:
                                mem[_13710 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13710) + 32], 
                        _13711 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13711)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13711)]
                        if ceil32(_13711) > _13711:
                            mem[_13711 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13711) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13712 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13712)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13712)]
                        if ceil32(_13712) > _13712:
                            mem[_13712 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13712) + 32], 
                    _13713 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13713)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13713)]
                    if ceil32(_13713) > _13713:
                        mem[_13713 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13713) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _91 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _139 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _139
                require _91 + _139 + 32 <= return_data.size
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_139)] = mem[ceil32(uint255(stor30.length) * 0.5) + _91 + 160 len ceil32(_139)]
                if ceil32(_139) <= _139:
                    _2558 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_139)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_139)]
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_139) <= _139:
                            _9794 = mem[64]
                            mem[64] = _2558 + (uint255(stor30.length) * 0.5) + _139 + 37
                            mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                            _10474 = mem[_9794]
                            mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9794]
                            mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10474)] = mem[_9794 + 32 len ceil32(_10474)]
                            if ceil32(_10474) > _10474:
                                mem[_10474 + _2558 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                            return 32, mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10474) + 32]
                        _9795 = mem[64]
                        mem[64] = _2558 + (uint255(stor30.length) * 0.5) + _139 + 37
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                        _10475 = mem[_9795]
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9795]
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10475)] = mem[_9795 + 32 len ceil32(_10475)]
                        if ceil32(_10475) > _10475:
                            mem[_10475 + _2558 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                        return 32, mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10475) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_2558 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_139)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_139)]
                    mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_139) <= _139:
                        _9796 = mem[64]
                        mem[64] = _2558 + (uint255(stor30.length) * 0.5) + _139 + 37
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                        _10476 = mem[_9796]
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9796]
                        mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10476)] = mem[_9796 + 32 len ceil32(_10476)]
                        if ceil32(_10476) > _10476:
                            mem[_10476 + _2558 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                        return 32, mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10476) + 32]
                    _9797 = mem[64]
                    mem[64] = _2558 + (uint255(stor30.length) * 0.5) + _139 + 37
                    mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                    _10477 = mem[_9797]
                    mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9797]
                    mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10477)] = mem[_9797 + 32 len ceil32(_10477)]
                    if ceil32(_10477) > _10477:
                        mem[_10477 + _2558 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                    return 32, mem[_2558 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10477) + 32]
                mem[_139 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                _2559 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_139)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_139)]
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_139) <= _139:
                        _9798 = mem[64]
                        mem[64] = _2559 + (uint255(stor30.length) * 0.5) + _139 + 37
                        mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                        _10478 = mem[_9798]
                        mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9798]
                        mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10478)] = mem[_9798 + 32 len ceil32(_10478)]
                        if ceil32(_10478) > _10478:
                            mem[_10478 + _2559 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                        return 32, mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10478) + 32]
                    _9799 = mem[64]
                    mem[64] = _2559 + (uint255(stor30.length) * 0.5) + _139 + 37
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                    _10479 = mem[_9799]
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9799]
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10479)] = mem[_9799 + 32 len ceil32(_10479)]
                    if ceil32(_10479) > _10479:
                        mem[_10479 + _2559 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                    return 32, mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10479) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_2559 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_139)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_139)]
                mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_139) <= _139:
                    _9800 = mem[64]
                    mem[64] = _2559 + (uint255(stor30.length) * 0.5) + _139 + 37
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                    _10480 = mem[_9800]
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9800]
                    mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10480)] = mem[_9800 + 32 len ceil32(_10480)]
                    if ceil32(_10480) > _10480:
                        mem[_10480 + _2559 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                    return 32, mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10480) + 32]
                _9801 = mem[64]
                mem[64] = _2559 + (uint255(stor30.length) * 0.5) + _139 + 37
                mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 37] = 32
                _10481 = mem[_9801]
                mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69] = mem[_9801]
                mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 101 len ceil32(_10481)] = mem[_9801 + 32 len ceil32(_10481)]
                if ceil32(_10481) > _10481:
                    mem[_10481 + _2559 + (uint255(stor30.length) * 0.5) + _139 + 101] = 0
                return 32, mem[_2559 + (uint255(stor30.length) * 0.5) + _139 + 69 len ceil32(_10481) + 32]
            if 31 >= uint255(stor30.length) * 0.5:
                mem[128] = 256 * stor30.length.field_8
                if not stor31:
                    if not arg1:
                        mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                        mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                            return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                        mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 0, 65
                    mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 0, 17
                            if 48 > !(idx % 10):
                                revert with 0, 17
                            if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                revert with 0, 50
                            mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                                _13730 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13730)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13730)]
                                if ceil32(_13730) > _13730:
                                    mem[_13730 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13730) + 32], 
                            _13731 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13731)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13731)]
                            if ceil32(_13731) > _13731:
                                mem[_13731 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13731) + 32], 
                        mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13732 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13732)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13732)]
                            if ceil32(_13732) > _13732:
                                mem[_13732 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13732) + 32], 
                        _13733 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13733)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13733)]
                        if ceil32(_13733) > _13733:
                            mem[_13733 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13733) + 32], 
                    mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13734 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13734)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13734)]
                            if ceil32(_13734) > _13734:
                                mem[_13734 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13734) + 32], 
                        _13735 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13735)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13735)]
                        if ceil32(_13735) > _13735:
                            mem[_13735 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13735) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13736 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13736)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13736)]
                        if ceil32(_13736) > _13736:
                            mem[_13736 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13736) + 32], 
                    _13737 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13737)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13737)]
                    if ceil32(_13737) > _13737:
                        mem[_13737 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13737) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
                require ext_code.size(stor31)
                staticcall stor31.0xff74ef30 with:
                        gas gas_remaining wei
                       args arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
                require return_data.size >= 32
                _142 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
                require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
                require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
                _188 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
                if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _188
                require _142 + _188 + 32 <= return_data.size
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_188)] = mem[ceil32(uint255(stor30.length) * 0.5) + _142 + 160 len ceil32(_188)]
                if ceil32(_188) <= _188:
                    _2562 = mem[64]
                    mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_188)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_188)]
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        if ceil32(_188) <= _188:
                            _9808 = mem[64]
                            mem[64] = _2562 + (uint255(stor30.length) * 0.5) + _188 + 37
                            mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                            _10506 = mem[_9808]
                            mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9808]
                            mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10506)] = mem[_9808 + 32 len ceil32(_10506)]
                            if ceil32(_10506) > _10506:
                                mem[_10506 + _2562 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                            return 32, mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10506) + 32]
                        _9809 = mem[64]
                        mem[64] = _2562 + (uint255(stor30.length) * 0.5) + _188 + 37
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                        _10507 = mem[_9809]
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9809]
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10507)] = mem[_9809 + 32 len ceil32(_10507)]
                        if ceil32(_10507) > _10507:
                            mem[_10507 + _2562 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                        return 32, mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10507) + 32]
                    mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                    mem[_2562 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_188)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_188)]
                    mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_188) <= _188:
                        _9810 = mem[64]
                        mem[64] = _2562 + (uint255(stor30.length) * 0.5) + _188 + 37
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                        _10508 = mem[_9810]
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9810]
                        mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10508)] = mem[_9810 + 32 len ceil32(_10508)]
                        if ceil32(_10508) > _10508:
                            mem[_10508 + _2562 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                        return 32, mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10508) + 32]
                    _9811 = mem[64]
                    mem[64] = _2562 + (uint255(stor30.length) * 0.5) + _188 + 37
                    mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                    _10509 = mem[_9811]
                    mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9811]
                    mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10509)] = mem[_9811 + 32 len ceil32(_10509)]
                    if ceil32(_10509) > _10509:
                        mem[_10509 + _2562 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                    return 32, mem[_2562 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10509) + 32]
                mem[_188 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
                _2563 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_188)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_188)]
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_188) <= _188:
                        _9812 = mem[64]
                        mem[64] = _2563 + (uint255(stor30.length) * 0.5) + _188 + 37
                        mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                        _10510 = mem[_9812]
                        mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9812]
                        mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10510)] = mem[_9812 + 32 len ceil32(_10510)]
                        if ceil32(_10510) > _10510:
                            mem[_10510 + _2563 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                        return 32, mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10510) + 32]
                    _9813 = mem[64]
                    mem[64] = _2563 + (uint255(stor30.length) * 0.5) + _188 + 37
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                    _10511 = mem[_9813]
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9813]
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10511)] = mem[_9813 + 32 len ceil32(_10511)]
                    if ceil32(_10511) > _10511:
                        mem[_10511 + _2563 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                    return 32, mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10511) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_2563 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_188)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_188)]
                mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_188) <= _188:
                    _9814 = mem[64]
                    mem[64] = _2563 + (uint255(stor30.length) * 0.5) + _188 + 37
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                    _10512 = mem[_9814]
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9814]
                    mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10512)] = mem[_9814 + 32 len ceil32(_10512)]
                    if ceil32(_10512) > _10512:
                        mem[_10512 + _2563 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                    return 32, mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10512) + 32]
                _9815 = mem[64]
                mem[64] = _2563 + (uint255(stor30.length) * 0.5) + _188 + 37
                mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 37] = 32
                _10513 = mem[_9815]
                mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69] = mem[_9815]
                mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 101 len ceil32(_10513)] = mem[_9815 + 32 len ceil32(_10513)]
                if ceil32(_10513) > _10513:
                    mem[_10513 + _2563 + (uint255(stor30.length) * 0.5) + _188 + 101] = 0
                return 32, mem[_2563 + (uint255(stor30.length) * 0.5) + _188 + 69 len ceil32(_10513) + 32]
            mem[0] = 30
            mem[128] = uint256(stor30.field_0)
            idx = 128
            s = 0
            while (uint255(stor30.length) * 0.5) + 96 > idx:
                mem[idx + 32] = stor30[s].field_256
                idx = idx + 32
                s = s + 1
                continue 
            if not stor31:
                if not arg1:
                    mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                        return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                    mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _15498 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15498)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15498)]
                            if ceil32(_15498) > _15498:
                                mem[_15498 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15498) + 32], 
                        _15499 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15499)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15499)]
                        if ceil32(_15499) > _15499:
                            mem[_15499 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15499) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _15500 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15500)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15500)]
                        if ceil32(_15500) > _15500:
                            mem[_15500 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15500) + 32], 
                    _15501 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15501)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15501)]
                    if ceil32(_15501) > _15501:
                        mem[_15501 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15501) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _15502 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15502)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15502)]
                        if ceil32(_15502) > _15502:
                            mem[_15502 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15502) + 32], 
                    _15503 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15503)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15503)]
                    if ceil32(_15503) > _15503:
                        mem[_15503 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15503) + 32], 
                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    _15504 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15504)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15504)]
                    if ceil32(_15504) > _15504:
                        mem[_15504 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15504) + 32], 
                _15505 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15505)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15505)]
                if ceil32(_15505) > _15505:
                    mem[_15505 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15505) + 32], 
            mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _2726 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _2890 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _2890
            require _2726 + _2890 + 32 <= return_data.size
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2890)] = mem[ceil32(uint255(stor30.length) * 0.5) + _2726 + 160 len ceil32(_2890)]
            if ceil32(_2890) <= _2890:
                _6040 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2890)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2890)]
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_2890) <= _2890:
                        _12946 = mem[64]
                        mem[64] = _6040 + (uint255(stor30.length) * 0.5) + _2890 + 37
                        mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                        _13714 = mem[_12946]
                        mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12946]
                        mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13714)] = mem[_12946 + 32 len ceil32(_13714)]
                        if ceil32(_13714) > _13714:
                            mem[_13714 + _6040 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                        return 32, mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13714) + 32]
                    _12947 = mem[64]
                    mem[64] = _6040 + (uint255(stor30.length) * 0.5) + _2890 + 37
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                    _13715 = mem[_12947]
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12947]
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13715)] = mem[_12947 + 32 len ceil32(_13715)]
                    if ceil32(_13715) > _13715:
                        mem[_13715 + _6040 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                    return 32, mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13715) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_6040 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2890)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2890)]
                mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2890) <= _2890:
                    _12948 = mem[64]
                    mem[64] = _6040 + (uint255(stor30.length) * 0.5) + _2890 + 37
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                    _13716 = mem[_12948]
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12948]
                    mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13716)] = mem[_12948 + 32 len ceil32(_13716)]
                    if ceil32(_13716) > _13716:
                        mem[_13716 + _6040 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                    return 32, mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13716) + 32]
                _12949 = mem[64]
                mem[64] = _6040 + (uint255(stor30.length) * 0.5) + _2890 + 37
                mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                _13717 = mem[_12949]
                mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12949]
                mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13717)] = mem[_12949 + 32 len ceil32(_13717)]
                if ceil32(_13717) > _13717:
                    mem[_13717 + _6040 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                return 32, mem[_6040 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13717) + 32]
            mem[_2890 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
            _6041 = mem[64]
            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2890)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2890)]
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2890) <= _2890:
                    _12950 = mem[64]
                    mem[64] = _6041 + (uint255(stor30.length) * 0.5) + _2890 + 37
                    mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                    _13718 = mem[_12950]
                    mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12950]
                    mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13718)] = mem[_12950 + 32 len ceil32(_13718)]
                    if ceil32(_13718) > _13718:
                        mem[_13718 + _6041 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                    return 32, mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13718) + 32]
                _12951 = mem[64]
                mem[64] = _6041 + (uint255(stor30.length) * 0.5) + _2890 + 37
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                _13719 = mem[_12951]
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12951]
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13719)] = mem[_12951 + 32 len ceil32(_13719)]
                if ceil32(_13719) > _13719:
                    mem[_13719 + _6041 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                return 32, mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13719) + 32]
            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
            mem[_6041 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2890)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2890)]
            mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2890) <= _2890:
                _12952 = mem[64]
                mem[64] = _6041 + (uint255(stor30.length) * 0.5) + _2890 + 37
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
                _13720 = mem[_12952]
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12952]
                mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13720)] = mem[_12952 + 32 len ceil32(_13720)]
                if ceil32(_13720) > _13720:
                    mem[_13720 + _6041 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
                return 32, mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13720) + 32]
            _12953 = mem[64]
            mem[64] = _6041 + (uint255(stor30.length) * 0.5) + _2890 + 37
            mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 37] = 32
            _13721 = mem[_12953]
            mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69] = mem[_12953]
            mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 101 len ceil32(_13721)] = mem[_12953 + 32 len ceil32(_13721)]
            if ceil32(_13721) > _13721:
                mem[_13721 + _6041 + (uint255(stor30.length) * 0.5) + _2890 + 101] = 0
            return 32, mem[_6041 + (uint255(stor30.length) * 0.5) + _2890 + 69 len ceil32(_13721) + 32]
        if bool(stor30.length) == stor30.length.field_1 < 32:
            revert with 0, 34
        if not stor30.length.field_1:
            if not stor31:
                if not arg1:
                    mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                        return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                    mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13738 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13738)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13738)]
                            if ceil32(_13738) > _13738:
                                mem[_13738 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13738) + 32], 
                        _13739 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13739)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13739)]
                        if ceil32(_13739) > _13739:
                            mem[_13739 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13739) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13740 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13740)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13740)]
                        if ceil32(_13740) > _13740:
                            mem[_13740 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13740) + 32], 
                    _13741 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13741)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13741)]
                    if ceil32(_13741) > _13741:
                        mem[_13741 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13741) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13742 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13742)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13742)]
                        if ceil32(_13742) > _13742:
                            mem[_13742 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13742) + 32], 
                    _13743 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13743)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13743)]
                    if ceil32(_13743) > _13743:
                        mem[_13743 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13743) + 32], 
                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    _13744 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13744)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13744)]
                    if ceil32(_13744) > _13744:
                        mem[_13744 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13744) + 32], 
                _13745 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13745)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13745)]
                if ceil32(_13745) > _13745:
                    mem[_13745 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13745) + 32], 
            mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _115 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _164 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _164
            require _115 + _164 + 32 <= return_data.size
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_164)] = mem[ceil32(uint255(stor30.length) * 0.5) + _115 + 160 len ceil32(_164)]
            if ceil32(_164) <= _164:
                _2564 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_164)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_164)]
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_164) <= _164:
                        _9816 = mem[64]
                        mem[64] = _2564 + (uint255(stor30.length) * 0.5) + _164 + 37
                        mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                        _10522 = mem[_9816]
                        mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9816]
                        mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10522)] = mem[_9816 + 32 len ceil32(_10522)]
                        if ceil32(_10522) > _10522:
                            mem[_10522 + _2564 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                        return 32, mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10522) + 32]
                    _9817 = mem[64]
                    mem[64] = _2564 + (uint255(stor30.length) * 0.5) + _164 + 37
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                    _10523 = mem[_9817]
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9817]
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10523)] = mem[_9817 + 32 len ceil32(_10523)]
                    if ceil32(_10523) > _10523:
                        mem[_10523 + _2564 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                    return 32, mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10523) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_2564 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_164)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_164)]
                mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_164) <= _164:
                    _9818 = mem[64]
                    mem[64] = _2564 + (uint255(stor30.length) * 0.5) + _164 + 37
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                    _10524 = mem[_9818]
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9818]
                    mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10524)] = mem[_9818 + 32 len ceil32(_10524)]
                    if ceil32(_10524) > _10524:
                        mem[_10524 + _2564 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                    return 32, mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10524) + 32]
                _9819 = mem[64]
                mem[64] = _2564 + (uint255(stor30.length) * 0.5) + _164 + 37
                mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                _10525 = mem[_9819]
                mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9819]
                mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10525)] = mem[_9819 + 32 len ceil32(_10525)]
                if ceil32(_10525) > _10525:
                    mem[_10525 + _2564 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                return 32, mem[_2564 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10525) + 32]
            mem[_164 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
            _2565 = mem[64]
            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_164)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_164)]
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_164) <= _164:
                    _9820 = mem[64]
                    mem[64] = _2565 + (uint255(stor30.length) * 0.5) + _164 + 37
                    mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                    _10526 = mem[_9820]
                    mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9820]
                    mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10526)] = mem[_9820 + 32 len ceil32(_10526)]
                    if ceil32(_10526) > _10526:
                        mem[_10526 + _2565 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                    return 32, mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10526) + 32]
                _9821 = mem[64]
                mem[64] = _2565 + (uint255(stor30.length) * 0.5) + _164 + 37
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                _10527 = mem[_9821]
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9821]
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10527)] = mem[_9821 + 32 len ceil32(_10527)]
                if ceil32(_10527) > _10527:
                    mem[_10527 + _2565 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                return 32, mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10527) + 32]
            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
            mem[_2565 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_164)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_164)]
            mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_164) <= _164:
                _9822 = mem[64]
                mem[64] = _2565 + (uint255(stor30.length) * 0.5) + _164 + 37
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
                _10528 = mem[_9822]
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9822]
                mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10528)] = mem[_9822 + 32 len ceil32(_10528)]
                if ceil32(_10528) > _10528:
                    mem[_10528 + _2565 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
                return 32, mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10528) + 32]
            _9823 = mem[64]
            mem[64] = _2565 + (uint255(stor30.length) * 0.5) + _164 + 37
            mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 37] = 32
            _10529 = mem[_9823]
            mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69] = mem[_9823]
            mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 101 len ceil32(_10529)] = mem[_9823 + 32 len ceil32(_10529)]
            if ceil32(_10529) > _10529:
                mem[_10529 + _2565 + (uint255(stor30.length) * 0.5) + _164 + 101] = 0
            return 32, mem[_2565 + (uint255(stor30.length) * 0.5) + _164 + 69 len ceil32(_10529) + 32]
        if 31 >= stor30.length.field_1:
            mem[128] = 256 * stor30.length.field_8
            if not stor31:
                if not arg1:
                    mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                    mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                        return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                    mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 0, 17
                        if 48 > !(idx % 10):
                            revert with 0, 17
                        if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            revert with 0, 50
                        mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                    if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                        if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                            _13762 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13762)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13762)]
                            if ceil32(_13762) > _13762:
                                mem[_13762 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13762) + 32], 
                        _13763 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13763)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13763)]
                        if ceil32(_13763) > _13763:
                            mem[_13763 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13763) + 32], 
                    mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13764 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13764)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13764)]
                        if ceil32(_13764) > _13764:
                            mem[_13764 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13764) + 32], 
                    _13765 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13765)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13765)]
                    if ceil32(_13765) > _13765:
                        mem[_13765 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13765) + 32], 
                mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _13766 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13766)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13766)]
                        if ceil32(_13766) > _13766:
                            mem[_13766 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13766) + 32], 
                    _13767 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13767)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13767)]
                    if ceil32(_13767) > _13767:
                        mem[_13767 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13767) + 32], 
                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    _13768 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13768)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13768)]
                    if ceil32(_13768) > _13768:
                        mem[_13768 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13768) + 32], 
                _13769 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_13769)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_13769)]
                if ceil32(_13769) > _13769:
                    mem[_13769 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_13769) + 32], 
            mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _167 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _211 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _211
            require _167 + _211 + 32 <= return_data.size
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_211)] = mem[ceil32(uint255(stor30.length) * 0.5) + _167 + 160 len ceil32(_211)]
            if ceil32(_211) <= _211:
                _2568 = mem[64]
                mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_211)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_211)]
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_211) <= _211:
                        _9830 = mem[64]
                        mem[64] = _2568 + (uint255(stor30.length) * 0.5) + _211 + 37
                        mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                        _10554 = mem[_9830]
                        mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9830]
                        mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10554)] = mem[_9830 + 32 len ceil32(_10554)]
                        if ceil32(_10554) > _10554:
                            mem[_10554 + _2568 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                        return 32, mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10554) + 32]
                    _9831 = mem[64]
                    mem[64] = _2568 + (uint255(stor30.length) * 0.5) + _211 + 37
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                    _10555 = mem[_9831]
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9831]
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10555)] = mem[_9831 + 32 len ceil32(_10555)]
                    if ceil32(_10555) > _10555:
                        mem[_10555 + _2568 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                    return 32, mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10555) + 32]
                mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
                mem[_2568 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_211)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_211)]
                mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_211) <= _211:
                    _9832 = mem[64]
                    mem[64] = _2568 + (uint255(stor30.length) * 0.5) + _211 + 37
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                    _10556 = mem[_9832]
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9832]
                    mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10556)] = mem[_9832 + 32 len ceil32(_10556)]
                    if ceil32(_10556) > _10556:
                        mem[_10556 + _2568 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                    return 32, mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10556) + 32]
                _9833 = mem[64]
                mem[64] = _2568 + (uint255(stor30.length) * 0.5) + _211 + 37
                mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                _10557 = mem[_9833]
                mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9833]
                mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10557)] = mem[_9833 + 32 len ceil32(_10557)]
                if ceil32(_10557) > _10557:
                    mem[_10557 + _2568 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                return 32, mem[_2568 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10557) + 32]
            mem[_211 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
            _2569 = mem[64]
            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_211)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_211)]
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_211) <= _211:
                    _9834 = mem[64]
                    mem[64] = _2569 + (uint255(stor30.length) * 0.5) + _211 + 37
                    mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                    _10558 = mem[_9834]
                    mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9834]
                    mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10558)] = mem[_9834 + 32 len ceil32(_10558)]
                    if ceil32(_10558) > _10558:
                        mem[_10558 + _2569 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                    return 32, mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10558) + 32]
                _9835 = mem[64]
                mem[64] = _2569 + (uint255(stor30.length) * 0.5) + _211 + 37
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                _10559 = mem[_9835]
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9835]
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10559)] = mem[_9835 + 32 len ceil32(_10559)]
                if ceil32(_10559) > _10559:
                    mem[_10559 + _2569 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                return 32, mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10559) + 32]
            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
            mem[_2569 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_211)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_211)]
            mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_211) <= _211:
                _9836 = mem[64]
                mem[64] = _2569 + (uint255(stor30.length) * 0.5) + _211 + 37
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
                _10560 = mem[_9836]
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9836]
                mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10560)] = mem[_9836 + 32 len ceil32(_10560)]
                if ceil32(_10560) > _10560:
                    mem[_10560 + _2569 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
                return 32, mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10560) + 32]
            _9837 = mem[64]
            mem[64] = _2569 + (uint255(stor30.length) * 0.5) + _211 + 37
            mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 37] = 32
            _10561 = mem[_9837]
            mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69] = mem[_9837]
            mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 101 len ceil32(_10561)] = mem[_9837 + 32 len ceil32(_10561)]
            if ceil32(_10561) > _10561:
                mem[_10561 + _2569 + (uint255(stor30.length) * 0.5) + _211 + 101] = 0
            return 32, mem[_2569 + (uint255(stor30.length) * 0.5) + _211 + 69 len ceil32(_10561) + 32]
        mem[0] = 30
        mem[128] = uint256(stor30.field_0)
        idx = 128
        s = 0
        while stor30.length.field_1 + 96 > idx:
            mem[idx + 32] = stor30[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        if not stor31:
            if not arg1:
                mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 230] = 32
                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262] = mem[ceil32(uint255(stor30.length) * 0.5) + 192]
                mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])] = mem[ceil32(uint255(stor30.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 192]:
                    return Array(len=mem[ceil32(uint255(stor30.length) * 0.5) + 192], data=mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192])]), 
                mem[mem[ceil32(uint255(stor30.length) * 0.5) + 192] + ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 294] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + (uint255(stor30.length) * 0.5) + 262 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 192]) + 32], 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 0, 65
            mem[ceil32(uint255(stor30.length) * 0.5) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
                if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                    if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                        _15506 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15506)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15506)]
                        if ceil32(_15506) > _15506:
                            mem[_15506 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                        return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15506) + 32], 
                    _15507 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15507)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15507)]
                    if ceil32(_15507) > _15507:
                        mem[_15507 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15507) + 32], 
                mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    _15508 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15508)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15508)]
                    if ceil32(_15508) > _15508:
                        mem[_15508 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15508) + 32], 
                _15509 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15509)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15509)]
                if ceil32(_15509) > _15509:
                    mem[_15509 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15509) + 32], 
            mem[ceil32(uint255(stor30.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    revert with 0, 50
                mem[t + ceil32(uint255(stor30.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
                if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                    _15510 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                    mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15510)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15510)]
                    if ceil32(_15510) > _15510:
                        mem[_15510 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                    return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15510) + 32], 
                _15511 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15511)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15511)]
                if ceil32(_15511) > _15511:
                    mem[_15511 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15511) + 32], 
            mem[(uint255(stor30.length) * 0.5) + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192] = 0
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])] = mem[ceil32(uint255(stor30.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128])]
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 197] = 32
            if ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + 128]) <= mem[ceil32(uint255(stor30.length) * 0.5) + 128]:
                _15512 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
                mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15512)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15512)]
                if ceil32(_15512) > _15512:
                    mem[_15512 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
                return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15512) + 32], 
            _15513 = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 160]
            mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261 len ceil32(_15513)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + 192 len ceil32(_15513)]
            if ceil32(_15513) > _15513:
                mem[_15513 + ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 261] = 0
            return 32, mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(s) + (uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128] + 229 len ceil32(_15513) + 32], 
        mem[ceil32(uint255(stor30.length) * 0.5) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
        mem[ceil32(uint255(stor30.length) * 0.5) + 132] = arg1
        require ext_code.size(stor31)
        staticcall stor31.0xff74ef30 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(uint255(stor30.length) * 0.5) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128
        require return_data.size >= 32
        _2736 = mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32
        require mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require ceil32(uint255(stor30.length) * 0.5) + return_data.size + 128 > ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
        _2899 = mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        if mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(uint255(stor30.length) * 0.5) + mem[ceil32(uint255(stor30.length) * 0.5) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 128] = _2899
        require _2736 + _2899 + 32 <= return_data.size
        mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2899)] = mem[ceil32(uint255(stor30.length) * 0.5) + _2736 + 160 len ceil32(_2899)]
        if ceil32(_2899) <= _2899:
            _6054 = mem[64]
            mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
            if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
                mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2899)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2899)]
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2899) <= _2899:
                    _12970 = mem[64]
                    mem[64] = _6054 + (uint255(stor30.length) * 0.5) + _2899 + 37
                    mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
                    _13746 = mem[_12970]
                    mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12970]
                    mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13746)] = mem[_12970 + 32 len ceil32(_13746)]
                    if ceil32(_13746) > _13746:
                        mem[_13746 + _6054 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
                    return 32, mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13746) + 32]
                _12971 = mem[64]
                mem[64] = _6054 + (uint255(stor30.length) * 0.5) + _2899 + 37
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
                _13747 = mem[_12971]
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12971]
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13747)] = mem[_12971 + 32 len ceil32(_13747)]
                if ceil32(_13747) > _13747:
                    mem[_13747 + _6054 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
                return 32, mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13747) + 32]
            mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
            mem[_6054 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2899)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2899)]
            mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2899) <= _2899:
                _12972 = mem[64]
                mem[64] = _6054 + (uint255(stor30.length) * 0.5) + _2899 + 37
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
                _13748 = mem[_12972]
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12972]
                mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13748)] = mem[_12972 + 32 len ceil32(_13748)]
                if ceil32(_13748) > _13748:
                    mem[_13748 + _6054 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
                return 32, mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13748) + 32]
            _12973 = mem[64]
            mem[64] = _6054 + (uint255(stor30.length) * 0.5) + _2899 + 37
            mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
            _13749 = mem[_12973]
            mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12973]
            mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13749)] = mem[_12973 + 32 len ceil32(_13749)]
            if ceil32(_13749) > _13749:
                mem[_13749 + _6054 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
            return 32, mem[_6054 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13749) + 32]
        mem[_2899 + ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160] = 0
        _6055 = mem[64]
        mem[mem[64] + 32 len ceil32(uint255(stor30.length) * 0.5)] = mem[128 len ceil32(uint255(stor30.length) * 0.5)]
        if ceil32(uint255(stor30.length) * 0.5) <= uint255(stor30.length) * 0.5:
            mem[mem[64] + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2899)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2899)]
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2899) <= _2899:
                _12974 = mem[64]
                mem[64] = _6055 + (uint255(stor30.length) * 0.5) + _2899 + 37
                mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
                _13750 = mem[_12974]
                mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12974]
                mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13750)] = mem[_12974 + 32 len ceil32(_13750)]
                if ceil32(_13750) > _13750:
                    mem[_13750 + _6055 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
                return 32, mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13750) + 32]
            _12975 = mem[64]
            mem[64] = _6055 + (uint255(stor30.length) * 0.5) + _2899 + 37
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
            _13751 = mem[_12975]
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12975]
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13751)] = mem[_12975 + 32 len ceil32(_13751)]
            if ceil32(_13751) > _13751:
                mem[_13751 + _6055 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
            return 32, mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13751) + 32]
        mem[(uint255(stor30.length) * 0.5) + mem[64] + 32] = 0
        mem[_6055 + (uint255(stor30.length) * 0.5) + 32 len ceil32(_2899)] = mem[ceil32(uint255(stor30.length) * 0.5) + ceil32(return_data.size) + 160 len ceil32(_2899)]
        mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_2899) <= _2899:
            _12976 = mem[64]
            mem[64] = _6055 + (uint255(stor30.length) * 0.5) + _2899 + 37
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
            _13752 = mem[_12976]
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12976]
            mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13752)] = mem[_12976 + 32 len ceil32(_13752)]
            if ceil32(_13752) > _13752:
                mem[_13752 + _6055 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
            return 32, mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13752) + 32]
        _12977 = mem[64]
        mem[64] = _6055 + (uint255(stor30.length) * 0.5) + _2899 + 37
        mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 37] = 32
        _13753 = mem[_12977]
        mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69] = mem[_12977]
        mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 101 len ceil32(_13753)] = mem[_12977 + 32 len ceil32(_13753)]
        if ceil32(_13753) > _13753:
            mem[_13753 + _6055 + (uint255(stor30.length) * 0.5) + _2899 + 101] = 0
        return 32, mem[_6055 + (uint255(stor30.length) * 0.5) + _2899 + 69 len ceil32(_13753) + 32]
    if bool(stor30.length) == stor30.length.field_1 < 32:
        revert with 0, 34
    mem[96] = stor30.length.field_1
    if bool(stor30.length):
        if bool(stor30.length) == uint255(stor30.length) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, stor30.length):
            if not stor31:
                if not arg1:
                    mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                    mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(stor30.length.field_1) + 128] = s
                if s:
                    mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) > stor30.length.field_1:
                    mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                    return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) + 32], 
            mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _121 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _169 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            require _121 + _169 + 32 <= return_data.size
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_169)] = mem[ceil32(stor30.length.field_1) + _121 + 160 len ceil32(_169)]
            if ceil32(_169) <= _169:
                _2570 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    _5950 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5950 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5950) <= _5950:
                        _9838 = mem[64]
                        mem[64] = _2570 + stor30.length.field_1 + _5950 + 37
                        mem[_2570 + stor30.length.field_1 + _5950 + 37] = 32
                        _10570 = mem[_9838]
                        mem[_2570 + stor30.length.field_1 + _5950 + 69] = mem[_9838]
                        mem[_2570 + stor30.length.field_1 + _5950 + 101 len ceil32(_10570)] = mem[_9838 + 32 len ceil32(_10570)]
                        if ceil32(_10570) > _10570:
                            mem[_10570 + _2570 + stor30.length.field_1 + _5950 + 101] = 0
                        return 32, mem[_2570 + stor30.length.field_1 + _5950 + 69 len ceil32(_10570) + 32]
                    _9839 = mem[64]
                    mem[64] = _2570 + stor30.length.field_1 + _5950 + 37
                    mem[_2570 + stor30.length.field_1 + _5950 + 37] = 32
                    _10571 = mem[_9839]
                    mem[_2570 + stor30.length.field_1 + _5950 + 69] = mem[_9839]
                    mem[_2570 + stor30.length.field_1 + _5950 + 101 len ceil32(_10571)] = mem[_9839 + 32 len ceil32(_10571)]
                    if ceil32(_10571) > _10571:
                        mem[_10571 + _2570 + stor30.length.field_1 + _5950 + 101] = 0
                    return 32, mem[_2570 + stor30.length.field_1 + _5950 + 69 len ceil32(_10571) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                _5951 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5951 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5951) <= _5951:
                    _9840 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5951 + 37
                    mem[_2570 + stor30.length.field_1 + _5951 + 37] = 32
                    _10572 = mem[_9840]
                    mem[_2570 + stor30.length.field_1 + _5951 + 69] = mem[_9840]
                    mem[_2570 + stor30.length.field_1 + _5951 + 101 len ceil32(_10572)] = mem[_9840 + 32 len ceil32(_10572)]
                    if ceil32(_10572) > _10572:
                        mem[_10572 + _2570 + stor30.length.field_1 + _5951 + 101] = 0
                    return 32, mem[_2570 + stor30.length.field_1 + _5951 + 69 len ceil32(_10572) + 32]
                _9841 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5951 + 37
                mem[_2570 + stor30.length.field_1 + _5951 + 37] = 32
                _10573 = mem[_9841]
                mem[_2570 + stor30.length.field_1 + _5951 + 69] = mem[_9841]
                mem[_2570 + stor30.length.field_1 + _5951 + 101 len ceil32(_10573)] = mem[_9841 + 32 len ceil32(_10573)]
                if ceil32(_10573) > _10573:
                    mem[_10573 + _2570 + stor30.length.field_1 + _5951 + 101] = 0
                return 32, mem[_2570 + stor30.length.field_1 + _5951 + 69 len ceil32(_10573) + 32]
            mem[_169 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
            _2571 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                _5952 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5952 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5952) <= _5952:
                    _9842 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5952 + 37
                    mem[_2571 + stor30.length.field_1 + _5952 + 37] = 32
                    _10574 = mem[_9842]
                    mem[_2571 + stor30.length.field_1 + _5952 + 69] = mem[_9842]
                    mem[_2571 + stor30.length.field_1 + _5952 + 101 len ceil32(_10574)] = mem[_9842 + 32 len ceil32(_10574)]
                    if ceil32(_10574) > _10574:
                        mem[_10574 + _2571 + stor30.length.field_1 + _5952 + 101] = 0
                    return 32, mem[_2571 + stor30.length.field_1 + _5952 + 69 len ceil32(_10574) + 32]
                _9843 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5952 + 37
                mem[_2571 + stor30.length.field_1 + _5952 + 37] = 32
                _10575 = mem[_9843]
                mem[_2571 + stor30.length.field_1 + _5952 + 69] = mem[_9843]
                mem[_2571 + stor30.length.field_1 + _5952 + 101 len ceil32(_10575)] = mem[_9843 + 32 len ceil32(_10575)]
                if ceil32(_10575) > _10575:
                    mem[_10575 + _2571 + stor30.length.field_1 + _5952 + 101] = 0
                return 32, mem[_2571 + stor30.length.field_1 + _5952 + 69 len ceil32(_10575) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            _5953 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5953 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5953) <= _5953:
                _9844 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5953 + 37
                mem[_2571 + stor30.length.field_1 + _5953 + 37] = 32
                _10576 = mem[_9844]
                mem[_2571 + stor30.length.field_1 + _5953 + 69] = mem[_9844]
                mem[_2571 + stor30.length.field_1 + _5953 + 101 len ceil32(_10576)] = mem[_9844 + 32 len ceil32(_10576)]
                if ceil32(_10576) > _10576:
                    mem[_10576 + _2571 + stor30.length.field_1 + _5953 + 101] = 0
                return 32, mem[_2571 + stor30.length.field_1 + _5953 + 69 len ceil32(_10576) + 32]
            _9845 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5953 + 37
            mem[_2571 + stor30.length.field_1 + _5953 + 37] = 32
            _10577 = mem[_9845]
            mem[_2571 + stor30.length.field_1 + _5953 + 69] = mem[_9845]
            mem[_2571 + stor30.length.field_1 + _5953 + 101 len ceil32(_10577)] = mem[_9845 + 32 len ceil32(_10577)]
            if ceil32(_10577) > _10577:
                mem[_10577 + _2571 + stor30.length.field_1 + _5953 + 101] = 0
            return 32, mem[_2571 + stor30.length.field_1 + _5953 + 69 len ceil32(_10577) + 32]
        if 31 >= uint255(stor30.length) * 0.5:
            mem[128] = 256 * stor30.length.field_8
            if not stor31:
                if not arg1:
                    mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                    mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                    if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                        return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                    mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                    return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 0, 65
                mem[ceil32(stor30.length.field_1) + 128] = s
                if s:
                    mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 0, 17
                    if 48 > !(idx % 10):
                        revert with 0, 17
                    if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                        revert with 0, 50
                    mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) > stor30.length.field_1:
                    mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
                mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
                return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
            mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + 132] = arg1
            require ext_code.size(stor31)
            staticcall stor31.0xff74ef30 with:
                    gas gas_remaining wei
                   args arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
            require return_data.size >= 32
            _172 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
            require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
            _215 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
            require _172 + _215 + 32 <= return_data.size
            mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_215)] = mem[ceil32(stor30.length.field_1) + _172 + 160 len ceil32(_215)]
            if ceil32(_215) <= _215:
                _2574 = mem[64]
                mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                    _5958 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                    mem[mem[64] + stor30.length.field_1 + _5958 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                    if ceil32(_5958) <= _5958:
                        _9852 = mem[64]
                        mem[64] = mem[64] + stor30.length.field_1 + _5958 + 37
                        mem[_2574 + stor30.length.field_1 + _5958 + 37] = 32
                        _10602 = mem[_9852]
                        mem[_2574 + stor30.length.field_1 + _5958 + 69] = mem[_9852]
                        mem[_2574 + stor30.length.field_1 + _5958 + 101 len ceil32(_10602)] = mem[_9852 + 32 len ceil32(_10602)]
                        if ceil32(_10602) > _10602:
                            mem[_10602 + _2574 + stor30.length.field_1 + _5958 + 101] = 0
                        return 32, mem[_2574 + stor30.length.field_1 + _5958 + 69 len ceil32(_10602) + 32]
                    _9853 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5958 + 37
                    mem[_2574 + stor30.length.field_1 + _5958 + 37] = 32
                    _10603 = mem[_9853]
                    mem[_2574 + stor30.length.field_1 + _5958 + 69] = mem[_9853]
                    mem[_2574 + stor30.length.field_1 + _5958 + 101 len ceil32(_10603)] = mem[_9853 + 32 len ceil32(_10603)]
                    if ceil32(_10603) > _10603:
                        mem[_10603 + _2574 + stor30.length.field_1 + _5958 + 101] = 0
                    return 32, mem[_2574 + stor30.length.field_1 + _5958 + 69 len ceil32(_10603) + 32]
                mem[stor30.length.field_1 + mem[64] + 32] = 0
                _5959 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5959 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5959) <= _5959:
                    _9854 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5959 + 37
                    mem[_2574 + stor30.length.field_1 + _5959 + 37] = 32
                    _10604 = mem[_9854]
                    mem[_2574 + stor30.length.field_1 + _5959 + 69] = mem[_9854]
                    mem[_2574 + stor30.length.field_1 + _5959 + 101 len ceil32(_10604)] = mem[_9854 + 32 len ceil32(_10604)]
                    if ceil32(_10604) > _10604:
                        mem[_10604 + _2574 + stor30.length.field_1 + _5959 + 101] = 0
                    return 32, mem[_2574 + stor30.length.field_1 + _5959 + 69 len ceil32(_10604) + 32]
                _9855 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5959 + 37
                mem[_2574 + stor30.length.field_1 + _5959 + 37] = 32
                _10605 = mem[_9855]
                mem[_2574 + stor30.length.field_1 + _5959 + 69] = mem[_9855]
                mem[_2574 + stor30.length.field_1 + _5959 + 101 len ceil32(_10605)] = mem[_9855 + 32 len ceil32(_10605)]
                if ceil32(_10605) > _10605:
                    mem[_10605 + _2574 + stor30.length.field_1 + _5959 + 101] = 0
                return 32, mem[_2574 + stor30.length.field_1 + _5959 + 69 len ceil32(_10605) + 32]
            mem[_215 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
            _2575 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                _5960 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5960 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5960) <= _5960:
                    _9856 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5960 + 37
                    mem[_2575 + stor30.length.field_1 + _5960 + 37] = 32
                    _10606 = mem[_9856]
                    mem[_2575 + stor30.length.field_1 + _5960 + 69] = mem[_9856]
                    mem[_2575 + stor30.length.field_1 + _5960 + 101 len ceil32(_10606)] = mem[_9856 + 32 len ceil32(_10606)]
                    if ceil32(_10606) > _10606:
                        mem[_10606 + _2575 + stor30.length.field_1 + _5960 + 101] = 0
                    return 32, mem[_2575 + stor30.length.field_1 + _5960 + 69 len ceil32(_10606) + 32]
                _9857 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5960 + 37
                mem[_2575 + stor30.length.field_1 + _5960 + 37] = 32
                _10607 = mem[_9857]
                mem[_2575 + stor30.length.field_1 + _5960 + 69] = mem[_9857]
                mem[_2575 + stor30.length.field_1 + _5960 + 101 len ceil32(_10607)] = mem[_9857 + 32 len ceil32(_10607)]
                if ceil32(_10607) > _10607:
                    mem[_10607 + _2575 + stor30.length.field_1 + _5960 + 101] = 0
                return 32, mem[_2575 + stor30.length.field_1 + _5960 + 69 len ceil32(_10607) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            _5961 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5961 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5961) <= _5961:
                _9858 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5961 + 37
                mem[_2575 + stor30.length.field_1 + _5961 + 37] = 32
                _10608 = mem[_9858]
                mem[_2575 + stor30.length.field_1 + _5961 + 69] = mem[_9858]
                mem[_2575 + stor30.length.field_1 + _5961 + 101 len ceil32(_10608)] = mem[_9858 + 32 len ceil32(_10608)]
                if ceil32(_10608) > _10608:
                    mem[_10608 + _2575 + stor30.length.field_1 + _5961 + 101] = 0
                return 32, mem[_2575 + stor30.length.field_1 + _5961 + 69 len ceil32(_10608) + 32]
            _9859 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5961 + 37
            mem[_2575 + stor30.length.field_1 + _5961 + 37] = 32
            _10609 = mem[_9859]
            mem[_2575 + stor30.length.field_1 + _5961 + 69] = mem[_9859]
            mem[_2575 + stor30.length.field_1 + _5961 + 101 len ceil32(_10609)] = mem[_9859 + 32 len ceil32(_10609)]
            if ceil32(_10609) > _10609:
                mem[_10609 + _2575 + stor30.length.field_1 + _5961 + 101] = 0
            return 32, mem[_2575 + stor30.length.field_1 + _5961 + 69 len ceil32(_10609) + 32]
        mem[0] = 30
        mem[128] = uint256(stor30.field_0)
        idx = 128
        s = 0
        while (uint255(stor30.length) * 0.5) + 96 > idx:
            mem[idx + 32] = stor30[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        if not stor31:
            if not arg1:
                mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                    return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 0, 65
            mem[ceil32(stor30.length.field_1) + 128] = s
            if s:
                mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                    revert with 0, 50
                mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) > stor30.length.field_1:
                mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
            return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
        mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
        mem[ceil32(stor30.length.field_1) + 132] = arg1
        require ext_code.size(stor31)
        staticcall stor31.0xff74ef30 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
        require return_data.size >= 32
        _2746 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
        require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
        _2908 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        require _2746 + _2908 + 32 <= return_data.size
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2908)] = mem[ceil32(stor30.length.field_1) + _2746 + 160 len ceil32(_2908)]
        if ceil32(_2908) <= _2908:
            _6068 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2908)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2908)]
                mem[mem[64] + stor30.length.field_1 + _2908 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_2908) <= _2908:
                    _12994 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
                    mem[_6068 + stor30.length.field_1 + _2908 + 37] = 32
                    _13778 = mem[_12994]
                    mem[_6068 + stor30.length.field_1 + _2908 + 69] = mem[_12994]
                    mem[_6068 + stor30.length.field_1 + _2908 + 101 len ceil32(_13778)] = mem[_12994 + 32 len ceil32(_13778)]
                    if ceil32(_13778) > _13778:
                        mem[_13778 + _6068 + stor30.length.field_1 + _2908 + 101] = 0
                    return 32, mem[_6068 + stor30.length.field_1 + _2908 + 69 len ceil32(_13778) + 32]
                _12995 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
                mem[_6068 + stor30.length.field_1 + _2908 + 37] = 32
                _13779 = mem[_12995]
                mem[_6068 + stor30.length.field_1 + _2908 + 69] = mem[_12995]
                mem[_6068 + stor30.length.field_1 + _2908 + 101 len ceil32(_13779)] = mem[_12995 + 32 len ceil32(_13779)]
                if ceil32(_13779) > _13779:
                    mem[_13779 + _6068 + stor30.length.field_1 + _2908 + 101] = 0
                return 32, mem[_6068 + stor30.length.field_1 + _2908 + 69 len ceil32(_13779) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2908)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2908)]
            mem[mem[64] + stor30.length.field_1 + _2908 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2908) <= _2908:
                _12996 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
                mem[_6068 + stor30.length.field_1 + _2908 + 37] = 32
                _13780 = mem[_12996]
                mem[_6068 + stor30.length.field_1 + _2908 + 69] = mem[_12996]
                mem[_6068 + stor30.length.field_1 + _2908 + 101 len ceil32(_13780)] = mem[_12996 + 32 len ceil32(_13780)]
                if ceil32(_13780) > _13780:
                    mem[_13780 + _6068 + stor30.length.field_1 + _2908 + 101] = 0
                return 32, mem[_6068 + stor30.length.field_1 + _2908 + 69 len ceil32(_13780) + 32]
            _12997 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
            mem[_6068 + stor30.length.field_1 + _2908 + 37] = 32
            _13781 = mem[_12997]
            mem[_6068 + stor30.length.field_1 + _2908 + 69] = mem[_12997]
            mem[_6068 + stor30.length.field_1 + _2908 + 101 len ceil32(_13781)] = mem[_12997 + 32 len ceil32(_13781)]
            if ceil32(_13781) > _13781:
                mem[_13781 + _6068 + stor30.length.field_1 + _2908 + 101] = 0
            return 32, mem[_6068 + stor30.length.field_1 + _2908 + 69 len ceil32(_13781) + 32]
        mem[_2908 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
        _6069 = mem[64]
        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2908)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2908)]
            mem[mem[64] + stor30.length.field_1 + _2908 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2908) <= _2908:
                _12998 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
                mem[_6069 + stor30.length.field_1 + _2908 + 37] = 32
                _13782 = mem[_12998]
                mem[_6069 + stor30.length.field_1 + _2908 + 69] = mem[_12998]
                mem[_6069 + stor30.length.field_1 + _2908 + 101 len ceil32(_13782)] = mem[_12998 + 32 len ceil32(_13782)]
                if ceil32(_13782) > _13782:
                    mem[_13782 + _6069 + stor30.length.field_1 + _2908 + 101] = 0
                return 32, mem[_6069 + stor30.length.field_1 + _2908 + 69 len ceil32(_13782) + 32]
            _12999 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
            mem[_6069 + stor30.length.field_1 + _2908 + 37] = 32
            _13783 = mem[_12999]
            mem[_6069 + stor30.length.field_1 + _2908 + 69] = mem[_12999]
            mem[_6069 + stor30.length.field_1 + _2908 + 101 len ceil32(_13783)] = mem[_12999 + 32 len ceil32(_13783)]
            if ceil32(_13783) > _13783:
                mem[_13783 + _6069 + stor30.length.field_1 + _2908 + 101] = 0
            return 32, mem[_6069 + stor30.length.field_1 + _2908 + 69 len ceil32(_13783) + 32]
        mem[stor30.length.field_1 + mem[64] + 32] = 0
        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2908)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2908)]
        mem[mem[64] + stor30.length.field_1 + _2908 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_2908) <= _2908:
            _13000 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
            mem[_6069 + stor30.length.field_1 + _2908 + 37] = 32
            _13784 = mem[_13000]
            mem[_6069 + stor30.length.field_1 + _2908 + 69] = mem[_13000]
            mem[_6069 + stor30.length.field_1 + _2908 + 101 len ceil32(_13784)] = mem[_13000 + 32 len ceil32(_13784)]
            if ceil32(_13784) > _13784:
                mem[_13784 + _6069 + stor30.length.field_1 + _2908 + 101] = 0
            return 32, mem[_6069 + stor30.length.field_1 + _2908 + 69 len ceil32(_13784) + 32]
        _13001 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _2908 + 37
        mem[_6069 + stor30.length.field_1 + _2908 + 37] = 32
        _13785 = mem[_13001]
        mem[_6069 + stor30.length.field_1 + _2908 + 69] = mem[_13001]
        mem[_6069 + stor30.length.field_1 + _2908 + 101 len ceil32(_13785)] = mem[_13001 + 32 len ceil32(_13785)]
        if ceil32(_13785) > _13785:
            mem[_13785 + _6069 + stor30.length.field_1 + _2908 + 101] = 0
        return 32, mem[_6069 + stor30.length.field_1 + _2908 + 69 len ceil32(_13785) + 32]
    if bool(stor30.length) == stor30.length.field_1 < 32:
        revert with 0, 34
    if not stor30.length.field_1:
        if not stor31:
            if not arg1:
                mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                    return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 0, 65
            mem[ceil32(stor30.length.field_1) + 128] = s
            if s:
                mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                    revert with 0, 50
                mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) > stor30.length.field_1:
                mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) <= mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
            return 32, mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) + 32], 
        mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
        mem[ceil32(stor30.length.field_1) + 132] = arg1
        require ext_code.size(stor31)
        staticcall stor31.0xff74ef30 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
        require return_data.size >= 32
        _146 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
        require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
        _191 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        require _146 + _191 + 32 <= return_data.size
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_191)] = mem[ceil32(stor30.length.field_1) + _146 + 160 len ceil32(_191)]
        if ceil32(_191) <= _191:
            _2576 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                _5964 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5964 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5964) <= _5964:
                    _9860 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5964 + 37
                    mem[_2576 + stor30.length.field_1 + _5964 + 37] = 32
                    _10618 = mem[_9860]
                    mem[_2576 + stor30.length.field_1 + _5964 + 69] = mem[_9860]
                    mem[_2576 + stor30.length.field_1 + _5964 + 101 len ceil32(_10618)] = mem[_9860 + 32 len ceil32(_10618)]
                    if ceil32(_10618) > _10618:
                        mem[_10618 + _2576 + stor30.length.field_1 + _5964 + 101] = 0
                    return 32, mem[_2576 + stor30.length.field_1 + _5964 + 69 len ceil32(_10618) + 32]
                _9861 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5964 + 37
                mem[_2576 + stor30.length.field_1 + _5964 + 37] = 32
                _10619 = mem[_9861]
                mem[_2576 + stor30.length.field_1 + _5964 + 69] = mem[_9861]
                mem[_2576 + stor30.length.field_1 + _5964 + 101 len ceil32(_10619)] = mem[_9861 + 32 len ceil32(_10619)]
                if ceil32(_10619) > _10619:
                    mem[_10619 + _2576 + stor30.length.field_1 + _5964 + 101] = 0
                return 32, mem[_2576 + stor30.length.field_1 + _5964 + 69 len ceil32(_10619) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            _5965 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5965 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5965) <= _5965:
                _9862 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5965 + 37
                mem[_2576 + stor30.length.field_1 + _5965 + 37] = 32
                _10620 = mem[_9862]
                mem[_2576 + stor30.length.field_1 + _5965 + 69] = mem[_9862]
                mem[_2576 + stor30.length.field_1 + _5965 + 101 len ceil32(_10620)] = mem[_9862 + 32 len ceil32(_10620)]
                if ceil32(_10620) > _10620:
                    mem[_10620 + _2576 + stor30.length.field_1 + _5965 + 101] = 0
                return 32, mem[_2576 + stor30.length.field_1 + _5965 + 69 len ceil32(_10620) + 32]
            _9863 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5965 + 37
            mem[_2576 + stor30.length.field_1 + _5965 + 37] = 32
            _10621 = mem[_9863]
            mem[_2576 + stor30.length.field_1 + _5965 + 69] = mem[_9863]
            mem[_2576 + stor30.length.field_1 + _5965 + 101 len ceil32(_10621)] = mem[_9863 + 32 len ceil32(_10621)]
            if ceil32(_10621) > _10621:
                mem[_10621 + _2576 + stor30.length.field_1 + _5965 + 101] = 0
            return 32, mem[_2576 + stor30.length.field_1 + _5965 + 69 len ceil32(_10621) + 32]
        mem[_191 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
        _2577 = mem[64]
        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
            _5966 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5966 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5966) <= _5966:
                _9864 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5966 + 37
                mem[_2577 + stor30.length.field_1 + _5966 + 37] = 32
                _10622 = mem[_9864]
                mem[_2577 + stor30.length.field_1 + _5966 + 69] = mem[_9864]
                mem[_2577 + stor30.length.field_1 + _5966 + 101 len ceil32(_10622)] = mem[_9864 + 32 len ceil32(_10622)]
                if ceil32(_10622) > _10622:
                    mem[_10622 + _2577 + stor30.length.field_1 + _5966 + 101] = 0
                return 32, mem[_2577 + stor30.length.field_1 + _5966 + 69 len ceil32(_10622) + 32]
            _9865 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5966 + 37
            mem[_2577 + stor30.length.field_1 + _5966 + 37] = 32
            _10623 = mem[_9865]
            mem[_2577 + stor30.length.field_1 + _5966 + 69] = mem[_9865]
            mem[_2577 + stor30.length.field_1 + _5966 + 101 len ceil32(_10623)] = mem[_9865 + 32 len ceil32(_10623)]
            if ceil32(_10623) > _10623:
                mem[_10623 + _2577 + stor30.length.field_1 + _5966 + 101] = 0
            return 32, mem[_2577 + stor30.length.field_1 + _5966 + 69 len ceil32(_10623) + 32]
        mem[stor30.length.field_1 + mem[64] + 32] = 0
        _5967 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
        mem[mem[64] + stor30.length.field_1 + _5967 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_5967) <= _5967:
            _9866 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5967 + 37
            mem[_2577 + stor30.length.field_1 + _5967 + 37] = 32
            _10624 = mem[_9866]
            mem[_2577 + stor30.length.field_1 + _5967 + 69] = mem[_9866]
            mem[_2577 + stor30.length.field_1 + _5967 + 101 len ceil32(_10624)] = mem[_9866 + 32 len ceil32(_10624)]
            if ceil32(_10624) > _10624:
                mem[_10624 + _2577 + stor30.length.field_1 + _5967 + 101] = 0
            return 32, mem[_2577 + stor30.length.field_1 + _5967 + 69 len ceil32(_10624) + 32]
        _9867 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _5967 + 37
        mem[_2577 + stor30.length.field_1 + _5967 + 37] = 32
        _10625 = mem[_9867]
        mem[_2577 + stor30.length.field_1 + _5967 + 69] = mem[_9867]
        mem[_2577 + stor30.length.field_1 + _5967 + 101 len ceil32(_10625)] = mem[_9867 + 32 len ceil32(_10625)]
        if ceil32(_10625) > _10625:
            mem[_10625 + _2577 + stor30.length.field_1 + _5967 + 101] = 0
        return 32, mem[_2577 + stor30.length.field_1 + _5967 + 69 len ceil32(_10625) + 32]
    if 31 >= stor30.length.field_1:
        mem[128] = 256 * stor30.length.field_8
        if not stor31:
            if not arg1:
                mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
                mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
                if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                    return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
                mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
                return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 0, 65
            mem[ceil32(stor30.length.field_1) + 128] = s
            if s:
                mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                    revert with 0, 50
                mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) > stor30.length.field_1:
                mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
            mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
                mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
            return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
        mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
        mem[ceil32(stor30.length.field_1) + 132] = arg1
        require ext_code.size(stor31)
        staticcall stor31.0xff74ef30 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
        require return_data.size >= 32
        _194 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
        require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
        _238 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
        require _194 + _238 + 32 <= return_data.size
        mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_238)] = mem[ceil32(stor30.length.field_1) + _194 + 160 len ceil32(_238)]
        if ceil32(_238) <= _238:
            _2580 = mem[64]
            mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            if ceil32(stor30.length.field_1) <= stor30.length.field_1:
                _5972 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
                mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
                mem[mem[64] + stor30.length.field_1 + _5972 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_5972) <= _5972:
                    _9874 = mem[64]
                    mem[64] = mem[64] + stor30.length.field_1 + _5972 + 37
                    mem[_2580 + stor30.length.field_1 + _5972 + 37] = 32
                    _10650 = mem[_9874]
                    mem[_2580 + stor30.length.field_1 + _5972 + 69] = mem[_9874]
                    mem[_2580 + stor30.length.field_1 + _5972 + 101 len ceil32(_10650)] = mem[_9874 + 32 len ceil32(_10650)]
                    if ceil32(_10650) > _10650:
                        mem[_10650 + _2580 + stor30.length.field_1 + _5972 + 101] = 0
                    return 32, mem[_2580 + stor30.length.field_1 + _5972 + 69 len ceil32(_10650) + 32]
                _9875 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5972 + 37
                mem[_2580 + stor30.length.field_1 + _5972 + 37] = 32
                _10651 = mem[_9875]
                mem[_2580 + stor30.length.field_1 + _5972 + 69] = mem[_9875]
                mem[_2580 + stor30.length.field_1 + _5972 + 101 len ceil32(_10651)] = mem[_9875 + 32 len ceil32(_10651)]
                if ceil32(_10651) > _10651:
                    mem[_10651 + _2580 + stor30.length.field_1 + _5972 + 101] = 0
                return 32, mem[_2580 + stor30.length.field_1 + _5972 + 69 len ceil32(_10651) + 32]
            mem[stor30.length.field_1 + mem[64] + 32] = 0
            _5973 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5973 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5973) <= _5973:
                _9876 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _5973 + 37
                mem[_2580 + stor30.length.field_1 + _5973 + 37] = 32
                _10652 = mem[_9876]
                mem[_2580 + stor30.length.field_1 + _5973 + 69] = mem[_9876]
                mem[_2580 + stor30.length.field_1 + _5973 + 101 len ceil32(_10652)] = mem[_9876 + 32 len ceil32(_10652)]
                if ceil32(_10652) > _10652:
                    mem[_10652 + _2580 + stor30.length.field_1 + _5973 + 101] = 0
                return 32, mem[_2580 + stor30.length.field_1 + _5973 + 69 len ceil32(_10652) + 32]
            _9877 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5973 + 37
            mem[_2580 + stor30.length.field_1 + _5973 + 37] = 32
            _10653 = mem[_9877]
            mem[_2580 + stor30.length.field_1 + _5973 + 69] = mem[_9877]
            mem[_2580 + stor30.length.field_1 + _5973 + 101 len ceil32(_10653)] = mem[_9877 + 32 len ceil32(_10653)]
            if ceil32(_10653) > _10653:
                mem[_10653 + _2580 + stor30.length.field_1 + _5973 + 101] = 0
            return 32, mem[_2580 + stor30.length.field_1 + _5973 + 69 len ceil32(_10653) + 32]
        mem[_238 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
        _2581 = mem[64]
        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
            _5974 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
            mem[mem[64] + stor30.length.field_1 + _5974 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_5974) <= _5974:
                _9878 = mem[64]
                mem[64] = _2581 + stor30.length.field_1 + _5974 + 37
                mem[_2581 + stor30.length.field_1 + _5974 + 37] = 32
                _10654 = mem[_9878]
                mem[_2581 + stor30.length.field_1 + _5974 + 69] = mem[_9878]
                mem[_2581 + stor30.length.field_1 + _5974 + 101 len ceil32(_10654)] = mem[_9878 + 32 len ceil32(_10654)]
                if ceil32(_10654) > _10654:
                    mem[_10654 + _2581 + stor30.length.field_1 + _5974 + 101] = 0
                return 32, mem[_2581 + stor30.length.field_1 + _5974 + 69 len ceil32(_10654) + 32]
            _9879 = mem[64]
            mem[64] = _2581 + stor30.length.field_1 + _5974 + 37
            mem[_2581 + stor30.length.field_1 + _5974 + 37] = 32
            _10655 = mem[_9879]
            mem[_2581 + stor30.length.field_1 + _5974 + 69] = mem[_9879]
            mem[_2581 + stor30.length.field_1 + _5974 + 101 len ceil32(_10655)] = mem[_9879 + 32 len ceil32(_10655)]
            if ceil32(_10655) > _10655:
                mem[_10655 + _2581 + stor30.length.field_1 + _5974 + 101] = 0
            return 32, mem[_2581 + stor30.length.field_1 + _5974 + 69 len ceil32(_10655) + 32]
        mem[stor30.length.field_1 + mem[64] + 32] = 0
        _5975 = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128]
        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128])]
        mem[mem[64] + stor30.length.field_1 + _5975 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_5975) <= _5975:
            _9880 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _5975 + 37
            mem[_2581 + stor30.length.field_1 + _5975 + 37] = 32
            _10656 = mem[_9880]
            mem[_2581 + stor30.length.field_1 + _5975 + 69] = mem[_9880]
            mem[_2581 + stor30.length.field_1 + _5975 + 101 len ceil32(_10656)] = mem[_9880 + 32 len ceil32(_10656)]
            if ceil32(_10656) > _10656:
                mem[_10656 + _2581 + stor30.length.field_1 + _5975 + 101] = 0
            return 32, mem[_2581 + stor30.length.field_1 + _5975 + 69 len ceil32(_10656) + 32]
        _9881 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _5975 + 37
        mem[_2581 + stor30.length.field_1 + _5975 + 37] = 32
        _10657 = mem[_9881]
        mem[_2581 + stor30.length.field_1 + _5975 + 69] = mem[_9881]
        mem[_2581 + stor30.length.field_1 + _5975 + 101 len ceil32(_10657)] = mem[_9881 + 32 len ceil32(_10657)]
        if ceil32(_10657) > _10657:
            mem[_10657 + _2581 + stor30.length.field_1 + _5975 + 101] = 0
        return 32, mem[_2581 + stor30.length.field_1 + _5975 + 69 len ceil32(_10657) + 32]
    mem[0] = 30
    mem[128] = uint256(stor30.field_0)
    idx = 128
    s = 0
    while stor30.length.field_1 + 96 > idx:
        mem[idx + 32] = stor30[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    if not stor31:
        if not arg1:
            mem[ceil32(stor30.length.field_1) + 224 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 225] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 230] = 32
            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262] = mem[ceil32(stor30.length.field_1) + 192]
            mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])] = mem[ceil32(stor30.length.field_1) + 224 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]
            if ceil32(mem[ceil32(stor30.length.field_1) + 192]) <= mem[ceil32(stor30.length.field_1) + 192]:
                return Array(len=mem[ceil32(stor30.length.field_1) + 192], data=mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 294 len ceil32(mem[ceil32(stor30.length.field_1) + 192])]), 
            mem[mem[ceil32(stor30.length.field_1) + 192] + ceil32(stor30.length.field_1) + stor30.length.field_1 + 294] = 0
            return 32, mem[ceil32(stor30.length.field_1) + stor30.length.field_1 + 262 len ceil32(mem[ceil32(stor30.length.field_1) + 192]) + 32], 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 0, 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 0, 65
        mem[ceil32(stor30.length.field_1) + 128] = s
        if s:
            mem[ceil32(stor30.length.field_1) + 160 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 0, 17
            if 48 > !(idx % 10):
                revert with 0, 17
            if t - 1 >= mem[ceil32(stor30.length.field_1) + 128]:
                revert with 0, 50
            mem[t + ceil32(stor30.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
        if ceil32(stor30.length.field_1) > stor30.length.field_1:
            mem[stor30.length.field_1 + ceil32(stor30.length.field_1) + ceil32(s) + 192] = 0
        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + 192 len ceil32(mem[ceil32(stor30.length.field_1) + 128])] = mem[ceil32(stor30.length.field_1) + 160 len ceil32(mem[ceil32(stor30.length.field_1) + 128])]
        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 192] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 197] = 32
        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 229] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]
        mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])] = mem[ceil32(stor30.length.field_1) + ceil32(s) + 192 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]
        if ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]) > mem[ceil32(stor30.length.field_1) + ceil32(s) + 160]:
            mem[mem[ceil32(stor30.length.field_1) + ceil32(s) + 160] + ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261] = 0
        return Array(len=mem[ceil32(stor30.length.field_1) + ceil32(s) + 160], data=mem[ceil32(stor30.length.field_1) + ceil32(s) + stor30.length.field_1 + mem[ceil32(stor30.length.field_1) + 128] + 261 len ceil32(mem[ceil32(stor30.length.field_1) + ceil32(s) + 160])]), 
    mem[ceil32(stor30.length.field_1) + 128] = 0xff74ef3000000000000000000000000000000000000000000000000000000000
    mem[ceil32(stor30.length.field_1) + 132] = arg1
    require ext_code.size(stor31)
    staticcall stor31.0xff74ef30 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(stor30.length.field_1) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128
    require return_data.size >= 32
    _2756 = mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32
    require mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require ceil32(stor30.length.field_1) + return_data.size + 128 > ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 159
    _2917 = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
    if mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 1 < 0 or ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(stor30.length.field_1) + ceil32(return_data.size) + ceil32(ceil32(mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128])) + 129
    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 128] = mem[ceil32(stor30.length.field_1) + mem[ceil32(stor30.length.field_1) + 128 len 4], Mask(224, 32, arg1) >> 32 + 128]
    require _2756 + _2917 + 32 <= return_data.size
    mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2917)] = mem[ceil32(stor30.length.field_1) + _2756 + 160 len ceil32(_2917)]
    if ceil32(_2917) <= _2917:
        _6082 = mem[64]
        mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
        if ceil32(stor30.length.field_1) <= stor30.length.field_1:
            mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2917)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2917)]
            mem[mem[64] + stor30.length.field_1 + _2917 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_2917) <= _2917:
                _13018 = mem[64]
                mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
                mem[_6082 + stor30.length.field_1 + _2917 + 37] = 32
                _13810 = mem[_13018]
                mem[_6082 + stor30.length.field_1 + _2917 + 69] = mem[_13018]
                mem[_6082 + stor30.length.field_1 + _2917 + 101 len ceil32(_13810)] = mem[_13018 + 32 len ceil32(_13810)]
                if ceil32(_13810) > _13810:
                    mem[_13810 + _6082 + stor30.length.field_1 + _2917 + 101] = 0
                return 32, mem[_6082 + stor30.length.field_1 + _2917 + 69 len ceil32(_13810) + 32]
            _13019 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
            mem[_6082 + stor30.length.field_1 + _2917 + 37] = 32
            _13811 = mem[_13019]
            mem[_6082 + stor30.length.field_1 + _2917 + 69] = mem[_13019]
            mem[_6082 + stor30.length.field_1 + _2917 + 101 len ceil32(_13811)] = mem[_13019 + 32 len ceil32(_13811)]
            if ceil32(_13811) > _13811:
                mem[_13811 + _6082 + stor30.length.field_1 + _2917 + 101] = 0
            return 32, mem[_6082 + stor30.length.field_1 + _2917 + 69 len ceil32(_13811) + 32]
        mem[stor30.length.field_1 + mem[64] + 32] = 0
        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2917)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2917)]
        mem[mem[64] + stor30.length.field_1 + _2917 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_2917) <= _2917:
            _13020 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
            mem[_6082 + stor30.length.field_1 + _2917 + 37] = 32
            _13812 = mem[_13020]
            mem[_6082 + stor30.length.field_1 + _2917 + 69] = mem[_13020]
            mem[_6082 + stor30.length.field_1 + _2917 + 101 len ceil32(_13812)] = mem[_13020 + 32 len ceil32(_13812)]
            if ceil32(_13812) > _13812:
                mem[_13812 + _6082 + stor30.length.field_1 + _2917 + 101] = 0
            return 32, mem[_6082 + stor30.length.field_1 + _2917 + 69 len ceil32(_13812) + 32]
        _13021 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
        mem[_6082 + stor30.length.field_1 + _2917 + 37] = 32
        _13813 = mem[_13021]
        mem[_6082 + stor30.length.field_1 + _2917 + 69] = mem[_13021]
        mem[_6082 + stor30.length.field_1 + _2917 + 101 len ceil32(_13813)] = mem[_13021 + 32 len ceil32(_13813)]
        if ceil32(_13813) > _13813:
            mem[_13813 + _6082 + stor30.length.field_1 + _2917 + 101] = 0
        return 32, mem[_6082 + stor30.length.field_1 + _2917 + 69 len ceil32(_13813) + 32]
    mem[_2917 + ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160] = 0
    _6083 = mem[64]
    mem[mem[64] + 32 len ceil32(stor30.length.field_1)] = mem[128 len ceil32(stor30.length.field_1)]
    if ceil32(stor30.length.field_1) <= stor30.length.field_1:
        mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2917)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2917)]
        mem[mem[64] + stor30.length.field_1 + _2917 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_2917) <= _2917:
            _13022 = mem[64]
            mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
            mem[_6083 + stor30.length.field_1 + _2917 + 37] = 32
            _13814 = mem[_13022]
            mem[_6083 + stor30.length.field_1 + _2917 + 69] = mem[_13022]
            mem[_6083 + stor30.length.field_1 + _2917 + 101 len ceil32(_13814)] = mem[_13022 + 32 len ceil32(_13814)]
            if ceil32(_13814) > _13814:
                mem[_13814 + _6083 + stor30.length.field_1 + _2917 + 101] = 0
            return 32, mem[_6083 + stor30.length.field_1 + _2917 + 69 len ceil32(_13814) + 32]
        _13023 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
        mem[_6083 + stor30.length.field_1 + _2917 + 37] = 32
        _13815 = mem[_13023]
        mem[_6083 + stor30.length.field_1 + _2917 + 69] = mem[_13023]
        mem[_6083 + stor30.length.field_1 + _2917 + 101 len ceil32(_13815)] = mem[_13023 + 32 len ceil32(_13815)]
        if ceil32(_13815) > _13815:
            mem[_13815 + _6083 + stor30.length.field_1 + _2917 + 101] = 0
        return 32, mem[_6083 + stor30.length.field_1 + _2917 + 69 len ceil32(_13815) + 32]
    mem[stor30.length.field_1 + mem[64] + 32] = 0
    mem[mem[64] + stor30.length.field_1 + 32 len ceil32(_2917)] = mem[ceil32(stor30.length.field_1) + ceil32(return_data.size) + 160 len ceil32(_2917)]
    mem[mem[64] + stor30.length.field_1 + _2917 + 32] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
    if ceil32(_2917) <= _2917:
        _13024 = mem[64]
        mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
        mem[_6083 + stor30.length.field_1 + _2917 + 37] = 32
        _13816 = mem[_13024]
        mem[_6083 + stor30.length.field_1 + _2917 + 69] = mem[_13024]
        mem[_6083 + stor30.length.field_1 + _2917 + 101 len ceil32(_13816)] = mem[_13024 + 32 len ceil32(_13816)]
        if ceil32(_13816) > _13816:
            mem[_13816 + _6083 + stor30.length.field_1 + _2917 + 101] = 0
        return 32, mem[_6083 + stor30.length.field_1 + _2917 + 69 len ceil32(_13816) + 32]
    _13025 = mem[64]
    mem[64] = mem[64] + stor30.length.field_1 + _2917 + 37
    mem[_6083 + stor30.length.field_1 + _2917 + 37] = 32
    _13817 = mem[_13025]
    mem[_6083 + stor30.length.field_1 + _2917 + 69] = mem[_13025]
    mem[_6083 + stor30.length.field_1 + _2917 + 101 len ceil32(_13817)] = mem[_13025 + 32 len ceil32(_13817)]
    if ceil32(_13817) > _13817:
        mem[_13817 + _6083 + stor30.length.field_1 + _2917 + 101] = 0
    return 32, mem[_6083 + stor30.length.field_1 + _2917 + 69 len ceil32(_13817) + 32]
}



}
