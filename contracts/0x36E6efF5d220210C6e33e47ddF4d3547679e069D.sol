contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - initialize()
#
array of uint256 stor1;
array of uint256 stor99;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;
address owner;
array of struct transactions;
uint256 stor202;
mapping of uint256 stor203;
mapping of uint256 stor204;
mapping of uint256 allowance;
mapping of uint8 stor206;
array of address stor207;
uint256 totalSupply;
uint256 stor209;
uint256 totalFees;
uint256 _tFeePercent;
uint256 _tFeeTimestamp;
address _rebaserAddress;
uint256 _limitTimestamp;
array of struct stor46472157311649131651317580928243384587355742660275723744700495089454914805032;
array of address stor78124409783719932406374152597529114957380397136489353056513409383928196874025;
uint256 storD7B0;

function name() payable {
    return name[0 len name.length]
}

function _limitTimestamp() payable {
    return _limitTimestamp
}

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function _tFeePercent() payable {
    return _tFeePercent
}

function decimals() payable {
    return decimals
}

function _rebaser() payable {
    return _rebaserAddress
}

function owner() payable {
    return owner
}

function transactionsSize() payable {
    return transactions.length
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function transactions(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < transactions.length
    mem[128] = stor[sha3((2 * arg1) + ('name', 'transactions', 201) + 1)].field_0
    idx = 128
    s = 0
    while stor[(2 * arg1) + ('name', 'transactions', 201) + 1].length + 96 > idx:
        mem[idx + 32] = stor[s + sha3((2 * arg1) + ('name', 'transactions', 201) + 1)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return bool(uint8(transactions[arg1].field_0)), 
           address(transactions[arg1].field_0),
           Array(len=stor[(2 * arg1) + ('name', 'transactions', 201) + 1].length, data=mem[128 len stor[(2 * arg1) + ('name', 'transactions', 201) + 1].length])
}

function _tFeeTimestamp() payable {
    return _tFeeTimestamp
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor206[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    emit 0x728be007: owner, 0
    owner = 0
}

function setRebaser(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    _rebaserAddress = arg1
}

function rebalance() payable {
    if 0x87c4cebffb95746d1935de7fbcab092f40 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x7445524332303a2043616c6c6572206973206e6f7420746865206465706c6f7965,
                    mem[197 len 31]
    storD7B0 = 10000000000000000000 * 10^18
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit 0x728be007: owner, arg1
    owner = arg1
}

function setTransactionEnabled(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg1 >= transactions.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    40,
                    0x73696e646578206d75737420626520696e2072616e6765206f662073746f726564207478206c6973,
                    mem[204 len 24]
    uint8(transactions[arg1].field_0) = uint8(arg2)
}

function setTransferFeePercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if block.timestamp < _tFeeTimestamp + (12 * 3600):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x655472616e7366657220666565206368616e6765732074696d656c6f636b656420666f7220313220686f7572,
                    mem[208 len 20]
    _tFeePercent = arg1
    _tFeeTimestamp = block.timestamp
}

function addTransaction(address arg1, bytes arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    transactions.length++
    uint8(stor66BE[stor201.length].field_0) = 1
    address(stor66BE[stor201.length].field_8) = arg1
    Mask(88, 0, stor66BE[stor201.length].field_168) = 0
    stor[sha3((2 * stor201.length) + 0x66be4f155c5ef2ebd3772b228f2f00681e4ed5826cdb3b1943cc11ad15ad1d29)][] = Array(len=arg2.length, data=arg2[all])
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if not stor206[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor207.length:
        mem[0] = 207
        if stor207[idx] != arg1:
            idx = idx + 1
            continue 
        require stor207.length - 1 < stor207.length
        require idx < stor207.length
        stor207[idx] = stor207[stor207.length]
        stor204[address(arg1)] = 0
        stor206[address(arg1)] = 0
        require stor207.length
        stor207[stor207.length] = 0
        stor207.length--
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0xf245524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6e45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0xf245524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 + allowance[address(msg.sender)][address(arg1)] < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0xf245524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((arg2 + allowance[address(msg.sender)][address(arg1)]), msg.sender, arg1);
    return 1
}

function removeTransaction(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg1 >= transactions.length:
        revert with 0, 'index out of bounds'
    if arg1 < transactions.length - 1:
        require transactions.length - 1 < transactions.length
        require arg1 < transactions.length
        uint8(transactions[arg1].field_0) = uint8(bool(uint8(transactions[transactions.length - 1].field_0)))
        uint8(transactions[arg1].field_0) = uint8(bool(uint8(transactions[transactions.length - 1].field_0)))
        Mask(248, 0, transactions[arg1].field_8) = address(transactions[transactions.length - 1].field_8)
        Mask(88, 0, transactions[arg1].field_168) = Mask(88, 168, bool(uint8(transactions[transactions.length - 1].field_0))) >> 168
        if 31 >= stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length:
            transactions[arg1].field_256 = transactions[transactions.length - 1].field_256
            idx = 0
            while stor[('name', 'transactions', 201) + (2 * arg1) + 1].length + 31 / 32 > idx:
                stor[idx + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = 0
                idx = idx + 1
                continue 
        else:
            transactions[arg1].field_256 = Mask(255, 1, transactions[transactions.length - 1].field_256 and (256 * not bool(transactions[transactions.length - 1].field_256)) - 1) + 1
            if not Mask(255, 1, transactions[transactions.length - 1].field_256 and (256 * not bool(transactions[transactions.length - 1].field_256)) - 1):
                idx = 0
                while stor[('name', 'transactions', 201) + (2 * arg1) + 1].length + 31 / 32 > idx:
                    stor[idx + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = 0
                while stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length + 31 / 32 > idx:
                    stor[s + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = stor[idx + sha3((2 * transactions.length - 1) + ('name', 'transactions', 201) + 1)].field_0
                    s = s + 1
                    idx = idx + 1
                    continue 
                idx = stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length + 31 / 32
                while stor[('name', 'transactions', 201) + (2 * arg1) + 1].length + 31 / 32 > idx:
                    stor[idx + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = 0
                    idx = idx + 1
                    continue 
    require transactions.length
    Mask(168, 0, transactions[transactions.length - 1].field_0) = 0
    transactions[transactions.length - 1].field_256 = 0
    if 31 < stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length:
        idx = 0
        while stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length + 31 / 32 > idx:
            stor[idx + sha3((2 * transactions.length - 1) + ('name', 'transactions', 201) + 1)].field_0 = 0
            idx = idx + 1
            continue 
    transactions.length--
}

function tokenFromRefraction(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor209:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0xef416d6f756e74206d757374206265206c657373207468616e20746f74616c2072656672616374696f6e,
                    mem[206 len 22]
    idx = 0
    s = totalSupply
    t = stor209
    while idx < stor207.length:
        mem[0] = stor207[idx]
        mem[32] = 203
        if stor203[stor207[idx]] > t:
            _156 = mem[64]
            mem[64] = mem[64] + 64
            mem[_156] = 26
            mem[_156 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _156 + 32]
                    idx = idx + 32
                    continue 
            else:
                _198 = mem[64]
                mem[64] = mem[64] + 64
                mem[_198] = 26
                mem[_198 + 32] = 'SafeMath: division by zero' << 48
                if stor209 / totalSupply:
                    return (arg1 / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _198 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        if stor204[stor207[idx]] > s:
            _166 = mem[64]
            mem[64] = mem[64] + 64
            mem[_166] = 26
            mem[_166 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _166 + 32]
                    idx = idx + 32
                    continue 
            else:
                _220 = mem[64]
                mem[64] = mem[64] + 64
                mem[_220] = 26
                mem[_220 + 32] = 'SafeMath: division by zero' << 48
                if stor209 / totalSupply:
                    return (arg1 / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _220 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 203
        _161 = mem[64]
        mem[64] = mem[64] + 64
        mem[_161] = 30
        mem[_161 + 32] = 'SafeMath: subtraction overflow'
        if stor203[stor207[idx]] > t:
            _168 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _168 + 68] = mem[idx + _161 + 32]
                idx = idx + 32
                continue 
            mem[_168 + 68] = mem[_168 + 70 len 30]
            revert with memory
              from mem[64]
               len _168 + -mem[64] + 100
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 30
        mem[_200 + 32] = 'SafeMath: subtraction overflow'
        if stor204[stor207[idx]] <= s:
            idx = idx + 1
            s = s - stor204[stor207[idx]]
            t = t - stor203[stor207[idx]]
            continue 
        _217 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _217 + 68] = mem[idx + _200 + 32]
            idx = idx + 32
            continue 
        mem[_217 + 68] = mem[_217 + 70 len 30]
        revert with memory
          from mem[64]
           len _217 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if t >= stor209 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero'
        if not t / s:
            revert with 0, 'SafeMath: division by zero'
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if not stor209 / totalSupply:
        revert with 0, 'SafeMath: division by zero'
    return (arg1 / stor209 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor206[address(arg1)]:
        return stor204[address(arg1)]
    mem[0] = arg1
    mem[32] = 203
    if stor203[address(arg1)] > stor209:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0xef416d6f756e74206d757374206265206c657373207468616e20746f74616c2072656672616374696f6e,
                    mem[206 len 22]
    idx = 0
    s = totalSupply
    t = stor209
    while idx < stor207.length:
        mem[0] = stor207[idx]
        mem[32] = 203
        if stor203[stor207[idx]] > t:
            _161 = mem[64]
            mem[64] = mem[64] + 64
            mem[_161] = 26
            mem[_161 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _161 + 32]
                    idx = idx + 32
                    continue 
            else:
                _203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_203] = 26
                mem[_203 + 32] = 'SafeMath: division by zero' << 48
                if stor209 / totalSupply:
                    return (stor203[address(arg1)] / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _203 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        if stor204[stor207[idx]] > s:
            _171 = mem[64]
            mem[64] = mem[64] + 64
            mem[_171] = 26
            mem[_171 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _171 + 32]
                    idx = idx + 32
                    continue 
            else:
                _225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_225] = 26
                mem[_225 + 32] = 'SafeMath: division by zero' << 48
                if stor209 / totalSupply:
                    return (stor203[address(arg1)] / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _225 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 203
        _166 = mem[64]
        mem[64] = mem[64] + 64
        mem[_166] = 30
        mem[_166 + 32] = 'SafeMath: subtraction overflow'
        if stor203[stor207[idx]] > t:
            _173 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _173 + 68] = mem[idx + _166 + 32]
                idx = idx + 32
                continue 
            mem[_173 + 68] = mem[_173 + 70 len 30]
            revert with memory
              from mem[64]
               len _173 + -mem[64] + 100
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        _205 = mem[64]
        mem[64] = mem[64] + 64
        mem[_205] = 30
        mem[_205 + 32] = 'SafeMath: subtraction overflow'
        if stor204[stor207[idx]] <= s:
            idx = idx + 1
            s = s - stor204[stor207[idx]]
            t = t - stor203[stor207[idx]]
            continue 
        _222 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _222 + 68] = mem[idx + _205 + 32]
            idx = idx + 32
            continue 
        mem[_222 + 68] = mem[_222 + 70 len 30]
        revert with memory
          from mem[64]
           len _222 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if t >= stor209 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero'
        if not t / s:
            revert with 0, 'SafeMath: division by zero'
        return (stor203[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if not stor209 / totalSupply:
        revert with 0, 'SafeMath: division by zero'
    return (stor203[address(arg1)] / stor209 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if stor206[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor203[address(arg1)]:
        mem[0] = arg1
        mem[32] = 203
        if stor203[address(arg1)] > stor209:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        42,
                        0xef416d6f756e74206d757374206265206c657373207468616e20746f74616c2072656672616374696f6e,
                        mem[206 len 22]
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _166 = mem[64]
                mem[64] = mem[64] + 64
                mem[_166] = 26
                mem[_166 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _166 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_208] = 26
                    mem[_208 + 32] = 'SafeMath: division by zero' << 48
                    if stor209 / totalSupply:
                        stor204[address(arg1)] = stor203[address(arg1)] / stor209 / totalSupply
                        stor206[address(arg1)] = 1
                        stor207.length++
                        storACB8[stor207.length] = arg1
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _208 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _176 = mem[64]
                mem[64] = mem[64] + 64
                mem[_176] = 26
                mem[_176 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _176 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_230] = 26
                    mem[_230 + 32] = 'SafeMath: division by zero' << 48
                    if stor209 / totalSupply:
                        stor204[address(arg1)] = stor203[address(arg1)] / stor209 / totalSupply
                        stor206[address(arg1)] = 1
                        stor207.length++
                        storACB8[stor207.length] = arg1
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _230 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _171 = mem[64]
            mem[64] = mem[64] + 64
            mem[_171] = 30
            mem[_171 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _178 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _178 + 68] = mem[idx + _171 + 32]
                    idx = idx + 32
                    continue 
                mem[_178 + 68] = mem[_178 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _178 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _210 = mem[64]
            mem[64] = mem[64] + 64
            mem[_210] = 30
            mem[_210 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _227 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _227 + 68] = mem[idx + _210 + 32]
                idx = idx + 32
                continue 
            mem[_227 + 68] = mem[_227 + 70 len 30]
            revert with memory
              from mem[64]
               len _227 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not t / s:
                revert with 0, 'SafeMath: division by zero'
            stor204[address(arg1)] = stor203[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not stor209 / totalSupply:
                revert with 0, 'SafeMath: division by zero'
            stor204[address(arg1)] = stor203[address(arg1)] / stor209 / totalSupply
    stor206[address(arg1)] = 1
    stor207.length++
    storACB8[stor207.length] = arg1
}

function refractionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero' << 48
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            s = totalSupply
            t = stor209
            while idx < stor207.length:
                mem[0] = stor207[idx]
                mem[32] = 203
                if stor203[stor207[idx]] > t:
                    _878 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_878] = 26
                    mem[_878 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _878 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1211 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1211] = 30
                    mem[_1211 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1239 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1239 + 68] = mem[idx + _1211 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1239 + 68] = mem[_1239 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1239 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                if stor204[stor207[idx]] > s:
                    _912 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_912] = 26
                    mem[_912 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _912 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1242 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1242] = 30
                    mem[_1242 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1298 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1298 + 68] = mem[idx + _1242 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1298 + 68] = mem[_1298 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1298 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 203
                _896 = mem[64]
                mem[64] = mem[64] + 64
                mem[_896] = 30
                mem[_896 + 32] = 'SafeMath: subtraction overflow'
                if stor203[stor207[idx]] > t:
                    _928 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _928 + 68] = mem[idx + _896 + 32]
                        idx = idx + 32
                        continue 
                    mem[_928 + 68] = mem[_928 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _928 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                _1049 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1049] = 30
                mem[_1049 + 32] = 'SafeMath: subtraction overflow'
                if stor204[stor207[idx]] <= s:
                    idx = idx + 1
                    s = s - stor204[stor207[idx]]
                    t = t - stor203[stor207[idx]]
                    continue 
                _1103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1103 + 68] = mem[idx + _1049 + 32]
                    idx = idx + 32
                    continue 
                mem[_1103 + 68] = mem[_1103 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1103 + -mem[64] + 100
            _820 = mem[64]
            mem[64] = mem[64] + 64
            mem[_820] = 26
            mem[_820 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if t >= stor209 / totalSupply:
                _946 = mem[64]
                mem[64] = mem[64] + 64
                mem[_946] = 26
                mem[_946 + 32] = 'SafeMath: division by zero' << 48
                if not s:
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (t / s * arg1)
            _947 = mem[64]
            mem[64] = mem[64] + 64
            mem[_947] = 26
            mem[_947 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                return 0
            if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (stor209 / totalSupply * arg1)
        if _tFeePercent * arg1 / arg1 != _tFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero' << 48
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if _tFeePercent * arg1 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _873 = mem[64]
                mem[64] = mem[64] + 64
                mem[_873] = 26
                mem[_873 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _873 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1208] = 30
                    mem[_1208 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return (-1 * stor209 / totalSupply * _tFeePercent * arg1 / 10000)
                    _1234 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1234 + 68] = mem[idx + _1208 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1234 + 68] = mem[_1234 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1234 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1207 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1207] = 30
                    mem[_1207 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1231 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1231 + 68] = mem[idx + _1207 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1231 + 68] = mem[_1231 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1231 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1217 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1217] = 30
                mem[_1217 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return ((stor209 / totalSupply * arg1) - (stor209 / totalSupply * _tFeePercent * arg1 / 10000))
                _1265 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1265 + 68] = mem[idx + _1217 + 32]
                    idx = idx + 32
                    continue 
                mem[_1265 + 68] = mem[_1265 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1265 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _907 = mem[64]
                mem[64] = mem[64] + 64
                mem[_907] = 26
                mem[_907 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _907 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1238] = 30
                    mem[_1238 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return (-1 * stor209 / totalSupply * _tFeePercent * arg1 / 10000)
                    _1292 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1292 + 68] = mem[idx + _1238 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1292 + 68] = mem[_1292 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1292 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1237 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1237] = 30
                    mem[_1237 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1289 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1289 + 68] = mem[idx + _1237 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1289 + 68] = mem[_1289 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1289 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1268 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1268] = 30
                mem[_1268 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return ((stor209 / totalSupply * arg1) - (stor209 / totalSupply * _tFeePercent * arg1 / 10000))
                _1326 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1326 + 68] = mem[idx + _1268 + 32]
                    idx = idx + 32
                    continue 
                mem[_1326 + 68] = mem[_1326 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1326 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _893 = mem[64]
            mem[64] = mem[64] + 64
            mem[_893] = 30
            mem[_893 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _924 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _924 + 68] = mem[idx + _893 + 32]
                    idx = idx + 32
                    continue 
                mem[_924 + 68] = mem[_924 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _924 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _1042 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1042] = 30
            mem[_1042 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _1095 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1095 + 68] = mem[idx + _1042 + 32]
                idx = idx + 32
                continue 
            mem[_1095 + 68] = mem[_1095 + 70 len 30]
            revert with memory
              from mem[64]
               len _1095 + -mem[64] + 100
        _815 = mem[64]
        mem[64] = mem[64] + 64
        mem[_815] = 26
        mem[_815 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _939 = mem[64]
            mem[64] = mem[64] + 64
            mem[_939] = 26
            mem[_939 + 32] = 'SafeMath: division by zero' << 48
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if not _tFeePercent * arg1 / 10000:
                    return 0
                if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if t / s * _tFeePercent * arg1 / 10000 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (-1 * t / s * _tFeePercent * arg1 / 10000)
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not _tFeePercent * arg1 / 10000:
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (t / s * arg1)
            if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if t / s * _tFeePercent * arg1 / 10000 > t / s * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((t / s * arg1) - (t / s * _tFeePercent * arg1 / 10000))
        _940 = mem[64]
        mem[64] = mem[64] + 64
        mem[_940] = 26
        mem[_940 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            if not _tFeePercent * arg1 / 10000:
                return 0
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return (-1 * stor209 / totalSupply * _tFeePercent * arg1 / 10000)
        if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not _tFeePercent * arg1 / 10000:
            if 0 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (stor209 / totalSupply * arg1)
        if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((stor209 / totalSupply * arg1) - (stor209 / totalSupply * _tFeePercent * arg1 / 10000))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero' << 48
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _888 = mem[64]
                mem[64] = mem[64] + 64
                mem[_888] = 26
                mem[_888 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _888 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1216 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1216] = 30
                mem[_1216 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1255 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1255 + 68] = mem[idx + _1216 + 32]
                    idx = idx + 32
                    continue 
                mem[_1255 + 68] = mem[_1255 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1255 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _922 = mem[64]
                mem[64] = mem[64] + 64
                mem[_922] = 26
                mem[_922 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _922 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1258 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1258] = 30
                mem[_1258 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1316 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1316 + 68] = mem[idx + _1258 + 32]
                    idx = idx + 32
                    continue 
                mem[_1316 + 68] = mem[_1316 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1316 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _902 = mem[64]
            mem[64] = mem[64] + 64
            mem[_902] = 30
            mem[_902 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _936 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _936 + 68] = mem[idx + _902 + 32]
                    idx = idx + 32
                    continue 
                mem[_936 + 68] = mem[_936 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _936 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _1063 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1063] = 30
            mem[_1063 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _1119 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1119 + 68] = mem[idx + _1063 + 32]
                idx = idx + 32
                continue 
            mem[_1119 + 68] = mem[_1119 + 70 len 30]
            revert with memory
              from mem[64]
               len _1119 + -mem[64] + 100
        _830 = mem[64]
        mem[64] = mem[64] + 64
        mem[_830] = 26
        mem[_830 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _960 = mem[64]
            mem[64] = mem[64] + 64
            mem[_960] = 26
            mem[_960 + 32] = 'SafeMath: division by zero' << 48
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                return 0
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > t / s * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (t / s * arg1)
        _961 = mem[64]
        mem[64] = mem[64] + 64
        mem[_961] = 26
        mem[_961 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            return 0
        if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if 0 > stor209 / totalSupply * arg1:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        if _tFeePercent * arg1 / arg1 != _tFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero' << 48
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if _tFeePercent * arg1 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _883 = mem[64]
                mem[64] = mem[64] + 64
                mem[_883] = 26
                mem[_883 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _883 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1213] = 30
                    mem[_1213 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return 0
                    _1250 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1250 + 68] = mem[idx + _1213 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1250 + 68] = mem[_1250 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1250 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1212 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1212] = 30
                    mem[_1212 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1247 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1247 + 68] = mem[idx + _1212 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1247 + 68] = mem[_1247 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1247 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1222 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1222] = 30
                mem[_1222 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1277 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1277 + 68] = mem[idx + _1222 + 32]
                    idx = idx + 32
                    continue 
                mem[_1277 + 68] = mem[_1277 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1277 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _917 = mem[64]
                mem[64] = mem[64] + 64
                mem[_917] = 26
                mem[_917 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _917 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1254] = 30
                    mem[_1254 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return 0
                    _1310 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1310 + 68] = mem[idx + _1254 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1310 + 68] = mem[_1310 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1310 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1253 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1253] = 30
                    mem[_1253 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1307 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1307 + 68] = mem[idx + _1253 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1307 + 68] = mem[_1307 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1307 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1280 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1280] = 30
                mem[_1280 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1338 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1338 + 68] = mem[idx + _1280 + 32]
                    idx = idx + 32
                    continue 
                mem[_1338 + 68] = mem[_1338 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1338 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _899 = mem[64]
            mem[64] = mem[64] + 64
            mem[_899] = 30
            mem[_899 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _932 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _932 + 68] = mem[idx + _899 + 32]
                    idx = idx + 32
                    continue 
                mem[_932 + 68] = mem[_932 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _932 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _1056 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1056] = 30
            mem[_1056 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _1111 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1111 + 68] = mem[idx + _1056 + 32]
                idx = idx + 32
                continue 
            mem[_1111 + 68] = mem[_1111 + 70 len 30]
            revert with memory
              from mem[64]
               len _1111 + -mem[64] + 100
        _825 = mem[64]
        mem[64] = mem[64] + 64
        mem[_825] = 26
        mem[_825 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _953 = mem[64]
            mem[64] = mem[64] + 64
            mem[_953] = 26
            mem[_953 + 32] = 'SafeMath: division by zero' << 48
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if _tFeePercent * arg1 / 10000:
                    if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * _tFeePercent * arg1 / 10000 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        return 0
                else:
                    return 0
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not _tFeePercent * arg1 / 10000:
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if t / s * _tFeePercent * arg1 / 10000 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
            return (t / s * arg1)
        _954 = mem[64]
        mem[64] = mem[64] + 64
        mem[_954] = 26
        mem[_954 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            if _tFeePercent * arg1 / 10000:
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            else:
                return 0
        if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not _tFeePercent * arg1 / 10000:
            if 0 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
    return (stor209 / totalSupply * arg1)
}

function refract(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 206
    if stor206[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x734578636c75646564206164647265737365732063616e6e6f742063616c6c20746869732066756e6374696f,
                    mem[208 len 20]
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero' << 48
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _877 = mem[64]
                mem[64] = mem[64] + 64
                mem[_877] = 26
                mem[_877 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _877 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    _1037 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1037] = 30
                    mem[_1037 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1137 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1137] = 30
                    mem[_1137 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor203[address(msg.sender)]:
                        _1176 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1176 + 68] = mem[idx + _1137 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1176 + 68] = mem[_1176 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1176 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1273 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1273] = 30
                    mem[_1273 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1347 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1347 + 68] = mem[idx + _1273 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1347 + 68] = mem[_1347 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1347 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1042 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1042] = 30
                mem[_1042 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor209 / totalSupply * arg1:
                    _1060 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1060 + 68] = mem[idx + _1042 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1060 + 68] = mem[_1060 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1060 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1155 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1155] = 30
                mem[_1155 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    _1210 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1210 + 68] = mem[idx + _1155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1210 + 68] = mem[_1210 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1210 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                _1307 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1307] = 30
                mem[_1307 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 <= stor209:
                    stor209 += -1 * stor209 / totalSupply * arg1
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1385 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1385 + 68] = mem[idx + _1307 + 32]
                    idx = idx + 32
                    continue 
                mem[_1385 + 68] = mem[_1385 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1385 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] <= s:
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 203
                _885 = mem[64]
                mem[64] = mem[64] + 64
                mem[_885] = 30
                mem[_885 + 32] = 'SafeMath: subtraction overflow'
                if stor203[stor207[idx]] > t:
                    _901 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _901 + 68] = mem[idx + _885 + 32]
                        idx = idx + 32
                        continue 
                    mem[_901 + 68] = mem[_901 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _901 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                _964 = mem[64]
                mem[64] = mem[64] + 64
                mem[_964] = 30
                mem[_964 + 32] = 'SafeMath: subtraction overflow'
                if stor204[stor207[idx]] <= s:
                    idx = idx + 1
                    s = s - stor204[stor207[idx]]
                    t = t - stor203[stor207[idx]]
                    continue 
                _992 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _992 + 68] = mem[idx + _964 + 32]
                    idx = idx + 32
                    continue 
                mem[_992 + 68] = mem[_992 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _992 + -mem[64] + 100
            _895 = mem[64]
            mem[64] = mem[64] + 64
            mem[_895] = 26
            mem[_895 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _895 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                _1047 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1047] = 30
                mem[_1047 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 203
                _1181 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1181] = 30
                mem[_1181 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    _1245 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1245 + 68] = mem[idx + _1181 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1245 + 68] = mem[_1245 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1245 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1352 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1352] = 30
                mem[_1352 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209:
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1430 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1430 + 68] = mem[idx + _1352 + 32]
                    idx = idx + 32
                    continue 
                mem[_1430 + 68] = mem[_1430 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1430 + -mem[64] + 100
            if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1063 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1063] = 30
            mem[_1063 + 32] = 'SafeMath: subtraction overflow'
            if 0 > stor209 / totalSupply * arg1:
                _1091 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1091 + 68] = mem[idx + _1063 + 32]
                    idx = idx + 32
                    continue 
                mem[_1091 + 68] = mem[_1091 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1091 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            _1213 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1213] = 30
            mem[_1213 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                _1276 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1276 + 68] = mem[idx + _1213 + 32]
                    idx = idx + 32
                    continue 
                mem[_1276 + 68] = mem[_1276 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1276 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
            _1388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1388] = 30
            mem[_1388 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 <= stor209:
                stor209 += -1 * stor209 / totalSupply * arg1
                if arg1 + totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1473 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1473 + 68] = mem[idx + _1388 + 32]
                idx = idx + 32
                continue 
            mem[_1473 + 68] = mem[_1473 + 70 len 30]
            revert with memory
              from mem[64]
               len _1473 + -mem[64] + 100
        _847 = mem[64]
        mem[64] = mem[64] + 64
        mem[_847] = 26
        mem[_847 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _911 = mem[64]
            mem[64] = mem[64] + 64
            mem[_911] = 26
            mem[_911 + 32] = 'SafeMath: division by zero' << 48
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                if t / s * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * t / s * arg1
                if t / s * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * t / s * arg1
        else:
            _912 = mem[64]
            mem[64] = mem[64] + 64
            mem[_912] = 26
            mem[_912 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > stor209 / totalSupply * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                if stor209 / totalSupply * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * stor209 / totalSupply * arg1
    else:
        if _tFeePercent * arg1 / arg1 != _tFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero' << 48
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if _tFeePercent * arg1 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _872 = mem[64]
                mem[64] = mem[64] + 64
                mem[_872] = 26
                mem[_872 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _872 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        _1036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1036] = 30
                        mem[_1036 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 203
                        _1126 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1126] = 30
                        mem[_1126 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor203[address(msg.sender)]:
                            _1164 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1164 + 68] = mem[idx + _1126 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1164 + 68] = mem[_1164 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1164 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 203
                        _1260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1260] = 30
                        mem[_1260 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if arg1 + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _1330 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1330 + 68] = mem[idx + _1260 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1330 + 68] = mem[_1330 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1330 + -mem[64] + 100
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1039 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1039] = 30
                    mem[_1039 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                        _1055 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1055 + 68] = mem[idx + _1039 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1055 + 68] = mem[_1055 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1055 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1148 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1148] = 30
                    mem[_1148 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor203[address(msg.sender)]:
                        _1197 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1197 + 68] = mem[idx + _1148 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1197 + 68] = mem[_1197 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1197 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1292 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1292] = 30
                    mem[_1292 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1369 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1369 + 68] = mem[idx + _1292 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1369 + 68] = mem[_1369 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1369 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1038 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1038] = 30
                    mem[_1038 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor209 / totalSupply * arg1:
                        _1052 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1052 + 68] = mem[idx + _1038 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1052 + 68] = mem[_1052 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1052 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1147 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1147] = 30
                    mem[_1147 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                        _1194 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1194 + 68] = mem[idx + _1147 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1194 + 68] = mem[_1194 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1194 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                    _1289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1289] = 30
                    mem[_1289 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg1 <= stor209:
                        stor209 += -1 * stor209 / totalSupply * arg1
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1366 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1366 + 68] = mem[idx + _1289 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1366 + 68] = mem[_1366 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1366 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1043 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1043] = 30
                mem[_1043 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                    _1070 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1070 + 68] = mem[idx + _1043 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1070 + 68] = mem[_1070 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1070 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1163 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1163] = 30
                mem[_1163 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    _1228 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1228 + 68] = mem[idx + _1163 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1228 + 68] = mem[_1228 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1228 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                _1325 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1325] = 30
                mem[_1325 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 <= stor209:
                    stor209 += -1 * stor209 / totalSupply * arg1
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1406 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1406 + 68] = mem[idx + _1325 + 32]
                    idx = idx + 32
                    continue 
                mem[_1406 + 68] = mem[_1406 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1406 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] <= s:
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 203
                _882 = mem[64]
                mem[64] = mem[64] + 64
                mem[_882] = 30
                mem[_882 + 32] = 'SafeMath: subtraction overflow'
                if stor203[stor207[idx]] > t:
                    _897 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _897 + 68] = mem[idx + _882 + 32]
                        idx = idx + 32
                        continue 
                    mem[_897 + 68] = mem[_897 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _897 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                _957 = mem[64]
                mem[64] = mem[64] + 64
                mem[_957] = 30
                mem[_957 + 32] = 'SafeMath: subtraction overflow'
                if stor204[stor207[idx]] <= s:
                    idx = idx + 1
                    s = s - stor204[stor207[idx]]
                    t = t - stor203[stor207[idx]]
                    continue 
                _984 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _984 + 68] = mem[idx + _957 + 32]
                    idx = idx + 32
                    continue 
                mem[_984 + 68] = mem[_984 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _984 + -mem[64] + 100
            _890 = mem[64]
            mem[64] = mem[64] + 64
            mem[_890] = 26
            mem[_890 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _890 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if not _tFeePercent * arg1 / 10000:
                    _1046 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1046] = 30
                    mem[_1046 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1173 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1173] = 30
                    mem[_1173 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor203[address(msg.sender)]:
                        _1234 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1234 + 68] = mem[idx + _1173 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1234 + 68] = mem[_1234 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1234 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1337 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1337] = 30
                    mem[_1337 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1415 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1415 + 68] = mem[idx + _1337 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1415 + 68] = mem[_1415 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1415 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1059 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1059] = 30
                mem[_1059 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                    _1085 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1085 + 68] = mem[idx + _1059 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1085 + 68] = mem[_1085 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1085 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1203] = 30
                mem[_1203 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    _1266 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1266 + 68] = mem[idx + _1203 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1266 + 68] = mem[_1266 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1266 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1377 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1377] = 30
                mem[_1377 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209:
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1459 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1459 + 68] = mem[idx + _1377 + 32]
                    idx = idx + 32
                    continue 
                mem[_1459 + 68] = mem[_1459 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1459 + -mem[64] + 100
            if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not _tFeePercent * arg1 / 10000:
                _1058 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1058] = 30
                mem[_1058 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor209 / totalSupply * arg1:
                    _1082 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1082 + 68] = mem[idx + _1058 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1082 + 68] = mem[_1082 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1082 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1202 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1202] = 30
                mem[_1202 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    _1263 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1263 + 68] = mem[idx + _1202 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1263 + 68] = mem[_1263 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1263 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                _1374 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1374] = 30
                mem[_1374 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 <= stor209:
                    stor209 += -1 * stor209 / totalSupply * arg1
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1456 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1456 + 68] = mem[idx + _1374 + 32]
                    idx = idx + 32
                    continue 
                mem[_1456 + 68] = mem[_1456 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1456 + -mem[64] + 100
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1073 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1073] = 30
            mem[_1073 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                _1102 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1102 + 68] = mem[idx + _1073 + 32]
                    idx = idx + 32
                    continue 
                mem[_1102 + 68] = mem[_1102 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1102 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            _1233 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1233] = 30
            mem[_1233 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                _1296 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1296 + 68] = mem[idx + _1233 + 32]
                    idx = idx + 32
                    continue 
                mem[_1296 + 68] = mem[_1296 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1296 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
            _1410 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1410] = 30
            mem[_1410 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 <= stor209:
                stor209 += -1 * stor209 / totalSupply * arg1
                if arg1 + totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1500 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1500 + 68] = mem[idx + _1410 + 32]
                idx = idx + 32
                continue 
            mem[_1500 + 68] = mem[_1500 + 70 len 30]
            revert with memory
              from mem[64]
               len _1500 + -mem[64] + 100
        _842 = mem[64]
        mem[64] = mem[64] + 64
        mem[_842] = 26
        mem[_842 + 32] = 'SafeMath: division by zero' << 48
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _904 = mem[64]
            mem[64] = mem[64] + 64
            mem[_904] = 26
            mem[_904 + 32] = 'SafeMath: division by zero' << 48
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if _tFeePercent * arg1 / 10000:
                    if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * _tFeePercent * arg1 / 10000 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    if 0 > t / s * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * _tFeePercent * arg1 / 10000 > t / s * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                if t / s * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * t / s * arg1
                if t / s * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * t / s * arg1
        else:
            _905 = mem[64]
            mem[64] = mem[64] + 64
            mem[_905] = 26
            mem[_905 + 32] = 'SafeMath: division by zero' << 48
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if _tFeePercent * arg1 / 10000:
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    if 0 > stor209 / totalSupply * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                if stor209 / totalSupply * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * stor209 / totalSupply * arg1
    if arg1 + totalFees < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function rebase(int256 arg1) payable {
    require calldata.size - 4 >= 32
    if msg.sender == owner:
        if stor202 + 1 < stor202:
            revert with 0, 'SafeMath: addition overflow'
        stor202++
        if not arg1:
            emit 0x7372725a: totalSupply, stor202
        else:
            if arg1 >= 0:
                if not arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3010] = 26
                                        mem[_3010 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3138 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3138] = 26
                                        mem[_3138 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4405 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4405] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4405 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4405 + 32
                                t = sha3(mem[0])
                                while _4405 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4405 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4405 + 36 len mem[_4405] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6011 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6011 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6011 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6011 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3014 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3014] = 26
                                        mem[_3014 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3142 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3142] = 26
                                        mem[_3142 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4408 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4408] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4408 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4408 + 32
                                t = sha3(mem[0])
                                while _4408 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4408 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4408 + 36 len mem[_4408] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6012 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6012 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6012 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6012 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3018] = 26
                                        mem[_3018 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3146 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3146] = 26
                                        mem[_3146 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4411 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4411] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4411 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4411 + 32
                                t = sha3(mem[0])
                                while _4411 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4411 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4411 + 36 len mem[_4411] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6013 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6013 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6013 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6013 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3022 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3022] = 26
                                        mem[_3022 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3150 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3150] = 26
                                        mem[_3150 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4414 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4414] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4414 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4414 + 32
                                t = sha3(mem[0])
                                while _4414 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4414 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4414 + 36 len mem[_4414] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6014 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6014 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6014 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6014 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if 10^9 * arg1 / arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2994] = 26
                                        mem[_2994 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3122 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3122] = 26
                                        mem[_3122 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4393 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4393] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4393 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4393 + 32
                                t = sha3(mem[0])
                                while _4393 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4393 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4393 + 36 len mem[_4393] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6007 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6007 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6007 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6007 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2998 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2998] = 26
                                        mem[_2998 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3126 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3126] = 26
                                        mem[_3126 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4396 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4396] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4396 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4396 + 32
                                t = sha3(mem[0])
                                while _4396 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4396 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4396 + 36 len mem[_4396] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6008 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6008 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6008 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6008 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3002] = 26
                                        mem[_3002 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3130] = 26
                                        mem[_3130 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4399 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4399] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4399 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4399 + 32
                                t = sha3(mem[0])
                                while _4399 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4399 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4399 + 36 len mem[_4399] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6009 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6009 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6009 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6009 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3006] = 26
                                        mem[_3006 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3134 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3134] = 26
                                        mem[_3134 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4402 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4402] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4402 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4402 + 32
                                t = sha3(mem[0])
                                while _4402 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4402 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4402 + 36 len mem[_4402] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6010 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6010 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6010 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6010 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
            else:
                if -arg1 < 0:
                    revert with 0, 'SafeCast: value must be positive'
                if not -arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2978 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2978] = 26
                                        mem[_2978 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3106 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3106] = 26
                                        mem[_3106 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4381 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4381] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4381 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4381 + 32
                                t = sha3(mem[0])
                                while _4381 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4381 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4381 + 36 len mem[_4381] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6003 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6003 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6003 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6003 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2982 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2982] = 26
                                        mem[_2982 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3110] = 26
                                        mem[_3110 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4384 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4384] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4384 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4384 + 32
                                t = sha3(mem[0])
                                while _4384 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4384 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4384 + 36 len mem[_4384] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6004 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6004 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6004 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6004 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2986 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2986] = 26
                                        mem[_2986 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3114 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3114] = 26
                                        mem[_3114 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4387 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4387] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4387 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4387 + 32
                                t = sha3(mem[0])
                                while _4387 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4387 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4387 + 36 len mem[_4387] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6005 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6005 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6005 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6005 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2990] = 26
                                        mem[_2990 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3118 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3118] = 26
                                        mem[_3118 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4390 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4390] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4390 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4390 + 32
                                t = sha3(mem[0])
                                while _4390 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4390 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4390 + 36 len mem[_4390] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6006 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6006 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6006 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6006 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if -1 * 10^9 * arg1 / -arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (-1 * 10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2962] = 26
                                        mem[_2962 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3090] = 26
                                        mem[_3090 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4369 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4369] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4369 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4369 + 32
                                t = sha3(mem[0])
                                while _4369 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4369 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4369 + 36 len mem[_4369] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5999 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5999 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _5999 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5999 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2966] = 26
                                        mem[_2966 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3094] = 26
                                        mem[_3094 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4372 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4372] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4372 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4372 + 32
                                t = sha3(mem[0])
                                while _4372 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4372 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4372 + 36 len mem[_4372] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6000 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6000 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6000 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6000 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if -1 * 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2970 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2970] = 26
                                        mem[_2970 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3098] = 26
                                        mem[_3098 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4375 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4375] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4375 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4375 + 32
                                t = sha3(mem[0])
                                while _4375 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4375 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4375 + 36 len mem[_4375] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6001 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6001 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6001 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6001 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2974 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2974] = 26
                                        mem[_2974 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3102 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3102] = 26
                                        mem[_3102 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4378 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4378] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4378 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4378 + 32
                                t = sha3(mem[0])
                                while _4378 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4378 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4378 + 36 len mem[_4378] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6002 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6002 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6002 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6002 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
    else:
        if _rebaserAddress != msg.sender:
            revert with 0, 'Sender not authorized'
        if stor202 + 1 < stor202:
            revert with 0, 'SafeMath: addition overflow'
        stor202++
        if not arg1:
            emit 0x7372725a: totalSupply, stor202
        else:
            if arg1 >= 0:
                if not arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3074] = 26
                                        mem[_3074 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3202] = 26
                                        mem[_3202 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4453 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4453] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4453 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4453 + 32
                                t = sha3(mem[0])
                                while _4453 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4453 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4453 + 36 len mem[_4453] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6027 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6027 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6027 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6027 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3078 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3078] = 26
                                        mem[_3078 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3206 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3206] = 26
                                        mem[_3206 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4456 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4456] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4456 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4456 + 32
                                t = sha3(mem[0])
                                while _4456 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4456 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4456 + 36 len mem[_4456] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6028 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6028 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6028 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6028 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3082 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3082] = 26
                                        mem[_3082 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3210 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3210] = 26
                                        mem[_3210 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4459 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4459] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4459 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4459 + 32
                                t = sha3(mem[0])
                                while _4459 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4459 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4459 + 36 len mem[_4459] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6029 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6029 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6029 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6029 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3086 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3086] = 26
                                        mem[_3086 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3214 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3214] = 26
                                        mem[_3214 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4462 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4462] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4462 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4462 + 32
                                t = sha3(mem[0])
                                while _4462 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4462 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4462 + 36 len mem[_4462] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6030 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6030 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6030 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6030 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if 10^9 * arg1 / arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3058 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3058] = 26
                                        mem[_3058 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3186] = 26
                                        mem[_3186 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4441 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4441] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4441 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4441 + 32
                                t = sha3(mem[0])
                                while _4441 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4441 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4441 + 36 len mem[_4441] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6023 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6023 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6023 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6023 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3062] = 26
                                        mem[_3062 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3190 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3190] = 26
                                        mem[_3190 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4444 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4444] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4444 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4444 + 32
                                t = sha3(mem[0])
                                while _4444 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4444 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4444 + 36 len mem[_4444] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6024 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6024 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6024 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6024 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3066] = 26
                                        mem[_3066 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3194 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3194] = 26
                                        mem[_3194 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4447 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4447] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4447 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4447 + 32
                                t = sha3(mem[0])
                                while _4447 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4447 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4447 + 36 len mem[_4447] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6025 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6025 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6025 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6025 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3070] = 26
                                        mem[_3070 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3198 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3198] = 26
                                        mem[_3198 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4450 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4450] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4450 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4450 + 32
                                t = sha3(mem[0])
                                while _4450 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4450 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4450 + 36 len mem[_4450] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6026 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6026 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6026 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6026 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
            else:
                if -arg1 < 0:
                    revert with 0, 'SafeCast: value must be positive'
                if not -arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3042] = 26
                                        mem[_3042 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3170 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3170] = 26
                                        mem[_3170 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4429 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4429] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4429 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4429 + 32
                                t = sha3(mem[0])
                                while _4429 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4429 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4429 + 36 len mem[_4429] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6019 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6019 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6019 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6019 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3046 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3046] = 26
                                        mem[_3046 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3174] = 26
                                        mem[_3174 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4432 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4432] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4432 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4432 + 32
                                t = sha3(mem[0])
                                while _4432 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4432 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4432 + 36 len mem[_4432] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6020 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6020 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6020 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6020 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3050 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3050] = 26
                                        mem[_3050 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3178] = 26
                                        mem[_3178 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4435 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4435] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4435 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4435 + 32
                                t = sha3(mem[0])
                                while _4435 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4435 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4435 + 36 len mem[_4435] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6021 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6021 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6021 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6021 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3054] = 26
                                        mem[_3054 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3182 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3182] = 26
                                        mem[_3182 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4438 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4438] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4438 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4438 + 32
                                t = sha3(mem[0])
                                while _4438 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4438 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4438 + 36 len mem[_4438] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6022 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6022 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6022 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6022 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if -1 * 10^9 * arg1 / -arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (-1 * 10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3026] = 26
                                        mem[_3026 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3154 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3154] = 26
                                        mem[_3154 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4417 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4417] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4417 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4417 + 32
                                t = sha3(mem[0])
                                while _4417 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4417 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4417 + 36 len mem[_4417] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6015 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6015 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6015 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6015 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3030 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3030] = 26
                                        mem[_3030 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3158 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3158] = 26
                                        mem[_3158 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4420 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4420] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4420 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4420 + 32
                                t = sha3(mem[0])
                                while _4420 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4420 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4420 + 36 len mem[_4420] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6016 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6016 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6016 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6016 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if -1 * 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3034] = 26
                                        mem[_3034 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3162 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3162] = 26
                                        mem[_3162 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4423 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4423] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4423 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4423 + 32
                                t = sha3(mem[0])
                                while _4423 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4423 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4423 + 36 len mem[_4423] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6017 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6017 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6017 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6017 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _3038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3038] = 26
                                        mem[_3038 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3166] = 26
                                        mem[_3166 + 32] = 'SafeMath: division by zero' << 48
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit 0x7372725a: totalSupply, stor202
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4426 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4426] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4426 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4426 + 32
                                t = sha3(mem[0])
                                while _4426 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4426 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4426 + 36 len mem[_4426] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _6018 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _6018 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address arg1, uint256 arg2, bytes arg3):
                                                       mem[mem[64] len _6018 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_6018 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
    return totalSupply
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x7345524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0xe05472616e7366657220616d6f756e74206d7573742062652067726561746572207468616e207a6572,
                    mem[205 len 23]
    if not stor206[address(msg.sender)]:
        if stor206[address(msg.sender)]:
            if stor206[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 206
                if not stor206[address(msg.sender)]:
                    if not arg2:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero' << 48
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _33994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33994] = 26
                                mem[_33994 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33994 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39058 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39058] = 30
                                    mem[_39058 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41074 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41074] = 30
                                    mem[_41074 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42459 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42459 + 68] = mem[idx + _41074 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42459 + 68] = mem[_42459 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42459 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _49434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49434] = 30
                                    mem[_49434 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _51899 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51899 + 68] = mem[idx + _49434 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51899 + 68] = mem[_51899 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51899 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39167] = 30
                                mem[_39167 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39437 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39437 + 68] = mem[idx + _39167 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39437 + 68] = mem[_39437 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39437 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41934] = 30
                                mem[_41934 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43127 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43127 + 68] = mem[idx + _41934 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43127 + 68] = mem[_43127 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43127 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _50723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50723] = 30
                                mem[_50723 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _52993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _52993 + 68] = mem[idx + _50723 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52993 + 68] = mem[_52993 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52993 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _34302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34302] = 30
                                mem[_34302 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _34798 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _34798 + 68] = mem[idx + _34302 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34798 + 68] = mem[_34798 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34798 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _36601 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36601] = 30
                                mem[_36601 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _37409 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _37409 + 68] = mem[idx + _36601 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37409 + 68] = mem[_37409 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37409 + -mem[64] + 100
                            _34492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34492] = 26
                            mem[_34492 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34492 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _39298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39298] = 30
                                mem[_39298 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42464 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42464] = 30
                                mem[_42464 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _44028 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44028 + 68] = mem[idx + _42464 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44028 + 68] = mem[_44028 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44028 + -mem[64] + 100
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = stor203[arg1]
                                _51902 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51902] = 30
                                mem[_51902 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _53828 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53828 + 68] = mem[idx + _51902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53828 + 68] = mem[_53828 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53828 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39440] = 30
                            mem[_39440 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _40180 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40180 + 68] = mem[idx + _39440 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40180 + 68] = mem[_40180 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40180 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _43130 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43130] = 30
                            mem[_43130 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _45044 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45044 + 68] = mem[idx + _43130 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45044 + 68] = mem[_45044 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45044 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            _52996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_52996] = 30
                            mem[_52996 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                                return 1
                            _54479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _54479 + 68] = mem[idx + _52996 + 32]
                                idx = idx + 32
                                continue 
                            mem[_54479 + 68] = mem[_54479 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _54479 + -mem[64] + 100
                        _33124 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33124] = 26
                        mem[_33124 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _35048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35048] = 26
                            mem[_35048 + 32] = 'SafeMath: division by zero' << 48
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                        else:
                            _35049 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35049] = 26
                            mem[_35049 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit 0x64ddf252: arg2, msg.sender, arg1
                    else:
                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero' << 48
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if _tFeePercent * arg2 / 10000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _33989 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33989] = 26
                                mem[_33989 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33989 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39057 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39057] = 30
                                        mem[_39057 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41063 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41063] = 30
                                        mem[_41063 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42447 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42447 + 68] = mem[idx + _41063 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42447 + 68] = mem[_42447 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42447 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _49414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49414] = 30
                                        mem[_49414 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _51886 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51886 + 68] = mem[idx + _49414 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51886 + 68] = mem[_51886 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51886 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39164 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39164] = 30
                                    mem[_39164 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _39432 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39432 + 68] = mem[idx + _39164 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39432 + 68] = mem[_39432 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39432 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41927] = 30
                                    mem[_41927 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43114 + 68] = mem[idx + _41927 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43114 + 68] = mem[_43114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43114 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _50707 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50707] = 30
                                    mem[_50707 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _52986 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52986 + 68] = mem[idx + _50707 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52986 + 68] = mem[_52986 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52986 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39163 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39163] = 30
                                    mem[_39163 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39429 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39429 + 68] = mem[idx + _39163 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39429 + 68] = mem[_39429 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39429 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41926 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41926] = 30
                                    mem[_41926 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43111 + 68] = mem[idx + _41926 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43111 + 68] = mem[_43111 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43111 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _50706 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50706] = 30
                                    mem[_50706 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _52983 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52983 + 68] = mem[idx + _50706 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52983 + 68] = mem[_52983 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52983 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39294] = 30
                                mem[_39294 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39863 + 68] = mem[idx + _39294 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39863 + 68] = mem[_39863 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39863 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42446] = 30
                                mem[_42446 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44009 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44009 + 68] = mem[idx + _42446 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44009 + 68] = mem[_44009 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44009 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _51885 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51885] = 30
                                mem[_51885 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _53817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53817 + 68] = mem[idx + _51885 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53817 + 68] = mem[_53817 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53817 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _34299 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34299] = 30
                                mem[_34299 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _34794 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _34794 + 68] = mem[idx + _34299 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34794 + 68] = mem[_34794 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34794 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _36594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36594] = 30
                                mem[_36594 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _37401 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _37401 + 68] = mem[idx + _36594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37401 + 68] = mem[_37401 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37401 + -mem[64] + 100
                            _34487 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34487] = 26
                            mem[_34487 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34487 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _39297 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39297] = 30
                                    mem[_39297 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42456 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42456] = 30
                                    mem[_42456 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44016 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44016 + 68] = mem[idx + _42456 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44016 + 68] = mem[_44016 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44016 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _51890 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51890] = 30
                                    mem[_51890 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53822 + 68] = mem[idx + _51890 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53822 + 68] = mem[_53822 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53822 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39436] = 30
                                mem[_39436 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _40174 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40174 + 68] = mem[idx + _39436 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40174 + 68] = mem[_40174 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40174 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43120 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43120] = 30
                                mem[_43120 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _45034 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45034 + 68] = mem[idx + _43120 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45034 + 68] = mem[_45034 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45034 + -mem[64] + 100
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52990 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52990] = 30
                                mem[_52990 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _54471 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54471 + 68] = mem[idx + _52990 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54471 + 68] = mem[_54471 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54471 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _39435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39435] = 30
                                mem[_39435 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40171 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40171 + 68] = mem[idx + _39435 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40171 + 68] = mem[_40171 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40171 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43119 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43119] = 30
                                mem[_43119 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45031 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45031 + 68] = mem[idx + _43119 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45031 + 68] = mem[_45031 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45031 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _52989 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52989] = 30
                                mem[_52989 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _54468 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54468 + 68] = mem[idx + _52989 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54468 + 68] = mem[_54468 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54468 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39866] = 30
                            mem[_39866 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _40683 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40683 + 68] = mem[idx + _39866 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40683 + 68] = mem[_40683 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40683 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _44015 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_44015] = 30
                            mem[_44015 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _45947 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45947 + 68] = mem[idx + _44015 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45947 + 68] = mem[_45947 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45947 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            _53821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53821] = 30
                            mem[_53821 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _55282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _55282 + 68] = mem[idx + _53821 + 32]
                                idx = idx + 32
                                continue 
                            mem[_55282 + 68] = mem[_55282 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55282 + -mem[64] + 100
                        _33119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33119] = 26
                        mem[_33119 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _35041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35041] = 26
                            mem[_35041 + 32] = 'SafeMath: division by zero' << 48
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            _35042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35042] = 26
                            mem[_35042 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                else:
                    mem[0] = arg1
                    mem[32] = 206
                    if not stor206[address(arg1)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34004 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34004] = 26
                                    mem[_34004 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34004 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39062] = 30
                                        mem[_39062 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41105 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41105] = 30
                                        mem[_41105 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42482 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42482 + 68] = mem[idx + _41105 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42482 + 68] = mem[_42482 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42482 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _49476 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49476] = 30
                                        mem[_49476 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _51935 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51935 + 68] = mem[idx + _49476 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51935 + 68] = mem[_51935 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51935 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39172] = 30
                                    mem[_39172 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39453 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39453 + 68] = mem[idx + _39172 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39453 + 68] = mem[_39453 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39453 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41954] = 30
                                    mem[_41954 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43159 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43159 + 68] = mem[idx + _41954 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43159 + 68] = mem[_43159 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43159 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _50762 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50762] = 30
                                    mem[_50762 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53017 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53017 + 68] = mem[idx + _50762 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53017 + 68] = mem[_53017 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53017 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34308] = 30
                                    mem[_34308 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34806 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34806 + 68] = mem[idx + _34308 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34806 + 68] = mem[_34806 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34806 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36615 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36615] = 30
                                    mem[_36615 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37425 + 68] = mem[idx + _36615 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37425 + 68] = mem[_37425 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37425 + -mem[64] + 100
                                _34502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34502] = 26
                                mem[_34502 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34502 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39303] = 30
                                    mem[_39303 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42487 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42487] = 30
                                    mem[_42487 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44064 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44064 + 68] = mem[idx + _42487 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44064 + 68] = mem[_44064 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44064 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _51938 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51938] = 30
                                    mem[_51938 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53846 + 68] = mem[idx + _51938 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53846 + 68] = mem[_53846 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53846 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39456 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39456] = 30
                                mem[_39456 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40198 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40198 + 68] = mem[idx + _39456 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40198 + 68] = mem[_40198 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40198 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43162] = 30
                                mem[_43162 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45076 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45076 + 68] = mem[idx + _43162 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45076 + 68] = mem[_45076 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45076 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53020 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53020] = 30
                                mem[_53020 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _54501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54501 + 68] = mem[idx + _53020 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54501 + 68] = mem[_54501 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54501 + -mem[64] + 100
                            _33134 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33134] = 26
                            mem[_33134 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35062] = 26
                                mem[_35062 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _35063 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35063] = 26
                                mem[_35063 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _33999 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33999] = 26
                                    mem[_33999 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33999 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39061 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39061] = 30
                                            mem[_39061 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41094 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41094] = 30
                                            mem[_41094 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42470 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42470 + 68] = mem[idx + _41094 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42470 + 68] = mem[_42470 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42470 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49456 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49456] = 30
                                            mem[_49456 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _51922 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51922 + 68] = mem[idx + _49456 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51922 + 68] = mem[_51922 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51922 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39169 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39169] = 30
                                        mem[_39169 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39448 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39448 + 68] = mem[idx + _39169 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39448 + 68] = mem[_39448 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39448 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41947 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41947] = 30
                                        mem[_41947 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43146 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43146 + 68] = mem[idx + _41947 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43146 + 68] = mem[_43146 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43146 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50746 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50746] = 30
                                        mem[_50746 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53010 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53010 + 68] = mem[idx + _50746 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53010 + 68] = mem[_53010 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53010 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39168 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39168] = 30
                                        mem[_39168 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39445 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39445 + 68] = mem[idx + _39168 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39445 + 68] = mem[_39445 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39445 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41946 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41946] = 30
                                        mem[_41946 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43143 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43143 + 68] = mem[idx + _41946 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43143 + 68] = mem[_43143 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43143 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50745 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50745] = 30
                                        mem[_50745 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53007 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53007 + 68] = mem[idx + _50745 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53007 + 68] = mem[_53007 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53007 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39299 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39299] = 30
                                    mem[_39299 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39875 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39875 + 68] = mem[idx + _39299 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39875 + 68] = mem[_39875 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39875 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42469 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42469] = 30
                                    mem[_42469 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44045 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44045 + 68] = mem[idx + _42469 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44045 + 68] = mem[_44045 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44045 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51921 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51921] = 30
                                    mem[_51921 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53835 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53835 + 68] = mem[idx + _51921 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53835 + 68] = mem[_53835 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53835 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34305] = 30
                                    mem[_34305 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34802 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34802 + 68] = mem[idx + _34305 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34802 + 68] = mem[_34802 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34802 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36608 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36608] = 30
                                    mem[_36608 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37417 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37417 + 68] = mem[idx + _36608 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37417 + 68] = mem[_37417 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37417 + -mem[64] + 100
                                _34497 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34497] = 26
                                mem[_34497 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34497 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39302 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39302] = 30
                                        mem[_39302 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42479 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42479] = 30
                                        mem[_42479 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44052 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44052 + 68] = mem[idx + _42479 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44052 + 68] = mem[_44052 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44052 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51926 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51926] = 30
                                        mem[_51926 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53840 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53840 + 68] = mem[idx + _51926 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53840 + 68] = mem[_53840 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53840 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39452 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39452] = 30
                                    mem[_39452 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _40192 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40192 + 68] = mem[idx + _39452 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40192 + 68] = mem[_40192 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40192 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43152 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43152] = 30
                                    mem[_43152 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _45066 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45066 + 68] = mem[idx + _43152 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45066 + 68] = mem[_45066 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45066 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53014] = 30
                                    mem[_53014 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54493 + 68] = mem[idx + _53014 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54493 + 68] = mem[_54493 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54493 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39451 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39451] = 30
                                    mem[_39451 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40189 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40189 + 68] = mem[idx + _39451 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40189 + 68] = mem[_40189 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40189 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43151] = 30
                                    mem[_43151 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45063 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45063 + 68] = mem[idx + _43151 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45063 + 68] = mem[_45063 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45063 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53013 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53013] = 30
                                    mem[_53013 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54490 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54490 + 68] = mem[idx + _53013 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54490 + 68] = mem[_54490 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54490 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39878 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39878] = 30
                                mem[_39878 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40697 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40697 + 68] = mem[idx + _39878 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40697 + 68] = mem[_40697 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40697 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _44051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44051] = 30
                                mem[_44051 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45985 + 68] = mem[idx + _44051 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45985 + 68] = mem[_45985 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45985 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _53839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53839] = 30
                                mem[_53839 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55314 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55314 + 68] = mem[idx + _53839 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55314 + 68] = mem[_55314 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55314 + -mem[64] + 100
                            _33129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33129] = 26
                            mem[_33129 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35055 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35055] = 26
                                mem[_35055 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _35056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35056] = 26
                                mem[_35056 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                    else:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34014] = 26
                                    mem[_34014 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34014 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39064 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39064] = 30
                                        mem[_39064 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41125] = 30
                                        mem[_41125 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42498 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42498 + 68] = mem[idx + _41125 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42498 + 68] = mem[_42498 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42498 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _45095 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45095] = 30
                                        mem[_45095 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _47121 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47121 + 68] = mem[idx + _45095 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47121 + 68] = mem[_47121 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47121 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _57309 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57309] = 30
                                        mem[_57309 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _59121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59121 + 68] = mem[idx + _57309 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59121 + 68] = mem[_59121 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59121 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39174] = 30
                                    mem[_39174 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39461 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39461 + 68] = mem[idx + _39174 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39461 + 68] = mem[_39461 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39461 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _41962 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41962] = 30
                                    mem[_41962 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _43179 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43179 + 68] = mem[idx + _41962 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43179 + 68] = mem[_43179 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43179 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _46024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_46024] = 30
                                    mem[_46024 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _48380 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _48380 + 68] = mem[idx + _46024 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48380 + 68] = mem[_48380 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48380 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58189 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58189] = 30
                                    mem[_58189 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _60173 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _60173 + 68] = mem[idx + _58189 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60173 + 68] = mem[_60173 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60173 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34314] = 30
                                    mem[_34314 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34814 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34814 + 68] = mem[idx + _34314 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34814 + 68] = mem[_34814 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34814 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36629 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36629] = 30
                                    mem[_36629 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37441 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37441 + 68] = mem[idx + _36629 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37441 + 68] = mem[_37441 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37441 + -mem[64] + 100
                                _34512 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34512] = 26
                                mem[_34512 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34512 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39305] = 30
                                    mem[_39305 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _42503 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42503] = 30
                                    mem[_42503 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _44088 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44088 + 68] = mem[idx + _42503 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44088 + 68] = mem[_44088 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44088 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47127] = 30
                                    mem[_47127 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _49516 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49516 + 68] = mem[idx + _47127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49516 + 68] = mem[_49516 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49516 + -mem[64] + 100
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _59124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59124] = 30
                                    mem[_59124 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _61042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61042 + 68] = mem[idx + _59124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61042 + 68] = mem[_61042 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61042 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39464 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39464] = 30
                                mem[_39464 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40210 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40210 + 68] = mem[idx + _39464 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40210 + 68] = mem[_40210 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40210 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 204
                                _43182 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43182] = 30
                                mem[_43182 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor204[address(msg.sender)]:
                                    _45098 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45098 + 68] = mem[idx + _43182 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45098 + 68] = mem[_45098 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45098 + -mem[64] + 100
                                mem[0] = msg.sender
                                stor204[address(msg.sender)] -= arg2
                                mem[32] = 203
                                _48383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_48383] = 30
                                mem[_48383 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _50793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _50793 + 68] = mem[idx + _48383 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50793 + 68] = mem[_50793 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50793 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _60176 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60176] = 30
                                mem[_60176 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _61836 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61836 + 68] = mem[idx + _60176 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61836 + 68] = mem[_61836 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61836 + -mem[64] + 100
                            _33144 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33144] = 26
                            mem[_33144 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35076] = 26
                                mem[_35076 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += t / s * arg2
                            else:
                                _35077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35077] = 26
                                mem[_35077 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                        else:
                            if 0 / arg2:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34009 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34009] = 26
                                    mem[_34009 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34009 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39063 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39063] = 30
                                        mem[_39063 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41115 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41115] = 30
                                        mem[_41115 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42490 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42490 + 68] = mem[idx + _41115 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42490 + 68] = mem[_42490 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42490 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _45084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45084] = 30
                                        mem[_45084 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _47105 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47105 + 68] = mem[idx + _45084 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47105 + 68] = mem[_47105 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47105 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _57301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57301] = 30
                                        mem[_57301 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _59111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59111 + 68] = mem[idx + _57301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59111 + 68] = mem[_59111 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59111 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39173 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39173] = 30
                                    mem[_39173 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39457 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39457 + 68] = mem[idx + _39173 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39457 + 68] = mem[_39457 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39457 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _41958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41958] = 30
                                    mem[_41958 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _43169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43169 + 68] = mem[idx + _41958 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43169 + 68] = mem[_43169 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43169 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _46011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_46011] = 30
                                    mem[_46011 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _48367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _48367 + 68] = mem[idx + _46011 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48367 + 68] = mem[_48367 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48367 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58183] = 30
                                    mem[_58183 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _60167 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _60167 + 68] = mem[idx + _58183 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60167 + 68] = mem[_60167 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60167 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34311] = 30
                                    mem[_34311 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34810 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34810 + 68] = mem[idx + _34311 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34810 + 68] = mem[_34810 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34810 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36622] = 30
                                    mem[_36622 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37433 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37433 + 68] = mem[idx + _36622 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37433 + 68] = mem[_37433 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37433 + -mem[64] + 100
                                _34507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34507] = 26
                                mem[_34507 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34507 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39304 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39304] = 30
                                    mem[_39304 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _42495 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42495] = 30
                                    mem[_42495 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _44076 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44076 + 68] = mem[idx + _42495 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44076 + 68] = mem[_44076 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44076 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47111 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47111] = 30
                                    mem[_47111 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _49497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49497 + 68] = mem[idx + _47111 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49497 + 68] = mem[_49497 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49497 + -mem[64] + 100
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _59114 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59114] = 30
                                    mem[_59114 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _61036 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61036 + 68] = mem[idx + _59114 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61036 + 68] = mem[_61036 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61036 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39460] = 30
                                mem[_39460 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40204 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40204 + 68] = mem[idx + _39460 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40204 + 68] = mem[_40204 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40204 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 204
                                _43172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43172] = 30
                                mem[_43172 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor204[address(msg.sender)]:
                                    _45087 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45087 + 68] = mem[idx + _43172 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45087 + 68] = mem[_45087 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45087 + -mem[64] + 100
                                mem[0] = msg.sender
                                stor204[address(msg.sender)] -= arg2
                                mem[32] = 203
                                _48370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_48370] = 30
                                mem[_48370 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _50777 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _50777 + 68] = mem[idx + _48370 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50777 + 68] = mem[_50777 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50777 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _60170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60170] = 30
                                mem[_60170 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _61828 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61828 + 68] = mem[idx + _60170 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61828 + 68] = mem[_61828 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61828 + -mem[64] + 100
                            _33139 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33139] = 26
                            mem[_33139 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35069 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35069] = 26
                                mem[_35069 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += t / s * arg2
                            else:
                                _35070 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35070] = 26
                                mem[_35070 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit 0x64ddf252: arg2, msg.sender, arg1
            else:
                mem[0] = arg1
                mem[32] = 206
                if not stor206[address(arg1)]:
                    if not arg2:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero' << 48
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _34054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34054] = 26
                                mem[_34054 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34054 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39078] = 30
                                    mem[_39078 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41238 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41238] = 30
                                    mem[_41238 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42583 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42583 + 68] = mem[idx + _41238 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42583 + 68] = mem[_42583 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42583 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _49678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49678] = 30
                                    mem[_49678 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _52107 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52107 + 68] = mem[idx + _49678 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52107 + 68] = mem[_52107 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52107 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39191] = 30
                                mem[_39191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39517 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39517 + 68] = mem[idx + _39191 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39517 + 68] = mem[_39517 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39517 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42030] = 30
                                mem[_42030 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43295 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43295 + 68] = mem[idx + _42030 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43295 + 68] = mem[_43295 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43295 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _50943 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50943] = 30
                                mem[_50943 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _53153 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53153 + 68] = mem[idx + _50943 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53153 + 68] = mem[_53153 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53153 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _34338 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34338] = 30
                                mem[_34338 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _34846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _34846 + 68] = mem[idx + _34338 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34846 + 68] = mem[_34846 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34846 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _36685 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36685] = 30
                                mem[_36685 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _37505 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _37505 + 68] = mem[idx + _36685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37505 + 68] = mem[_37505 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37505 + -mem[64] + 100
                            _34552 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34552] = 26
                            mem[_34552 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34552 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _39322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39322] = 30
                                mem[_39322 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42588] = 30
                                mem[_42588 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _44220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44220 + 68] = mem[idx + _42588 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44220 + 68] = mem[_44220 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44220 + -mem[64] + 100
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = stor203[arg1]
                                _52110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52110] = 30
                                mem[_52110 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _53952 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53952 + 68] = mem[idx + _52110 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53952 + 68] = mem[_53952 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53952 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39520] = 30
                            mem[_39520 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _40276 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40276 + 68] = mem[idx + _39520 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40276 + 68] = mem[_40276 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40276 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _43298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43298] = 30
                            mem[_43298 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _45216 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45216 + 68] = mem[idx + _43298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45216 + 68] = mem[_45216 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45216 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            _53156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53156] = 30
                            mem[_53156 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                                return 1
                            _54635 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _54635 + 68] = mem[idx + _53156 + 32]
                                idx = idx + 32
                                continue 
                            mem[_54635 + 68] = mem[_54635 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _54635 + -mem[64] + 100
                        _33184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33184] = 26
                        mem[_33184 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _35132 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35132] = 26
                            mem[_35132 + 32] = 'SafeMath: division by zero' << 48
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                        else:
                            _35133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35133] = 26
                            mem[_35133 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit 0x64ddf252: arg2, msg.sender, arg1
                    else:
                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero' << 48
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if _tFeePercent * arg2 / 10000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _34049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34049] = 26
                                mem[_34049 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34049 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39077 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39077] = 30
                                        mem[_39077 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41227] = 30
                                        mem[_41227 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42571 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42571 + 68] = mem[idx + _41227 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42571 + 68] = mem[_42571 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42571 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _49658 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49658] = 30
                                        mem[_49658 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _52094 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52094 + 68] = mem[idx + _49658 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52094 + 68] = mem[_52094 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52094 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39188] = 30
                                    mem[_39188 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _39512 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39512 + 68] = mem[idx + _39188 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39512 + 68] = mem[_39512 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39512 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42023 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42023] = 30
                                    mem[_42023 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43282 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43282 + 68] = mem[idx + _42023 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43282 + 68] = mem[_43282 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43282 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _50927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50927] = 30
                                    mem[_50927 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53146 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53146 + 68] = mem[idx + _50927 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53146 + 68] = mem[_53146 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53146 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39187] = 30
                                    mem[_39187 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39509 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39509 + 68] = mem[idx + _39187 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39509 + 68] = mem[_39509 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39509 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42022] = 30
                                    mem[_42022 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43279 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43279 + 68] = mem[idx + _42022 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43279 + 68] = mem[_43279 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43279 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _50926 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50926] = 30
                                    mem[_50926 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53143 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53143 + 68] = mem[idx + _50926 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53143 + 68] = mem[_53143 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53143 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39318 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39318] = 30
                                mem[_39318 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39919 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39919 + 68] = mem[idx + _39318 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39919 + 68] = mem[_39919 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39919 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42570 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42570] = 30
                                mem[_42570 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44201 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44201 + 68] = mem[idx + _42570 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44201 + 68] = mem[_44201 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44201 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52093] = 30
                                mem[_52093 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _53941 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53941 + 68] = mem[idx + _52093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53941 + 68] = mem[_53941 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53941 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _34335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34335] = 30
                                mem[_34335 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _34842 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _34842 + 68] = mem[idx + _34335 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34842 + 68] = mem[_34842 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34842 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _36678 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36678] = 30
                                mem[_36678 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _37497 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _37497 + 68] = mem[idx + _36678 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37497 + 68] = mem[_37497 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37497 + -mem[64] + 100
                            _34547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34547] = 26
                            mem[_34547 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34547 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _39321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39321] = 30
                                    mem[_39321 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42580 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42580] = 30
                                    mem[_42580 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44208 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44208 + 68] = mem[idx + _42580 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44208 + 68] = mem[_44208 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44208 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _52098 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52098] = 30
                                    mem[_52098 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53946 + 68] = mem[idx + _52098 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53946 + 68] = mem[_53946 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53946 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39516] = 30
                                mem[_39516 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _40270 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40270 + 68] = mem[idx + _39516 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40270 + 68] = mem[_40270 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40270 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43288] = 30
                                mem[_43288 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _45206 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45206 + 68] = mem[idx + _43288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45206 + 68] = mem[_45206 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45206 + -mem[64] + 100
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _53150 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53150] = 30
                                mem[_53150 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _54627 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54627 + 68] = mem[idx + _53150 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54627 + 68] = mem[_54627 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54627 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _39515 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39515] = 30
                                mem[_39515 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40267 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40267 + 68] = mem[idx + _39515 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40267 + 68] = mem[_40267 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40267 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43287] = 30
                                mem[_43287 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45203 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45203 + 68] = mem[idx + _43287 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45203 + 68] = mem[_45203 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45203 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53149] = 30
                                mem[_53149 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _54624 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54624 + 68] = mem[idx + _53149 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54624 + 68] = mem[_54624 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54624 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39922 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39922] = 30
                            mem[_39922 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _40751 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40751 + 68] = mem[idx + _39922 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40751 + 68] = mem[_40751 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40751 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _44207 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_44207] = 30
                            mem[_44207 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _46151 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _46151 + 68] = mem[idx + _44207 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_46151 + 68] = mem[_46151 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _46151 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            _53945 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53945] = 30
                            mem[_53945 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _55470 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _55470 + 68] = mem[idx + _53945 + 32]
                                idx = idx + 32
                                continue 
                            mem[_55470 + 68] = mem[_55470 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55470 + -mem[64] + 100
                        _33179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33179] = 26
                        mem[_33179 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _35125 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35125] = 26
                            mem[_35125 + 32] = 'SafeMath: division by zero' << 48
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            _35126 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35126] = 26
                            mem[_35126 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                else:
                    mem[0] = msg.sender
                    mem[32] = 206
                    if not stor206[address(msg.sender)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34024] = 26
                                    mem[_34024 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34024 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39068 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39068] = 30
                                        mem[_39068 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41156 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41156] = 30
                                        mem[_41156 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42521 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42521 + 68] = mem[idx + _41156 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42521 + 68] = mem[_42521 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42521 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _49556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49556] = 30
                                        mem[_49556 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _52003 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52003 + 68] = mem[idx + _49556 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52003 + 68] = mem[_52003 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52003 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39179 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39179] = 30
                                    mem[_39179 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39477 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39477 + 68] = mem[idx + _39179 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39477 + 68] = mem[_39477 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39477 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41982 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41982] = 30
                                    mem[_41982 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43211 + 68] = mem[idx + _41982 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43211 + 68] = mem[_43211 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43211 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _50833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50833] = 30
                                    mem[_50833 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53073 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53073 + 68] = mem[idx + _50833 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53073 + 68] = mem[_53073 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53073 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34320] = 30
                                    mem[_34320 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34822 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34822 + 68] = mem[idx + _34320 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34822 + 68] = mem[_34822 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34822 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36643] = 30
                                    mem[_36643 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37457 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37457 + 68] = mem[idx + _36643 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37457 + 68] = mem[_37457 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37457 + -mem[64] + 100
                                _34522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34522] = 26
                                mem[_34522 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34522 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39310] = 30
                                    mem[_39310 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42526 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42526] = 30
                                    mem[_42526 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44124 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44124 + 68] = mem[idx + _42526 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44124 + 68] = mem[_44124 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44124 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _52006 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52006] = 30
                                    mem[_52006 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53890 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53890 + 68] = mem[idx + _52006 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53890 + 68] = mem[_53890 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53890 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39480 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39480] = 30
                                mem[_39480 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40228 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40228 + 68] = mem[idx + _39480 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40228 + 68] = mem[_40228 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40228 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43214 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43214] = 30
                                mem[_43214 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45130 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45130 + 68] = mem[idx + _43214 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45130 + 68] = mem[_45130 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45130 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53076] = 30
                                mem[_53076 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _54557 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54557 + 68] = mem[idx + _53076 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54557 + 68] = mem[_54557 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54557 + -mem[64] + 100
                            _33154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33154] = 26
                            mem[_33154 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35090] = 26
                                mem[_35090 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _35091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35091] = 26
                                mem[_35091 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34019] = 26
                                    mem[_34019 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34019 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39067 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39067] = 30
                                            mem[_39067 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41145 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41145] = 30
                                            mem[_41145 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42509 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42509 + 68] = mem[idx + _41145 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42509 + 68] = mem[_42509 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42509 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49536 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49536] = 30
                                            mem[_49536 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _51990 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51990 + 68] = mem[idx + _49536 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51990 + 68] = mem[_51990 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51990 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39176] = 30
                                        mem[_39176 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39472 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39472 + 68] = mem[idx + _39176 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39472 + 68] = mem[_39472 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39472 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41975] = 30
                                        mem[_41975 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43198 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43198 + 68] = mem[idx + _41975 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43198 + 68] = mem[_43198 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43198 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50817 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50817] = 30
                                        mem[_50817 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53066 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53066 + 68] = mem[idx + _50817 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53066 + 68] = mem[_53066 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53066 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39175] = 30
                                        mem[_39175 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39469 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39469 + 68] = mem[idx + _39175 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39469 + 68] = mem[_39469 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39469 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41974 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41974] = 30
                                        mem[_41974 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43195 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43195 + 68] = mem[idx + _41974 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43195 + 68] = mem[_43195 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43195 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50816 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50816] = 30
                                        mem[_50816 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53063 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53063 + 68] = mem[idx + _50816 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53063 + 68] = mem[_53063 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53063 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39306] = 30
                                    mem[_39306 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39891 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39891 + 68] = mem[idx + _39306 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39891 + 68] = mem[_39891 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39891 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42508] = 30
                                    mem[_42508 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44105 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44105 + 68] = mem[idx + _42508 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44105 + 68] = mem[_44105 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44105 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51989] = 30
                                    mem[_51989 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53879 + 68] = mem[idx + _51989 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53879 + 68] = mem[_53879 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53879 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34317] = 30
                                    mem[_34317 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34818 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34818 + 68] = mem[idx + _34317 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34818 + 68] = mem[_34818 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34818 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36636] = 30
                                    mem[_36636 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37449 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37449 + 68] = mem[idx + _36636 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37449 + 68] = mem[_37449 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37449 + -mem[64] + 100
                                _34517 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34517] = 26
                                mem[_34517 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34517 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39309 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39309] = 30
                                        mem[_39309 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42518 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42518] = 30
                                        mem[_42518 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44112 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44112 + 68] = mem[idx + _42518 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44112 + 68] = mem[_44112 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44112 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51994] = 30
                                        mem[_51994 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53884 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53884 + 68] = mem[idx + _51994 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53884 + 68] = mem[_53884 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53884 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39476 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39476] = 30
                                    mem[_39476 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _40222 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40222 + 68] = mem[idx + _39476 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40222 + 68] = mem[_40222 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40222 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43204] = 30
                                    mem[_43204 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _45120 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45120 + 68] = mem[idx + _43204 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45120 + 68] = mem[_45120 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45120 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53070 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53070] = 30
                                    mem[_53070 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54549 + 68] = mem[idx + _53070 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54549 + 68] = mem[_54549 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54549 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39475 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39475] = 30
                                    mem[_39475 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40219 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40219 + 68] = mem[idx + _39475 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40219 + 68] = mem[_40219 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40219 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43203 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43203] = 30
                                    mem[_43203 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45117 + 68] = mem[idx + _43203 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45117 + 68] = mem[_45117 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45117 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53069 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53069] = 30
                                    mem[_53069 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54546 + 68] = mem[idx + _53069 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54546 + 68] = mem[_54546 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54546 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39894] = 30
                                mem[_39894 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40717 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40717 + 68] = mem[idx + _39894 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40717 + 68] = mem[_40717 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40717 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _44111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44111] = 30
                                mem[_44111 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _46049 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _46049 + 68] = mem[idx + _44111 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_46049 + 68] = mem[_46049 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _46049 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _53883 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53883] = 30
                                mem[_53883 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55376 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55376 + 68] = mem[idx + _53883 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55376 + 68] = mem[_55376 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55376 + -mem[64] + 100
                            _33149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33149] = 26
                            mem[_33149 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35083 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35083] = 26
                                mem[_35083 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _35084 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35084] = 26
                                mem[_35084 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34034] = 26
                                        mem[_34034 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34034 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39072 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39072] = 30
                                            mem[_39072 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41187 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41187] = 30
                                            mem[_41187 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42544 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42544 + 68] = mem[idx + _41187 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42544 + 68] = mem[_42544 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42544 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49598 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49598] = 30
                                            mem[_49598 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52039 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52039 + 68] = mem[idx + _49598 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52039 + 68] = mem[_52039 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52039 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39184 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39184] = 30
                                        mem[_39184 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39493 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39493 + 68] = mem[idx + _39184 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39493 + 68] = mem[_39493 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39493 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42002] = 30
                                        mem[_42002 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43243 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43243 + 68] = mem[idx + _42002 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43243 + 68] = mem[_43243 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43243 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50872 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50872] = 30
                                        mem[_50872 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53097 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53097 + 68] = mem[idx + _50872 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53097 + 68] = mem[_53097 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53097 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34326 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34326] = 30
                                        mem[_34326 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34830 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34830 + 68] = mem[idx + _34326 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34830 + 68] = mem[_34830 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34830 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36657 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36657] = 30
                                        mem[_36657 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37473 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37473 + 68] = mem[idx + _36657 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37473 + 68] = mem[_37473 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37473 + -mem[64] + 100
                                    _34532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34532] = 26
                                    mem[_34532 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34532 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39315 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39315] = 30
                                        mem[_39315 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42549 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42549] = 30
                                        mem[_42549 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44160 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44160 + 68] = mem[idx + _42549 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44160 + 68] = mem[_44160 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44160 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52042] = 30
                                        mem[_52042 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53908 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53908 + 68] = mem[idx + _52042 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53908 + 68] = mem[_53908 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53908 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39496 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39496] = 30
                                    mem[_39496 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40246 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40246 + 68] = mem[idx + _39496 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40246 + 68] = mem[_40246 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40246 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43246 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43246] = 30
                                    mem[_43246 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45162 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45162 + 68] = mem[idx + _43246 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45162 + 68] = mem[_45162 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45162 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53100 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53100] = 30
                                    mem[_53100 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54579 + 68] = mem[idx + _53100 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54579 + 68] = mem[_54579 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54579 + -mem[64] + 100
                                _33164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33164] = 26
                                mem[_33164 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35104 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35104] = 26
                                    mem[_35104 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35105] = 26
                                    mem[_35105 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34029] = 26
                                        mem[_34029 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34029 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39071 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39071] = 30
                                                mem[_39071 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41176 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41176] = 30
                                                mem[_41176 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42532 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42532 + 68] = mem[idx + _41176 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42532 + 68] = mem[_42532 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42532 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49578 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49578] = 30
                                                mem[_49578 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52026 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52026 + 68] = mem[idx + _49578 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52026 + 68] = mem[_52026 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52026 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39181] = 30
                                            mem[_39181 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39488 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39488 + 68] = mem[idx + _39181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39488 + 68] = mem[_39488 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39488 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41995 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41995] = 30
                                            mem[_41995 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43230 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43230 + 68] = mem[idx + _41995 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43230 + 68] = mem[_43230 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43230 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _50856 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50856] = 30
                                            mem[_50856 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53090 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53090 + 68] = mem[idx + _50856 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53090 + 68] = mem[_53090 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53090 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39180 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39180] = 30
                                            mem[_39180 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39485 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39485 + 68] = mem[idx + _39180 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39485 + 68] = mem[_39485 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39485 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41994 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41994] = 30
                                            mem[_41994 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43227 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43227 + 68] = mem[idx + _41994 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43227 + 68] = mem[_43227 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43227 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50855 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50855] = 30
                                            mem[_50855 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53087 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53087 + 68] = mem[idx + _50855 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53087 + 68] = mem[_53087 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53087 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39311 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39311] = 30
                                        mem[_39311 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39903 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39903 + 68] = mem[idx + _39311 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39903 + 68] = mem[_39903 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39903 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42531 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42531] = 30
                                        mem[_42531 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44141 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44141 + 68] = mem[idx + _42531 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44141 + 68] = mem[_44141 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44141 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52025 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52025] = 30
                                        mem[_52025 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53897 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53897 + 68] = mem[idx + _52025 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53897 + 68] = mem[_53897 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53897 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34323 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34323] = 30
                                        mem[_34323 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34826 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34826 + 68] = mem[idx + _34323 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34826 + 68] = mem[_34826 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34826 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36650] = 30
                                        mem[_36650 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37465 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37465 + 68] = mem[idx + _36650 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37465 + 68] = mem[_37465 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37465 + -mem[64] + 100
                                    _34527 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34527] = 26
                                    mem[_34527 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34527 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39314 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39314] = 30
                                            mem[_39314 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42541 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42541] = 30
                                            mem[_42541 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44148 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44148 + 68] = mem[idx + _42541 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44148 + 68] = mem[_44148 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44148 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52030] = 30
                                            mem[_52030 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53902 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53902 + 68] = mem[idx + _52030 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53902 + 68] = mem[_53902 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53902 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39492 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39492] = 30
                                        mem[_39492 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40240 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40240 + 68] = mem[idx + _39492 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40240 + 68] = mem[_40240 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40240 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43236 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43236] = 30
                                        mem[_43236 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45152 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45152 + 68] = mem[idx + _43236 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45152 + 68] = mem[_45152 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45152 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53094] = 30
                                        mem[_53094 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54571 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54571 + 68] = mem[idx + _53094 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54571 + 68] = mem[_54571 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54571 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39491 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39491] = 30
                                        mem[_39491 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40237 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40237 + 68] = mem[idx + _39491 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40237 + 68] = mem[_40237 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40237 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43235 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43235] = 30
                                        mem[_43235 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45149 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45149 + 68] = mem[idx + _43235 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45149 + 68] = mem[_45149 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45149 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53093 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53093] = 30
                                        mem[_53093 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54568 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54568 + 68] = mem[idx + _53093 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54568 + 68] = mem[_54568 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54568 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39906] = 30
                                    mem[_39906 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40731 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40731 + 68] = mem[idx + _39906 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40731 + 68] = mem[_40731 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40731 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44147] = 30
                                    mem[_44147 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46087 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46087 + 68] = mem[idx + _44147 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46087 + 68] = mem[_46087 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46087 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53901 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53901] = 30
                                    mem[_53901 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55408 + 68] = mem[idx + _53901 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55408 + 68] = mem[_55408 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55408 + -mem[64] + 100
                                _33159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33159] = 26
                                mem[_33159 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35097 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35097] = 26
                                    mem[_35097 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35098 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35098] = 26
                                    mem[_35098 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34044] = 26
                                        mem[_34044 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34044 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39074 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39074] = 30
                                            mem[_39074 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41207 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41207] = 30
                                            mem[_41207 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42560 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42560 + 68] = mem[idx + _41207 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42560 + 68] = mem[_42560 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42560 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45181] = 30
                                            mem[_45181 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _47241 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47241 + 68] = mem[idx + _45181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47241 + 68] = mem[_47241 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47241 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57393 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57393] = 30
                                            mem[_57393 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _59223 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59223 + 68] = mem[idx + _57393 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59223 + 68] = mem[_59223 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59223 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39186] = 30
                                        mem[_39186 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39501 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39501 + 68] = mem[idx + _39186 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39501 + 68] = mem[_39501 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39501 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42010] = 30
                                        mem[_42010 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43263 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43263 + 68] = mem[idx + _42010 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43263 + 68] = mem[_43263 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43263 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46126 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46126] = 30
                                        mem[_46126 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _48484 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48484 + 68] = mem[idx + _46126 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48484 + 68] = mem[_48484 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48484 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58275 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58275] = 30
                                        mem[_58275 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _60253 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60253 + 68] = mem[idx + _58275 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60253 + 68] = mem[_60253 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60253 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34332] = 30
                                        mem[_34332 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34838 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34838 + 68] = mem[idx + _34332 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34838 + 68] = mem[_34838 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34838 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36671 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36671] = 30
                                        mem[_36671 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37489 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37489 + 68] = mem[idx + _36671 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37489 + 68] = mem[_37489 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37489 + -mem[64] + 100
                                    _34542 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34542] = 26
                                    mem[_34542 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34542 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39317 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39317] = 30
                                        mem[_39317 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42565] = 30
                                        mem[_42565 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44184 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44184 + 68] = mem[idx + _42565 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44184 + 68] = mem[_44184 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44184 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47247 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47247] = 30
                                        mem[_47247 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _49638 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _49638 + 68] = mem[idx + _47247 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_49638 + 68] = mem[_49638 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _49638 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _59226 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59226] = 30
                                        mem[_59226 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _61114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61114 + 68] = mem[idx + _59226 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61114 + 68] = mem[_61114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61114 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39504] = 30
                                    mem[_39504 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40258 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40258 + 68] = mem[idx + _39504 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40258 + 68] = mem[_40258 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40258 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _43266 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43266] = 30
                                    mem[_43266 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _45184 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45184 + 68] = mem[idx + _43266 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45184 + 68] = mem[_45184 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45184 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _48487 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48487] = 30
                                    mem[_48487 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _50903 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50903 + 68] = mem[idx + _48487 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50903 + 68] = mem[_50903 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50903 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _60256 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60256] = 30
                                    mem[_60256 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _61912 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61912 + 68] = mem[idx + _60256 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61912 + 68] = mem[_61912 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61912 + -mem[64] + 100
                                _33174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33174] = 26
                                mem[_33174 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35118 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35118] = 26
                                    mem[_35118 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _35119 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35119] = 26
                                    mem[_35119 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            else:
                                if 0 / arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34039 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34039] = 26
                                        mem[_34039 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34039 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39073 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39073] = 30
                                            mem[_39073 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41197 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41197] = 30
                                            mem[_41197 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42552 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42552 + 68] = mem[idx + _41197 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42552 + 68] = mem[_42552 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42552 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45170 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45170] = 30
                                            mem[_45170 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _47225 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47225 + 68] = mem[idx + _45170 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47225 + 68] = mem[_47225 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47225 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57385 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57385] = 30
                                            mem[_57385 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _59213 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59213 + 68] = mem[idx + _57385 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59213 + 68] = mem[_59213 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59213 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39185 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39185] = 30
                                        mem[_39185 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39497 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39497 + 68] = mem[idx + _39185 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39497 + 68] = mem[_39497 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39497 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42006] = 30
                                        mem[_42006 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43253 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43253 + 68] = mem[idx + _42006 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43253 + 68] = mem[_43253 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43253 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46113 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46113] = 30
                                        mem[_46113 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _48471 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48471 + 68] = mem[idx + _46113 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48471 + 68] = mem[_48471 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48471 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58269 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58269] = 30
                                        mem[_58269 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _60247 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60247 + 68] = mem[idx + _58269 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60247 + 68] = mem[_60247 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60247 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34329] = 30
                                        mem[_34329 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34834 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34834 + 68] = mem[idx + _34329 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34834 + 68] = mem[_34834 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34834 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36664 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36664] = 30
                                        mem[_36664 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37481 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37481 + 68] = mem[idx + _36664 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37481 + 68] = mem[_37481 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37481 + -mem[64] + 100
                                    _34537 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34537] = 26
                                    mem[_34537 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34537 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39316 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39316] = 30
                                        mem[_39316 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42557 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42557] = 30
                                        mem[_42557 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44172 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44172 + 68] = mem[idx + _42557 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44172 + 68] = mem[_44172 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44172 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47231 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47231] = 30
                                        mem[_47231 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _49619 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _49619 + 68] = mem[idx + _47231 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_49619 + 68] = mem[_49619 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _49619 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _59216 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59216] = 30
                                        mem[_59216 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _61108 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61108 + 68] = mem[idx + _59216 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61108 + 68] = mem[_61108 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61108 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39500 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39500] = 30
                                    mem[_39500 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40252 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40252 + 68] = mem[idx + _39500 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40252 + 68] = mem[_40252 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40252 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _43256 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43256] = 30
                                    mem[_43256 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _45173 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45173 + 68] = mem[idx + _43256 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45173 + 68] = mem[_45173 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45173 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _48474 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48474] = 30
                                    mem[_48474 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _50887 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50887 + 68] = mem[idx + _48474 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50887 + 68] = mem[_50887 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50887 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _60250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60250] = 30
                                    mem[_60250 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _61904 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61904 + 68] = mem[idx + _60250 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61904 + 68] = mem[_61904 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61904 + -mem[64] + 100
                                _33169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33169] = 26
                                mem[_33169 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35111 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35111] = 26
                                    mem[_35111 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _35112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35112] = 26
                                    mem[_35112 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
        else:
            mem[0] = arg1
            mem[32] = 206
            if stor206[address(arg1)]:
                if not arg2:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = totalSupply
                    t = stor209
                    while idx < stor207.length:
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        if stor203[stor207[idx]] > t:
                            _34134 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34134] = 26
                            mem[_34134 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34134 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _39106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39106] = 30
                                mem[_39106 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41464 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41464] = 30
                                mem[_41464 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _42753 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42753 + 68] = mem[idx + _41464 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42753 + 68] = mem[_42753 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42753 + -mem[64] + 100
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                _53366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53366] = 30
                                mem[_53366 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _54838 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54838 + 68] = mem[idx + _53366 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54838 + 68] = mem[_54838 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54838 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39225 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39225] = 30
                            mem[_39225 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _39629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39629 + 68] = mem[idx + _39225 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39629 + 68] = mem[_39629 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39629 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42166 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42166] = 30
                            mem[_42166 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _43527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43527 + 68] = mem[idx + _42166 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43527 + 68] = mem[_43527 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43527 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                            _54115 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54115] = 30
                            mem[_54115 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                                return 1
                            _55724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _55724 + 68] = mem[idx + _54115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_55724 + 68] = mem[_55724 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55724 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        if stor204[stor207[idx]] <= s:
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            _34386 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34386] = 30
                            mem[_34386 + 32] = 'SafeMath: subtraction overflow'
                            if stor203[stor207[idx]] > t:
                                _34910 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _34910 + 68] = mem[idx + _34386 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34910 + 68] = mem[_34910 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34910 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            _36797 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36797] = 30
                            mem[_36797 + 32] = 'SafeMath: subtraction overflow'
                            if stor204[stor207[idx]] <= s:
                                idx = idx + 1
                                s = s - stor204[stor207[idx]]
                                t = t - stor203[stor207[idx]]
                                continue 
                            _37633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _37633 + 68] = mem[idx + _36797 + 32]
                                idx = idx + 32
                                continue 
                            mem[_37633 + 68] = mem[_37633 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _37633 + -mem[64] + 100
                        _34632 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34632] = 26
                        mem[_34632 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _34632 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            _39356 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39356] = 30
                            mem[_39356 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42758] = 30
                            mem[_42758 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _44484 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44484 + 68] = mem[idx + _42758 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44484 + 68] = mem[_44484 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44484 + -mem[64] + 100
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            _54841 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54841] = 30
                            mem[_54841 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                                return 1
                            _56708 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56708 + 68] = mem[idx + _54841 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56708 + 68] = mem[_56708 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56708 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _39632 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39632] = 30
                        mem[_39632 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor209 / totalSupply * arg2:
                            _40408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _40408 + 68] = mem[idx + _39632 + 32]
                                idx = idx + 32
                                continue 
                            mem[_40408 + 68] = mem[_40408 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40408 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 203
                        _43530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43530] = 30
                        mem[_43530 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _45452 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _45452 + 68] = mem[idx + _43530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_45452 + 68] = mem[_45452 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _45452 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor204[address(arg1)] += arg2
                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                        _55727 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55727] = 30
                        mem[_55727 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                            return 1
                        _57652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _57652 + 68] = mem[idx + _55727 + 32]
                            idx = idx + 32
                            continue 
                        mem[_57652 + 68] = mem[_57652 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57652 + -mem[64] + 100
                    _33264 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33264] = 26
                    mem[_33264 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor209 / totalSupply:
                        _35244 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35244] = 26
                        mem[_35244 + 32] = 'SafeMath: division by zero' << 48
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if t / s * arg2 / arg2 != t / s:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > t / s * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if t / s * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * t / s * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] += t / s * arg2
                    else:
                        _35245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35245] = 26
                        mem[_35245 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > stor209 / totalSupply * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                    if 0 > stor209:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit 0x64ddf252: arg2, msg.sender, arg1
                else:
                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero' << 48
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if _tFeePercent * arg2 / 10000 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = totalSupply
                    t = stor209
                    while idx < stor207.length:
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        if stor203[stor207[idx]] > t:
                            _34129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34129] = 26
                            mem[_34129 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34129 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _39105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39105] = 30
                                    mem[_39105 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41453 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41453] = 30
                                    mem[_41453 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42741 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42741 + 68] = mem[idx + _41453 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42741 + 68] = mem[_42741 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42741 + -mem[64] + 100
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _53356 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53356] = 30
                                    mem[_53356 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54827 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54827 + 68] = mem[idx + _53356 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54827 + 68] = mem[_54827 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54827 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39222 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39222] = 30
                                mem[_39222 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _39624 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39624 + 68] = mem[idx + _39222 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39624 + 68] = mem[_39624 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39624 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42159] = 30
                                mem[_42159 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _43514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43514 + 68] = mem[idx + _42159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43514 + 68] = mem[_43514 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43514 + -mem[64] + 100
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                _54106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54106] = 30
                                mem[_54106 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55717 + 68] = mem[idx + _54106 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55717 + 68] = mem[_55717 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55717 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _39221 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39221] = 30
                                mem[_39221 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39621 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39621 + 68] = mem[idx + _39221 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39621 + 68] = mem[_39621 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39621 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42158] = 30
                                mem[_42158 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43511 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43511 + 68] = mem[idx + _42158 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43511 + 68] = mem[_43511 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43511 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _54105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54105] = 30
                                mem[_54105 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55714 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55714 + 68] = mem[idx + _54105 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55714 + 68] = mem[_55714 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55714 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39352 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39352] = 30
                            mem[_39352 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _39999 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39999 + 68] = mem[idx + _39352 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39999 + 68] = mem[_39999 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39999 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42740 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42740] = 30
                            mem[_42740 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _44465 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44465 + 68] = mem[idx + _42740 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44465 + 68] = mem[_44465 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44465 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                            _54826 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54826] = 30
                            mem[_54826 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _56697 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56697 + 68] = mem[idx + _54826 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56697 + 68] = mem[_56697 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56697 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        if stor204[stor207[idx]] <= s:
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            _34383 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34383] = 30
                            mem[_34383 + 32] = 'SafeMath: subtraction overflow'
                            if stor203[stor207[idx]] > t:
                                _34906 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _34906 + 68] = mem[idx + _34383 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34906 + 68] = mem[_34906 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34906 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            _36790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36790] = 30
                            mem[_36790 + 32] = 'SafeMath: subtraction overflow'
                            if stor204[stor207[idx]] <= s:
                                idx = idx + 1
                                s = s - stor204[stor207[idx]]
                                t = t - stor203[stor207[idx]]
                                continue 
                            _37625 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _37625 + 68] = mem[idx + _36790 + 32]
                                idx = idx + 32
                                continue 
                            mem[_37625 + 68] = mem[_37625 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _37625 + -mem[64] + 100
                        _34627 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34627] = 26
                        mem[_34627 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _34627 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                _39355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39355] = 30
                                mem[_39355 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42750] = 30
                                mem[_42750 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _44472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44472 + 68] = mem[idx + _42750 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44472 + 68] = mem[_44472 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44472 + -mem[64] + 100
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                _54831 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54831] = 30
                                mem[_54831 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _56702 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _56702 + 68] = mem[idx + _54831 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_56702 + 68] = mem[_56702 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _56702 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39628 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39628] = 30
                            mem[_39628 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                _40402 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40402 + 68] = mem[idx + _39628 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40402 + 68] = mem[_40402 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40402 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _43520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43520] = 30
                            mem[_43520 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _45442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45442 + 68] = mem[idx + _43520 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45442 + 68] = mem[_45442 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45442 + -mem[64] + 100
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            _55721 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_55721] = 30
                            mem[_55721 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _57644 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _57644 + 68] = mem[idx + _55721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_57644 + 68] = mem[_57644 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _57644 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            _39627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39627] = 30
                            mem[_39627 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _40399 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40399 + 68] = mem[idx + _39627 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40399 + 68] = mem[_40399 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40399 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _43519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43519] = 30
                            mem[_43519 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _45439 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45439 + 68] = mem[idx + _43519 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45439 + 68] = mem[_45439 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45439 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                            _55720 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_55720] = 30
                            mem[_55720 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _57641 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _57641 + 68] = mem[idx + _55720 + 32]
                                idx = idx + 32
                                continue 
                            mem[_57641 + 68] = mem[_57641 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _57641 + -mem[64] + 100
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _40002 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_40002] = 30
                        mem[_40002 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                            _40847 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _40847 + 68] = mem[idx + _40002 + 32]
                                idx = idx + 32
                                continue 
                            mem[_40847 + 68] = mem[_40847 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40847 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 203
                        _44471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_44471] = 30
                        mem[_44471 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _46431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _46431 + 68] = mem[idx + _44471 + 32]
                                idx = idx + 32
                                continue 
                            mem[_46431 + 68] = mem[_46431 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _46431 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                        _56701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_56701] = 30
                        mem[_56701 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            return 1
                        _58539 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _58539 + 68] = mem[idx + _56701 + 32]
                            idx = idx + 32
                            continue 
                        mem[_58539 + 68] = mem[_58539 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _58539 + -mem[64] + 100
                    _33259 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33259] = 26
                    mem[_33259 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor209 / totalSupply:
                        _35237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35237] = 26
                        mem[_35237 + 32] = 'SafeMath: division by zero' << 48
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += -1 * t / s * _tFeePercent * arg2 / 10000
                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            if t / s * arg2 / arg2 != t / s:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += t / s * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                    else:
                        _35238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35238] = 26
                        mem[_35238 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        else:
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += _tFeePercent * arg2 / 10000
                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
            else:
                if stor206[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 206
                    if not stor206[address(msg.sender)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34064 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34064] = 26
                                    mem[_34064 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34064 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39082 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39082] = 30
                                        mem[_39082 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41269 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41269] = 30
                                        mem[_41269 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42606 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42606 + 68] = mem[idx + _41269 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42606 + 68] = mem[_42606 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42606 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _49720 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49720] = 30
                                        mem[_49720 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _52143 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52143 + 68] = mem[idx + _49720 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52143 + 68] = mem[_52143 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52143 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39196 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39196] = 30
                                    mem[_39196 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39533 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39533 + 68] = mem[idx + _39196 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39533 + 68] = mem[_39533 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39533 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42050] = 30
                                    mem[_42050 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43327 + 68] = mem[idx + _42050 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43327 + 68] = mem[_43327 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43327 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _50982 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50982] = 30
                                    mem[_50982 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53177 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53177 + 68] = mem[idx + _50982 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53177 + 68] = mem[_53177 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53177 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34344] = 30
                                    mem[_34344 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34854 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34854 + 68] = mem[idx + _34344 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34854 + 68] = mem[_34854 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34854 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36699 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36699] = 30
                                    mem[_36699 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37521 + 68] = mem[idx + _36699 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37521 + 68] = mem[_37521 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37521 + -mem[64] + 100
                                _34562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34562] = 26
                                mem[_34562 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34562 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39327 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39327] = 30
                                    mem[_39327 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42611 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42611] = 30
                                    mem[_42611 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44256 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44256 + 68] = mem[idx + _42611 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44256 + 68] = mem[_44256 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44256 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _52146 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52146] = 30
                                    mem[_52146 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53970 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53970 + 68] = mem[idx + _52146 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53970 + 68] = mem[_53970 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53970 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39536 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39536] = 30
                                mem[_39536 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40294 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40294 + 68] = mem[idx + _39536 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40294 + 68] = mem[_40294 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40294 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43330] = 30
                                mem[_43330 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45248 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45248 + 68] = mem[idx + _43330 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45248 + 68] = mem[_45248 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45248 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53180] = 30
                                mem[_53180 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _54657 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54657 + 68] = mem[idx + _53180 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54657 + 68] = mem[_54657 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54657 + -mem[64] + 100
                            _33194 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33194] = 26
                            mem[_33194 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35146] = 26
                                mem[_35146 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _35147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35147] = 26
                                mem[_35147 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34059 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34059] = 26
                                    mem[_34059 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34059 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39081 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39081] = 30
                                            mem[_39081 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41258 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41258] = 30
                                            mem[_41258 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42594 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42594 + 68] = mem[idx + _41258 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42594 + 68] = mem[_42594 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42594 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49700] = 30
                                            mem[_49700 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _52130 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52130 + 68] = mem[idx + _49700 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52130 + 68] = mem[_52130 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52130 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39193 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39193] = 30
                                        mem[_39193 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39528 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39528 + 68] = mem[idx + _39193 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39528 + 68] = mem[_39528 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39528 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42043] = 30
                                        mem[_42043 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43314 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43314 + 68] = mem[idx + _42043 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43314 + 68] = mem[_43314 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43314 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50966] = 30
                                        mem[_50966 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53170 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53170 + 68] = mem[idx + _50966 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53170 + 68] = mem[_53170 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53170 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39192 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39192] = 30
                                        mem[_39192 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39525 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39525 + 68] = mem[idx + _39192 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39525 + 68] = mem[_39525 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39525 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42042] = 30
                                        mem[_42042 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43311 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43311 + 68] = mem[idx + _42042 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43311 + 68] = mem[_43311 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43311 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50965] = 30
                                        mem[_50965 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53167 + 68] = mem[idx + _50965 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53167 + 68] = mem[_53167 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53167 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39323] = 30
                                    mem[_39323 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39931 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39931 + 68] = mem[idx + _39323 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39931 + 68] = mem[_39931 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39931 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42593] = 30
                                    mem[_42593 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44237 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44237 + 68] = mem[idx + _42593 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44237 + 68] = mem[_44237 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44237 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52129] = 30
                                    mem[_52129 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _53959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53959 + 68] = mem[idx + _52129 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53959 + 68] = mem[_53959 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53959 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34341] = 30
                                    mem[_34341 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34850 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34850 + 68] = mem[idx + _34341 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34850 + 68] = mem[_34850 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34850 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36692 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36692] = 30
                                    mem[_36692 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37513 + 68] = mem[idx + _36692 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37513 + 68] = mem[_37513 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37513 + -mem[64] + 100
                                _34557 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34557] = 26
                                mem[_34557 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34557 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39326 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39326] = 30
                                        mem[_39326 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42603 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42603] = 30
                                        mem[_42603 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44244 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44244 + 68] = mem[idx + _42603 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44244 + 68] = mem[_44244 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44244 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52134 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52134] = 30
                                        mem[_52134 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53964 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53964 + 68] = mem[idx + _52134 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53964 + 68] = mem[_53964 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53964 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39532] = 30
                                    mem[_39532 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _40288 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40288 + 68] = mem[idx + _39532 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40288 + 68] = mem[_40288 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40288 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43320] = 30
                                    mem[_43320 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _45238 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45238 + 68] = mem[idx + _43320 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45238 + 68] = mem[_45238 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45238 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53174] = 30
                                    mem[_53174 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54649 + 68] = mem[idx + _53174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54649 + 68] = mem[_54649 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54649 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39531 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39531] = 30
                                    mem[_39531 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40285 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40285 + 68] = mem[idx + _39531 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40285 + 68] = mem[_40285 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40285 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43319] = 30
                                    mem[_43319 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45235 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45235 + 68] = mem[idx + _43319 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45235 + 68] = mem[_45235 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45235 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53173 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53173] = 30
                                    mem[_53173 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54646 + 68] = mem[idx + _53173 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54646 + 68] = mem[_54646 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54646 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39934] = 30
                                mem[_39934 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40765 + 68] = mem[idx + _39934 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40765 + 68] = mem[_40765 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40765 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _44243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44243] = 30
                                mem[_44243 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _46189 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _46189 + 68] = mem[idx + _44243 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_46189 + 68] = mem[_46189 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _46189 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _53963 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53963] = 30
                                mem[_53963 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55502 + 68] = mem[idx + _53963 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55502 + 68] = mem[_55502 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55502 + -mem[64] + 100
                            _33189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33189] = 26
                            mem[_33189 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35139 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35139] = 26
                                mem[_35139 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _35140 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35140] = 26
                                mem[_35140 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34074] = 26
                                        mem[_34074 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34074 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39086 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39086] = 30
                                            mem[_39086 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41300 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41300] = 30
                                            mem[_41300 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42629 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42629 + 68] = mem[idx + _41300 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42629 + 68] = mem[_42629 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42629 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49762] = 30
                                            mem[_49762 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52179 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52179 + 68] = mem[idx + _49762 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52179 + 68] = mem[_52179 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52179 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39201 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39201] = 30
                                        mem[_39201 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39549 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39549 + 68] = mem[idx + _39201 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39549 + 68] = mem[_39549 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39549 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42070] = 30
                                        mem[_42070 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43359 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43359 + 68] = mem[idx + _42070 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43359 + 68] = mem[_43359 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43359 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51021 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51021] = 30
                                        mem[_51021 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53201 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53201 + 68] = mem[idx + _51021 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53201 + 68] = mem[_53201 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53201 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34350] = 30
                                        mem[_34350 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34862 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34862 + 68] = mem[idx + _34350 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34862 + 68] = mem[_34862 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34862 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36713 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36713] = 30
                                        mem[_36713 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37537 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37537 + 68] = mem[idx + _36713 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37537 + 68] = mem[_37537 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37537 + -mem[64] + 100
                                    _34572 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34572] = 26
                                    mem[_34572 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34572 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39332] = 30
                                        mem[_39332 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42634 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42634] = 30
                                        mem[_42634 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44292 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44292 + 68] = mem[idx + _42634 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44292 + 68] = mem[_44292 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44292 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52182 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52182] = 30
                                        mem[_52182 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53988 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53988 + 68] = mem[idx + _52182 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53988 + 68] = mem[_53988 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53988 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39552] = 30
                                    mem[_39552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40312 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40312 + 68] = mem[idx + _39552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40312 + 68] = mem[_40312 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40312 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43362] = 30
                                    mem[_43362 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45280 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45280 + 68] = mem[idx + _43362 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45280 + 68] = mem[_45280 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45280 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53204] = 30
                                    mem[_53204 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54679 + 68] = mem[idx + _53204 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54679 + 68] = mem[_54679 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54679 + -mem[64] + 100
                                _33204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33204] = 26
                                mem[_33204 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35160] = 26
                                    mem[_35160 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35161 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35161] = 26
                                    mem[_35161 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34069 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34069] = 26
                                        mem[_34069 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34069 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39085 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39085] = 30
                                                mem[_39085 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41289 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41289] = 30
                                                mem[_41289 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42617 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42617 + 68] = mem[idx + _41289 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42617 + 68] = mem[_42617 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42617 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49742 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49742] = 30
                                                mem[_49742 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52166 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52166 + 68] = mem[idx + _49742 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52166 + 68] = mem[_52166 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52166 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39198 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39198] = 30
                                            mem[_39198 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39544 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39544 + 68] = mem[idx + _39198 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39544 + 68] = mem[_39544 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39544 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42063 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42063] = 30
                                            mem[_42063 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43346 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43346 + 68] = mem[idx + _42063 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43346 + 68] = mem[_43346 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43346 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51005 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51005] = 30
                                            mem[_51005 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53194 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53194 + 68] = mem[idx + _51005 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53194 + 68] = mem[_53194 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53194 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39197 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39197] = 30
                                            mem[_39197 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39541 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39541 + 68] = mem[idx + _39197 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39541 + 68] = mem[_39541 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39541 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42062 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42062] = 30
                                            mem[_42062 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43343 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43343 + 68] = mem[idx + _42062 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43343 + 68] = mem[_43343 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43343 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51004 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51004] = 30
                                            mem[_51004 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53191 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53191 + 68] = mem[idx + _51004 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53191 + 68] = mem[_53191 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53191 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39328 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39328] = 30
                                        mem[_39328 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39943 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39943 + 68] = mem[idx + _39328 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39943 + 68] = mem[_39943 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39943 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42616 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42616] = 30
                                        mem[_42616 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44273 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44273 + 68] = mem[idx + _42616 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44273 + 68] = mem[_44273 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44273 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52165 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52165] = 30
                                        mem[_52165 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53977 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53977 + 68] = mem[idx + _52165 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53977 + 68] = mem[_53977 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53977 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34347] = 30
                                        mem[_34347 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34858 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34858 + 68] = mem[idx + _34347 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34858 + 68] = mem[_34858 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34858 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36706] = 30
                                        mem[_36706 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37529 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37529 + 68] = mem[idx + _36706 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37529 + 68] = mem[_37529 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37529 + -mem[64] + 100
                                    _34567 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34567] = 26
                                    mem[_34567 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34567 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39331 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39331] = 30
                                            mem[_39331 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42626 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42626] = 30
                                            mem[_42626 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44280 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44280 + 68] = mem[idx + _42626 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44280 + 68] = mem[_44280 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44280 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52170 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52170] = 30
                                            mem[_52170 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53982 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53982 + 68] = mem[idx + _52170 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53982 + 68] = mem[_53982 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53982 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39548 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39548] = 30
                                        mem[_39548 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40306 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40306 + 68] = mem[idx + _39548 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40306 + 68] = mem[_40306 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40306 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43352 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43352] = 30
                                        mem[_43352 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45270 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45270 + 68] = mem[idx + _43352 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45270 + 68] = mem[_45270 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45270 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53198 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53198] = 30
                                        mem[_53198 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54671 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54671 + 68] = mem[idx + _53198 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54671 + 68] = mem[_54671 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54671 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39547 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39547] = 30
                                        mem[_39547 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40303 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40303 + 68] = mem[idx + _39547 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40303 + 68] = mem[_40303 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40303 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43351 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43351] = 30
                                        mem[_43351 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45267 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45267 + 68] = mem[idx + _43351 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45267 + 68] = mem[_45267 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45267 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53197 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53197] = 30
                                        mem[_53197 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54668 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54668 + 68] = mem[idx + _53197 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54668 + 68] = mem[_54668 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54668 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39946] = 30
                                    mem[_39946 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40779 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40779 + 68] = mem[idx + _39946 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40779 + 68] = mem[_40779 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40779 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44279 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44279] = 30
                                    mem[_44279 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46227 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46227 + 68] = mem[idx + _44279 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46227 + 68] = mem[_46227 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46227 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53981 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53981] = 30
                                    mem[_53981 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55534 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55534 + 68] = mem[idx + _53981 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55534 + 68] = mem[_55534 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55534 + -mem[64] + 100
                                _33199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33199] = 26
                                mem[_33199 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35153] = 26
                                    mem[_35153 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35154 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35154] = 26
                                    mem[_35154 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34084] = 26
                                        mem[_34084 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34084 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39088 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39088] = 30
                                            mem[_39088 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41320 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41320] = 30
                                            mem[_41320 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42645 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42645 + 68] = mem[idx + _41320 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42645 + 68] = mem[_42645 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42645 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45299 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45299] = 30
                                            mem[_45299 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _47405 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47405 + 68] = mem[idx + _45299 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47405 + 68] = mem[_47405 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47405 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57511 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57511] = 30
                                            mem[_57511 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _59366 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59366 + 68] = mem[idx + _57511 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59366 + 68] = mem[_59366 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59366 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39203 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39203] = 30
                                        mem[_39203 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39557 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39557 + 68] = mem[idx + _39203 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39557 + 68] = mem[_39557 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39557 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42078 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42078] = 30
                                        mem[_42078 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43379 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43379 + 68] = mem[idx + _42078 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43379 + 68] = mem[_43379 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43379 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46266 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46266] = 30
                                        mem[_46266 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _48627 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48627 + 68] = mem[idx + _46266 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48627 + 68] = mem[_48627 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48627 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58398 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58398] = 30
                                        mem[_58398 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _60367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60367 + 68] = mem[idx + _58398 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60367 + 68] = mem[_60367 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60367 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34356 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34356] = 30
                                        mem[_34356 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34870 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34870 + 68] = mem[idx + _34356 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34870 + 68] = mem[_34870 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34870 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36727 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36727] = 30
                                        mem[_36727 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37553 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37553 + 68] = mem[idx + _36727 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37553 + 68] = mem[_37553 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37553 + -mem[64] + 100
                                    _34582 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34582] = 26
                                    mem[_34582 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34582 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39334 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39334] = 30
                                        mem[_39334 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42650] = 30
                                        mem[_42650 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44316 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44316 + 68] = mem[idx + _42650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44316 + 68] = mem[_44316 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44316 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47411] = 30
                                        mem[_47411 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _49802 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _49802 + 68] = mem[idx + _47411 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_49802 + 68] = mem[_49802 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _49802 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _59369 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59369] = 30
                                        mem[_59369 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _61212 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61212 + 68] = mem[idx + _59369 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61212 + 68] = mem[_61212 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61212 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39560] = 30
                                    mem[_39560 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40324 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40324 + 68] = mem[idx + _39560 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40324 + 68] = mem[_40324 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40324 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _43382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43382] = 30
                                    mem[_43382 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _45302 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45302 + 68] = mem[idx + _43382 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45302 + 68] = mem[_45302 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45302 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _48630 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48630] = 30
                                    mem[_48630 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _51052 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51052 + 68] = mem[idx + _48630 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51052 + 68] = mem[_51052 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51052 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _60370 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60370] = 30
                                    mem[_60370 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _62016 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62016 + 68] = mem[idx + _60370 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62016 + 68] = mem[_62016 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62016 + -mem[64] + 100
                                _33214 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33214] = 26
                                mem[_33214 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35174] = 26
                                    mem[_35174 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _35175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35175] = 26
                                    mem[_35175 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            else:
                                if 0 / arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34079] = 26
                                        mem[_34079 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34079 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39087 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39087] = 30
                                            mem[_39087 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41310 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41310] = 30
                                            mem[_41310 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42637 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42637 + 68] = mem[idx + _41310 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42637 + 68] = mem[_42637 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42637 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45288] = 30
                                            mem[_45288 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _47389 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47389 + 68] = mem[idx + _45288 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47389 + 68] = mem[_47389 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47389 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57503 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57503] = 30
                                            mem[_57503 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _59356 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59356 + 68] = mem[idx + _57503 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59356 + 68] = mem[_59356 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59356 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39202] = 30
                                        mem[_39202 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39553 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39553 + 68] = mem[idx + _39202 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39553 + 68] = mem[_39553 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39553 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42074] = 30
                                        mem[_42074 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43369 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43369 + 68] = mem[idx + _42074 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43369 + 68] = mem[_43369 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43369 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46253 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46253] = 30
                                        mem[_46253 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _48614 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48614 + 68] = mem[idx + _46253 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48614 + 68] = mem[_48614 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48614 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58392 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58392] = 30
                                        mem[_58392 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _60361 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60361 + 68] = mem[idx + _58392 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60361 + 68] = mem[_60361 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60361 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34353] = 30
                                        mem[_34353 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34866 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34866 + 68] = mem[idx + _34353 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34866 + 68] = mem[_34866 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34866 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36720 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36720] = 30
                                        mem[_36720 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37545 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37545 + 68] = mem[idx + _36720 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37545 + 68] = mem[_37545 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37545 + -mem[64] + 100
                                    _34577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34577] = 26
                                    mem[_34577 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34577 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39333 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39333] = 30
                                        mem[_39333 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42642 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42642] = 30
                                        mem[_42642 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44304 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44304 + 68] = mem[idx + _42642 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44304 + 68] = mem[_44304 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44304 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47395] = 30
                                        mem[_47395 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _49783 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _49783 + 68] = mem[idx + _47395 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_49783 + 68] = mem[_49783 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _49783 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _59359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59359] = 30
                                        mem[_59359 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _61206 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61206 + 68] = mem[idx + _59359 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61206 + 68] = mem[_61206 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61206 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39556 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39556] = 30
                                    mem[_39556 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40318 + 68] = mem[idx + _39556 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40318 + 68] = mem[_40318 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40318 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _43372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43372] = 30
                                    mem[_43372 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _45291 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45291 + 68] = mem[idx + _43372 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45291 + 68] = mem[_45291 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45291 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _48617 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48617] = 30
                                    mem[_48617 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _51036 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51036 + 68] = mem[idx + _48617 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51036 + 68] = mem[_51036 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51036 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _60364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60364] = 30
                                    mem[_60364 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _62008 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62008 + 68] = mem[idx + _60364 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62008 + 68] = mem[_62008 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62008 + -mem[64] + 100
                                _33209 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33209] = 26
                                mem[_33209 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35167] = 26
                                    mem[_35167 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _35168 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35168] = 26
                                    mem[_35168 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                else:
                    mem[0] = arg1
                    mem[32] = 206
                    if not stor206[address(arg1)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34124] = 26
                                    mem[_34124 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34124 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39102 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39102] = 30
                                        mem[_39102 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41433 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41433] = 30
                                        mem[_41433 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42730 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42730 + 68] = mem[idx + _41433 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42730 + 68] = mem[_42730 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42730 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _49964 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49964] = 30
                                        mem[_49964 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _52351 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52351 + 68] = mem[idx + _49964 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52351 + 68] = mem[_52351 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52351 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39220 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39220] = 30
                                    mem[_39220 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39613 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39613 + 68] = mem[idx + _39220 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39613 + 68] = mem[_39613 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39613 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42146 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42146] = 30
                                    mem[_42146 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43495 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43495 + 68] = mem[idx + _42146 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43495 + 68] = mem[_43495 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43495 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51202 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51202] = 30
                                    mem[_51202 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53337 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53337 + 68] = mem[idx + _51202 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53337 + 68] = mem[_53337 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53337 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34380] = 30
                                    mem[_34380 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34902 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34902 + 68] = mem[idx + _34380 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34902 + 68] = mem[_34902 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34902 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36783] = 30
                                    mem[_36783 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37617 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37617 + 68] = mem[idx + _36783 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37617 + 68] = mem[_37617 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37617 + -mem[64] + 100
                                _34622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34622] = 26
                                mem[_34622 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34622 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39351 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39351] = 30
                                    mem[_39351 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42735 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42735] = 30
                                    mem[_42735 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44448 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44448 + 68] = mem[idx + _42735 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44448 + 68] = mem[_44448 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44448 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _52354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52354] = 30
                                    mem[_52354 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54094 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54094 + 68] = mem[idx + _52354 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54094 + 68] = mem[_54094 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54094 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39616] = 30
                                mem[_39616 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40390 + 68] = mem[idx + _39616 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40390 + 68] = mem[_40390 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40390 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43498] = 30
                                mem[_43498 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45420 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45420 + 68] = mem[idx + _43498 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45420 + 68] = mem[_45420 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45420 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53340] = 30
                                mem[_53340 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _54813 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54813 + 68] = mem[idx + _53340 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54813 + 68] = mem[_54813 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54813 + -mem[64] + 100
                            _33254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33254] = 26
                            mem[_33254 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35230 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35230] = 26
                                mem[_35230 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _35231 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35231] = 26
                                mem[_35231 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34119 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34119] = 26
                                    mem[_34119 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34119 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39101 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39101] = 30
                                            mem[_39101 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41422 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41422] = 30
                                            mem[_41422 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42718 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42718 + 68] = mem[idx + _41422 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42718 + 68] = mem[_42718 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42718 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49944 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49944] = 30
                                            mem[_49944 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _52338 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52338 + 68] = mem[idx + _49944 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52338 + 68] = mem[_52338 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52338 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39217 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39217] = 30
                                        mem[_39217 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39608 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39608 + 68] = mem[idx + _39217 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39608 + 68] = mem[_39608 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39608 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42139 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42139] = 30
                                        mem[_42139 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43482 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43482 + 68] = mem[idx + _42139 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43482 + 68] = mem[_43482 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43482 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51186] = 30
                                        mem[_51186 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53330 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53330 + 68] = mem[idx + _51186 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53330 + 68] = mem[_53330 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53330 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39216 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39216] = 30
                                        mem[_39216 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39605 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39605 + 68] = mem[idx + _39216 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39605 + 68] = mem[_39605 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39605 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42138 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42138] = 30
                                        mem[_42138 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43479 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43479 + 68] = mem[idx + _42138 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43479 + 68] = mem[_43479 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43479 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51185 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51185] = 30
                                        mem[_51185 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53327 + 68] = mem[idx + _51185 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53327 + 68] = mem[_53327 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53327 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39347] = 30
                                    mem[_39347 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39987 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39987 + 68] = mem[idx + _39347 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39987 + 68] = mem[_39987 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39987 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42717 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42717] = 30
                                    mem[_42717 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44429 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44429 + 68] = mem[idx + _42717 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44429 + 68] = mem[_44429 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44429 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52337 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52337] = 30
                                    mem[_52337 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54083 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54083 + 68] = mem[idx + _52337 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54083 + 68] = mem[_54083 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54083 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34377] = 30
                                    mem[_34377 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34898 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34898 + 68] = mem[idx + _34377 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34898 + 68] = mem[_34898 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34898 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36776 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36776] = 30
                                    mem[_36776 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37609 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37609 + 68] = mem[idx + _36776 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37609 + 68] = mem[_37609 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37609 + -mem[64] + 100
                                _34617 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34617] = 26
                                mem[_34617 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34617 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39350] = 30
                                        mem[_39350 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42727 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42727] = 30
                                        mem[_42727 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44436 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44436 + 68] = mem[idx + _42727 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44436 + 68] = mem[_44436 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44436 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52342] = 30
                                        mem[_52342 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54088 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54088 + 68] = mem[idx + _52342 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54088 + 68] = mem[_54088 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54088 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39612 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39612] = 30
                                    mem[_39612 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _40384 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40384 + 68] = mem[idx + _39612 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40384 + 68] = mem[_40384 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40384 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43488 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43488] = 30
                                    mem[_43488 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _45410 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45410 + 68] = mem[idx + _43488 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45410 + 68] = mem[_45410 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45410 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53334 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53334] = 30
                                    mem[_53334 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54805 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54805 + 68] = mem[idx + _53334 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54805 + 68] = mem[_54805 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54805 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39611 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39611] = 30
                                    mem[_39611 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40381 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40381 + 68] = mem[idx + _39611 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40381 + 68] = mem[_40381 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40381 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43487 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43487] = 30
                                    mem[_43487 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45407 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45407 + 68] = mem[idx + _43487 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45407 + 68] = mem[_45407 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45407 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53333] = 30
                                    mem[_53333 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54802 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54802 + 68] = mem[idx + _53333 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54802 + 68] = mem[_54802 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54802 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39990 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39990] = 30
                                mem[_39990 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40833 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40833 + 68] = mem[idx + _39990 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40833 + 68] = mem[_40833 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40833 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _44435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44435] = 30
                                mem[_44435 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _46393 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _46393 + 68] = mem[idx + _44435 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_46393 + 68] = mem[_46393 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _46393 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _54087 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54087] = 30
                                mem[_54087 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55690 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55690 + 68] = mem[idx + _54087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55690 + 68] = mem[_55690 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55690 + -mem[64] + 100
                            _33249 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33249] = 26
                            mem[_33249 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35223] = 26
                                mem[_35223 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _35224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35224] = 26
                                mem[_35224 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                    else:
                        mem[0] = msg.sender
                        mem[32] = 206
                        if not stor206[address(msg.sender)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34094] = 26
                                        mem[_34094 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34094 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39092 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39092] = 30
                                            mem[_39092 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41351 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41351] = 30
                                            mem[_41351 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42668 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42668 + 68] = mem[idx + _41351 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42668 + 68] = mem[_42668 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42668 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49842 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49842] = 30
                                            mem[_49842 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52247 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52247 + 68] = mem[idx + _49842 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52247 + 68] = mem[_52247 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52247 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39208 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39208] = 30
                                        mem[_39208 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39573 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39573 + 68] = mem[idx + _39208 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39573 + 68] = mem[_39573 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39573 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42098] = 30
                                        mem[_42098 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43411 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43411 + 68] = mem[idx + _42098 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43411 + 68] = mem[_43411 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43411 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51092 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51092] = 30
                                        mem[_51092 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53257 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53257 + 68] = mem[idx + _51092 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53257 + 68] = mem[_53257 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53257 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34362] = 30
                                        mem[_34362 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34878 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34878 + 68] = mem[idx + _34362 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34878 + 68] = mem[_34878 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34878 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36741 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36741] = 30
                                        mem[_36741 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37569 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37569 + 68] = mem[idx + _36741 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37569 + 68] = mem[_37569 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37569 + -mem[64] + 100
                                    _34592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34592] = 26
                                    mem[_34592 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34592 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39339] = 30
                                        mem[_39339 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42673 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42673] = 30
                                        mem[_42673 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44352 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44352 + 68] = mem[idx + _42673 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44352 + 68] = mem[_44352 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44352 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52250 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52250] = 30
                                        mem[_52250 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54032 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54032 + 68] = mem[idx + _52250 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54032 + 68] = mem[_54032 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54032 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39576 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39576] = 30
                                    mem[_39576 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40342 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40342 + 68] = mem[idx + _39576 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40342 + 68] = mem[_40342 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40342 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43414] = 30
                                    mem[_43414 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45334 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45334 + 68] = mem[idx + _43414 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45334 + 68] = mem[_45334 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45334 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53260 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53260] = 30
                                    mem[_53260 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54735 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54735 + 68] = mem[idx + _53260 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54735 + 68] = mem[_54735 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54735 + -mem[64] + 100
                                _33224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33224] = 26
                                mem[_33224 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35188] = 26
                                    mem[_35188 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35189 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35189] = 26
                                    mem[_35189 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34089 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34089] = 26
                                        mem[_34089 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34089 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39091 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39091] = 30
                                                mem[_39091 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41340 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41340] = 30
                                                mem[_41340 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42656 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42656 + 68] = mem[idx + _41340 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42656 + 68] = mem[_42656 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42656 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49822 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49822] = 30
                                                mem[_49822 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52234 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52234 + 68] = mem[idx + _49822 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52234 + 68] = mem[_52234 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52234 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39205 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39205] = 30
                                            mem[_39205 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39568 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39568 + 68] = mem[idx + _39205 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39568 + 68] = mem[_39568 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39568 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42091] = 30
                                            mem[_42091 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43398 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43398 + 68] = mem[idx + _42091 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43398 + 68] = mem[_43398 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43398 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51076 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51076] = 30
                                            mem[_51076 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53250 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53250 + 68] = mem[idx + _51076 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53250 + 68] = mem[_53250 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53250 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39204 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39204] = 30
                                            mem[_39204 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39565 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39565 + 68] = mem[idx + _39204 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39565 + 68] = mem[_39565 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39565 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42090 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42090] = 30
                                            mem[_42090 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43395 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43395 + 68] = mem[idx + _42090 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43395 + 68] = mem[_43395 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43395 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51075 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51075] = 30
                                            mem[_51075 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53247 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53247 + 68] = mem[idx + _51075 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53247 + 68] = mem[_53247 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53247 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39335 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39335] = 30
                                        mem[_39335 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39959 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39959 + 68] = mem[idx + _39335 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39959 + 68] = mem[_39959 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39959 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42655] = 30
                                        mem[_42655 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44333 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44333 + 68] = mem[idx + _42655 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44333 + 68] = mem[_44333 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44333 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52233 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52233] = 30
                                        mem[_52233 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54021 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54021 + 68] = mem[idx + _52233 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54021 + 68] = mem[_54021 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54021 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34359] = 30
                                        mem[_34359 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34874 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34874 + 68] = mem[idx + _34359 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34874 + 68] = mem[_34874 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34874 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36734 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36734] = 30
                                        mem[_36734 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37561 + 68] = mem[idx + _36734 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37561 + 68] = mem[_37561 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37561 + -mem[64] + 100
                                    _34587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34587] = 26
                                    mem[_34587 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34587 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39338] = 30
                                            mem[_39338 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42665 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42665] = 30
                                            mem[_42665 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44340 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44340 + 68] = mem[idx + _42665 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44340 + 68] = mem[_44340 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44340 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52238 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52238] = 30
                                            mem[_52238 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54026 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54026 + 68] = mem[idx + _52238 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54026 + 68] = mem[_54026 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54026 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39572 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39572] = 30
                                        mem[_39572 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40336 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40336 + 68] = mem[idx + _39572 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40336 + 68] = mem[_40336 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40336 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43404] = 30
                                        mem[_43404 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45324 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45324 + 68] = mem[idx + _43404 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45324 + 68] = mem[_45324 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45324 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53254 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53254] = 30
                                        mem[_53254 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54727 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54727 + 68] = mem[idx + _53254 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54727 + 68] = mem[_54727 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54727 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39571 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39571] = 30
                                        mem[_39571 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40333 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40333 + 68] = mem[idx + _39571 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40333 + 68] = mem[_40333 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40333 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43403 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43403] = 30
                                        mem[_43403 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45321 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45321 + 68] = mem[idx + _43403 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45321 + 68] = mem[_45321 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45321 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53253 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53253] = 30
                                        mem[_53253 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54724 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54724 + 68] = mem[idx + _53253 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54724 + 68] = mem[_54724 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54724 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39962 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39962] = 30
                                    mem[_39962 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40799 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40799 + 68] = mem[idx + _39962 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40799 + 68] = mem[_40799 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40799 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44339 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44339] = 30
                                    mem[_44339 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46291 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46291 + 68] = mem[idx + _44339 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46291 + 68] = mem[_46291 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46291 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _54025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54025] = 30
                                    mem[_54025 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55596 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55596 + 68] = mem[idx + _54025 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55596 + 68] = mem[_55596 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55596 + -mem[64] + 100
                                _33219 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33219] = 26
                                mem[_33219 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35181 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35181] = 26
                                    mem[_35181 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35182] = 26
                                    mem[_35182 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            mem[0] = arg1
                            mem[32] = 206
                            if not stor206[address(arg1)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34104 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34104] = 26
                                            mem[_34104 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34104 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39096 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39096] = 30
                                                mem[_39096 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41382 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41382] = 30
                                                mem[_41382 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42691 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42691 + 68] = mem[idx + _41382 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42691 + 68] = mem[_42691 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42691 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49884 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49884] = 30
                                                mem[_49884 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _52283 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52283 + 68] = mem[idx + _49884 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52283 + 68] = mem[_52283 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52283 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39213 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39213] = 30
                                            mem[_39213 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39589 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39589 + 68] = mem[idx + _39213 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39589 + 68] = mem[_39589 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39589 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42118 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42118] = 30
                                            mem[_42118 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43443 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43443 + 68] = mem[idx + _42118 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43443 + 68] = mem[_43443 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43443 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51131 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51131] = 30
                                            mem[_51131 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _53281 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53281 + 68] = mem[idx + _51131 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53281 + 68] = mem[_53281 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53281 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34368] = 30
                                            mem[_34368 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34886 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34886 + 68] = mem[idx + _34368 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34886 + 68] = mem[_34886 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34886 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36755] = 30
                                            mem[_36755 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37585 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37585 + 68] = mem[idx + _36755 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37585 + 68] = mem[_37585 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37585 + -mem[64] + 100
                                        _34602 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34602] = 26
                                        mem[_34602 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34602 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39344 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39344] = 30
                                            mem[_39344 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42696 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42696] = 30
                                            mem[_42696 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44388 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44388 + 68] = mem[idx + _42696 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44388 + 68] = mem[_44388 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44388 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52286 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52286] = 30
                                            mem[_52286 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _54050 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54050 + 68] = mem[idx + _52286 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54050 + 68] = mem[_54050 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54050 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39592 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39592] = 30
                                        mem[_39592 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40360 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40360 + 68] = mem[idx + _39592 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40360 + 68] = mem[_40360 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40360 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43446 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43446] = 30
                                        mem[_43446 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45366 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45366 + 68] = mem[idx + _43446 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45366 + 68] = mem[_45366 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45366 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53284 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53284] = 30
                                        mem[_53284 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54757 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54757 + 68] = mem[idx + _53284 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54757 + 68] = mem[_54757 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54757 + -mem[64] + 100
                                    _33234 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33234] = 26
                                    mem[_33234 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35202] = 26
                                        mem[_35202 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _35203 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35203] = 26
                                        mem[_35203 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34099 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34099] = 26
                                            mem[_34099 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34099 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _39095 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39095] = 30
                                                    mem[_39095 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41371 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41371] = 30
                                                    mem[_41371 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _42679 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _42679 + 68] = mem[idx + _41371 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_42679 + 68] = mem[_42679 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _42679 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _49864 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_49864] = 30
                                                    mem[_49864 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _52270 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52270 + 68] = mem[idx + _49864 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52270 + 68] = mem[_52270 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52270 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39210 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39210] = 30
                                                mem[_39210 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _39584 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39584 + 68] = mem[idx + _39210 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39584 + 68] = mem[_39584 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39584 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42111 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42111] = 30
                                                mem[_42111 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43430 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43430 + 68] = mem[idx + _42111 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43430 + 68] = mem[_43430 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43430 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _51115 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51115] = 30
                                                mem[_51115 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53274 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53274 + 68] = mem[idx + _51115 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53274 + 68] = mem[_53274 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53274 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _39209 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39209] = 30
                                                mem[_39209 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39581 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39581 + 68] = mem[idx + _39209 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39581 + 68] = mem[_39581 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39581 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42110 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42110] = 30
                                                mem[_42110 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _43427 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43427 + 68] = mem[idx + _42110 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43427 + 68] = mem[_43427 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43427 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _51114 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51114] = 30
                                                mem[_51114 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53271 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53271 + 68] = mem[idx + _51114 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53271 + 68] = mem[_53271 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53271 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39340 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39340] = 30
                                            mem[_39340 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _39971 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39971 + 68] = mem[idx + _39340 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39971 + 68] = mem[_39971 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39971 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42678] = 30
                                            mem[_42678 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44369 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44369 + 68] = mem[idx + _42678 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44369 + 68] = mem[_44369 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44369 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52269 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52269] = 30
                                            mem[_52269 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54039 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54039 + 68] = mem[idx + _52269 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54039 + 68] = mem[_54039 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54039 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34365 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34365] = 30
                                            mem[_34365 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34882 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34882 + 68] = mem[idx + _34365 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34882 + 68] = mem[_34882 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34882 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36748 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36748] = 30
                                            mem[_36748 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37577 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37577 + 68] = mem[idx + _36748 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37577 + 68] = mem[_37577 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37577 + -mem[64] + 100
                                        _34597 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34597] = 26
                                        mem[_34597 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34597 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39343 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39343] = 30
                                                mem[_39343 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42688 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42688] = 30
                                                mem[_42688 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _44376 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44376 + 68] = mem[idx + _42688 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44376 + 68] = mem[_44376 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44376 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _52274 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52274] = 30
                                                mem[_52274 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _54044 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _54044 + 68] = mem[idx + _52274 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_54044 + 68] = mem[_54044 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _54044 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39588 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39588] = 30
                                            mem[_39588 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _40354 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40354 + 68] = mem[idx + _39588 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40354 + 68] = mem[_40354 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40354 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43436 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43436] = 30
                                            mem[_43436 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _45356 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45356 + 68] = mem[idx + _43436 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45356 + 68] = mem[_45356 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45356 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _53278 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53278] = 30
                                            mem[_53278 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54749 + 68] = mem[idx + _53278 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54749 + 68] = mem[_54749 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54749 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39587] = 30
                                            mem[_39587 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40351 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40351 + 68] = mem[idx + _39587 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40351 + 68] = mem[_40351 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40351 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43435 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43435] = 30
                                            mem[_43435 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _45353 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45353 + 68] = mem[idx + _43435 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45353 + 68] = mem[_45353 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45353 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _53277 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53277] = 30
                                            mem[_53277 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54746 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54746 + 68] = mem[idx + _53277 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54746 + 68] = mem[_54746 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54746 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39974 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39974] = 30
                                        mem[_39974 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40813 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40813 + 68] = mem[idx + _39974 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40813 + 68] = mem[_40813 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40813 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _44375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44375] = 30
                                        mem[_44375 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _46329 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _46329 + 68] = mem[idx + _44375 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_46329 + 68] = mem[_46329 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _46329 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _54043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_54043] = 30
                                        mem[_54043 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55628 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55628 + 68] = mem[idx + _54043 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55628 + 68] = mem[_55628 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55628 + -mem[64] + 100
                                    _33229 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33229] = 26
                                    mem[_33229 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35195 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35195] = 26
                                        mem[_35195 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _35196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35196] = 26
                                        mem[_35196 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            else:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34114 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34114] = 26
                                            mem[_34114 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34114 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39098 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39098] = 30
                                                mem[_39098 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41402 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41402] = 30
                                                mem[_41402 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42707 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42707 + 68] = mem[idx + _41402 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42707 + 68] = mem[_42707 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42707 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45385 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45385] = 30
                                                mem[_45385 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _47525 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _47525 + 68] = mem[idx + _45385 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_47525 + 68] = mem[_47525 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _47525 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _57595 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57595] = 30
                                                mem[_57595 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _59468 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59468 + 68] = mem[idx + _57595 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59468 + 68] = mem[_59468 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59468 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39215 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39215] = 30
                                            mem[_39215 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39597 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39597 + 68] = mem[idx + _39215 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39597 + 68] = mem[_39597 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39597 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42126 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42126] = 30
                                            mem[_42126 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43463 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43463 + 68] = mem[idx + _42126 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43463 + 68] = mem[_43463 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43463 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46368] = 30
                                            mem[_46368 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _48731 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _48731 + 68] = mem[idx + _46368 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48731 + 68] = mem[_48731 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48731 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _58484 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58484] = 30
                                            mem[_58484 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _60447 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60447 + 68] = mem[idx + _58484 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60447 + 68] = mem[_60447 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60447 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34374] = 30
                                            mem[_34374 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34894 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34894 + 68] = mem[idx + _34374 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34894 + 68] = mem[_34894 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34894 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36769 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36769] = 30
                                            mem[_36769 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37601 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37601 + 68] = mem[idx + _36769 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37601 + 68] = mem[_37601 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37601 + -mem[64] + 100
                                        _34612 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34612] = 26
                                        mem[_34612 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34612 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39346 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39346] = 30
                                            mem[_39346 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42712 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42712] = 30
                                            mem[_42712 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44412 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44412 + 68] = mem[idx + _42712 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44412 + 68] = mem[_44412 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44412 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _47531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47531] = 30
                                            mem[_47531 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _49924 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49924 + 68] = mem[idx + _47531 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49924 + 68] = mem[_49924 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49924 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _59471 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59471] = 30
                                            mem[_59471 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _61284 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _61284 + 68] = mem[idx + _59471 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_61284 + 68] = mem[_61284 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _61284 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39600 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39600] = 30
                                        mem[_39600 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40372 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40372 + 68] = mem[idx + _39600 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40372 + 68] = mem[_40372 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40372 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _43466 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43466] = 30
                                        mem[_43466 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _45388 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45388 + 68] = mem[idx + _43466 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45388 + 68] = mem[_45388 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45388 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _48734 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48734] = 30
                                        mem[_48734 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _51162 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51162 + 68] = mem[idx + _48734 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51162 + 68] = mem[_51162 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51162 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _60450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_60450] = 30
                                        mem[_60450 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _62092 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62092 + 68] = mem[idx + _60450 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62092 + 68] = mem[_62092 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62092 + -mem[64] + 100
                                    _33244 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33244] = 26
                                    mem[_33244 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35216 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35216] = 26
                                        mem[_35216 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _35217 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35217] = 26
                                        mem[_35217 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                else:
                                    if 0 / arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34109] = 26
                                            mem[_34109 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34109 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39097 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39097] = 30
                                                mem[_39097 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41392 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41392] = 30
                                                mem[_41392 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42699 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42699 + 68] = mem[idx + _41392 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42699 + 68] = mem[_42699 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42699 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45374 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45374] = 30
                                                mem[_45374 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _47509 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _47509 + 68] = mem[idx + _45374 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_47509 + 68] = mem[_47509 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _47509 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _57587 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57587] = 30
                                                mem[_57587 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _59458 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59458 + 68] = mem[idx + _57587 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59458 + 68] = mem[_59458 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59458 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39214 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39214] = 30
                                            mem[_39214 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39593 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39593 + 68] = mem[idx + _39214 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39593 + 68] = mem[_39593 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39593 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42122 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42122] = 30
                                            mem[_42122 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43453 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43453 + 68] = mem[idx + _42122 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43453 + 68] = mem[_43453 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43453 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46355 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46355] = 30
                                            mem[_46355 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _48718 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _48718 + 68] = mem[idx + _46355 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48718 + 68] = mem[_48718 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48718 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _58478 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58478] = 30
                                            mem[_58478 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _60441 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60441 + 68] = mem[idx + _58478 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60441 + 68] = mem[_60441 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60441 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34371 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34371] = 30
                                            mem[_34371 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34890 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34890 + 68] = mem[idx + _34371 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34890 + 68] = mem[_34890 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34890 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36762] = 30
                                            mem[_36762 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37593 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37593 + 68] = mem[idx + _36762 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37593 + 68] = mem[_37593 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37593 + -mem[64] + 100
                                        _34607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34607] = 26
                                        mem[_34607 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34607 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39345 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39345] = 30
                                            mem[_39345 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42704 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42704] = 30
                                            mem[_42704 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44400 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44400 + 68] = mem[idx + _42704 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44400 + 68] = mem[_44400 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44400 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _47515 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47515] = 30
                                            mem[_47515 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _49905 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49905 + 68] = mem[idx + _47515 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49905 + 68] = mem[_49905 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49905 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _59461 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59461] = 30
                                            mem[_59461 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _61278 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _61278 + 68] = mem[idx + _59461 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_61278 + 68] = mem[_61278 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _61278 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39596 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39596] = 30
                                        mem[_39596 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40366 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40366 + 68] = mem[idx + _39596 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40366 + 68] = mem[_40366 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40366 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _43456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43456] = 30
                                        mem[_43456 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _45377 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45377 + 68] = mem[idx + _43456 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45377 + 68] = mem[_45377 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45377 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _48721 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48721] = 30
                                        mem[_48721 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _51146 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51146 + 68] = mem[idx + _48721 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51146 + 68] = mem[_51146 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51146 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _60444 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_60444] = 30
                                        mem[_60444 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _62084 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62084 + 68] = mem[idx + _60444 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62084 + 68] = mem[_62084 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62084 + -mem[64] + 100
                                    _33239 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33239] = 26
                                    mem[_33239 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35209 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35209] = 26
                                        mem[_35209 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _35210 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35210] = 26
                                        mem[_35210 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
    else:
        mem[0] = arg1
        mem[32] = 206
        if not stor206[address(arg1)]:
            if not arg2:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero' << 48
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = totalSupply
                t = stor209
                while idx < stor207.length:
                    mem[0] = stor207[idx]
                    mem[32] = 203
                    if stor203[stor207[idx]] > t:
                        _34294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34294] = 26
                        mem[_34294 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _34294 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            _39162 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39162] = 30
                            mem[_39162 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 204
                            _41916 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41916] = 30
                            mem[_41916 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _43093 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43093 + 68] = mem[idx + _41916 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43093 + 68] = mem[_43093 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43093 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _45923 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_45923] = 30
                            mem[_45923 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _48274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _48274 + 68] = mem[idx + _45923 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_48274 + 68] = mem[_48274 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _48274 + -mem[64] + 100
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = stor203[arg1]
                            _55261 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_55261] = 30
                            mem[_55261 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                                return 1
                            _57225 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _57225 + 68] = mem[idx + _55261 + 32]
                                idx = idx + 32
                                continue 
                            mem[_57225 + 68] = mem[_57225 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _57225 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _39293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39293] = 30
                        mem[_39293 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor209 / totalSupply * arg2:
                            _39853 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _39853 + 68] = mem[idx + _39293 + 32]
                                idx = idx + 32
                                continue 
                            mem[_39853 + 68] = mem[_39853 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _39853 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _42438 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_42438] = 30
                        mem[_42438 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _43991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _43991 + 68] = mem[idx + _42438 + 32]
                                idx = idx + 32
                                continue 
                            mem[_43991 + 68] = mem[_43991 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _43991 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _47003 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_47003] = 30
                        mem[_47003 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _49390 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _49390 + 68] = mem[idx + _47003 + 32]
                                idx = idx + 32
                                continue 
                            mem[_49390 + 68] = mem[_49390 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _49390 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        _56227 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_56227] = 30
                        mem[_56227 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                            return 1
                        _58101 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _58101 + 68] = mem[idx + _56227 + 32]
                            idx = idx + 32
                            continue 
                        mem[_58101 + 68] = mem[_58101 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _58101 + -mem[64] + 100
                    require idx < stor207.length
                    mem[0] = stor207[idx]
                    mem[32] = 204
                    if stor204[stor207[idx]] <= s:
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        _34482 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34482] = 30
                        mem[_34482 + 32] = 'SafeMath: subtraction overflow'
                        if stor203[stor207[idx]] > t:
                            _35038 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35038 + 68] = mem[idx + _34482 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35038 + 68] = mem[_35038 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35038 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        _37021 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_37021] = 30
                        mem[_37021 + 32] = 'SafeMath: subtraction overflow'
                        if stor204[stor207[idx]] <= s:
                            idx = idx + 1
                            s = s - stor204[stor207[idx]]
                            t = t - stor203[stor207[idx]]
                            continue 
                        _37889 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _37889 + 68] = mem[idx + _37021 + 32]
                            idx = idx + 32
                            continue 
                        mem[_37889 + 68] = mem[_37889 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _37889 + -mem[64] + 100
                    _34792 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34792] = 26
                    mem[_34792 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _34792 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        _39424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39424] = 30
                        mem[_39424 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 204
                        _43098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43098] = 30
                        mem[_43098 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _45012 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _45012 + 68] = mem[idx + _43098 + 32]
                                idx = idx + 32
                                continue 
                            mem[_45012 + 68] = mem[_45012 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _45012 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _48280 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_48280] = 30
                        mem[_48280 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor203[address(msg.sender)]:
                            _50683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _50683 + 68] = mem[idx + _48280 + 32]
                                idx = idx + 32
                                continue 
                            mem[_50683 + 68] = mem[_50683 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _50683 + -mem[64] + 100
                        if stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = stor203[arg1]
                        _57228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57228] = 30
                        mem[_57228 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                            return 1
                        _59020 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _59020 + 68] = mem[idx + _57228 + 32]
                            idx = idx + 32
                            continue 
                        mem[_59020 + 68] = mem[_59020 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _59020 + -mem[64] + 100
                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _39856 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_39856] = 30
                    mem[_39856 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor209 / totalSupply * arg2:
                        _40672 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _40672 + 68] = mem[idx + _39856 + 32]
                            idx = idx + 32
                            continue 
                        mem[_40672 + 68] = mem[_40672 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _40672 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 204
                    _43994 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_43994] = 30
                    mem[_43994 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor204[address(msg.sender)]:
                        _45926 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _45926 + 68] = mem[idx + _43994 + 32]
                            idx = idx + 32
                            continue 
                        mem[_45926 + 68] = mem[_45926 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _45926 + -mem[64] + 100
                    mem[0] = msg.sender
                    stor204[address(msg.sender)] -= arg2
                    mem[32] = 203
                    _49393 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_49393] = 30
                    mem[_49393 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                        _51864 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _51864 + 68] = mem[idx + _49393 + 32]
                            idx = idx + 32
                            continue 
                        mem[_51864 + 68] = mem[_51864 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _51864 + -mem[64] + 100
                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 203
                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                    _58104 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58104] = 30
                    mem[_58104 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit 0x64ddf252: arg2, msg.sender, arg1
                        return 1
                    _60094 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _60094 + 68] = mem[idx + _58104 + 32]
                        idx = idx + 32
                        continue 
                    mem[_60094 + 68] = mem[_60094 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _60094 + -mem[64] + 100
                _33424 = mem[64]
                mem[64] = mem[64] + 64
                mem[_33424] = 26
                mem[_33424 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor209 / totalSupply:
                    _35468 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35468] = 26
                    mem[_35468 + 32] = 'SafeMath: division by zero' << 48
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if 0 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = stor203[arg1]
                    else:
                        if t / s * arg2 / arg2 != t / s:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > t / s * arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if t / s * arg2 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor203[address(msg.sender)] += -1 * t / s * arg2
                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                else:
                    _35469 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35469] = 26
                    mem[_35469 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if 0 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = stor203[arg1]
                    else:
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > stor209 / totalSupply * arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit 0x64ddf252: arg2, msg.sender, arg1
            else:
                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero' << 48
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if _tFeePercent * arg2 / 10000 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = totalSupply
                t = stor209
                while idx < stor207.length:
                    mem[0] = stor207[idx]
                    mem[32] = 203
                    if stor203[stor207[idx]] > t:
                        _34289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34289] = 26
                        mem[_34289 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _34289 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                _39161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39161] = 30
                                mem[_39161 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 204
                                _41905 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41905] = 30
                                mem[_41905 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor204[address(msg.sender)]:
                                    _43081 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43081 + 68] = mem[idx + _41905 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43081 + 68] = mem[_43081 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43081 + -mem[64] + 100
                                mem[0] = msg.sender
                                stor204[address(msg.sender)] -= arg2
                                mem[32] = 203
                                _45909 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_45909] = 30
                                mem[_45909 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _48255 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _48255 + 68] = mem[idx + _45909 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_48255 + 68] = mem[_48255 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _48255 + -mem[64] + 100
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = stor203[arg1]
                                _55241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_55241] = 30
                                mem[_55241 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _57212 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _57212 + 68] = mem[idx + _55241 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_57212 + 68] = mem[_57212 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _57212 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39290 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39290] = 30
                            mem[_39290 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                _39848 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39848 + 68] = mem[idx + _39290 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39848 + 68] = mem[_39848 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39848 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 204
                            _42431 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42431] = 30
                            mem[_42431 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _43978 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43978 + 68] = mem[idx + _42431 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43978 + 68] = mem[_43978 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43978 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _46987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_46987] = 30
                            mem[_46987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _49371 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _49371 + 68] = mem[idx + _46987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_49371 + 68] = mem[_49371 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _49371 + -mem[64] + 100
                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            _56211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_56211] = 30
                            mem[_56211 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _58094 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _58094 + 68] = mem[idx + _56211 + 32]
                                idx = idx + 32
                                continue 
                            mem[_58094 + 68] = mem[_58094 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _58094 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            _39289 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39289] = 30
                            mem[_39289 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _39845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39845 + 68] = mem[idx + _39289 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39845 + 68] = mem[_39845 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39845 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 204
                            _42430 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42430] = 30
                            mem[_42430 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _43975 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43975 + 68] = mem[idx + _42430 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43975 + 68] = mem[_43975 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43975 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _46984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_46984] = 30
                            mem[_46984 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _49368 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _49368 + 68] = mem[idx + _46984 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_49368 + 68] = mem[_49368 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _49368 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            _56210 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_56210] = 30
                            mem[_56210 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _58091 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _58091 + 68] = mem[idx + _56210 + 32]
                                idx = idx + 32
                                continue 
                            mem[_58091 + 68] = mem[_58091 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _58091 + -mem[64] + 100
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _39420 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39420] = 30
                        mem[_39420 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                            _40159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _40159 + 68] = mem[idx + _39420 + 32]
                                idx = idx + 32
                                continue 
                            mem[_40159 + 68] = mem[_40159 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40159 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _43080 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43080] = 30
                        mem[_43080 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _44993 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _44993 + 68] = mem[idx + _43080 + 32]
                                idx = idx + 32
                                continue 
                            mem[_44993 + 68] = mem[_44993 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _44993 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _48250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_48250] = 30
                        mem[_48250 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _50653 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _50653 + 68] = mem[idx + _48250 + 32]
                                idx = idx + 32
                                continue 
                            mem[_50653 + 68] = mem[_50653 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _50653 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                        _57211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57211] = 30
                        mem[_57211 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            return 1
                        _59009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _59009 + 68] = mem[idx + _57211 + 32]
                            idx = idx + 32
                            continue 
                        mem[_59009 + 68] = mem[_59009 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _59009 + -mem[64] + 100
                    require idx < stor207.length
                    mem[0] = stor207[idx]
                    mem[32] = 204
                    if stor204[stor207[idx]] <= s:
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        _34479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34479] = 30
                        mem[_34479 + 32] = 'SafeMath: subtraction overflow'
                        if stor203[stor207[idx]] > t:
                            _35034 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35034 + 68] = mem[idx + _34479 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35034 + 68] = mem[_35034 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35034 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        _37014 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_37014] = 30
                        mem[_37014 + 32] = 'SafeMath: subtraction overflow'
                        if stor204[stor207[idx]] <= s:
                            idx = idx + 1
                            s = s - stor204[stor207[idx]]
                            t = t - stor203[stor207[idx]]
                            continue 
                        _37881 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _37881 + 68] = mem[idx + _37014 + 32]
                            idx = idx + 32
                            continue 
                        mem[_37881 + 68] = mem[_37881 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _37881 + -mem[64] + 100
                    _34787 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34787] = 26
                    mem[_34787 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _34787 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if not _tFeePercent * arg2 / 10000:
                            _39423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39423] = 30
                            mem[_39423 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 204
                            _43090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43090] = 30
                            mem[_43090 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _45000 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45000 + 68] = mem[idx + _43090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45000 + 68] = mem[_45000 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45000 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _48264 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_48264] = 30
                            mem[_48264 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _50664 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _50664 + 68] = mem[idx + _48264 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_50664 + 68] = mem[_50664 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _50664 + -mem[64] + 100
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = stor203[arg1]
                            _57216 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_57216] = 30
                            mem[_57216 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _59014 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _59014 + 68] = mem[idx + _57216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_59014 + 68] = mem[_59014 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _59014 + -mem[64] + 100
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _39852 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39852] = 30
                        mem[_39852 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                            _40666 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _40666 + 68] = mem[idx + _39852 + 32]
                                idx = idx + 32
                                continue 
                            mem[_40666 + 68] = mem[_40666 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40666 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _43984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43984] = 30
                        mem[_43984 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _45915 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _45915 + 68] = mem[idx + _43984 + 32]
                                idx = idx + 32
                                continue 
                            mem[_45915 + 68] = mem[_45915 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _45915 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _49380 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_49380] = 30
                        mem[_49380 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor203[address(msg.sender)]:
                            _51848 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _51848 + 68] = mem[idx + _49380 + 32]
                                idx = idx + 32
                                continue 
                            mem[_51848 + 68] = mem[_51848 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _51848 + -mem[64] + 100
                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                        _58098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58098] = 30
                        mem[_58098 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            return 1
                        _60086 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _60086 + 68] = mem[idx + _58098 + 32]
                            idx = idx + 32
                            continue 
                        mem[_60086 + 68] = mem[_60086 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _60086 + -mem[64] + 100
                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not _tFeePercent * arg2 / 10000:
                        _39851 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39851] = 30
                        mem[_39851 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor209 / totalSupply * arg2:
                            _40663 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _40663 + 68] = mem[idx + _39851 + 32]
                                idx = idx + 32
                                continue 
                            mem[_40663 + 68] = mem[_40663 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40663 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _43983 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43983] = 30
                        mem[_43983 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _45912 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _45912 + 68] = mem[idx + _43983 + 32]
                                idx = idx + 32
                                continue 
                            mem[_45912 + 68] = mem[_45912 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _45912 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _49377 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_49377] = 30
                        mem[_49377 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _51845 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _51845 + 68] = mem[idx + _49377 + 32]
                                idx = idx + 32
                                continue 
                            mem[_51845 + 68] = mem[_51845 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _51845 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        _58097 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58097] = 30
                        mem[_58097 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            return 1
                        _60083 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _60083 + 68] = mem[idx + _58097 + 32]
                            idx = idx + 32
                            continue 
                        mem[_60083 + 68] = mem[_60083 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _60083 + -mem[64] + 100
                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _40162 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_40162] = 30
                    mem[_40162 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                        _41039 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _41039 + 68] = mem[idx + _40162 + 32]
                            idx = idx + 32
                            continue 
                        mem[_41039 + 68] = mem[_41039 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _41039 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 204
                    _44999 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_44999] = 30
                    mem[_44999 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor204[address(msg.sender)]:
                        _46991 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _46991 + 68] = mem[idx + _44999 + 32]
                            idx = idx + 32
                            continue 
                        mem[_46991 + 68] = mem[_46991 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _46991 + -mem[64] + 100
                    mem[0] = msg.sender
                    stor204[address(msg.sender)] -= arg2
                    mem[32] = 203
                    _50659 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_50659] = 30
                    mem[_50659 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                        _52951 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _52951 + 68] = mem[idx + _50659 + 32]
                            idx = idx + 32
                            continue 
                        mem[_52951 + 68] = mem[_52951 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _52951 + -mem[64] + 100
                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 203
                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                    _59013 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_59013] = 30
                    mem[_59013 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        return 1
                    _60957 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _60957 + 68] = mem[idx + _59013 + 32]
                        idx = idx + 32
                        continue 
                    mem[_60957 + 68] = mem[_60957 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _60957 + -mem[64] + 100
                _33419 = mem[64]
                mem[64] = mem[64] + 64
                mem[_33419] = 26
                mem[_33419 + 32] = 'SafeMath: division by zero' << 48
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor209 / totalSupply:
                    _35461 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35461] = 26
                    mem[_35461 + 32] = 'SafeMath: division by zero' << 48
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if not _tFeePercent * arg2 / 10000:
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                    else:
                        if t / s * arg2 / arg2 != t / s:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            if 0 > t / s * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if t / s * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * t / s * arg2
                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if t / s * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * t / s * arg2
                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                else:
                    _35462 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35462] = 26
                    mem[_35462 + 32] = 'SafeMath: division by zero' << 48
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if not _tFeePercent * arg2 / 10000:
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                    else:
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            if 0 > stor209 / totalSupply * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += _tFeePercent * arg2 / 10000
                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
        else:
            if stor206[address(msg.sender)]:
                if stor206[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 206
                    if not stor206[address(msg.sender)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34144] = 26
                                    mem[_34144 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34144 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39110] = 30
                                        mem[_39110 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41495 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41495] = 30
                                        mem[_41495 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42776 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42776 + 68] = mem[idx + _41495 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42776 + 68] = mem[_42776 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42776 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50053 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50053] = 30
                                        mem[_50053 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _52428 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52428 + 68] = mem[idx + _50053 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52428 + 68] = mem[_52428 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52428 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39230 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39230] = 30
                                    mem[_39230 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39645 + 68] = mem[idx + _39230 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39645 + 68] = mem[_39645 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39645 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42186 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42186] = 30
                                    mem[_42186 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43559 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43559 + 68] = mem[idx + _42186 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43559 + 68] = mem[_43559 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43559 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51288] = 30
                                    mem[_51288 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53390 + 68] = mem[idx + _51288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53390 + 68] = mem[_53390 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53390 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34392] = 30
                                    mem[_34392 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34918 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34918 + 68] = mem[idx + _34392 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34918 + 68] = mem[_34918 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34918 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36811 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36811] = 30
                                    mem[_36811 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37649 + 68] = mem[idx + _36811 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37649 + 68] = mem[_37649 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37649 + -mem[64] + 100
                                _34642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34642] = 26
                                mem[_34642 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34642 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39361] = 30
                                    mem[_39361 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42781 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42781] = 30
                                    mem[_42781 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44520 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44520 + 68] = mem[idx + _42781 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44520 + 68] = mem[_44520 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44520 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _52431 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52431] = 30
                                    mem[_52431 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54132 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54132 + 68] = mem[idx + _52431 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54132 + 68] = mem[_54132 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54132 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39648] = 30
                                mem[_39648 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40426 + 68] = mem[idx + _39648 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40426 + 68] = mem[_40426 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40426 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43562] = 30
                                mem[_43562 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45484 + 68] = mem[idx + _43562 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45484 + 68] = mem[_45484 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45484 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53393 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53393] = 30
                                mem[_53393 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _54861 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54861 + 68] = mem[idx + _53393 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54861 + 68] = mem[_54861 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54861 + -mem[64] + 100
                            _33274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33274] = 26
                            mem[_33274 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35258 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35258] = 26
                                mem[_35258 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _35259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35259] = 26
                                mem[_35259 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34139 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34139] = 26
                                    mem[_34139 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34139 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39109] = 30
                                            mem[_39109 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41484 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41484] = 30
                                            mem[_41484 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42764 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42764 + 68] = mem[idx + _41484 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42764 + 68] = mem[_42764 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42764 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50033 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50033] = 30
                                            mem[_50033 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _52415 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52415 + 68] = mem[idx + _50033 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52415 + 68] = mem[_52415 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52415 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39227] = 30
                                        mem[_39227 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39640 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39640 + 68] = mem[idx + _39227 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39640 + 68] = mem[_39640 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39640 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42179 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42179] = 30
                                        mem[_42179 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43546 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43546 + 68] = mem[idx + _42179 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43546 + 68] = mem[_43546 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43546 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51272 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51272] = 30
                                        mem[_51272 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53383 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53383 + 68] = mem[idx + _51272 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53383 + 68] = mem[_53383 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53383 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39226 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39226] = 30
                                        mem[_39226 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39637 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39637 + 68] = mem[idx + _39226 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39637 + 68] = mem[_39637 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39637 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42178] = 30
                                        mem[_42178 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43543 + 68] = mem[idx + _42178 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43543 + 68] = mem[_43543 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43543 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51271 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51271] = 30
                                        mem[_51271 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53380 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53380 + 68] = mem[idx + _51271 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53380 + 68] = mem[_53380 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53380 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39357] = 30
                                    mem[_39357 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40011 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40011 + 68] = mem[idx + _39357 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40011 + 68] = mem[_40011 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40011 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42763] = 30
                                    mem[_42763 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44501 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44501 + 68] = mem[idx + _42763 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44501 + 68] = mem[_44501 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44501 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52414] = 30
                                    mem[_52414 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54121 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54121 + 68] = mem[idx + _52414 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54121 + 68] = mem[_54121 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54121 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34389] = 30
                                    mem[_34389 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34914 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34914 + 68] = mem[idx + _34389 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34914 + 68] = mem[_34914 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34914 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36804 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36804] = 30
                                    mem[_36804 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37641 + 68] = mem[idx + _36804 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37641 + 68] = mem[_37641 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37641 + -mem[64] + 100
                                _34637 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34637] = 26
                                mem[_34637 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34637 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39360] = 30
                                        mem[_39360 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42773 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42773] = 30
                                        mem[_42773 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44508 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44508 + 68] = mem[idx + _42773 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44508 + 68] = mem[_44508 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44508 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52419 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52419] = 30
                                        mem[_52419 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54126 + 68] = mem[idx + _52419 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54126 + 68] = mem[_54126 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54126 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39644] = 30
                                    mem[_39644 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _40420 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40420 + 68] = mem[idx + _39644 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40420 + 68] = mem[_40420 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40420 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43552] = 30
                                    mem[_43552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _45474 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45474 + 68] = mem[idx + _43552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45474 + 68] = mem[_45474 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45474 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53387] = 30
                                    mem[_53387 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54853 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54853 + 68] = mem[idx + _53387 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54853 + 68] = mem[_54853 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54853 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39643] = 30
                                    mem[_39643 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40417 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40417 + 68] = mem[idx + _39643 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40417 + 68] = mem[_40417 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40417 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43551 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43551] = 30
                                    mem[_43551 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45471 + 68] = mem[idx + _43551 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45471 + 68] = mem[_45471 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45471 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53386] = 30
                                    mem[_53386 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54850 + 68] = mem[idx + _53386 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54850 + 68] = mem[_54850 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54850 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _40014 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40014] = 30
                                mem[_40014 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40861 + 68] = mem[idx + _40014 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40861 + 68] = mem[_40861 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40861 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _44507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44507] = 30
                                mem[_44507 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _46469 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _46469 + 68] = mem[idx + _44507 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_46469 + 68] = mem[_46469 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _46469 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _54125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54125] = 30
                                mem[_54125 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55744 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55744 + 68] = mem[idx + _54125 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55744 + 68] = mem[_55744 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55744 + -mem[64] + 100
                            _33269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33269] = 26
                            mem[_33269 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35251] = 26
                                mem[_35251 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _35252 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35252] = 26
                                mem[_35252 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34154 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34154] = 26
                                        mem[_34154 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34154 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39114 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39114] = 30
                                            mem[_39114 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41526 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41526] = 30
                                            mem[_41526 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42799 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42799 + 68] = mem[idx + _41526 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42799 + 68] = mem[_42799 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42799 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50095 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50095] = 30
                                            mem[_50095 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52464 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52464 + 68] = mem[idx + _50095 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52464 + 68] = mem[_52464 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52464 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39235 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39235] = 30
                                        mem[_39235 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39661 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39661 + 68] = mem[idx + _39235 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39661 + 68] = mem[_39661 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39661 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42206 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42206] = 30
                                        mem[_42206 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43591 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43591 + 68] = mem[idx + _42206 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43591 + 68] = mem[_43591 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43591 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51327 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51327] = 30
                                        mem[_51327 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53414 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53414 + 68] = mem[idx + _51327 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53414 + 68] = mem[_53414 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53414 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34398 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34398] = 30
                                        mem[_34398 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34926 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34926 + 68] = mem[idx + _34398 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34926 + 68] = mem[_34926 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34926 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36825] = 30
                                        mem[_36825 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37665 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37665 + 68] = mem[idx + _36825 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37665 + 68] = mem[_37665 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37665 + -mem[64] + 100
                                    _34652 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34652] = 26
                                    mem[_34652 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34652 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39366 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39366] = 30
                                        mem[_39366 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42804 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42804] = 30
                                        mem[_42804 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44556 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44556 + 68] = mem[idx + _42804 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44556 + 68] = mem[_44556 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44556 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52467] = 30
                                        mem[_52467 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54150 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54150 + 68] = mem[idx + _52467 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54150 + 68] = mem[_54150 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54150 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39664 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39664] = 30
                                    mem[_39664 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40444 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40444 + 68] = mem[idx + _39664 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40444 + 68] = mem[_40444 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40444 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43594 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43594] = 30
                                    mem[_43594 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45516 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45516 + 68] = mem[idx + _43594 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45516 + 68] = mem[_45516 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45516 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53417] = 30
                                    mem[_53417 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54883 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54883 + 68] = mem[idx + _53417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54883 + 68] = mem[_54883 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54883 + -mem[64] + 100
                                _33284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33284] = 26
                                mem[_33284 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35272 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35272] = 26
                                    mem[_35272 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35273 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35273] = 26
                                    mem[_35273 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34149 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34149] = 26
                                        mem[_34149 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34149 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39113 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39113] = 30
                                                mem[_39113 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41515 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41515] = 30
                                                mem[_41515 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42787 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42787 + 68] = mem[idx + _41515 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42787 + 68] = mem[_42787 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42787 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50075 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50075] = 30
                                                mem[_50075 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52451 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52451 + 68] = mem[idx + _50075 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52451 + 68] = mem[_52451 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52451 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39232 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39232] = 30
                                            mem[_39232 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39656 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39656 + 68] = mem[idx + _39232 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39656 + 68] = mem[_39656 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39656 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42199 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42199] = 30
                                            mem[_42199 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43578 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43578 + 68] = mem[idx + _42199 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43578 + 68] = mem[_43578 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43578 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51311 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51311] = 30
                                            mem[_51311 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53407 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53407 + 68] = mem[idx + _51311 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53407 + 68] = mem[_53407 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53407 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39231 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39231] = 30
                                            mem[_39231 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39653 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39653 + 68] = mem[idx + _39231 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39653 + 68] = mem[_39653 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39653 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42198 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42198] = 30
                                            mem[_42198 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43575 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43575 + 68] = mem[idx + _42198 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43575 + 68] = mem[_43575 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43575 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51310 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51310] = 30
                                            mem[_51310 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53404 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53404 + 68] = mem[idx + _51310 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53404 + 68] = mem[_53404 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53404 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39362] = 30
                                        mem[_39362 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40023 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40023 + 68] = mem[idx + _39362 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40023 + 68] = mem[_40023 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40023 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42786 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42786] = 30
                                        mem[_42786 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44537 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44537 + 68] = mem[idx + _42786 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44537 + 68] = mem[_44537 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44537 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52450] = 30
                                        mem[_52450 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54139 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54139 + 68] = mem[idx + _52450 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54139 + 68] = mem[_54139 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54139 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34395] = 30
                                        mem[_34395 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34922 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34922 + 68] = mem[idx + _34395 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34922 + 68] = mem[_34922 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34922 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36818] = 30
                                        mem[_36818 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37657 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37657 + 68] = mem[idx + _36818 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37657 + 68] = mem[_37657 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37657 + -mem[64] + 100
                                    _34647 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34647] = 26
                                    mem[_34647 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34647 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39365 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39365] = 30
                                            mem[_39365 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42796 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42796] = 30
                                            mem[_42796 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44544 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44544 + 68] = mem[idx + _42796 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44544 + 68] = mem[_44544 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44544 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52455 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52455] = 30
                                            mem[_52455 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54144 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54144 + 68] = mem[idx + _52455 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54144 + 68] = mem[_54144 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54144 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39660 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39660] = 30
                                        mem[_39660 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40438 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40438 + 68] = mem[idx + _39660 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40438 + 68] = mem[_40438 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40438 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43584 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43584] = 30
                                        mem[_43584 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45506 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45506 + 68] = mem[idx + _43584 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45506 + 68] = mem[_45506 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45506 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53411] = 30
                                        mem[_53411 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54875 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54875 + 68] = mem[idx + _53411 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54875 + 68] = mem[_54875 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54875 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39659 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39659] = 30
                                        mem[_39659 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40435 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40435 + 68] = mem[idx + _39659 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40435 + 68] = mem[_40435 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40435 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43583 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43583] = 30
                                        mem[_43583 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45503 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45503 + 68] = mem[idx + _43583 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45503 + 68] = mem[_45503 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45503 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53410] = 30
                                        mem[_53410 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54872 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54872 + 68] = mem[idx + _53410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54872 + 68] = mem[_54872 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54872 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _40026 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40026] = 30
                                    mem[_40026 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40875 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40875 + 68] = mem[idx + _40026 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40875 + 68] = mem[_40875 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40875 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44543 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44543] = 30
                                    mem[_44543 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46507 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46507 + 68] = mem[idx + _44543 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46507 + 68] = mem[_46507 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46507 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _54143 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54143] = 30
                                    mem[_54143 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55776 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55776 + 68] = mem[idx + _54143 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55776 + 68] = mem[_55776 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55776 + -mem[64] + 100
                                _33279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33279] = 26
                                mem[_33279 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35265 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35265] = 26
                                    mem[_35265 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35266 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35266] = 26
                                    mem[_35266 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34164 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34164] = 26
                                        mem[_34164 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34164 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39116 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39116] = 30
                                            mem[_39116 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41546 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41546] = 30
                                            mem[_41546 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42815 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42815 + 68] = mem[idx + _41546 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42815 + 68] = mem[_42815 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42815 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45535 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45535] = 30
                                            mem[_45535 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _47735 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47735 + 68] = mem[idx + _45535 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47735 + 68] = mem[_47735 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47735 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57735 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57735] = 30
                                            mem[_57735 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _59647 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59647 + 68] = mem[idx + _57735 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59647 + 68] = mem[_59647 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59647 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39237 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39237] = 30
                                        mem[_39237 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39669 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39669 + 68] = mem[idx + _39237 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39669 + 68] = mem[_39669 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39669 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42214 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42214] = 30
                                        mem[_42214 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43611 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43611 + 68] = mem[idx + _42214 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43611 + 68] = mem[_43611 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43611 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46546 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46546] = 30
                                        mem[_46546 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _48916 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48916 + 68] = mem[idx + _46546 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48916 + 68] = mem[_48916 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48916 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58639] = 30
                                        mem[_58639 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _60595 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60595 + 68] = mem[idx + _58639 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60595 + 68] = mem[_60595 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60595 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34404] = 30
                                        mem[_34404 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34934 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34934 + 68] = mem[idx + _34404 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34934 + 68] = mem[_34934 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34934 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36839 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36839] = 30
                                        mem[_36839 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37681 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37681 + 68] = mem[idx + _36839 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37681 + 68] = mem[_37681 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37681 + -mem[64] + 100
                                    _34662 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34662] = 26
                                    mem[_34662 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34662 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39368 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39368] = 30
                                        mem[_39368 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42820 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42820] = 30
                                        mem[_42820 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44580 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44580 + 68] = mem[idx + _42820 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44580 + 68] = mem[_44580 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44580 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47741 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47741] = 30
                                        mem[_47741 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _50135 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50135 + 68] = mem[idx + _47741 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50135 + 68] = mem[_50135 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50135 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _59650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59650] = 30
                                        mem[_59650 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _61419 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61419 + 68] = mem[idx + _59650 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61419 + 68] = mem[_61419 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61419 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39672] = 30
                                    mem[_39672 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40456 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40456 + 68] = mem[idx + _39672 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40456 + 68] = mem[_40456 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40456 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _43614 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43614] = 30
                                    mem[_43614 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _45538 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45538 + 68] = mem[idx + _43614 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45538 + 68] = mem[_45538 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45538 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _48919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48919] = 30
                                    mem[_48919 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _51358 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51358 + 68] = mem[idx + _48919 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51358 + 68] = mem[_51358 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51358 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _60598 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60598] = 30
                                    mem[_60598 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _62237 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62237 + 68] = mem[idx + _60598 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62237 + 68] = mem[_62237 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62237 + -mem[64] + 100
                                _33294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33294] = 26
                                mem[_33294 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35286 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35286] = 26
                                    mem[_35286 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _35287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35287] = 26
                                    mem[_35287 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            else:
                                if 0 / arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34159 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34159] = 26
                                        mem[_34159 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34159 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39115 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39115] = 30
                                            mem[_39115 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41536 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41536] = 30
                                            mem[_41536 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42807 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42807 + 68] = mem[idx + _41536 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42807 + 68] = mem[_42807 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42807 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45524 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45524] = 30
                                            mem[_45524 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _47719 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47719 + 68] = mem[idx + _45524 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47719 + 68] = mem[_47719 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47719 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57727 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57727] = 30
                                            mem[_57727 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _59637 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59637 + 68] = mem[idx + _57727 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59637 + 68] = mem[_59637 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59637 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39236 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39236] = 30
                                        mem[_39236 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39665 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39665 + 68] = mem[idx + _39236 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39665 + 68] = mem[_39665 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39665 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42210 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42210] = 30
                                        mem[_42210 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43601 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43601 + 68] = mem[idx + _42210 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43601 + 68] = mem[_43601 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43601 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46533 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46533] = 30
                                        mem[_46533 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _48903 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48903 + 68] = mem[idx + _46533 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48903 + 68] = mem[_48903 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48903 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58633 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58633] = 30
                                        mem[_58633 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _60589 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60589 + 68] = mem[idx + _58633 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60589 + 68] = mem[_60589 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60589 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34401] = 30
                                        mem[_34401 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34930 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34930 + 68] = mem[idx + _34401 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34930 + 68] = mem[_34930 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34930 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36832] = 30
                                        mem[_36832 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37673 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37673 + 68] = mem[idx + _36832 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37673 + 68] = mem[_37673 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37673 + -mem[64] + 100
                                    _34657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34657] = 26
                                    mem[_34657 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34657 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39367 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39367] = 30
                                        mem[_39367 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42812 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42812] = 30
                                        mem[_42812 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44568 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44568 + 68] = mem[idx + _42812 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44568 + 68] = mem[_44568 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44568 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47725 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47725] = 30
                                        mem[_47725 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _50116 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50116 + 68] = mem[idx + _47725 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50116 + 68] = mem[_50116 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50116 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _59640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59640] = 30
                                        mem[_59640 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _61413 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61413 + 68] = mem[idx + _59640 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61413 + 68] = mem[_61413 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61413 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39668] = 30
                                    mem[_39668 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40450 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40450 + 68] = mem[idx + _39668 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40450 + 68] = mem[_40450 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40450 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _43604 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43604] = 30
                                    mem[_43604 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _45527 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45527 + 68] = mem[idx + _43604 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45527 + 68] = mem[_45527 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45527 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _48906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48906] = 30
                                    mem[_48906 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _51342 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51342 + 68] = mem[idx + _48906 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51342 + 68] = mem[_51342 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51342 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _60592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60592] = 30
                                    mem[_60592 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _62229 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62229 + 68] = mem[idx + _60592 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62229 + 68] = mem[_62229 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62229 + -mem[64] + 100
                                _33289 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33289] = 26
                                mem[_33289 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35279 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35279] = 26
                                    mem[_35279 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _35280 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35280] = 26
                                    mem[_35280 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                else:
                    mem[0] = arg1
                    mem[32] = 206
                    if not stor206[address(arg1)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34204] = 26
                                    mem[_34204 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34204 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39130] = 30
                                        mem[_39130 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41659 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41659] = 30
                                        mem[_41659 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42900 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42900 + 68] = mem[idx + _41659 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42900 + 68] = mem[_42900 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42900 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50297] = 30
                                        mem[_50297 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _52636 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52636 + 68] = mem[idx + _50297 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52636 + 68] = mem[_52636 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52636 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39254] = 30
                                    mem[_39254 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39725 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39725 + 68] = mem[idx + _39254 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39725 + 68] = mem[_39725 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39725 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42282 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42282] = 30
                                    mem[_42282 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43727 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43727 + 68] = mem[idx + _42282 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43727 + 68] = mem[_43727 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43727 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51508] = 30
                                    mem[_51508 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _53550 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53550 + 68] = mem[idx + _51508 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53550 + 68] = mem[_53550 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53550 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34428 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34428] = 30
                                    mem[_34428 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34966 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34966 + 68] = mem[idx + _34428 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34966 + 68] = mem[_34966 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34966 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36895 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36895] = 30
                                    mem[_36895 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37745 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37745 + 68] = mem[idx + _36895 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37745 + 68] = mem[_37745 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37745 + -mem[64] + 100
                                _34702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34702] = 26
                                mem[_34702 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34702 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39385 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39385] = 30
                                    mem[_39385 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42905] = 30
                                    mem[_42905 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44712 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44712 + 68] = mem[idx + _42905 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44712 + 68] = mem[_44712 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44712 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _52639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52639] = 30
                                    mem[_52639 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54256 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54256 + 68] = mem[idx + _52639 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54256 + 68] = mem[_54256 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54256 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39728] = 30
                                mem[_39728 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40522 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40522 + 68] = mem[idx + _39728 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40522 + 68] = mem[_40522 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40522 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43730] = 30
                                mem[_43730 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45656 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45656 + 68] = mem[idx + _43730 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45656 + 68] = mem[_45656 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45656 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _53553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53553] = 30
                                mem[_53553 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _55017 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55017 + 68] = mem[idx + _53553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55017 + 68] = mem[_55017 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55017 + -mem[64] + 100
                            _33334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33334] = 26
                            mem[_33334 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35342] = 26
                                mem[_35342 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _35343 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35343] = 26
                                mem[_35343 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit 0x64ddf252: arg2, msg.sender, arg1
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero' << 48
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _34199 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34199] = 26
                                    mem[_34199 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34199 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39129 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39129] = 30
                                            mem[_39129 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41648] = 30
                                            mem[_41648 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42888 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42888 + 68] = mem[idx + _41648 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42888 + 68] = mem[_42888 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42888 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50277 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50277] = 30
                                            mem[_50277 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _52623 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52623 + 68] = mem[idx + _50277 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52623 + 68] = mem[_52623 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52623 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39251 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39251] = 30
                                        mem[_39251 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39720 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39720 + 68] = mem[idx + _39251 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39720 + 68] = mem[_39720 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39720 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42275 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42275] = 30
                                        mem[_42275 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43714 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43714 + 68] = mem[idx + _42275 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43714 + 68] = mem[_43714 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43714 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51492 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51492] = 30
                                        mem[_51492 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53543 + 68] = mem[idx + _51492 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53543 + 68] = mem[_53543 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53543 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39250 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39250] = 30
                                        mem[_39250 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39717 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39717 + 68] = mem[idx + _39250 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39717 + 68] = mem[_39717 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39717 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42274] = 30
                                        mem[_42274 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43711 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43711 + 68] = mem[idx + _42274 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43711 + 68] = mem[_43711 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43711 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51491 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51491] = 30
                                        mem[_51491 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _53540 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53540 + 68] = mem[idx + _51491 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53540 + 68] = mem[_53540 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53540 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39381 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39381] = 30
                                    mem[_39381 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40067 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40067 + 68] = mem[idx + _39381 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40067 + 68] = mem[_40067 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40067 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42887 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42887] = 30
                                    mem[_42887 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44693 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44693 + 68] = mem[idx + _42887 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44693 + 68] = mem[_44693 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44693 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52622] = 30
                                    mem[_52622 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _54245 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54245 + 68] = mem[idx + _52622 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54245 + 68] = mem[_54245 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54245 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _34425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34425] = 30
                                    mem[_34425 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _34962 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34962 + 68] = mem[idx + _34425 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34962 + 68] = mem[_34962 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34962 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _36888 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36888] = 30
                                    mem[_36888 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _37737 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _37737 + 68] = mem[idx + _36888 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37737 + 68] = mem[_37737 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37737 + -mem[64] + 100
                                _34697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34697] = 26
                                mem[_34697 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34697 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39384] = 30
                                        mem[_39384 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42897 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42897] = 30
                                        mem[_42897 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44700 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44700 + 68] = mem[idx + _42897 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44700 + 68] = mem[_44700 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44700 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52627 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52627] = 30
                                        mem[_52627 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54250 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54250 + 68] = mem[idx + _52627 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54250 + 68] = mem[_54250 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54250 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39724] = 30
                                    mem[_39724 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _40516 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40516 + 68] = mem[idx + _39724 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40516 + 68] = mem[_40516 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40516 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43720] = 30
                                    mem[_43720 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _45646 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45646 + 68] = mem[idx + _43720 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45646 + 68] = mem[_45646 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45646 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53547] = 30
                                    mem[_53547 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55009 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55009 + 68] = mem[idx + _53547 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55009 + 68] = mem[_55009 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55009 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39723] = 30
                                    mem[_39723 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40513 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40513 + 68] = mem[idx + _39723 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40513 + 68] = mem[_40513 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40513 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43719 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43719] = 30
                                    mem[_43719 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45643 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45643 + 68] = mem[idx + _43719 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45643 + 68] = mem[_45643 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45643 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53546] = 30
                                    mem[_53546 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55006 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55006 + 68] = mem[idx + _53546 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55006 + 68] = mem[_55006 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55006 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _40070 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40070] = 30
                                mem[_40070 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40929 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40929 + 68] = mem[idx + _40070 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40929 + 68] = mem[_40929 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40929 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _44699 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44699] = 30
                                mem[_44699 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _46673 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _46673 + 68] = mem[idx + _44699 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_46673 + 68] = mem[_46673 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _46673 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _54249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54249] = 30
                                mem[_54249 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _55932 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55932 + 68] = mem[idx + _54249 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55932 + 68] = mem[_55932 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55932 + -mem[64] + 100
                            _33329 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33329] = 26
                            mem[_33329 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _35335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35335] = 26
                                mem[_35335 + 32] = 'SafeMath: division by zero' << 48
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _35336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35336] = 26
                                mem[_35336 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                    else:
                        mem[0] = msg.sender
                        mem[32] = 206
                        if not stor206[address(msg.sender)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34174] = 26
                                        mem[_34174 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34174 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39120 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39120] = 30
                                            mem[_39120 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41577 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41577] = 30
                                            mem[_41577 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42838 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42838 + 68] = mem[idx + _41577 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42838 + 68] = mem[_42838 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42838 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50175 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50175] = 30
                                            mem[_50175 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52532 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52532 + 68] = mem[idx + _50175 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52532 + 68] = mem[_52532 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52532 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39242 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39242] = 30
                                        mem[_39242 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39685 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39685 + 68] = mem[idx + _39242 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39685 + 68] = mem[_39685 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39685 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42234 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42234] = 30
                                        mem[_42234 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43643 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43643 + 68] = mem[idx + _42234 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43643 + 68] = mem[_43643 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43643 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51398 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51398] = 30
                                        mem[_51398 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53470 + 68] = mem[idx + _51398 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53470 + 68] = mem[_53470 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53470 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34410] = 30
                                        mem[_34410 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34942 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34942 + 68] = mem[idx + _34410 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34942 + 68] = mem[_34942 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34942 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36853 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36853] = 30
                                        mem[_36853 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37697 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37697 + 68] = mem[idx + _36853 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37697 + 68] = mem[_37697 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37697 + -mem[64] + 100
                                    _34672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34672] = 26
                                    mem[_34672 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34672 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39373] = 30
                                        mem[_39373 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42843] = 30
                                        mem[_42843 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44616 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44616 + 68] = mem[idx + _42843 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44616 + 68] = mem[_44616 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44616 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52535] = 30
                                        mem[_52535 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54194 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54194 + 68] = mem[idx + _52535 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54194 + 68] = mem[_54194 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54194 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39688 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39688] = 30
                                    mem[_39688 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40474 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40474 + 68] = mem[idx + _39688 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40474 + 68] = mem[_40474 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40474 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43646 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43646] = 30
                                    mem[_43646 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45570 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45570 + 68] = mem[idx + _43646 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45570 + 68] = mem[_45570 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45570 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53473] = 30
                                    mem[_53473 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _54939 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54939 + 68] = mem[idx + _53473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54939 + 68] = mem[_54939 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54939 + -mem[64] + 100
                                _33304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33304] = 26
                                mem[_33304 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35300 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35300] = 26
                                    mem[_35300 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35301] = 26
                                    mem[_35301 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34169 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34169] = 26
                                        mem[_34169 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34169 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39119 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39119] = 30
                                                mem[_39119 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41566 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41566] = 30
                                                mem[_41566 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42826 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42826 + 68] = mem[idx + _41566 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42826 + 68] = mem[_42826 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42826 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50155 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50155] = 30
                                                mem[_50155 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52519 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52519 + 68] = mem[idx + _50155 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52519 + 68] = mem[_52519 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52519 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39239 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39239] = 30
                                            mem[_39239 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39680 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39680 + 68] = mem[idx + _39239 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39680 + 68] = mem[_39680 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39680 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42227 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42227] = 30
                                            mem[_42227 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43630 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43630 + 68] = mem[idx + _42227 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43630 + 68] = mem[_43630 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43630 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51382 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51382] = 30
                                            mem[_51382 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53463 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53463 + 68] = mem[idx + _51382 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53463 + 68] = mem[_53463 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53463 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39238 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39238] = 30
                                            mem[_39238 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39677 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39677 + 68] = mem[idx + _39238 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39677 + 68] = mem[_39677 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39677 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42226 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42226] = 30
                                            mem[_42226 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43627 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43627 + 68] = mem[idx + _42226 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43627 + 68] = mem[_43627 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43627 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51381 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51381] = 30
                                            mem[_51381 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53460 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53460 + 68] = mem[idx + _51381 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53460 + 68] = mem[_53460 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53460 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39369 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39369] = 30
                                        mem[_39369 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40039 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40039 + 68] = mem[idx + _39369 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40039 + 68] = mem[_40039 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40039 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42825] = 30
                                        mem[_42825 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44597 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44597 + 68] = mem[idx + _42825 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44597 + 68] = mem[_44597 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44597 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52518 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52518] = 30
                                        mem[_52518 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54183 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54183 + 68] = mem[idx + _52518 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54183 + 68] = mem[_54183 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54183 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34407 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34407] = 30
                                        mem[_34407 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34938 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34938 + 68] = mem[idx + _34407 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34938 + 68] = mem[_34938 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34938 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36846] = 30
                                        mem[_36846 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37689 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37689 + 68] = mem[idx + _36846 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37689 + 68] = mem[_37689 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37689 + -mem[64] + 100
                                    _34667 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34667] = 26
                                    mem[_34667 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34667 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39372 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39372] = 30
                                            mem[_39372 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42835 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42835] = 30
                                            mem[_42835 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44604 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44604 + 68] = mem[idx + _42835 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44604 + 68] = mem[_44604 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44604 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52523 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52523] = 30
                                            mem[_52523 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54188 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54188 + 68] = mem[idx + _52523 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54188 + 68] = mem[_54188 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54188 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39684] = 30
                                        mem[_39684 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40468 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40468 + 68] = mem[idx + _39684 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40468 + 68] = mem[_40468 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40468 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43636] = 30
                                        mem[_43636 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45560 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45560 + 68] = mem[idx + _43636 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45560 + 68] = mem[_45560 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45560 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53467] = 30
                                        mem[_53467 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54931 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54931 + 68] = mem[idx + _53467 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54931 + 68] = mem[_54931 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54931 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39683] = 30
                                        mem[_39683 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40465 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40465 + 68] = mem[idx + _39683 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40465 + 68] = mem[_40465 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40465 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43635 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43635] = 30
                                        mem[_43635 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45557 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45557 + 68] = mem[idx + _43635 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45557 + 68] = mem[_45557 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45557 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53466 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53466] = 30
                                        mem[_53466 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54928 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54928 + 68] = mem[idx + _53466 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54928 + 68] = mem[_54928 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54928 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _40042 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40042] = 30
                                    mem[_40042 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40895 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40895 + 68] = mem[idx + _40042 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40895 + 68] = mem[_40895 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40895 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44603 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44603] = 30
                                    mem[_44603 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46571 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46571 + 68] = mem[idx + _44603 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46571 + 68] = mem[_46571 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46571 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _54187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54187] = 30
                                    mem[_54187 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55838 + 68] = mem[idx + _54187 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55838 + 68] = mem[_55838 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55838 + -mem[64] + 100
                                _33299 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33299] = 26
                                mem[_33299 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35293] = 26
                                    mem[_35293 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35294] = 26
                                    mem[_35294 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            mem[0] = arg1
                            mem[32] = 206
                            if not stor206[address(arg1)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34184] = 26
                                            mem[_34184 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34184 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39124 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39124] = 30
                                                mem[_39124 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41608 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41608] = 30
                                                mem[_41608 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42861 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42861 + 68] = mem[idx + _41608 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42861 + 68] = mem[_42861 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42861 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50217 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50217] = 30
                                                mem[_50217 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _52568 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52568 + 68] = mem[idx + _50217 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52568 + 68] = mem[_52568 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52568 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39247 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39247] = 30
                                            mem[_39247 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39701 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39701 + 68] = mem[idx + _39247 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39701 + 68] = mem[_39701 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39701 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42254 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42254] = 30
                                            mem[_42254 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43675 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43675 + 68] = mem[idx + _42254 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43675 + 68] = mem[_43675 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43675 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51437 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51437] = 30
                                            mem[_51437 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _53494 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53494 + 68] = mem[idx + _51437 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53494 + 68] = mem[_53494 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53494 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34416 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34416] = 30
                                            mem[_34416 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34950 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34950 + 68] = mem[idx + _34416 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34950 + 68] = mem[_34950 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34950 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36867 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36867] = 30
                                            mem[_36867 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37713 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37713 + 68] = mem[idx + _36867 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37713 + 68] = mem[_37713 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37713 + -mem[64] + 100
                                        _34682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34682] = 26
                                        mem[_34682 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34682 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39378 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39378] = 30
                                            mem[_39378 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42866 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42866] = 30
                                            mem[_42866 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44652 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44652 + 68] = mem[idx + _42866 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44652 + 68] = mem[_44652 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44652 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52571 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52571] = 30
                                            mem[_52571 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _54212 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54212 + 68] = mem[idx + _52571 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54212 + 68] = mem[_54212 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54212 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39704 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39704] = 30
                                        mem[_39704 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40492 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40492 + 68] = mem[idx + _39704 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40492 + 68] = mem[_40492 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40492 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43678 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43678] = 30
                                        mem[_43678 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45602 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45602 + 68] = mem[idx + _43678 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45602 + 68] = mem[_45602 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45602 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53497 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53497] = 30
                                        mem[_53497 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54961 + 68] = mem[idx + _53497 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54961 + 68] = mem[_54961 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54961 + -mem[64] + 100
                                    _33314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33314] = 26
                                    mem[_33314 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35314 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35314] = 26
                                        mem[_35314 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _35315 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35315] = 26
                                        mem[_35315 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34179] = 26
                                            mem[_34179 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34179 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _39123 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39123] = 30
                                                    mem[_39123 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41597 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41597] = 30
                                                    mem[_41597 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _42849 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _42849 + 68] = mem[idx + _41597 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_42849 + 68] = mem[_42849 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _42849 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _50197 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_50197] = 30
                                                    mem[_50197 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _52555 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52555 + 68] = mem[idx + _50197 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52555 + 68] = mem[_52555 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52555 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39244 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39244] = 30
                                                mem[_39244 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _39696 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39696 + 68] = mem[idx + _39244 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39696 + 68] = mem[_39696 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39696 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42247 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42247] = 30
                                                mem[_42247 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43662 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43662 + 68] = mem[idx + _42247 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43662 + 68] = mem[_43662 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43662 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _51421 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51421] = 30
                                                mem[_51421 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53487 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53487 + 68] = mem[idx + _51421 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53487 + 68] = mem[_53487 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53487 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _39243 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39243] = 30
                                                mem[_39243 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39693 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39693 + 68] = mem[idx + _39243 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39693 + 68] = mem[_39693 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39693 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42246 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42246] = 30
                                                mem[_42246 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _43659 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43659 + 68] = mem[idx + _42246 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43659 + 68] = mem[_43659 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43659 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _51420 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51420] = 30
                                                mem[_51420 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53484 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53484 + 68] = mem[idx + _51420 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53484 + 68] = mem[_53484 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53484 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39374] = 30
                                            mem[_39374 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _40051 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40051 + 68] = mem[idx + _39374 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40051 + 68] = mem[_40051 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40051 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42848 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42848] = 30
                                            mem[_42848 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44633 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44633 + 68] = mem[idx + _42848 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44633 + 68] = mem[_44633 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44633 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52554 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52554] = 30
                                            mem[_52554 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54201 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54201 + 68] = mem[idx + _52554 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54201 + 68] = mem[_54201 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54201 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34413 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34413] = 30
                                            mem[_34413 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34946 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34946 + 68] = mem[idx + _34413 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34946 + 68] = mem[_34946 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34946 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36860 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36860] = 30
                                            mem[_36860 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37705 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37705 + 68] = mem[idx + _36860 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37705 + 68] = mem[_37705 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37705 + -mem[64] + 100
                                        _34677 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34677] = 26
                                        mem[_34677 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34677 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39377 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39377] = 30
                                                mem[_39377 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42858 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42858] = 30
                                                mem[_42858 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _44640 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44640 + 68] = mem[idx + _42858 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44640 + 68] = mem[_44640 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44640 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _52559 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52559] = 30
                                                mem[_52559 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _54206 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _54206 + 68] = mem[idx + _52559 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_54206 + 68] = mem[_54206 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _54206 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39700] = 30
                                            mem[_39700 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _40486 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40486 + 68] = mem[idx + _39700 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40486 + 68] = mem[_40486 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40486 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43668 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43668] = 30
                                            mem[_43668 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _45592 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45592 + 68] = mem[idx + _43668 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45592 + 68] = mem[_45592 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45592 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _53491 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53491] = 30
                                            mem[_53491 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54953 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54953 + 68] = mem[idx + _53491 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54953 + 68] = mem[_54953 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54953 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39699 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39699] = 30
                                            mem[_39699 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40483 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40483 + 68] = mem[idx + _39699 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40483 + 68] = mem[_40483 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40483 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43667 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43667] = 30
                                            mem[_43667 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _45589 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45589 + 68] = mem[idx + _43667 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45589 + 68] = mem[_45589 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45589 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _53490 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53490] = 30
                                            mem[_53490 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54950 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54950 + 68] = mem[idx + _53490 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54950 + 68] = mem[_54950 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54950 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _40054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40054] = 30
                                        mem[_40054 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40909 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40909 + 68] = mem[idx + _40054 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40909 + 68] = mem[_40909 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40909 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _44639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44639] = 30
                                        mem[_44639 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _46609 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _46609 + 68] = mem[idx + _44639 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_46609 + 68] = mem[_46609 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _46609 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _54205 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_54205] = 30
                                        mem[_54205 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55870 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55870 + 68] = mem[idx + _54205 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55870 + 68] = mem[_55870 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55870 + -mem[64] + 100
                                    _33309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33309] = 26
                                    mem[_33309 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35307] = 26
                                        mem[_35307 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _35308 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35308] = 26
                                        mem[_35308 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            else:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34194 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34194] = 26
                                            mem[_34194 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34194 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39126 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39126] = 30
                                                mem[_39126 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41628 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41628] = 30
                                                mem[_41628 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42877 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42877 + 68] = mem[idx + _41628 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42877 + 68] = mem[_42877 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42877 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45621 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45621] = 30
                                                mem[_45621 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _47855 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _47855 + 68] = mem[idx + _45621 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_47855 + 68] = mem[_47855 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _47855 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _57819 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57819] = 30
                                                mem[_57819 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _59749 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59749 + 68] = mem[idx + _57819 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59749 + 68] = mem[_59749 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59749 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39249 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39249] = 30
                                            mem[_39249 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39709 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39709 + 68] = mem[idx + _39249 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39709 + 68] = mem[_39709 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39709 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42262 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42262] = 30
                                            mem[_42262 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43695 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43695 + 68] = mem[idx + _42262 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43695 + 68] = mem[_43695 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43695 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46648] = 30
                                            mem[_46648 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _49020 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49020 + 68] = mem[idx + _46648 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49020 + 68] = mem[_49020 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49020 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _58725 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58725] = 30
                                            mem[_58725 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _60675 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60675 + 68] = mem[idx + _58725 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60675 + 68] = mem[_60675 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60675 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34422 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34422] = 30
                                            mem[_34422 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34958 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34958 + 68] = mem[idx + _34422 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34958 + 68] = mem[_34958 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34958 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36881 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36881] = 30
                                            mem[_36881 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37729 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37729 + 68] = mem[idx + _36881 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37729 + 68] = mem[_37729 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37729 + -mem[64] + 100
                                        _34692 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34692] = 26
                                        mem[_34692 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34692 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39380 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39380] = 30
                                            mem[_39380 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42882 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42882] = 30
                                            mem[_42882 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44676 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44676 + 68] = mem[idx + _42882 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44676 + 68] = mem[_44676 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44676 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _47861 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47861] = 30
                                            mem[_47861 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _50257 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50257 + 68] = mem[idx + _47861 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50257 + 68] = mem[_50257 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50257 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _59752 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59752] = 30
                                            mem[_59752 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _61491 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _61491 + 68] = mem[idx + _59752 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_61491 + 68] = mem[_61491 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _61491 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39712] = 30
                                        mem[_39712 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40504 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40504 + 68] = mem[idx + _39712 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40504 + 68] = mem[_40504 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40504 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _43698 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43698] = 30
                                        mem[_43698 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _45624 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45624 + 68] = mem[idx + _43698 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45624 + 68] = mem[_45624 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45624 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _49023 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49023] = 30
                                        mem[_49023 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _51468 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51468 + 68] = mem[idx + _49023 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51468 + 68] = mem[_51468 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51468 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _60678 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_60678] = 30
                                        mem[_60678 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _62313 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62313 + 68] = mem[idx + _60678 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62313 + 68] = mem[_62313 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62313 + -mem[64] + 100
                                    _33324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33324] = 26
                                    mem[_33324 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35328 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35328] = 26
                                        mem[_35328 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _35329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35329] = 26
                                        mem[_35329 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                else:
                                    if 0 / arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34189 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34189] = 26
                                            mem[_34189 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34189 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39125 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39125] = 30
                                                mem[_39125 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41618 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41618] = 30
                                                mem[_41618 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42869 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42869 + 68] = mem[idx + _41618 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42869 + 68] = mem[_42869 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42869 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45610] = 30
                                                mem[_45610 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _47839 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _47839 + 68] = mem[idx + _45610 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_47839 + 68] = mem[_47839 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _47839 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _57811 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57811] = 30
                                                mem[_57811 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _59739 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59739 + 68] = mem[idx + _57811 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59739 + 68] = mem[_59739 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59739 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39248 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39248] = 30
                                            mem[_39248 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39705 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39705 + 68] = mem[idx + _39248 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39705 + 68] = mem[_39705 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39705 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42258 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42258] = 30
                                            mem[_42258 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43685 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43685 + 68] = mem[idx + _42258 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43685 + 68] = mem[_43685 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43685 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46635 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46635] = 30
                                            mem[_46635 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _49007 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49007 + 68] = mem[idx + _46635 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49007 + 68] = mem[_49007 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49007 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _58719 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58719] = 30
                                            mem[_58719 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _60669 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60669 + 68] = mem[idx + _58719 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60669 + 68] = mem[_60669 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60669 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34419 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34419] = 30
                                            mem[_34419 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34954 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34954 + 68] = mem[idx + _34419 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34954 + 68] = mem[_34954 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34954 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36874] = 30
                                            mem[_36874 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37721 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37721 + 68] = mem[idx + _36874 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37721 + 68] = mem[_37721 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37721 + -mem[64] + 100
                                        _34687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34687] = 26
                                        mem[_34687 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34687 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39379 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39379] = 30
                                            mem[_39379 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42874] = 30
                                            mem[_42874 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44664 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44664 + 68] = mem[idx + _42874 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44664 + 68] = mem[_44664 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44664 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _47845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47845] = 30
                                            mem[_47845 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _50238 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50238 + 68] = mem[idx + _47845 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50238 + 68] = mem[_50238 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50238 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _59742 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59742] = 30
                                            mem[_59742 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _61485 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _61485 + 68] = mem[idx + _59742 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_61485 + 68] = mem[_61485 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _61485 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39708 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39708] = 30
                                        mem[_39708 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40498 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40498 + 68] = mem[idx + _39708 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40498 + 68] = mem[_40498 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40498 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _43688 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43688] = 30
                                        mem[_43688 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _45613 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45613 + 68] = mem[idx + _43688 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45613 + 68] = mem[_45613 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45613 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _49010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49010] = 30
                                        mem[_49010 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _51452 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51452 + 68] = mem[idx + _49010 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51452 + 68] = mem[_51452 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51452 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _60672 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_60672] = 30
                                        mem[_60672 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _62305 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62305 + 68] = mem[idx + _60672 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62305 + 68] = mem[_62305 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62305 + -mem[64] + 100
                                    _33319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33319] = 26
                                    mem[_33319 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35321 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35321] = 26
                                        mem[_35321 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _35322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35322] = 26
                                        mem[_35322 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
            else:
                mem[0] = arg1
                mem[32] = 206
                if stor206[address(arg1)]:
                    if not arg2:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero' << 48
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _34284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34284] = 26
                                mem[_34284 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34284 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _39158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39158] = 30
                                    mem[_39158 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41885] = 30
                                    mem[_41885 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43070 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43070 + 68] = mem[idx + _41885 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43070 + 68] = mem[_43070 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43070 + -mem[64] + 100
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _53763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53763] = 30
                                    mem[_53763 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _55220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55220 + 68] = mem[idx + _53763 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55220 + 68] = mem[_55220 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55220 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39288] = 30
                                mem[_39288 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39837 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39837 + 68] = mem[idx + _39288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39837 + 68] = mem[_39837 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39837 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42418 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42418] = 30
                                mem[_42418 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43959 + 68] = mem[idx + _42418 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43959 + 68] = mem[_43959 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43959 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _54419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54419] = 30
                                mem[_54419 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _56186 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _56186 + 68] = mem[idx + _54419 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_56186 + 68] = mem[_56186 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _56186 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _34476 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34476] = 30
                                mem[_34476 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _35030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35030 + 68] = mem[idx + _34476 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35030 + 68] = mem[_35030 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35030 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _37007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37007] = 30
                                mem[_37007 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _37873 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _37873 + 68] = mem[idx + _37007 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37873 + 68] = mem[_37873 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37873 + -mem[64] + 100
                            _34782 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34782] = 26
                            mem[_34782 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34782 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _39419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39419] = 30
                                mem[_39419 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43075] = 30
                                mem[_43075 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _44976 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44976 + 68] = mem[idx + _43075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44976 + 68] = mem[_44976 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44976 + -mem[64] + 100
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                _55223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_55223] = 30
                                mem[_55223 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                    return 1
                                _57190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _57190 + 68] = mem[idx + _55223 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_57190 + 68] = mem[_57190 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _57190 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _39840 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39840] = 30
                            mem[_39840 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _40654 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _40654 + 68] = mem[idx + _39840 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40654 + 68] = mem[_40654 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40654 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _43962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43962] = 30
                            mem[_43962 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _45892 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45892 + 68] = mem[idx + _43962 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45892 + 68] = mem[_45892 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45892 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                            _56189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_56189] = 30
                            mem[_56189 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                                return 1
                            _58078 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _58078 + 68] = mem[idx + _56189 + 32]
                                idx = idx + 32
                                continue 
                            mem[_58078 + 68] = mem[_58078 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _58078 + -mem[64] + 100
                        _33414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33414] = 26
                        mem[_33414 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _35454 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35454] = 26
                            mem[_35454 + 32] = 'SafeMath: division by zero' << 48
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += t / s * arg2
                        else:
                            _35455 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35455] = 26
                            mem[_35455 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit 0x64ddf252: arg2, msg.sender, arg1
                    else:
                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero' << 48
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if _tFeePercent * arg2 / 10000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _34279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34279] = 26
                                mem[_34279 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _34279 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _39157 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39157] = 30
                                        mem[_39157 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41874] = 30
                                        mem[_41874 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43058 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43058 + 68] = mem[idx + _41874 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43058 + 68] = mem[_43058 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43058 + -mem[64] + 100
                                        if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _53753 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53753] = 30
                                        mem[_53753 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55209 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55209 + 68] = mem[idx + _53753 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55209 + 68] = mem[_55209 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55209 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39285 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39285] = 30
                                    mem[_39285 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _39832 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39832 + 68] = mem[idx + _39285 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39832 + 68] = mem[_39832 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39832 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42411] = 30
                                    mem[_42411 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43946 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43946 + 68] = mem[idx + _42411 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43946 + 68] = mem[_43946 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43946 + -mem[64] + 100
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    _54410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54410] = 30
                                    mem[_54410 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _56179 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _56179 + 68] = mem[idx + _54410 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_56179 + 68] = mem[_56179 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _56179 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _39284 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39284] = 30
                                    mem[_39284 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39829 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39829 + 68] = mem[idx + _39284 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39829 + 68] = mem[_39829 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39829 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42410] = 30
                                    mem[_42410 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43943 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43943 + 68] = mem[idx + _42410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43943 + 68] = mem[_43943 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43943 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _54409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54409] = 30
                                    mem[_54409 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _56176 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _56176 + 68] = mem[idx + _54409 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_56176 + 68] = mem[_56176 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _56176 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39415 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39415] = 30
                                mem[_39415 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _40147 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40147 + 68] = mem[idx + _39415 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40147 + 68] = mem[_40147 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40147 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43057 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43057] = 30
                                mem[_43057 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44957 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44957 + 68] = mem[idx + _43057 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44957 + 68] = mem[_44957 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44957 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                _55208 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_55208] = 30
                                mem[_55208 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _57179 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _57179 + 68] = mem[idx + _55208 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_57179 + 68] = mem[_57179 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _57179 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _34473 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34473] = 30
                                mem[_34473 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _35026 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35026 + 68] = mem[idx + _34473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35026 + 68] = mem[_35026 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35026 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _37000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37000] = 30
                                mem[_37000 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _37865 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _37865 + 68] = mem[idx + _37000 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37865 + 68] = mem[_37865 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37865 + -mem[64] + 100
                            _34777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34777] = 26
                            mem[_34777 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _34777 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _39418 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39418] = 30
                                    mem[_39418 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43067] = 30
                                    mem[_43067 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44964 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44964 + 68] = mem[idx + _43067 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44964 + 68] = mem[_44964 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44964 + -mem[64] + 100
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _55213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_55213] = 30
                                    mem[_55213 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _57184 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _57184 + 68] = mem[idx + _55213 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_57184 + 68] = mem[_57184 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _57184 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _39836 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39836] = 30
                                mem[_39836 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _40648 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40648 + 68] = mem[idx + _39836 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40648 + 68] = mem[_40648 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40648 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43952 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43952] = 30
                                mem[_43952 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _45882 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45882 + 68] = mem[idx + _43952 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45882 + 68] = mem[_45882 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45882 + -mem[64] + 100
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                _56183 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_56183] = 30
                                mem[_56183 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _58070 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _58070 + 68] = mem[idx + _56183 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_58070 + 68] = mem[_58070 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _58070 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _39835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39835] = 30
                                mem[_39835 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _40645 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _40645 + 68] = mem[idx + _39835 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40645 + 68] = mem[_40645 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40645 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43951 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43951] = 30
                                mem[_43951 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45879 + 68] = mem[idx + _43951 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45879 + 68] = mem[_45879 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45879 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _56182 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_56182] = 30
                                mem[_56182 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                    return 1
                                _58067 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _58067 + 68] = mem[idx + _56182 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_58067 + 68] = mem[_58067 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _58067 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _40150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_40150] = 30
                            mem[_40150 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _41025 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _41025 + 68] = mem[idx + _40150 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_41025 + 68] = mem[_41025 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _41025 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _44963 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_44963] = 30
                            mem[_44963 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _46953 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _46953 + 68] = mem[idx + _44963 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_46953 + 68] = mem[_46953 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _46953 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                            _57183 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_57183] = 30
                            mem[_57183 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                return 1
                            _58989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _58989 + 68] = mem[idx + _57183 + 32]
                                idx = idx + 32
                                continue 
                            mem[_58989 + 68] = mem[_58989 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _58989 + -mem[64] + 100
                        _33409 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33409] = 26
                        mem[_33409 + 32] = 'SafeMath: division by zero' << 48
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _35447 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35447] = 26
                            mem[_35447 + 32] = 'SafeMath: division by zero' << 48
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += -1 * t / s * _tFeePercent * arg2 / 10000
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += t / s * arg2
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            _35448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35448] = 26
                            mem[_35448 + 32] = 'SafeMath: division by zero' << 48
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                else:
                    if stor206[address(msg.sender)]:
                        mem[0] = msg.sender
                        mem[32] = 206
                        if not stor206[address(msg.sender)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34214 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34214] = 26
                                        mem[_34214 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34214 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39134 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39134] = 30
                                            mem[_39134 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41690] = 30
                                            mem[_41690 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42923 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42923 + 68] = mem[idx + _41690 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42923 + 68] = mem[_42923 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42923 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50339 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50339] = 30
                                            mem[_50339 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52672 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52672 + 68] = mem[idx + _50339 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52672 + 68] = mem[_52672 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52672 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39259 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39259] = 30
                                        mem[_39259 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39741 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39741 + 68] = mem[idx + _39259 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39741 + 68] = mem[_39741 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39741 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42302 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42302] = 30
                                        mem[_42302 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43759 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43759 + 68] = mem[idx + _42302 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43759 + 68] = mem[_43759 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43759 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51547 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51547] = 30
                                        mem[_51547 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53574 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53574 + 68] = mem[idx + _51547 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53574 + 68] = mem[_53574 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53574 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34434] = 30
                                        mem[_34434 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34974 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34974 + 68] = mem[idx + _34434 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34974 + 68] = mem[_34974 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34974 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36909 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36909] = 30
                                        mem[_36909 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37761 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37761 + 68] = mem[idx + _36909 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37761 + 68] = mem[_37761 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37761 + -mem[64] + 100
                                    _34712 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34712] = 26
                                    mem[_34712 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34712 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39390 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39390] = 30
                                        mem[_39390 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42928 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42928] = 30
                                        mem[_42928 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44748 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44748 + 68] = mem[idx + _42928 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44748 + 68] = mem[_44748 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44748 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52675 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52675] = 30
                                        mem[_52675 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54274 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54274 + 68] = mem[idx + _52675 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54274 + 68] = mem[_54274 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54274 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39744 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39744] = 30
                                    mem[_39744 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40540 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40540 + 68] = mem[idx + _39744 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40540 + 68] = mem[_40540 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40540 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43762 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43762] = 30
                                    mem[_43762 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45688 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45688 + 68] = mem[idx + _43762 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45688 + 68] = mem[_45688 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45688 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53577] = 30
                                    mem[_53577 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _55039 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55039 + 68] = mem[idx + _53577 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55039 + 68] = mem[_55039 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55039 + -mem[64] + 100
                                _33344 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33344] = 26
                                mem[_33344 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35356 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35356] = 26
                                    mem[_35356 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35357] = 26
                                    mem[_35357 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34209 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34209] = 26
                                        mem[_34209 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34209 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39133 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39133] = 30
                                                mem[_39133 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41679 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41679] = 30
                                                mem[_41679 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42911 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42911 + 68] = mem[idx + _41679 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42911 + 68] = mem[_42911 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42911 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50319 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50319] = 30
                                                mem[_50319 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52659 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52659 + 68] = mem[idx + _50319 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52659 + 68] = mem[_52659 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52659 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39256 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39256] = 30
                                            mem[_39256 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39736 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39736 + 68] = mem[idx + _39256 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39736 + 68] = mem[_39736 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39736 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42295] = 30
                                            mem[_42295 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43746 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43746 + 68] = mem[idx + _42295 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43746 + 68] = mem[_43746 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43746 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51531] = 30
                                            mem[_51531 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53567 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53567 + 68] = mem[idx + _51531 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53567 + 68] = mem[_53567 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53567 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39255 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39255] = 30
                                            mem[_39255 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39733 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39733 + 68] = mem[idx + _39255 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39733 + 68] = mem[_39733 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39733 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42294 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42294] = 30
                                            mem[_42294 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43743 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43743 + 68] = mem[idx + _42294 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43743 + 68] = mem[_43743 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43743 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51530 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51530] = 30
                                            mem[_51530 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53564 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53564 + 68] = mem[idx + _51530 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53564 + 68] = mem[_53564 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53564 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39386] = 30
                                        mem[_39386 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40079 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40079 + 68] = mem[idx + _39386 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40079 + 68] = mem[_40079 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40079 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42910] = 30
                                        mem[_42910 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44729 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44729 + 68] = mem[idx + _42910 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44729 + 68] = mem[_44729 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44729 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52658 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52658] = 30
                                        mem[_52658 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54263 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54263 + 68] = mem[idx + _52658 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54263 + 68] = mem[_54263 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54263 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34431 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34431] = 30
                                        mem[_34431 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _34970 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _34970 + 68] = mem[idx + _34431 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34970 + 68] = mem[_34970 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _34970 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36902] = 30
                                        mem[_36902 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37753 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37753 + 68] = mem[idx + _36902 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37753 + 68] = mem[_37753 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37753 + -mem[64] + 100
                                    _34707 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34707] = 26
                                    mem[_34707 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34707 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39389 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39389] = 30
                                            mem[_39389 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42920] = 30
                                            mem[_42920 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44736 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44736 + 68] = mem[idx + _42920 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44736 + 68] = mem[_44736 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44736 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52663 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52663] = 30
                                            mem[_52663 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54268 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54268 + 68] = mem[idx + _52663 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54268 + 68] = mem[_54268 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54268 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39740 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39740] = 30
                                        mem[_39740 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40534 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40534 + 68] = mem[idx + _39740 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40534 + 68] = mem[_40534 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40534 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43752 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43752] = 30
                                        mem[_43752 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45678 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45678 + 68] = mem[idx + _43752 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45678 + 68] = mem[_45678 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45678 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53571 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53571] = 30
                                        mem[_53571 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55031 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55031 + 68] = mem[idx + _53571 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55031 + 68] = mem[_55031 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55031 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39739] = 30
                                        mem[_39739 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40531 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40531 + 68] = mem[idx + _39739 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40531 + 68] = mem[_40531 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40531 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43751] = 30
                                        mem[_43751 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45675 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45675 + 68] = mem[idx + _43751 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45675 + 68] = mem[_45675 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45675 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53570 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53570] = 30
                                        mem[_53570 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55028 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55028 + 68] = mem[idx + _53570 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55028 + 68] = mem[_55028 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55028 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _40082 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40082] = 30
                                    mem[_40082 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _40943 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40943 + 68] = mem[idx + _40082 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40943 + 68] = mem[_40943 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40943 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44735 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44735] = 30
                                    mem[_44735 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46711 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46711 + 68] = mem[idx + _44735 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46711 + 68] = mem[_46711 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46711 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _54267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54267] = 30
                                    mem[_54267 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _55964 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55964 + 68] = mem[idx + _54267 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55964 + 68] = mem[_55964 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55964 + -mem[64] + 100
                                _33339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33339] = 26
                                mem[_33339 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35349] = 26
                                    mem[_35349 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35350] = 26
                                    mem[_35350 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            mem[0] = arg1
                            mem[32] = 206
                            if not stor206[address(arg1)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34224 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34224] = 26
                                            mem[_34224 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34224 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39138 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39138] = 30
                                                mem[_39138 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41721 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41721] = 30
                                                mem[_41721 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42946 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42946 + 68] = mem[idx + _41721 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42946 + 68] = mem[_42946 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42946 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50381 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50381] = 30
                                                mem[_50381 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _52708 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52708 + 68] = mem[idx + _50381 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52708 + 68] = mem[_52708 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52708 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39264 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39264] = 30
                                            mem[_39264 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39757 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39757 + 68] = mem[idx + _39264 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39757 + 68] = mem[_39757 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39757 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42322 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42322] = 30
                                            mem[_42322 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43791 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43791 + 68] = mem[idx + _42322 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43791 + 68] = mem[_43791 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43791 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51586 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51586] = 30
                                            mem[_51586 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _53598 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53598 + 68] = mem[idx + _51586 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53598 + 68] = mem[_53598 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53598 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34440 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34440] = 30
                                            mem[_34440 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34982 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34982 + 68] = mem[idx + _34440 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34982 + 68] = mem[_34982 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34982 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36923 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36923] = 30
                                            mem[_36923 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37777 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37777 + 68] = mem[idx + _36923 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37777 + 68] = mem[_37777 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37777 + -mem[64] + 100
                                        _34722 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34722] = 26
                                        mem[_34722 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34722 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39395 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39395] = 30
                                            mem[_39395 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42951] = 30
                                            mem[_42951 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44784 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44784 + 68] = mem[idx + _42951 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44784 + 68] = mem[_44784 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44784 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52711 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52711] = 30
                                            mem[_52711 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _54292 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54292 + 68] = mem[idx + _52711 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54292 + 68] = mem[_54292 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54292 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39760 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39760] = 30
                                        mem[_39760 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40558 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40558 + 68] = mem[idx + _39760 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40558 + 68] = mem[_40558 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40558 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43794 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43794] = 30
                                        mem[_43794 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45720 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45720 + 68] = mem[idx + _43794 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45720 + 68] = mem[_45720 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45720 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53601 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53601] = 30
                                        mem[_53601 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _55061 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55061 + 68] = mem[idx + _53601 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55061 + 68] = mem[_55061 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55061 + -mem[64] + 100
                                    _33354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33354] = 26
                                    mem[_33354 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35370] = 26
                                        mem[_35370 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _35371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35371] = 26
                                        mem[_35371 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34219 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34219] = 26
                                            mem[_34219 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34219 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _39137 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39137] = 30
                                                    mem[_39137 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41710 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41710] = 30
                                                    mem[_41710 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _42934 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _42934 + 68] = mem[idx + _41710 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_42934 + 68] = mem[_42934 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _42934 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _50361 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_50361] = 30
                                                    mem[_50361 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _52695 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52695 + 68] = mem[idx + _50361 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52695 + 68] = mem[_52695 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52695 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39261 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39261] = 30
                                                mem[_39261 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _39752 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39752 + 68] = mem[idx + _39261 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39752 + 68] = mem[_39752 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39752 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42315 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42315] = 30
                                                mem[_42315 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43778 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43778 + 68] = mem[idx + _42315 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43778 + 68] = mem[_43778 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43778 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _51570 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51570] = 30
                                                mem[_51570 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53591 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53591 + 68] = mem[idx + _51570 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53591 + 68] = mem[_53591 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53591 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _39260 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39260] = 30
                                                mem[_39260 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39749 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39749 + 68] = mem[idx + _39260 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39749 + 68] = mem[_39749 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39749 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42314 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42314] = 30
                                                mem[_42314 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _43775 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43775 + 68] = mem[idx + _42314 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43775 + 68] = mem[_43775 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43775 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _51569 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51569] = 30
                                                mem[_51569 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53588 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53588 + 68] = mem[idx + _51569 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53588 + 68] = mem[_53588 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53588 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39391 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39391] = 30
                                            mem[_39391 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _40091 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40091 + 68] = mem[idx + _39391 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40091 + 68] = mem[_40091 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40091 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42933 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42933] = 30
                                            mem[_42933 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44765 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44765 + 68] = mem[idx + _42933 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44765 + 68] = mem[_44765 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44765 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52694 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52694] = 30
                                            mem[_52694 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54281 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54281 + 68] = mem[idx + _52694 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54281 + 68] = mem[_54281 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54281 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34437 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34437] = 30
                                            mem[_34437 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34978 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34978 + 68] = mem[idx + _34437 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34978 + 68] = mem[_34978 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34978 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36916 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36916] = 30
                                            mem[_36916 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37769 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37769 + 68] = mem[idx + _36916 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37769 + 68] = mem[_37769 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37769 + -mem[64] + 100
                                        _34717 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34717] = 26
                                        mem[_34717 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34717 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39394 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39394] = 30
                                                mem[_39394 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42943 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42943] = 30
                                                mem[_42943 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _44772 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44772 + 68] = mem[idx + _42943 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44772 + 68] = mem[_44772 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44772 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _52699 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52699] = 30
                                                mem[_52699 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _54286 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _54286 + 68] = mem[idx + _52699 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_54286 + 68] = mem[_54286 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _54286 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39756 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39756] = 30
                                            mem[_39756 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _40552 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40552 + 68] = mem[idx + _39756 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40552 + 68] = mem[_40552 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40552 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43784 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43784] = 30
                                            mem[_43784 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _45710 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45710 + 68] = mem[idx + _43784 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45710 + 68] = mem[_45710 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45710 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _53595 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53595] = 30
                                            mem[_53595 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _55053 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _55053 + 68] = mem[idx + _53595 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55053 + 68] = mem[_55053 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55053 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39755] = 30
                                            mem[_39755 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40549 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40549 + 68] = mem[idx + _39755 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40549 + 68] = mem[_40549 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40549 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43783 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43783] = 30
                                            mem[_43783 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _45707 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45707 + 68] = mem[idx + _43783 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45707 + 68] = mem[_45707 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45707 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _53594 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53594] = 30
                                            mem[_53594 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _55050 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _55050 + 68] = mem[idx + _53594 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55050 + 68] = mem[_55050 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55050 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _40094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40094] = 30
                                        mem[_40094 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40957 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40957 + 68] = mem[idx + _40094 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40957 + 68] = mem[_40957 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40957 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _44771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44771] = 30
                                        mem[_44771 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _46749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _46749 + 68] = mem[idx + _44771 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_46749 + 68] = mem[_46749 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _46749 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _54285 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_54285] = 30
                                        mem[_54285 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55996 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55996 + 68] = mem[idx + _54285 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55996 + 68] = mem[_55996 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55996 + -mem[64] + 100
                                    _33349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33349] = 26
                                    mem[_33349 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35363 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35363] = 26
                                        mem[_35363 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _35364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35364] = 26
                                        mem[_35364 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            else:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34234 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34234] = 26
                                            mem[_34234 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34234 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39140 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39140] = 30
                                                mem[_39140 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41741 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41741] = 30
                                                mem[_41741 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42962 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42962 + 68] = mem[idx + _41741 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42962 + 68] = mem[_42962 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42962 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45739 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45739] = 30
                                                mem[_45739 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _48019 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _48019 + 68] = mem[idx + _45739 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48019 + 68] = mem[_48019 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48019 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _57937 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57937] = 30
                                                mem[_57937 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _59892 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59892 + 68] = mem[idx + _57937 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59892 + 68] = mem[_59892 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59892 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39266 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39266] = 30
                                            mem[_39266 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39765 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39765 + 68] = mem[idx + _39266 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39765 + 68] = mem[_39765 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39765 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42330 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42330] = 30
                                            mem[_42330 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43811 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43811 + 68] = mem[idx + _42330 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43811 + 68] = mem[_43811 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43811 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46788 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46788] = 30
                                            mem[_46788 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _49163 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49163 + 68] = mem[idx + _46788 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49163 + 68] = mem[_49163 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49163 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _58848 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58848] = 30
                                            mem[_58848 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _60789 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60789 + 68] = mem[idx + _58848 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60789 + 68] = mem[_60789 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60789 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34446 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34446] = 30
                                            mem[_34446 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34990 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34990 + 68] = mem[idx + _34446 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34990 + 68] = mem[_34990 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34990 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36937 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36937] = 30
                                            mem[_36937 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37793 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37793 + 68] = mem[idx + _36937 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37793 + 68] = mem[_37793 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37793 + -mem[64] + 100
                                        _34732 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34732] = 26
                                        mem[_34732 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34732 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39397] = 30
                                            mem[_39397 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42967 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42967] = 30
                                            mem[_42967 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44808 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44808 + 68] = mem[idx + _42967 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44808 + 68] = mem[_44808 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44808 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _48025 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48025] = 30
                                            mem[_48025 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _50421 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50421 + 68] = mem[idx + _48025 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50421 + 68] = mem[_50421 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50421 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _59895 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59895] = 30
                                            mem[_59895 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _61589 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _61589 + 68] = mem[idx + _59895 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_61589 + 68] = mem[_61589 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _61589 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39768 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39768] = 30
                                        mem[_39768 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40570 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40570 + 68] = mem[idx + _39768 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40570 + 68] = mem[_40570 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40570 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _43814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43814] = 30
                                        mem[_43814 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _45742 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45742 + 68] = mem[idx + _43814 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45742 + 68] = mem[_45742 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45742 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _49166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49166] = 30
                                        mem[_49166 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _51617 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51617 + 68] = mem[idx + _49166 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51617 + 68] = mem[_51617 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51617 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _60792 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_60792] = 30
                                        mem[_60792 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _62417 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62417 + 68] = mem[idx + _60792 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62417 + 68] = mem[_62417 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62417 + -mem[64] + 100
                                    _33364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33364] = 26
                                    mem[_33364 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35384] = 26
                                        mem[_35384 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _35385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35385] = 26
                                        mem[_35385 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                else:
                                    if 0 / arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34229 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34229] = 26
                                            mem[_34229 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34229 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39139 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39139] = 30
                                                mem[_39139 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41731 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41731] = 30
                                                mem[_41731 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42954 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42954 + 68] = mem[idx + _41731 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42954 + 68] = mem[_42954 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42954 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45728 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45728] = 30
                                                mem[_45728 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _48003 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _48003 + 68] = mem[idx + _45728 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48003 + 68] = mem[_48003 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48003 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _57929 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57929] = 30
                                                mem[_57929 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _59882 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59882 + 68] = mem[idx + _57929 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59882 + 68] = mem[_59882 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59882 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39265 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39265] = 30
                                            mem[_39265 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39761 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39761 + 68] = mem[idx + _39265 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39761 + 68] = mem[_39761 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39761 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42326 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42326] = 30
                                            mem[_42326 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43801 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43801 + 68] = mem[idx + _42326 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43801 + 68] = mem[_43801 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43801 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46775 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46775] = 30
                                            mem[_46775 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _49150 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49150 + 68] = mem[idx + _46775 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49150 + 68] = mem[_49150 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49150 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _58842 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58842] = 30
                                            mem[_58842 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _60783 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60783 + 68] = mem[idx + _58842 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60783 + 68] = mem[_60783 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60783 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34443 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34443] = 30
                                            mem[_34443 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34986 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34986 + 68] = mem[idx + _34443 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34986 + 68] = mem[_34986 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34986 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36930 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36930] = 30
                                            mem[_36930 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37785 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37785 + 68] = mem[idx + _36930 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37785 + 68] = mem[_37785 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37785 + -mem[64] + 100
                                        _34727 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34727] = 26
                                        mem[_34727 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34727 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39396 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39396] = 30
                                            mem[_39396 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42959 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42959] = 30
                                            mem[_42959 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44796 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44796 + 68] = mem[idx + _42959 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44796 + 68] = mem[_44796 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44796 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _48009 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48009] = 30
                                            mem[_48009 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _50402 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50402 + 68] = mem[idx + _48009 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50402 + 68] = mem[_50402 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50402 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _59885 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59885] = 30
                                            mem[_59885 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _61583 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _61583 + 68] = mem[idx + _59885 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_61583 + 68] = mem[_61583 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _61583 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39764 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39764] = 30
                                        mem[_39764 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40564 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40564 + 68] = mem[idx + _39764 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40564 + 68] = mem[_40564 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40564 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _43804 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43804] = 30
                                        mem[_43804 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _45731 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45731 + 68] = mem[idx + _43804 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45731 + 68] = mem[_45731 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45731 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _49153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49153] = 30
                                        mem[_49153 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _51601 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51601 + 68] = mem[idx + _49153 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51601 + 68] = mem[_51601 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51601 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _60786 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_60786] = 30
                                        mem[_60786 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _62409 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62409 + 68] = mem[idx + _60786 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62409 + 68] = mem[_62409 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62409 + -mem[64] + 100
                                    _33359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33359] = 26
                                    mem[_33359 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35377 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35377] = 26
                                        mem[_35377 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _35378 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35378] = 26
                                        mem[_35378 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34274] = 26
                                        mem[_34274 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34274 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39154 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39154] = 30
                                            mem[_39154 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41854] = 30
                                            mem[_41854 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43047 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43047 + 68] = mem[idx + _41854 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43047 + 68] = mem[_43047 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43047 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50583 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50583] = 30
                                            mem[_50583 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _52880 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52880 + 68] = mem[idx + _50583 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52880 + 68] = mem[_52880 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52880 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39283 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39283] = 30
                                        mem[_39283 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39821 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39821 + 68] = mem[idx + _39283 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39821 + 68] = mem[_39821 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39821 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42398 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42398] = 30
                                        mem[_42398 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43927 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43927 + 68] = mem[idx + _42398 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43927 + 68] = mem[_43927 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43927 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51767 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51767] = 30
                                        mem[_51767 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _53734 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53734 + 68] = mem[idx + _51767 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53734 + 68] = mem[_53734 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53734 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34470 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34470] = 30
                                        mem[_34470 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _35022 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _35022 + 68] = mem[idx + _34470 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35022 + 68] = mem[_35022 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35022 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36993 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36993] = 30
                                        mem[_36993 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37857 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37857 + 68] = mem[idx + _36993 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37857 + 68] = mem[_37857 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37857 + -mem[64] + 100
                                    _34772 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34772] = 26
                                    mem[_34772 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34772 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _39414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39414] = 30
                                        mem[_39414 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43052 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43052] = 30
                                        mem[_43052 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44940 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44940 + 68] = mem[idx + _43052 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44940 + 68] = mem[_44940 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44940 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _52883 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52883] = 30
                                        mem[_52883 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _54398 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54398 + 68] = mem[idx + _52883 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54398 + 68] = mem[_54398 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54398 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39824 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39824] = 30
                                    mem[_39824 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _40636 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _40636 + 68] = mem[idx + _39824 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40636 + 68] = mem[_40636 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40636 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43930] = 30
                                    mem[_43930 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45860 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45860 + 68] = mem[idx + _43930 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45860 + 68] = mem[_45860 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45860 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _53737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53737] = 30
                                    mem[_53737 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                        return 1
                                    _55195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55195 + 68] = mem[idx + _53737 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55195 + 68] = mem[_55195 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55195 + -mem[64] + 100
                                _33404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33404] = 26
                                mem[_33404 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35440] = 26
                                    mem[_35440 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _35441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35441] = 26
                                    mem[_35441 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit 0x64ddf252: arg2, msg.sender, arg1
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero' << 48
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _34269 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34269] = 26
                                        mem[_34269 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34269 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39153 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39153] = 30
                                                mem[_39153 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41843 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41843] = 30
                                                mem[_41843 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43035 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43035 + 68] = mem[idx + _41843 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43035 + 68] = mem[_43035 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43035 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50563 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50563] = 30
                                                mem[_50563 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _52867 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52867 + 68] = mem[idx + _50563 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52867 + 68] = mem[_52867 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52867 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39280 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39280] = 30
                                            mem[_39280 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39816 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39816 + 68] = mem[idx + _39280 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39816 + 68] = mem[_39816 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39816 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42391 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42391] = 30
                                            mem[_42391 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43914 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43914 + 68] = mem[idx + _42391 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43914 + 68] = mem[_43914 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43914 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51751 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51751] = 30
                                            mem[_51751 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53727 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53727 + 68] = mem[idx + _51751 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53727 + 68] = mem[_53727 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53727 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39279 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39279] = 30
                                            mem[_39279 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39813 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39813 + 68] = mem[idx + _39279 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39813 + 68] = mem[_39813 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39813 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42390 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42390] = 30
                                            mem[_42390 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43911 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43911 + 68] = mem[idx + _42390 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43911 + 68] = mem[_43911 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43911 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51750 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51750] = 30
                                            mem[_51750 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _53724 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53724 + 68] = mem[idx + _51750 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53724 + 68] = mem[_53724 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53724 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39410] = 30
                                        mem[_39410 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40135 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40135 + 68] = mem[idx + _39410 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40135 + 68] = mem[_40135 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40135 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43034] = 30
                                        mem[_43034 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44921 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44921 + 68] = mem[idx + _43034 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44921 + 68] = mem[_44921 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44921 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52866 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52866] = 30
                                        mem[_52866 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _54387 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54387 + 68] = mem[idx + _52866 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54387 + 68] = mem[_54387 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54387 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _34467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34467] = 30
                                        mem[_34467 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _35018 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _35018 + 68] = mem[idx + _34467 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35018 + 68] = mem[_35018 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35018 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _36986 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36986] = 30
                                        mem[_36986 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _37849 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _37849 + 68] = mem[idx + _36986 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37849 + 68] = mem[_37849 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37849 + -mem[64] + 100
                                    _34767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34767] = 26
                                    mem[_34767 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _34767 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _39413 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39413] = 30
                                            mem[_39413 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43044 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43044] = 30
                                            mem[_43044 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44928 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44928 + 68] = mem[idx + _43044 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44928 + 68] = mem[_44928 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44928 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52871 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52871] = 30
                                            mem[_52871 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54392 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54392 + 68] = mem[idx + _52871 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54392 + 68] = mem[_54392 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54392 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39820 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39820] = 30
                                        mem[_39820 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _40630 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40630 + 68] = mem[idx + _39820 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40630 + 68] = mem[_40630 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40630 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43920 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43920] = 30
                                        mem[_43920 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45850 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45850 + 68] = mem[idx + _43920 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45850 + 68] = mem[_45850 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45850 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _53731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53731] = 30
                                        mem[_53731 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55187 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55187 + 68] = mem[idx + _53731 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55187 + 68] = mem[_55187 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55187 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _39819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39819] = 30
                                        mem[_39819 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40627 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40627 + 68] = mem[idx + _39819 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40627 + 68] = mem[_40627 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40627 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43919] = 30
                                        mem[_43919 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45847 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45847 + 68] = mem[idx + _43919 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45847 + 68] = mem[_45847 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45847 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53730 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53730] = 30
                                        mem[_53730 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _55184 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55184 + 68] = mem[idx + _53730 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55184 + 68] = mem[_55184 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55184 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _40138 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40138] = 30
                                    mem[_40138 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _41011 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41011 + 68] = mem[idx + _40138 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41011 + 68] = mem[_41011 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41011 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _44927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44927] = 30
                                    mem[_44927 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _46915 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _46915 + 68] = mem[idx + _44927 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_46915 + 68] = mem[_46915 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _46915 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _54391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_54391] = 30
                                    mem[_54391 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                        return 1
                                    _56152 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _56152 + 68] = mem[idx + _54391 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_56152 + 68] = mem[_56152 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _56152 + -mem[64] + 100
                                _33399 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33399] = 26
                                mem[_33399 + 32] = 'SafeMath: division by zero' << 48
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _35433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35433] = 26
                                    mem[_35433 + 32] = 'SafeMath: division by zero' << 48
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _35434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35434] = 26
                                    mem[_35434 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                        else:
                            mem[0] = msg.sender
                            mem[32] = 206
                            if not stor206[address(msg.sender)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34244 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34244] = 26
                                            mem[_34244 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34244 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39144 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39144] = 30
                                                mem[_39144 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41772 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41772] = 30
                                                mem[_41772 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42985 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42985 + 68] = mem[idx + _41772 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42985 + 68] = mem[_42985 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42985 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50461 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50461] = 30
                                                mem[_50461 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _52776 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52776 + 68] = mem[idx + _50461 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52776 + 68] = mem[_52776 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52776 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39271 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39271] = 30
                                            mem[_39271 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39781 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39781 + 68] = mem[idx + _39271 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39781 + 68] = mem[_39781 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39781 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42350 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42350] = 30
                                            mem[_42350 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43843 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43843 + 68] = mem[idx + _42350 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43843 + 68] = mem[_43843 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43843 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51657 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51657] = 30
                                            mem[_51657 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _53654 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53654 + 68] = mem[idx + _51657 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53654 + 68] = mem[_53654 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53654 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34452 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34452] = 30
                                            mem[_34452 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34998 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34998 + 68] = mem[idx + _34452 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34998 + 68] = mem[_34998 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34998 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36951] = 30
                                            mem[_36951 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37809 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37809 + 68] = mem[idx + _36951 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37809 + 68] = mem[_37809 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37809 + -mem[64] + 100
                                        _34742 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34742] = 26
                                        mem[_34742 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34742 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _39402 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39402] = 30
                                            mem[_39402 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42990 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42990] = 30
                                            mem[_42990 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44844 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44844 + 68] = mem[idx + _42990 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44844 + 68] = mem[_44844 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44844 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _52779 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52779] = 30
                                            mem[_52779 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _54336 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54336 + 68] = mem[idx + _52779 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54336 + 68] = mem[_54336 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54336 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _39784 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39784] = 30
                                        mem[_39784 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _40588 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40588 + 68] = mem[idx + _39784 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40588 + 68] = mem[_40588 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40588 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43846] = 30
                                        mem[_43846 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45774 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45774 + 68] = mem[idx + _43846 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45774 + 68] = mem[_45774 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45774 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _53657 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53657] = 30
                                        mem[_53657 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit 0x64ddf252: arg2, msg.sender, arg1
                                            return 1
                                        _55117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _55117 + 68] = mem[idx + _53657 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55117 + 68] = mem[_55117 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55117 + -mem[64] + 100
                                    _33374 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33374] = 26
                                    mem[_33374 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35398 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35398] = 26
                                        mem[_35398 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _35399 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35399] = 26
                                        mem[_35399 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero' << 48
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _34239 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34239] = 26
                                            mem[_34239 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34239 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _39143 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39143] = 30
                                                    mem[_39143 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41761 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41761] = 30
                                                    mem[_41761 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _42973 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _42973 + 68] = mem[idx + _41761 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_42973 + 68] = mem[_42973 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _42973 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _50441 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_50441] = 30
                                                    mem[_50441 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _52763 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52763 + 68] = mem[idx + _50441 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52763 + 68] = mem[_52763 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52763 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39268 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39268] = 30
                                                mem[_39268 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _39776 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39776 + 68] = mem[idx + _39268 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39776 + 68] = mem[_39776 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39776 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42343 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42343] = 30
                                                mem[_42343 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43830 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43830 + 68] = mem[idx + _42343 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43830 + 68] = mem[_43830 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43830 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _51641 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51641] = 30
                                                mem[_51641 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53647 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53647 + 68] = mem[idx + _51641 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53647 + 68] = mem[_53647 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53647 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _39267 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39267] = 30
                                                mem[_39267 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39773 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39773 + 68] = mem[idx + _39267 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39773 + 68] = mem[_39773 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39773 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42342 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42342] = 30
                                                mem[_42342 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _43827 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43827 + 68] = mem[idx + _42342 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43827 + 68] = mem[_43827 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43827 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _51640 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51640] = 30
                                                mem[_51640 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _53644 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53644 + 68] = mem[idx + _51640 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53644 + 68] = mem[_53644 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53644 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39398] = 30
                                            mem[_39398 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _40107 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40107 + 68] = mem[idx + _39398 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40107 + 68] = mem[_40107 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40107 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42972 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42972] = 30
                                            mem[_42972 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44825 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44825 + 68] = mem[idx + _42972 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44825 + 68] = mem[_44825 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44825 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52762] = 30
                                            mem[_52762 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _54325 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54325 + 68] = mem[idx + _52762 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54325 + 68] = mem[_54325 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54325 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _34449 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34449] = 30
                                            mem[_34449 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _34994 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _34994 + 68] = mem[idx + _34449 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_34994 + 68] = mem[_34994 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _34994 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _36944 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36944] = 30
                                            mem[_36944 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _37801 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _37801 + 68] = mem[idx + _36944 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37801 + 68] = mem[_37801 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37801 + -mem[64] + 100
                                        _34737 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34737] = 26
                                        mem[_34737 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _34737 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _39401 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39401] = 30
                                                mem[_39401 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42982 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42982] = 30
                                                mem[_42982 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _44832 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44832 + 68] = mem[idx + _42982 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44832 + 68] = mem[_44832 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44832 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _52767 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52767] = 30
                                                mem[_52767 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _54330 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _54330 + 68] = mem[idx + _52767 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_54330 + 68] = mem[_54330 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _54330 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39780 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39780] = 30
                                            mem[_39780 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _40582 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40582 + 68] = mem[idx + _39780 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40582 + 68] = mem[_40582 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40582 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43836 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43836] = 30
                                            mem[_43836 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _45764 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45764 + 68] = mem[idx + _43836 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45764 + 68] = mem[_45764 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45764 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _53651 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53651] = 30
                                            mem[_53651 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _55109 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _55109 + 68] = mem[idx + _53651 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55109 + 68] = mem[_55109 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55109 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _39779 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39779] = 30
                                            mem[_39779 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40579 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40579 + 68] = mem[idx + _39779 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40579 + 68] = mem[_40579 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40579 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43835 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43835] = 30
                                            mem[_43835 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _45761 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45761 + 68] = mem[idx + _43835 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45761 + 68] = mem[_45761 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45761 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _53650 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53650] = 30
                                            mem[_53650 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _55106 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _55106 + 68] = mem[idx + _53650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55106 + 68] = mem[_55106 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55106 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _40110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40110] = 30
                                        mem[_40110 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _40977 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _40977 + 68] = mem[idx + _40110 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40977 + 68] = mem[_40977 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40977 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _44831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44831] = 30
                                        mem[_44831 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _46813 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _46813 + 68] = mem[idx + _44831 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_46813 + 68] = mem[_46813 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _46813 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _54329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_54329] = 30
                                        mem[_54329 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                            return 1
                                        _56058 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _56058 + 68] = mem[idx + _54329 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_56058 + 68] = mem[_56058 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _56058 + -mem[64] + 100
                                    _33369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33369] = 26
                                    mem[_33369 + 32] = 'SafeMath: division by zero' << 48
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _35391 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35391] = 26
                                        mem[_35391 + 32] = 'SafeMath: division by zero' << 48
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _35392 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35392] = 26
                                        mem[_35392 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                            else:
                                mem[0] = arg1
                                mem[32] = 206
                                if not stor206[address(arg1)]:
                                    if not arg2:
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero' << 48
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _34254 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34254] = 26
                                                mem[_34254 + 32] = 'SafeMath: division by zero' << 48
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _34254 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    _39148 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39148] = 30
                                                    mem[_39148 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41803 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41803] = 30
                                                    mem[_41803 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _43008 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _43008 + 68] = mem[idx + _41803 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43008 + 68] = mem[_43008 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43008 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _50503 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_50503] = 30
                                                    mem[_50503 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                                        return 1
                                                    _52812 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52812 + 68] = mem[idx + _50503 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52812 + 68] = mem[_52812 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52812 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39276 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39276] = 30
                                                mem[_39276 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39797 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39797 + 68] = mem[idx + _39276 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39797 + 68] = mem[_39797 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39797 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42370 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42370] = 30
                                                mem[_42370 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _43875 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43875 + 68] = mem[idx + _42370 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43875 + 68] = mem[_43875 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43875 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _51696 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51696] = 30
                                                mem[_51696 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _53678 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53678 + 68] = mem[idx + _51696 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53678 + 68] = mem[_53678 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53678 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _34458 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34458] = 30
                                                mem[_34458 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _35006 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _35006 + 68] = mem[idx + _34458 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35006 + 68] = mem[_35006 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35006 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _36965 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36965] = 30
                                                mem[_36965 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _37825 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _37825 + 68] = mem[idx + _36965 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37825 + 68] = mem[_37825 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37825 + -mem[64] + 100
                                            _34752 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34752] = 26
                                            mem[_34752 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34752 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39407 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39407] = 30
                                                mem[_39407 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _43013 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43013] = 30
                                                mem[_43013 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _44880 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44880 + 68] = mem[idx + _43013 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44880 + 68] = mem[_44880 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44880 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _52815 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52815] = 30
                                                mem[_52815 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _54354 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _54354 + 68] = mem[idx + _52815 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_54354 + 68] = mem[_54354 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _54354 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39800 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39800] = 30
                                            mem[_39800 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40606 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40606 + 68] = mem[idx + _39800 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40606 + 68] = mem[_40606 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40606 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43878 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43878] = 30
                                            mem[_43878 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _45806 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45806 + 68] = mem[idx + _43878 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45806 + 68] = mem[_45806 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45806 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _53681 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53681] = 30
                                            mem[_53681 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _55139 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _55139 + 68] = mem[idx + _53681 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55139 + 68] = mem[_55139 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55139 + -mem[64] + 100
                                        _33384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33384] = 26
                                        mem[_33384 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _35412 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35412] = 26
                                            mem[_35412 + 32] = 'SafeMath: division by zero' << 48
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        else:
                                            _35413 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35413] = 26
                                            mem[_35413 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                    else:
                                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero' << 48
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if _tFeePercent * arg2 / 10000 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _34249 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34249] = 26
                                                mem[_34249 + 32] = 'SafeMath: division by zero' << 48
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _34249 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    if not _tFeePercent * arg2 / 10000:
                                                        _39147 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_39147] = 30
                                                        mem[_39147 + 32] = 'SafeMath: subtraction overflow'
                                                        mem[0] = msg.sender
                                                        mem[32] = 203
                                                        _41792 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_41792] = 30
                                                        mem[_41792 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor203[address(msg.sender)]:
                                                            _42996 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _42996 + 68] = mem[idx + _41792 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_42996 + 68] = mem[_42996 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _42996 + -mem[64] + 100
                                                        if stor203[arg1] < stor203[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = arg1
                                                        mem[32] = 203
                                                        stor203[address(arg1)] = stor203[arg1]
                                                        _50483 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_50483] = 30
                                                        mem[_50483 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 <= stor209:
                                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += _tFeePercent * arg2 / 10000
                                                            emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                            return 1
                                                        _52799 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _52799 + 68] = mem[idx + _50483 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_52799 + 68] = mem[_52799 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _52799 + -mem[64] + 100
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _39273 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39273] = 30
                                                    mem[_39273 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                        _39792 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _39792 + 68] = mem[idx + _39273 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_39792 + 68] = mem[_39792 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _39792 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _42363 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_42363] = 30
                                                    mem[_42363 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _43862 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _43862 + 68] = mem[idx + _42363 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43862 + 68] = mem[_43862 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43862 + -mem[64] + 100
                                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    _51680 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_51680] = 30
                                                    mem[_51680 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _53671 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _53671 + 68] = mem[idx + _51680 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_53671 + 68] = mem[_53671 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _53671 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not _tFeePercent * arg2 / 10000:
                                                    _39272 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39272] = 30
                                                    mem[_39272 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor209 / totalSupply * arg2:
                                                        _39789 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _39789 + 68] = mem[idx + _39272 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_39789 + 68] = mem[_39789 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _39789 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _42362 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_42362] = 30
                                                    mem[_42362 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                        _43859 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _43859 + 68] = mem[idx + _42362 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43859 + 68] = mem[_43859 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43859 + -mem[64] + 100
                                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                    _51679 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_51679] = 30
                                                    mem[_51679 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _53668 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _53668 + 68] = mem[idx + _51679 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_53668 + 68] = mem[_53668 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _53668 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39403 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39403] = 30
                                                mem[_39403 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    _40119 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _40119 + 68] = mem[idx + _39403 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40119 + 68] = mem[_40119 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40119 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42995 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42995] = 30
                                                mem[_42995 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _44861 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44861 + 68] = mem[idx + _42995 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44861 + 68] = mem[_44861 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44861 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _52798 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52798] = 30
                                                mem[_52798 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _54343 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _54343 + 68] = mem[idx + _52798 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_54343 + 68] = mem[_54343 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _54343 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _34455 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34455] = 30
                                                mem[_34455 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _35002 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _35002 + 68] = mem[idx + _34455 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35002 + 68] = mem[_35002 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35002 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _36958 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36958] = 30
                                                mem[_36958 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _37817 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _37817 + 68] = mem[idx + _36958 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37817 + 68] = mem[_37817 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37817 + -mem[64] + 100
                                            _34747 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34747] = 26
                                            mem[_34747 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34747 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _39406 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39406] = 30
                                                    mem[_39406 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _43005 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_43005] = 30
                                                    mem[_43005 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _44868 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _44868 + 68] = mem[idx + _43005 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_44868 + 68] = mem[_44868 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _44868 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _52803 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_52803] = 30
                                                    mem[_52803 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                        return 1
                                                    _54348 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _54348 + 68] = mem[idx + _52803 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_54348 + 68] = mem[_54348 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _54348 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39796 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39796] = 30
                                                mem[_39796 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _40600 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _40600 + 68] = mem[idx + _39796 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40600 + 68] = mem[_40600 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40600 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _43868 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43868] = 30
                                                mem[_43868 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _45796 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _45796 + 68] = mem[idx + _43868 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45796 + 68] = mem[_45796 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45796 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _53675 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_53675] = 30
                                                mem[_53675 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _55131 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _55131 + 68] = mem[idx + _53675 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_55131 + 68] = mem[_55131 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _55131 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _39795 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39795] = 30
                                                mem[_39795 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _40597 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _40597 + 68] = mem[idx + _39795 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40597 + 68] = mem[_40597 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40597 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _43867 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43867] = 30
                                                mem[_43867 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _45793 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _45793 + 68] = mem[idx + _43867 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45793 + 68] = mem[_45793 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45793 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _53674 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_53674] = 30
                                                mem[_53674 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                    return 1
                                                _55128 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _55128 + 68] = mem[idx + _53674 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_55128 + 68] = mem[_55128 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _55128 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _40122 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40122] = 30
                                            mem[_40122 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _40991 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40991 + 68] = mem[idx + _40122 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40991 + 68] = mem[_40991 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40991 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _44867 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_44867] = 30
                                            mem[_44867 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _46851 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _46851 + 68] = mem[idx + _44867 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46851 + 68] = mem[_46851 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46851 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _54347 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_54347] = 30
                                            mem[_54347 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                                return 1
                                            _56090 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _56090 + 68] = mem[idx + _54347 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_56090 + 68] = mem[_56090 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _56090 + -mem[64] + 100
                                        _33379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33379] = 26
                                        mem[_33379 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _35405 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35405] = 26
                                            mem[_35405 + 32] = 'SafeMath: division by zero' << 48
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > t / s * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            _35406 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35406] = 26
                                            mem[_35406 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > stor209 / totalSupply * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit 0x64ddf252: (arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1
                                else:
                                    if not arg2:
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero' << 48
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _34264 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34264] = 26
                                                mem[_34264 + 32] = 'SafeMath: division by zero' << 48
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _34264 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    _39150 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39150] = 30
                                                    mem[_39150 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 204
                                                    _41823 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41823] = 30
                                                    mem[_41823 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor204[address(msg.sender)]:
                                                        _43024 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _43024 + 68] = mem[idx + _41823 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43024 + 68] = mem[_43024 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43024 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    stor204[address(msg.sender)] -= arg2
                                                    mem[32] = 203
                                                    _45825 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_45825] = 30
                                                    mem[_45825 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _48139 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _48139 + 68] = mem[idx + _45825 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_48139 + 68] = mem[_48139 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _48139 + -mem[64] + 100
                                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor204[address(arg1)] += arg2
                                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    _58021 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_58021] = 30
                                                    mem[_58021 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                                        return 1
                                                    _59994 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _59994 + 68] = mem[idx + _58021 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_59994 + 68] = mem[_59994 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _59994 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39278 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39278] = 30
                                                mem[_39278 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39805 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39805 + 68] = mem[idx + _39278 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39805 + 68] = mem[_39805 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39805 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _42378 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42378] = 30
                                                mem[_42378 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _43895 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43895 + 68] = mem[idx + _42378 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43895 + 68] = mem[_43895 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43895 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _46890 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46890] = 30
                                                mem[_46890 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _49267 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _49267 + 68] = mem[idx + _46890 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_49267 + 68] = mem[_49267 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _49267 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                                _58934 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58934] = 30
                                                mem[_58934 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _60869 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _60869 + 68] = mem[idx + _58934 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_60869 + 68] = mem[_60869 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _60869 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _34464 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34464] = 30
                                                mem[_34464 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _35014 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _35014 + 68] = mem[idx + _34464 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35014 + 68] = mem[_35014 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35014 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _36979 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36979] = 30
                                                mem[_36979 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _37841 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _37841 + 68] = mem[idx + _36979 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37841 + 68] = mem[_37841 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37841 + -mem[64] + 100
                                            _34762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34762] = 26
                                            mem[_34762 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34762 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39409 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39409] = 30
                                                mem[_39409 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _43029 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43029] = 30
                                                mem[_43029 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _44904 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44904 + 68] = mem[idx + _43029 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44904 + 68] = mem[_44904 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44904 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _48145 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48145] = 30
                                                mem[_48145 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _50543 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _50543 + 68] = mem[idx + _48145 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_50543 + 68] = mem[_50543 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _50543 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _59997 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_59997] = 30
                                                mem[_59997 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _61661 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _61661 + 68] = mem[idx + _59997 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_61661 + 68] = mem[_61661 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _61661 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39808 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39808] = 30
                                            mem[_39808 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40618 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40618 + 68] = mem[idx + _39808 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40618 + 68] = mem[_40618 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40618 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _43898 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43898] = 30
                                            mem[_43898 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _45828 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45828 + 68] = mem[idx + _43898 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45828 + 68] = mem[_45828 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45828 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _49270 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49270] = 30
                                            mem[_49270 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _51727 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51727 + 68] = mem[idx + _49270 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51727 + 68] = mem[_51727 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51727 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _60872 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_60872] = 30
                                            mem[_60872 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _62493 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62493 + 68] = mem[idx + _60872 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62493 + 68] = mem[_62493 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62493 + -mem[64] + 100
                                        _33394 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33394] = 26
                                        mem[_33394 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _35426 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35426] = 26
                                            mem[_35426 + 32] = 'SafeMath: division by zero' << 48
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += t / s * arg2
                                        else:
                                            _35427 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35427] = 26
                                            mem[_35427 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    else:
                                        if 0 / arg2:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero' << 48
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _34259 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34259] = 26
                                                mem[_34259 + 32] = 'SafeMath: division by zero' << 48
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _34259 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    _39149 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_39149] = 30
                                                    mem[_39149 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 204
                                                    _41813 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41813] = 30
                                                    mem[_41813 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor204[address(msg.sender)]:
                                                        _43016 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _43016 + 68] = mem[idx + _41813 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43016 + 68] = mem[_43016 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43016 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    stor204[address(msg.sender)] -= arg2
                                                    mem[32] = 203
                                                    _45814 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_45814] = 30
                                                    mem[_45814 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _48123 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _48123 + 68] = mem[idx + _45814 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_48123 + 68] = mem[_48123 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _48123 + -mem[64] + 100
                                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor204[address(arg1)] += arg2
                                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    _58013 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_58013] = 30
                                                    mem[_58013 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit 0x64ddf252: arg2, msg.sender, arg1
                                                        return 1
                                                    _59984 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _59984 + 68] = mem[idx + _58013 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_59984 + 68] = mem[_59984 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _59984 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39277 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39277] = 30
                                                mem[_39277 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39801 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39801 + 68] = mem[idx + _39277 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39801 + 68] = mem[_39801 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39801 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _42374 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42374] = 30
                                                mem[_42374 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _43885 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43885 + 68] = mem[idx + _42374 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43885 + 68] = mem[_43885 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43885 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _46877 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46877] = 30
                                                mem[_46877 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _49254 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _49254 + 68] = mem[idx + _46877 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_49254 + 68] = mem[_49254 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _49254 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                                _58928 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58928] = 30
                                                mem[_58928 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _60863 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _60863 + 68] = mem[idx + _58928 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_60863 + 68] = mem[_60863 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _60863 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _34461 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34461] = 30
                                                mem[_34461 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _35010 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _35010 + 68] = mem[idx + _34461 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35010 + 68] = mem[_35010 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35010 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _36972 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36972] = 30
                                                mem[_36972 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _37833 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _37833 + 68] = mem[idx + _36972 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37833 + 68] = mem[_37833 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37833 + -mem[64] + 100
                                            _34757 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34757] = 26
                                            mem[_34757 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero' << 48
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _34757 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _39408 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39408] = 30
                                                mem[_39408 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _43021 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43021] = 30
                                                mem[_43021 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _44892 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44892 + 68] = mem[idx + _43021 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44892 + 68] = mem[_44892 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44892 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _48129 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48129] = 30
                                                mem[_48129 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _50524 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _50524 + 68] = mem[idx + _48129 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_50524 + 68] = mem[_50524 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _50524 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _59987 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_59987] = 30
                                                mem[_59987 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit 0x64ddf252: arg2, msg.sender, arg1
                                                    return 1
                                                _61655 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _61655 + 68] = mem[idx + _59987 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_61655 + 68] = mem[_61655 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _61655 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39804 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39804] = 30
                                            mem[_39804 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _40612 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _40612 + 68] = mem[idx + _39804 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40612 + 68] = mem[_40612 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40612 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _43888 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43888] = 30
                                            mem[_43888 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _45817 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45817 + 68] = mem[idx + _43888 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45817 + 68] = mem[_45817 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45817 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _49257 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49257] = 30
                                            mem[_49257 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _51711 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51711 + 68] = mem[idx + _49257 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51711 + 68] = mem[_51711 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51711 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _60866 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_60866] = 30
                                            mem[_60866 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit 0x64ddf252: arg2, msg.sender, arg1
                                                return 1
                                            _62485 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62485 + 68] = mem[idx + _60866 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62485 + 68] = mem[_62485 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62485 + -mem[64] + 100
                                        _33389 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33389] = 26
                                        mem[_33389 + 32] = 'SafeMath: division by zero' << 48
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _35419 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35419] = 26
                                            mem[_35419 + 32] = 'SafeMath: division by zero' << 48
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += t / s * arg2
                                        else:
                                            _35420 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35420] = 26
                                            mem[_35420 + 32] = 'SafeMath: division by zero' << 48
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit 0x64ddf252: arg2, msg.sender, arg1
    return 1
}



}
