contract main {




// =====================  Runtime code  =====================


#
#  - deposit(uint8 arg1, uint256 arg2, uint8 arg3, address arg4)
#
bool stor0; offset 256
uint8 stor0; offset 160
uint8 stor0; offset 168
uint128 stor0; offset 168
address owner;
uint256 stor1;
mapping of struct sub_057a3048;
mapping of uint8 stor11;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699760;
address summitAddress;
address stor3;
address stor4;
array of uint8 stor5;
mapping of uint8 stor6;
mapping of struct totemLpSupplies;
mapping of struct sub_76fa17d2;
mapping of uint8 selectedTotem;

function selectedTotem(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return selectedTotem[address(arg2)]
}

function sub_057a3048(?) payable {
    require calldata.size - 4 >= 64
    return sub_057a3048[arg1][arg2].field_0, sub_057a3048[arg1][arg2].field_256, sub_057a3048[arg1][arg2].field_512
}

function lpToken(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    return summitAddress
}

function totemLpSupplies(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    require 0 < totemLpSupplies[arg1 << 248].field_1792
    require 1 < totemLpSupplies[arg1 << 248].field_1792
    return totemLpSupplies[arg1 << 248][7].field_0, totemLpSupplies[arg1 << 248][7].field_256
}

function expeditionsCount() payable {
    return stor5.length
}

function sub_76fa17d2(?) payable {
    require calldata.size - 4 >= 64
    return sub_76fa17d2[arg1][arg2].field_0, 
           sub_76fa17d2[arg1][arg2].field_256,
           sub_76fa17d2[arg1][arg2].field_512,
           sub_76fa17d2[arg1][arg2].field_768
}

function sub_7fc58b10(?) payable {
    require calldata.size - 4 >= 32
    return uint8(totemLpSupplies[arg1].field_0), 
           bool(uint8(totemLpSupplies[arg1].field_8)),
           address(totemLpSupplies[arg1].field_0),
           totemLpSupplies[arg1].field_256,
           totemLpSupplies[arg1].field_512,
           totemLpSupplies[arg1].field_768,
           totemLpSupplies[arg1].field_1024,
           totemLpSupplies[arg1].field_1280,
           totemLpSupplies[arg1].field_1536,
           totemLpSupplies[arg1].field_2048,
           totemLpSupplies[arg1].field_2560,
           totemLpSupplies[arg1].field_2816
}

function sub_83ead6b2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < stor5.length
    return sub_83ead6b2[uint8(arg1)]
}

function owner() payable {
    return owner
}

function summit() payable {
    return summitAddress
}

function poolExistence(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor11[arg1])
}

function lpSupply(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    return totemLpSupplies[arg1 << 248].field_1024
}

function userTotem(address arg1) payable {
    require calldata.size - 4 >= 32
    return selectedTotem[arg1]
}

function sub_e4be798b(?) payable {
    require calldata.size - 4 >= 32
    return bool(stor6[arg1])
}

function _fallback() payable {
    revert
}

function isLive(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    return 1
}

function depositFee(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    return 0
}

function elevateWithdraw(uint8 arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    return 0
}

function elevateDeposit(uint8 arg1, uint256 arg2, uint8 arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    return 0
}

function sub_8d2c35b2(?) payable {
    require calldata.size - 4 >= 224
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function enable(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    summitAddress = arg2
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > arg2:
        revert with 0, 'SafeMath: subtraction overflow'
    return (arg2 - arg1)
}

function set(uint8 arg1, bool arg2, uint16 arg3, bool arg4) payable {
    require calldata.size - 4 >= 128
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    revert with 0, 'Set doesnt exist for expedition'
}

function validateElevate(uint8 arg1, address arg2, uint256 arg3, uint8 arg4, address arg5) payable {
    require calldata.size - 4 >= 160
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    revert with 0, 'No exped elev switch'
}

function currentRoundDeityDivider(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    require ext_code.size(stor4)
    staticcall stor4.expeditionCurrentRoundDeityDivider() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[31 len 1]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x644f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function isTotemInUse(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    idx = 0
    while uint8(idx) < stor5.length:
        mem[0] = stor('array', ('mask_shl', 3, 5, -5, ('var', 0)), ('name', 'stor5', 5))[uint8(idx)]
        mem[32] = 7
        if not uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8):
            idx = idx + 1
            continue 
        require uint8(idx) < stor5.length
        mem[0] = arg2
        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 8)
        if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg2)].field_256 <= 0:
            idx = idx + 1
            continue 
        return 1
    return 0
}

function initialize(address arg1) payable {
    require calldata.size - 4 >= 32
    if not uint8(stor0.field_168):
        if ext_code.size(this.address):
            if uint8(stor0.field_160):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            46,
                            0x73496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                            mem[210 len 18]
        if not uint8(stor0.field_168):
            uint8(stor0.field_160) = 1
            uint8(stor0.field_168) = 1
            Mask(88, 0, stor0.field_168) = 0
            stor0.field_256 % 1 = 0
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not arg1:
        revert with 0, 'Contract is zero'
    stor4 = arg1
    if not uint8(stor0.field_168):
        uint8(stor0.field_168) = 0
}

function remainingRewards(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if not totemLpSupplies[arg1 << 248].field_2560:
        return totemLpSupplies[arg1 << 248].field_512
    if totemLpSupplies[arg1 << 248].field_2560 >= block.timestamp:
        return totemLpSupplies[arg1 << 248].field_512
    if totemLpSupplies[arg1 << 248].field_2560 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - totemLpSupplies[arg1 << 248].field_2560:
        if 0 > totemLpSupplies[arg1 << 248].field_512:
            revert with 0, 'SafeMath: subtraction overflow'
        return totemLpSupplies[arg1 << 248].field_512
    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_2560 != totemLpSupplies[arg1 << 248].field_768:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768) > totemLpSupplies[arg1 << 248].field_512:
        revert with 0, 'SafeMath: subtraction overflow'
    return (totemLpSupplies[arg1 << 248].field_512 - (block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768))
}

function restartExpeditionPool(uint8 arg1, uint256 arg2, uint256 arg3, bool arg4) payable {
    require calldata.size - 4 >= 128
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    require ext_code.size(address(totemLpSupplies[arg1 << 248].field_16))
    staticcall address(totemLpSupplies[arg1 << 248].field_16).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x4d75737420686176652066756e647320746f20636f7665722065787065646974696f00,
                    mem[199 len 29]
    if uint8(totemLpSupplies[arg1 << 248].field_8):
        revert with 0, 'Expedition already running'
    if arg4:
        require ext_code.size(stor3)
        call stor3.0x630b5ba1 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(stor4)
    staticcall stor4.elevationDuration(uint8 arg1) with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    if arg3 * ext_call.return_data[0] / ext_call.return_data[0] != arg3:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if arg3 * ext_call.return_data[0] <= 0:
        revert with 0, 'SafeMath: division by zero'
    require arg3 * ext_call.return_data[0]
    uint8(totemLpSupplies[arg1 << 248].field_8) = 0
    totemLpSupplies[arg1 << 248].field_256 = arg3
    totemLpSupplies[arg1 << 248].field_512 = arg2
    totemLpSupplies[arg1 << 248].field_768 = arg2 / arg3 * ext_call.return_data[0]
    totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
    totemLpSupplies[arg1 << 248].field_1536 = 0
    totemLpSupplies[arg1 << 248].field_2560 = 0
    require ext_code.size(stor4)
    staticcall stor4.getElevationStartRound(uint8 arg1) with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    totemLpSupplies[arg1 << 248].field_2816 = ext_call.return_data[0]
    emit ExpeditionRestarted(address(totemLpSupplies[arg1 << 248].field_0), totemLpSupplies[arg1 << 248].field_512, totemLpSupplies[arg1 << 248].field_256, arg1);
}

function sub_6ccfed7d(?) payable {
    require calldata.size - 4 >= 160
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if stor11[address(arg2)]:
        revert with 0, 'Duplicated'
    require ext_code.size(arg2)
    staticcall arg2.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < arg3:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x4d75737420686176652066756e647320746f20636f7665722065787065646974696f00,
                    mem[199 len 29]
    if arg5:
        require ext_code.size(stor3)
        call stor3.0x630b5ba1 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(stor4)
    staticcall stor4.elevationDuration(uint8 arg1) with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    stor11[address(arg2)] = 1
    stor6[arg1 << 248] = 1
    stor5.length++
    stor36B6[Mask(251, 0, stor5.length.field_5)] = stor36B6[Mask(251, 0, stor5.length.field_5)] and !(255 * 256^stor5.length % 32) or 256^stor5.length % 32 * arg1
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    if arg4 * ext_call.return_data[0] / ext_call.return_data[0] != arg4:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if arg4 * ext_call.return_data[0] <= 0:
        revert with 0, 'SafeMath: division by zero'
    require arg4 * ext_call.return_data[0]
    require ext_code.size(stor4)
    staticcall stor4.0xc416fa18 with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require uint8(ext_call.return_data[0]) <= test266151307()
    if uint8(ext_call.return_data[0]):
        mem[576 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
    require uint8(ext_call.return_data[0]) <= test266151307()
    mem[(32 * uint8(ext_call.return_data[0])) + 576] = uint8(ext_call.return_data[0])
    if uint8(ext_call.return_data[0]):
        mem[(32 * uint8(ext_call.return_data[0])) + 608 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
    require ext_code.size(stor4)
    staticcall stor4.getElevationStartRound(uint8 arg1) with:
            gas gas_remaining wei
           args 4, mem[(64 * uint8(ext_call.return_data[0])) + 644 len (64 * uint8(ext_call.return_data[0])) - (2 * 32 * uint8(ext_call.return_data[0]))]
    mem[(64 * uint8(ext_call.return_data[0])) + 608] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    uint8(totemLpSupplies[arg1 << 248].field_0) = arg1
    uint8(totemLpSupplies[arg1 << 248].field_8) = 0
    address(totemLpSupplies[arg1 << 248].field_16) = arg2
    Mask(80, 0, totemLpSupplies[arg1 << 248].field_176) = 0
    totemLpSupplies[arg1 << 248].field_256 = arg4
    totemLpSupplies[arg1 << 248].field_512 = arg3
    totemLpSupplies[arg1 << 248].field_768 = arg3 / arg4 * ext_call.return_data[0]
    totemLpSupplies[arg1 << 248].field_1024 = 0
    totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
    totemLpSupplies[arg1 << 248].field_1536 = 0
    uint8(totemLpSupplies[arg1 << 248].field_1792) = uint8(ext_call.return_data[0])
    Mask(248, 0, totemLpSupplies[arg1 << 248].field_1800) = 0
    if not uint8(ext_call.return_data[0]):
        idx = 0
        while totemLpSupplies[arg1 << 248].field_1792 > idx:
            totemLpSupplies[arg1 << 248][idx + 7].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 576
        while (32 * uint8(ext_call.return_data[0])) + 576 > idx:
            totemLpSupplies[arg1 << 248][s + 7].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * uint8(ext_call.return_data[0])) + 31) >> 5
        while totemLpSupplies[arg1 << 248].field_1792 > idx:
            totemLpSupplies[arg1 << 248][idx + 7].field_0 = 0
            idx = idx + 1
            continue 
    totemLpSupplies[arg1 << 248].field_2048 = 0
    uint8(totemLpSupplies[arg1 << 248].field_2304) = uint8(ext_call.return_data[0])
    Mask(248, 0, totemLpSupplies[arg1 << 248].field_2312) = 0
    if not uint8(ext_call.return_data[0]):
        idx = 0
        while totemLpSupplies[arg1 << 248].field_2304 > idx:
            totemLpSupplies[arg1 << 248][idx + 9].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = (32 * uint8(ext_call.return_data[0])) + 608
        while (64 * uint8(ext_call.return_data[0])) + 608 > idx:
            totemLpSupplies[arg1 << 248][s + 9].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * uint8(ext_call.return_data[0])) + 31) >> 5
        while totemLpSupplies[arg1 << 248].field_2304 > idx:
            totemLpSupplies[arg1 << 248][idx + 9].field_0 = 0
            idx = idx + 1
            continue 
    totemLpSupplies[arg1 << 248].field_2560 = 0
    totemLpSupplies[arg1 << 248].field_2816 = ext_call.return_data[0]
}

function rewards(uint8 arg1, address arg2) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if not arg2:
        revert with 0, 'User address is zero'
    if not stor6[uint8(stor7[arg1 << 248].field_0)]:
        revert with 0, 'nPool doesnt exist'
    require ext_code.size(stor4)
    staticcall stor4.0x8b02ea7b with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > totemLpSupplies[arg1 << 248].field_2816:
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = 4
                mem[mem[64] + 36] = idx
                require ext_code.size(stor4)
                staticcall stor4.0xcb4b3022 with:
                        gas gas_remaining wei
                       args 4, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = arg2
                mem[32] = 9
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)]:
                    _65 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_65] = 0
                    mem[_65 + 32] = 0
                    mem[_65 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                    _68 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_68] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                    mem[_68 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                    mem[_68 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
            return 0
        else:
            return 0
    else:
        return 0
}

function updatePool(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if totemLpSupplies[arg1 << 248].field_1280 != block.timestamp:
        if uint8(totemLpSupplies[arg1 << 248].field_8):
            if totemLpSupplies[arg1 << 248].field_1024:
                if totemLpSupplies[arg1 << 248].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - totemLpSupplies[arg1 << 248].field_1280:
                    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totemLpSupplies[arg1 << 248].field_1024
                    if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    totemLpSupplies[arg1 << 248].field_1536 += 0 / totemLpSupplies[arg1 << 248].field_1024
                    if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    while uint8(idx) < totemLpSupplies[arg1 << 248].field_2304:
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_1792
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                        mem[0] = sha3(arg1 << 248, 7) + 9
                        stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                        idx = idx + 1
                        continue 
                else:
                    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_1280 != totemLpSupplies[arg1 << 248].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_1536 += 0 / totemLpSupplies[arg1 << 248].field_1024
                    else:
                        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_1536 += (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024
                    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                        revert with 0, 'SafeMath: addition overflow'
                    totemLpSupplies[arg1 << 248].field_2048 = (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048
                    idx = 0
                    while uint8(idx) < totemLpSupplies[arg1 << 248].field_2304:
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_1792
                        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[arg1 << 248].field_1024
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            mem[0] = sha3(arg1 << 248, 7) + 9
                            stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                        else:
                            if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[arg1 << 248].field_1024
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            if ((block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            mem[0] = sha3(arg1 << 248, 7) + 9
                            stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / totemLpSupplies[arg1 << 248].field_1024
                        idx = idx + 1
                        continue 
        totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
}

function extendExpeditionPool(uint8 arg1, uint256 arg2, uint256 arg3, bool arg4) payable {
    require calldata.size - 4 >= 128
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if not uint8(totemLpSupplies[arg1 << 248].field_8):
        revert with 0, 'Pool not available yet'
    if totemLpSupplies[arg1 << 248].field_2560 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - totemLpSupplies[arg1 << 248].field_2560:
        if 0 > totemLpSupplies[arg1 << 248].field_512:
            revert with 0, 'SafeMath: subtraction overflow'
        if arg2 + totemLpSupplies[arg1 << 248].field_512 < totemLpSupplies[arg1 << 248].field_512:
            revert with 0, 'SafeMath: addition overflow'
        require ext_code.size(address(totemLpSupplies[arg1 << 248].field_16))
        staticcall address(totemLpSupplies[arg1 << 248].field_16).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= arg2 + totemLpSupplies[arg1 << 248].field_512:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        35,
                        0x4d75737420686176652066756e647320746f20636f7665722065787065646974696f00,
                        mem[199 len 29]
        if arg4:
            require ext_code.size(stor3)
            call stor3.0x630b5ba1 with:
                 gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(stor4)
        staticcall stor4.elevationDuration(uint8 arg1) with:
                gas gas_remaining wei
               args 4
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg3 + totemLpSupplies[arg1 << 248].field_256 < totemLpSupplies[arg1 << 248].field_256:
            revert with 0, 'SafeMath: addition overflow'
        if not arg3 + totemLpSupplies[arg1 << 248].field_256:
            if block.timestamp - totemLpSupplies[arg1 << 248].field_2560 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if -block.timestamp + totemLpSupplies[arg1 << 248].field_2560 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require -block.timestamp + totemLpSupplies[arg1 << 248].field_2560
            if arg2 + totemLpSupplies[arg1 << 248].field_512 < totemLpSupplies[arg1 << 248].field_512:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_512 += arg2
            if arg3 + totemLpSupplies[arg1 << 248].field_256 < totemLpSupplies[arg1 << 248].field_256:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_256 += arg3
            totemLpSupplies[arg1 << 248].field_768 = arg2 + totemLpSupplies[arg1 << 248].field_512 / -block.timestamp + totemLpSupplies[arg1 << 248].field_2560
        else:
            if (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) / arg3 + totemLpSupplies[arg1 << 248].field_256 != ext_call.return_data[0]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if block.timestamp - totemLpSupplies[arg1 << 248].field_2560 > (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]):
                revert with 0, 'SafeMath: subtraction overflow'
            if (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) - block.timestamp + totemLpSupplies[arg1 << 248].field_2560 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) - block.timestamp + totemLpSupplies[arg1 << 248].field_2560
            if arg2 + totemLpSupplies[arg1 << 248].field_512 < totemLpSupplies[arg1 << 248].field_512:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_512 += arg2
            if arg3 + totemLpSupplies[arg1 << 248].field_256 < totemLpSupplies[arg1 << 248].field_256:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_256 += arg3
            totemLpSupplies[arg1 << 248].field_768 = arg2 + totemLpSupplies[arg1 << 248].field_512 / (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) - block.timestamp + totemLpSupplies[arg1 << 248].field_2560
    else:
        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_2560 != totemLpSupplies[arg1 << 248].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768) > totemLpSupplies[arg1 << 248].field_512:
            revert with 0, 'SafeMath: subtraction overflow'
        if arg2 < 0:
            revert with 0, 'SafeMath: addition overflow'
        require ext_code.size(address(totemLpSupplies[arg1 << 248].field_16))
        staticcall address(totemLpSupplies[arg1 << 248].field_16).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= arg2 + totemLpSupplies[arg1 << 248].field_512 - (block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        35,
                        0x4d75737420686176652066756e647320746f20636f7665722065787065646974696f00,
                        mem[199 len 29]
        if arg4:
            require ext_code.size(stor3)
            call stor3.0x630b5ba1 with:
                 gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(stor4)
        staticcall stor4.elevationDuration(uint8 arg1) with:
                gas gas_remaining wei
               args 4
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg3 + totemLpSupplies[arg1 << 248].field_256 < totemLpSupplies[arg1 << 248].field_256:
            revert with 0, 'SafeMath: addition overflow'
        if not arg3 + totemLpSupplies[arg1 << 248].field_256:
            if block.timestamp - totemLpSupplies[arg1 << 248].field_2560 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if -block.timestamp + totemLpSupplies[arg1 << 248].field_2560 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require -block.timestamp + totemLpSupplies[arg1 << 248].field_2560
            if arg2 + totemLpSupplies[arg1 << 248].field_512 < totemLpSupplies[arg1 << 248].field_512:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_512 += arg2
            if arg3 + totemLpSupplies[arg1 << 248].field_256 < totemLpSupplies[arg1 << 248].field_256:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_256 += arg3
            totemLpSupplies[arg1 << 248].field_768 = arg2 + totemLpSupplies[arg1 << 248].field_512 - (block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768) / -block.timestamp + totemLpSupplies[arg1 << 248].field_2560
        else:
            if (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) / arg3 + totemLpSupplies[arg1 << 248].field_256 != ext_call.return_data[0]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if block.timestamp - totemLpSupplies[arg1 << 248].field_2560 > (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]):
                revert with 0, 'SafeMath: subtraction overflow'
            if (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) - block.timestamp + totemLpSupplies[arg1 << 248].field_2560 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) - block.timestamp + totemLpSupplies[arg1 << 248].field_2560
            if arg2 + totemLpSupplies[arg1 << 248].field_512 < totemLpSupplies[arg1 << 248].field_512:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_512 += arg2
            if arg3 + totemLpSupplies[arg1 << 248].field_256 < totemLpSupplies[arg1 << 248].field_256:
                revert with 0, 'SafeMath: addition overflow'
            totemLpSupplies[arg1 << 248].field_256 += arg3
            totemLpSupplies[arg1 << 248].field_768 = arg2 + totemLpSupplies[arg1 << 248].field_512 - (block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (totemLpSupplies[arg1 << 248].field_2560 * totemLpSupplies[arg1 << 248].field_768) / (arg3 * ext_call.return_data[0]) + (totemLpSupplies[arg1 << 248].field_256 * ext_call.return_data[0]) - block.timestamp + totemLpSupplies[arg1 << 248].field_2560
    emit ExpeditionExtended(address(totemLpSupplies[arg1 << 248].field_0), totemLpSupplies[arg1 << 248].field_512, arg3 + totemLpSupplies[arg1 << 248].field_256, arg1);
}

function emergencyWithdraw(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if not uint8(totemLpSupplies[arg1 << 248].field_8):
        revert with 0, 'Pool not available yet'
    if not arg2:
        revert with 0, 'User address is zero'
    require ext_code.size(stor4)
    staticcall stor4.getElevationLockedUntilRollover(uint8 arg1) with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'Elev locked until rollover'
    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
        revert with 0, 'Nothing to emergency withdraw'
    if totemLpSupplies[arg1 << 248].field_1280 != block.timestamp:
        if uint8(totemLpSupplies[arg1 << 248].field_8):
            if totemLpSupplies[arg1 << 248].field_1024:
                if totemLpSupplies[arg1 << 248].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - totemLpSupplies[arg1 << 248].field_1280:
                    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totemLpSupplies[arg1 << 248].field_1024
                    if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    totemLpSupplies[arg1 << 248].field_1536 += 0 / totemLpSupplies[arg1 << 248].field_1024
                    if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    while uint8(idx) < totemLpSupplies[arg1 << 248].field_2304:
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_1792
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                        mem[0] = sha3(arg1 << 248, 7) + 9
                        stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                        idx = idx + 1
                        continue 
                else:
                    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_1280 != totemLpSupplies[arg1 << 248].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_1536 += 0 / totemLpSupplies[arg1 << 248].field_1024
                    else:
                        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_1536 += (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024
                    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                        revert with 0, 'SafeMath: addition overflow'
                    totemLpSupplies[arg1 << 248].field_2048 = (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048
                    idx = 0
                    while uint8(idx) < totemLpSupplies[arg1 << 248].field_2304:
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_1792
                        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[arg1 << 248].field_1024
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            mem[0] = sha3(arg1 << 248, 7) + 9
                            stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                        else:
                            if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[arg1 << 248].field_1024
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            if ((block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                            mem[0] = sha3(arg1 << 248, 7) + 9
                            stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / totemLpSupplies[arg1 << 248].field_1024
                        idx = idx + 1
                        continue 
        totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
    sub_76fa17d2[arg1 << 248][address(arg2)].field_0 = 0
    sub_76fa17d2[arg1 << 248][address(arg2)].field_256 = 0
    sub_76fa17d2[arg1 << 248][address(arg2)].field_768 = 0
    require ext_code.size(summitAddress)
    call summitAddress.0xa9059cbb with:
         gas gas_remaining wei
        args address(arg2), sub_76fa17d2[arg1 << 248][address(arg2)].field_256
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_256 > stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
        revert with 0, 'SafeMath: subtraction overflow'
    require selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792
    stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 -= sub_76fa17d2[arg1 << 248][address(arg2)].field_256
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_256 > totemLpSupplies[arg1 << 248].field_1024:
        revert with 0, 'SafeMath: subtraction overflow'
    totemLpSupplies[arg1 << 248].field_1024 -= sub_76fa17d2[arg1 << 248][address(arg2)].field_256
    stor1 = 1
    return sub_76fa17d2[arg1 << 248][address(arg2)].field_256
}

function massUpdatePools() payable {
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    idx = 0
    while uint8(idx) < stor5.length:
        mem[0] = stor('array', ('mask_shl', 3, 5, -5, ('var', 0)), ('name', 'stor5', 5))[uint8(idx)]
        mem[32] = 7
        if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 != block.timestamp:
            if uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8):
                if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024:
                    if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280:
                        if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                        if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                        if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        s = 0
                        while uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304:
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                            if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            s = s + 1
                            continue 
                    else:
                        if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / block.timestamp - totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 != totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                        if not (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768):
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                        else:
                            if (10^12 * block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) != 10^12:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            if ((10^12 * block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 += (10^12 * block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                        if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048
                        s = 0
                        while uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304:
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                            if not (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768):
                                if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            else:
                                if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) != stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                if ((block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            s = s + 1
                            continue 
            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 = block.timestamp
        idx = idx + 1
        continue 
}

function totemRoundRewards(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if totemLpSupplies[arg1 << 248].field_1280 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - totemLpSupplies[arg1 << 248].field_1280:
        if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
            revert with 0, 'SafeMath: addition overflow'
        if 0 == totemLpSupplies[arg1 << 248].field_1024:
            require 0 < totemLpSupplies[arg1 << 248].field_2304
            if 0 == totemLpSupplies[arg1 << 248].field_1024:
                require 1 < totemLpSupplies[arg1 << 248].field_2304
                return totemLpSupplies[arg1 << 248].field_2048, 
                       totemLpSupplies[arg1 << 248][9].field_0,
                       totemLpSupplies[arg1 << 248][9].field_256
            require 1 < totemLpSupplies[arg1 << 248].field_1792
            if 0 == totemLpSupplies[arg1 << 248][7].field_256:
                require 1 < totemLpSupplies[arg1 << 248].field_2304
                return totemLpSupplies[arg1 << 248].field_2048, 
                       totemLpSupplies[arg1 << 248][9].field_0,
                       totemLpSupplies[arg1 << 248][9].field_256
            require 1 < totemLpSupplies[arg1 << 248].field_1792
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        require 0 < totemLpSupplies[arg1 << 248].field_1792
        if 0 == totemLpSupplies[arg1 << 248][7].field_0:
            require 0 < totemLpSupplies[arg1 << 248].field_2304
            if 0 == totemLpSupplies[arg1 << 248].field_1024:
                require 1 < totemLpSupplies[arg1 << 248].field_2304
                return totemLpSupplies[arg1 << 248].field_2048, 
                       totemLpSupplies[arg1 << 248][9].field_0,
                       totemLpSupplies[arg1 << 248][9].field_256
            require 1 < totemLpSupplies[arg1 << 248].field_1792
            if 0 == totemLpSupplies[arg1 << 248][7].field_256:
                require 1 < totemLpSupplies[arg1 << 248].field_2304
                return totemLpSupplies[arg1 << 248].field_2048, 
                       totemLpSupplies[arg1 << 248][9].field_0,
                       totemLpSupplies[arg1 << 248][9].field_256
            require 1 < totemLpSupplies[arg1 << 248].field_1792
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        require 0 < totemLpSupplies[arg1 << 248].field_1792
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 0 < totemLpSupplies[arg1 << 248].field_2304
        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0 < totemLpSupplies[arg1 << 248][9].field_0:
            revert with 0, 'SafeMath: addition overflow'
        if 0 == totemLpSupplies[arg1 << 248].field_1024:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if 0 == totemLpSupplies[arg1 << 248][7].field_256:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return totemLpSupplies[arg1 << 248].field_2048, 
               (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_1280 != totemLpSupplies[arg1 << 248].field_768:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]
    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
        revert with 0, 'SafeMath: addition overflow'
    if 0 == totemLpSupplies[arg1 << 248].field_1024:
        require 0 < totemLpSupplies[arg1 << 248].field_2304
        if 0 == totemLpSupplies[arg1 << 248].field_1024:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if 0 == totemLpSupplies[arg1 << 248][7].field_256:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != totemLpSupplies[arg1 << 248][7].field_256:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               totemLpSupplies[arg1 << 248][9].field_0,
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    require 0 < totemLpSupplies[arg1 << 248].field_1792
    if 0 == totemLpSupplies[arg1 << 248][7].field_0:
        require 0 < totemLpSupplies[arg1 << 248].field_2304
        if 0 == totemLpSupplies[arg1 << 248].field_1024:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if 0 == totemLpSupplies[arg1 << 248][7].field_256:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != totemLpSupplies[arg1 << 248][7].field_256:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               totemLpSupplies[arg1 << 248][9].field_0,
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    require 0 < totemLpSupplies[arg1 << 248].field_1792
    if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 0 < totemLpSupplies[arg1 << 248].field_2304
        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0 < totemLpSupplies[arg1 << 248][9].field_0:
            revert with 0, 'SafeMath: addition overflow'
        if 0 == totemLpSupplies[arg1 << 248].field_1024:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if 0 == totemLpSupplies[arg1 << 248][7].field_256:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != totemLpSupplies[arg1 << 248][7].field_256:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 0 < totemLpSupplies[arg1 << 248].field_2304
        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0 < totemLpSupplies[arg1 << 248][9].field_0:
            revert with 0, 'SafeMath: addition overflow'
        if 0 == totemLpSupplies[arg1 << 248].field_1024:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if 0 == totemLpSupplies[arg1 << 248][7].field_256:
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   totemLpSupplies[arg1 << 248][9].field_256
        require 1 < totemLpSupplies[arg1 << 248].field_1792
        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totemLpSupplies[arg1 << 248].field_1024
            require 1 < totemLpSupplies[arg1 << 248].field_2304
            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
                revert with 0, 'SafeMath: addition overflow'
            return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
                   (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != totemLpSupplies[arg1 << 248][7].field_256:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != totemLpSupplies[arg1 << 248][7].field_0:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totemLpSupplies[arg1 << 248].field_1024
    require 0 < totemLpSupplies[arg1 << 248].field_2304
    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0 < totemLpSupplies[arg1 << 248][9].field_0:
        revert with 0, 'SafeMath: addition overflow'
    if 0 == totemLpSupplies[arg1 << 248].field_1024:
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               totemLpSupplies[arg1 << 248][9].field_256
    require 1 < totemLpSupplies[arg1 << 248].field_1792
    if 0 == totemLpSupplies[arg1 << 248][7].field_256:
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               totemLpSupplies[arg1 << 248][9].field_256
    require 1 < totemLpSupplies[arg1 << 248].field_1792
    if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totemLpSupplies[arg1 << 248].field_1024
        require 1 < totemLpSupplies[arg1 << 248].field_2304
        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
            revert with 0, 'SafeMath: addition overflow'
        return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
               (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
    if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != totemLpSupplies[arg1 << 248][7].field_256:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totemLpSupplies[arg1 << 248].field_1024
    require 1 < totemLpSupplies[arg1 << 248].field_2304
    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256 < totemLpSupplies[arg1 << 248][9].field_256:
        revert with 0, 'SafeMath: addition overflow'
    return (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048, 
           ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_0,
           ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * totemLpSupplies[arg1 << 248][7].field_256) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + totemLpSupplies[arg1 << 248][9].field_256
}

function switchTotem(uint8 arg1, uint8 arg2, address arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    require ext_code.size(stor4)
    staticcall stor4.0xc416fa18 with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg2 >= ext_call.return_data[31 len 1]:
        revert with 0, 'Invalid totem'
    if not arg3:
        revert with 0, 'User address is zero'
    mem[100] = 4
    require ext_code.size(stor4)
    staticcall stor4.getElevationLockedUntilRollover(uint8 arg1) with:
            gas gas_remaining wei
           args 4
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'Elev locked until rollover'
    idx = 0
    while uint8(idx) < stor5.length:
        mem[0] = stor('array', ('mask_shl', 3, 5, -5, ('var', 0)), ('name', 'stor5', 5))[uint8(idx)]
        mem[32] = 7
        if uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8):
            mem[0] = arg3
            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 8)
            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                mem[0] = arg3
                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 8)
                if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                    mem[0] = uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)
                    mem[32] = 6
                    if not stor6[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)]:
                        revert with 0, 'nPool doesnt exist'
                    mem[mem[64] + 4] = 4
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816:
                        _1504 = mem[64]
                        mem[mem[64] + 36] = arg3
                        mem[mem[64] + 68] = 0
                        _1505 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_1505 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1505 + 36 len 28]
                        mem[64] = _1504 + 164
                        mem[_1504 + 100] = 32
                        mem[_1504 + 132] = 'SafeBEP20: low-level call failed'
                        if not ext_code.size(address(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_16)):
                            revert with 0, 'Address: call to non-contract'
                        _1522 = mem[_1505]
                        t = _1505 + 32
                        u = mem[64]
                        s = mem[_1505]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_1505])] = mem[_1505 + floor32(mem[_1505]) + -(mem[_1505] % 32) + 64 len mem[_1505] % 32] or Mask(8 * -(mem[_1505] % 32) + 32, -(8 * -(mem[_1505] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_1505])])
                        call address(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_16).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1522 + _1504 + -mem[64] + 160]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _2982 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_1504 + 100]
                                _2984 = mem[_1504 + 100]
                                idx = 0
                                while idx < _2984:
                                    mem[idx + _2982 + 68] = mem[idx + _1504 + 132]
                                    idx = idx + 32
                                    continue 
                                if not _2984 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _2984 + _2982 + -mem[64] + 68
                                mem[floor32(_2984) + _2982 + 68] = mem[floor32(_2984) + _2982 + -(_2984 % 32) + 100 len _2984 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_2984) + _2982 + -mem[64] + 100
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                mem[mem[64] + 110 len 22]
                        else:
                            _2962 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_2962] = return_data.size
                            mem[_2962 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2986 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_1504 + 100]
                                _2988 = mem[_1504 + 100]
                                idx = 0
                                while idx < _2988:
                                    mem[idx + _2986 + 68] = mem[idx + _1504 + 132]
                                    idx = idx + 32
                                    continue 
                                if not _2988 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _2988 + _2986 + -mem[64] + 68
                                mem[floor32(_2988) + _2986 + 68] = mem[floor32(_2988) + _2986 + -(_2988 % 32) + 100 len _2988 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_2988) + _2986 + -mem[64] + 100
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_2962 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                mem[mem[64] + 110 len 22]
                    else:
                        if ext_call.return_data[0] == sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_0:
                            _1509 = mem[64]
                            mem[mem[64] + 36] = arg3
                            mem[mem[64] + 68] = 0
                            _1510 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1510 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1510 + 36 len 28]
                            mem[64] = _1509 + 164
                            mem[_1509 + 100] = 32
                            mem[_1509 + 132] = 'SafeBEP20: low-level call failed'
                            if not ext_code.size(address(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_16)):
                                revert with 0, 'Address: call to non-contract'
                            _1527 = mem[_1510]
                            t = _1510 + 32
                            u = mem[64]
                            s = mem[_1510]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_1510])] = mem[_1510 + floor32(mem[_1510]) + -(mem[_1510] % 32) + 64 len mem[_1510] % 32] or Mask(8 * -(mem[_1510] % 32) + 32, -(8 * -(mem[_1510] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_1510])])
                            call address(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_16).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _1527 + _1509 + -mem[64] + 160]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _2974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_1509 + 100]
                                    _2976 = mem[_1509 + 100]
                                    idx = 0
                                    while idx < _2976:
                                        mem[idx + _2974 + 68] = mem[idx + _1509 + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _2976 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _2976 + _2974 + -mem[64] + 68
                                    mem[floor32(_2976) + _2974 + 68] = mem[floor32(_2976) + _2974 + -(_2976 % 32) + 100 len _2976 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_2976) + _2974 + -mem[64] + 100
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[mem[64] + 110 len 22]
                            else:
                                _2961 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_2961] = return_data.size
                                mem[_2961 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2978 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_1509 + 100]
                                    _2980 = mem[_1509 + 100]
                                    idx = 0
                                    while idx < _2980:
                                        mem[idx + _2978 + 68] = mem[idx + _1509 + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _2980 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _2980 + _2978 + -mem[64] + 68
                                    mem[floor32(_2980) + _2978 + 68] = mem[floor32(_2980) + _2978 + -(_2980 % 32) + 100 len _2980 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_2980) + _2978 + -mem[64] + 100
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_2961 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[mem[64] + 110 len 22]
                        else:
                            s = sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_0
                            while s < ext_call.return_data[0]:
                                mem[mem[64] + 4] = 4
                                mem[mem[64] + 36] = s
                                require ext_code.size(stor4)
                                staticcall stor4.0xcb4b3022 with:
                                        gas gas_remaining wei
                                       args 4, s
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg3
                                mem[32] = 9
                                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                                    _2990 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2990] = 0
                                    mem[_2990 + 32] = 0
                                    mem[_2990 + 64] = 0
                                    mem[0] = s
                                    mem[32] = sha3(uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0), 10)
                                    _2993 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2993] = sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0
                                    mem[_2993 + 32] = sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256
                                    mem[_2993 + 64] = sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_512
                                    if s != sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_0:
                                        if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                                            if sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_512 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 != sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_512:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if not sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 < -sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512:
                                                if (sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 * sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256) - (sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 * sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256) / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 != sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        else:
                                            if sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 != sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 > sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12) - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512:
                                                if (sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 * sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256) + (sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256) - (sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 * sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256) / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12) - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 != sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][s].field_256:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                s = s + 1
                                continue 
                            _2963 = mem[64]
                            mem[mem[64] + 36] = arg3
                            mem[mem[64] + 68] = 0
                            _2964 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_2964 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2964 + 36 len 28]
                            mem[64] = _2963 + 164
                            mem[_2963 + 100] = 32
                            mem[_2963 + 132] = 'SafeBEP20: low-level call failed'
                            if not ext_code.size(address(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_16)):
                                revert with 0, 'Address: call to non-contract'
                            _2999 = mem[_2964]
                            t = _2964 + 32
                            u = mem[64]
                            s = mem[_2964]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_2964])] = mem[_2964 + floor32(mem[_2964]) + -(mem[_2964] % 32) + 64 len mem[_2964] % 32] or Mask(8 * -(mem[_2964] % 32) + 32, -(8 * -(mem[_2964] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2964])])
                            call address(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_16).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _2999 + _2963 + -mem[64] + 160]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _4405 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_2963 + 100]
                                    _4407 = mem[_2963 + 100]
                                    idx = 0
                                    while idx < _4407:
                                        mem[idx + _4405 + 68] = mem[idx + _2963 + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _4407 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _4407 + _4405 + -mem[64] + 68
                                    mem[floor32(_4407) + _4405 + 68] = mem[floor32(_4407) + _4405 + -(_4407 % 32) + 100 len _4407 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_4407) + _4405 + -mem[64] + 100
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[mem[64] + 110 len 22]
                            else:
                                _4390 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_4390] = return_data.size
                                mem[_4390 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4409 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_2963 + 100]
                                    _4411 = mem[_2963 + 100]
                                    idx = 0
                                    while idx < _4411:
                                        mem[idx + _4409 + 68] = mem[idx + _2963 + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _4411 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _4411 + _4409 + -mem[64] + 68
                                    mem[floor32(_4411) + _4409 + 68] = mem[floor32(_4411) + _4409 + -(_4411 % 32) + 100 len _4411 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_4411) + _4409 + -mem[64] + 100
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_4390 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[mem[64] + 110 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                            sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256) / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 != totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 + sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 < sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 -= sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512
                        else:
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 != totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12) - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 + sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 < sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12) - sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 + sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768
                    if not sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256:
                        sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 != totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_512 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256 / 10^12
                    sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_0 = ext_call.return_data[0]
                    require selectedTotem[address(arg3)] < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                    stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + stor9[address(arg3)]].field_0 -= sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256
                    require arg2 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                    stor[arg2 + ('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7)))].field_0 += sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_256
                    mem[32] = 9
                    require selectedTotem[address(arg3)] < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                    stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + stor9[address(arg3)]].field_0 -= sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768
                    require arg2 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                    stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + arg2].field_0 += sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_768
                    mem[mem[64] + 4] = 4
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    sub_76fa17d2[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][address(arg3)].field_0 = ext_call.return_data[0]
        idx = idx + 1
        continue 
    selectedTotem[address(arg3)] = arg2
    stor1 = 1
}

function withdraw(uint8 arg1, uint256 arg2, address arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if not arg3:
        revert with 0, 'User address is zero'
    mem[100] = 4
    require ext_code.size(stor4)
    staticcall stor4.getElevationLockedUntilRollover(uint8 arg1) with:
            gas gas_remaining wei
           args 4
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'Elev locked until rollover'
    if not arg2:
        revert with 0, 'Bad withdrawal'
    if sub_76fa17d2[arg1 << 248][address(arg3)].field_256 <= 0:
        revert with 0, 'Bad withdrawal'
    if sub_76fa17d2[arg1 << 248][address(arg3)].field_256 < arg2:
        revert with 0, 'Bad withdrawal'
    mem[32] = 7
    if block.timestamp == totemLpSupplies[arg1 << 248].field_1280:
        mem[0] = uint8(totemLpSupplies[arg1 << 248].field_0)
        mem[32] = 6
        if not stor6[uint8(stor7[arg1 << 248].field_0)]:
            revert with 0, 'nPool doesnt exist'
        mem[100] = 4
        require ext_code.size(stor4)
        staticcall stor4.0x8b02ea7b with:
                gas gas_remaining wei
               args 4
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= totemLpSupplies[arg1 << 248].field_2816:
            if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                revert with 0, 'Address: call to non-contract'
            mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
            mem[324 len 0] = 0
            call address(totemLpSupplies[arg1 << 248].field_16) with:
                 gas gas_remaining wei
                args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                    revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                require ext_code.size(stor4)
                staticcall stor4.0x8b02ea7b with:
                        gas gas_remaining wei
                       args 4
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                    else:
                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                else:
                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
            else:
                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeBEP20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[292]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                    mem[ceil32(return_data.size) + 371 len 22]
                require ext_code.size(stor4)
                staticcall stor4.0x8b02ea7b with:
                        gas gas_remaining wei
                       args 4
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                    else:
                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[ceil32(return_data.size) + 362 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[ceil32(return_data.size) + 362 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                else:
                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[ceil32(return_data.size) + 362 len 31]
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
        else:
            if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                    revert with 0, 'Address: call to non-contract'
                mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                mem[324 len 0] = 0
                call address(totemLpSupplies[arg1 << 248].field_16) with:
                     gas gas_remaining wei
                    args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                    if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                        revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                else:
                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeBEP20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[292]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                        mem[ceil32(return_data.size) + 371 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[ceil32(return_data.size) + 362 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[ceil32(return_data.size) + 362 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[ceil32(return_data.size) + 362 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
            else:
                idx = sub_76fa17d2[arg1 << 248][address(arg3)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = 4
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor4)
                    staticcall stor4.0xcb4b3022 with:
                            gas gas_remaining wei
                           args 4, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = arg3
                    mem[32] = 9
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                        _12432 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_12432] = 0
                        mem[_12432 + 32] = 0
                        mem[_12432 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                        _12458 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_12458] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                        mem[_12458 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                        mem[_12458 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                    if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                    if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
                _12332 = mem[64]
                mem[mem[64] + 36] = arg3
                mem[mem[64] + 68] = 0
                _12333 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_12332 + 100] = 32
                mem[_12332 + 132] = 'SafeBEP20: low-level call failed'
                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                    revert with 0, 'Address: call to non-contract'
                _12505 = mem[_12333]
                mem[_12332 + 164 len floor32(mem[_12333])] = mem[_12333 + 32 len floor32(mem[_12333])]
                mem[_12332 + floor32(mem[_12333]) + -(mem[_12333] % 32) + 196 len mem[_12333] % 32] = mem[_12333 + floor32(mem[_12333]) + -(mem[_12333] % 32) + 64 len mem[_12333] % 32]
                call address(totemLpSupplies[arg1 << 248].field_16) with:
                     gas gas_remaining wei
                    args mem[_12332 + 168 len _12505 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeBEP20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                        mem[_12332 + 274 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12332 + 265 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12332 + 265 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12332 + 265 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                else:
                    mem[_12332 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeBEP20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_12332 + 196]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                        mem[_12332 + ceil32(return_data.size) + 275 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[_12332 + ceil32(return_data.size) + 266 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[_12332 + ceil32(return_data.size) + 266 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[_12332 + ceil32(return_data.size) + 266 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
    else:
        if not uint8(totemLpSupplies[arg1 << 248].field_8):
            totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
            mem[0] = uint8(totemLpSupplies[arg1 << 248].field_0)
            mem[32] = 6
            if not stor6[uint8(stor7[arg1 << 248].field_0)]:
                revert with 0, 'nPool doesnt exist'
            mem[100] = 4
            require ext_code.size(stor4)
            staticcall stor4.0x8b02ea7b with:
                    gas gas_remaining wei
                   args 4
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= totemLpSupplies[arg1 << 248].field_2816:
                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                    revert with 0, 'Address: call to non-contract'
                mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                mem[324 len 0] = 0
                call address(totemLpSupplies[arg1 << 248].field_16) with:
                     gas gas_remaining wei
                    args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                    if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                        revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                else:
                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeBEP20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[292]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                        mem[ceil32(return_data.size) + 371 len 22]
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                        else:
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[ceil32(return_data.size) + 362 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[ceil32(return_data.size) + 362 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[ceil32(return_data.size) + 362 len 31]
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
            else:
                if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                    if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                        revert with 0, 'Address: call to non-contract'
                    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                    mem[324 len 0] = 0
                    call address(totemLpSupplies[arg1 << 248].field_16) with:
                         gas gas_remaining wei
                        args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                        if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                            revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                            else:
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                    else:
                        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeBEP20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[292]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                            mem[ceil32(return_data.size) + 371 len 22]
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                            else:
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[ceil32(return_data.size) + 362 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[ceil32(return_data.size) + 362 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[ceil32(return_data.size) + 362 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                else:
                    idx = sub_76fa17d2[arg1 << 248][address(arg3)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = 4
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor4)
                        staticcall stor4.0xcb4b3022 with:
                                gas gas_remaining wei
                               args 4, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = arg3
                        mem[32] = 9
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                            _12430 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_12430] = 0
                            mem[_12430 + 32] = 0
                            mem[_12430 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                            _12435 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_12435] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                            mem[_12435 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                            mem[_12435 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                        if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                        if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    _12324 = mem[64]
                    mem[mem[64] + 36] = arg3
                    mem[mem[64] + 68] = 0
                    _12325 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_12324 + 100] = 32
                    mem[_12324 + 132] = 'SafeBEP20: low-level call failed'
                    if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                        revert with 0, 'Address: call to non-contract'
                    _12464 = mem[_12325]
                    mem[_12324 + 164 len floor32(mem[_12325])] = mem[_12325 + 32 len floor32(mem[_12325])]
                    mem[_12324 + floor32(mem[_12325]) + -(mem[_12325] % 32) + 196 len mem[_12325] % 32] = mem[_12325 + floor32(mem[_12325]) + -(mem[_12325] % 32) + 64 len mem[_12325] % 32]
                    call address(totemLpSupplies[arg1 << 248].field_16) with:
                         gas gas_remaining wei
                        args mem[_12324 + 168 len _12464 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeBEP20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                            mem[_12324 + 274 len 22]
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                            else:
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12324 + 265 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12324 + 265 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12324 + 265 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                    else:
                        mem[_12324 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeBEP20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_12324 + 196]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                            mem[_12324 + ceil32(return_data.size) + 275 len 22]
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                            else:
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[_12324 + ceil32(return_data.size) + 266 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[_12324 + ceil32(return_data.size) + 266 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[_12324 + ceil32(return_data.size) + 266 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
        else:
            if not totemLpSupplies[arg1 << 248].field_1024:
                totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
                mem[0] = uint8(totemLpSupplies[arg1 << 248].field_0)
                mem[32] = 6
                if not stor6[uint8(stor7[arg1 << 248].field_0)]:
                    revert with 0, 'nPool doesnt exist'
                mem[100] = 4
                require ext_code.size(stor4)
                staticcall stor4.0x8b02ea7b with:
                        gas gas_remaining wei
                       args 4
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= totemLpSupplies[arg1 << 248].field_2816:
                    if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                        revert with 0, 'Address: call to non-contract'
                    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                    mem[324 len 0] = 0
                    call address(totemLpSupplies[arg1 << 248].field_16) with:
                         gas gas_remaining wei
                        args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                        if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                            revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                            else:
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                    else:
                        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeBEP20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[292]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                            mem[ceil32(return_data.size) + 371 len 22]
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                            else:
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[ceil32(return_data.size) + 362 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[ceil32(return_data.size) + 362 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                        sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[ceil32(return_data.size) + 362 len 31]
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                else:
                    if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                        if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                            revert with 0, 'Address: call to non-contract'
                        mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                        mem[324 len 0] = 0
                        call address(totemLpSupplies[arg1 << 248].field_16) with:
                             gas gas_remaining wei
                            args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                            if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                else:
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                        else:
                            mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeBEP20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[292]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                mem[ceil32(return_data.size) + 371 len 22]
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                else:
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[ceil32(return_data.size) + 362 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                    else:
                        idx = sub_76fa17d2[arg1 << 248][address(arg3)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = 4
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor4)
                            staticcall stor4.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args 4, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = arg3
                            mem[32] = 9
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                                _12431 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_12431] = 0
                                mem[_12431 + 32] = 0
                                mem[_12431 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                                _12451 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_12451] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                                mem[_12451 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                                mem[_12451 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                            if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                            if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        _12328 = mem[64]
                        mem[mem[64] + 36] = arg3
                        mem[mem[64] + 68] = 0
                        _12329 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_12328 + 100] = 32
                        mem[_12328 + 132] = 'SafeBEP20: low-level call failed'
                        if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                            revert with 0, 'Address: call to non-contract'
                        _12488 = mem[_12329]
                        mem[_12328 + 164 len floor32(mem[_12329])] = mem[_12329 + 32 len floor32(mem[_12329])]
                        mem[_12328 + floor32(mem[_12329]) + -(mem[_12329] % 32) + 196 len mem[_12329] % 32] = mem[_12329 + floor32(mem[_12329]) + -(mem[_12329] % 32) + 64 len mem[_12329] % 32]
                        call address(totemLpSupplies[arg1 << 248].field_16) with:
                             gas gas_remaining wei
                            args mem[_12328 + 168 len _12488 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeBEP20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                mem[_12328 + 274 len 22]
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                else:
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12328 + 265 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12328 + 265 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_12328 + 265 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                        else:
                            mem[_12328 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeBEP20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_12328 + 196]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                mem[_12328 + ceil32(return_data.size) + 275 len 22]
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                else:
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[_12328 + ceil32(return_data.size) + 266 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[_12328 + ceil32(return_data.size) + 266 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[_12328 + ceil32(return_data.size) + 266 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
            else:
                if totemLpSupplies[arg1 << 248].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - totemLpSupplies[arg1 << 248].field_1280:
                    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totemLpSupplies[arg1 << 248].field_1024
                    if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    totemLpSupplies[arg1 << 248].field_1536 += 0 / totemLpSupplies[arg1 << 248].field_1024
                    if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    while uint8(idx) < totemLpSupplies[arg1 << 248].field_2304:
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_1792
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                        mem[0] = sha3(arg1 << 248, 7) + 9
                        stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                        idx = idx + 1
                        continue 
                    totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
                    mem[0] = uint8(totemLpSupplies[arg1 << 248].field_0)
                    mem[32] = 6
                    if not stor6[uint8(stor7[arg1 << 248].field_0)]:
                        revert with 0, 'nPool doesnt exist'
                    mem[100] = 4
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= totemLpSupplies[arg1 << 248].field_2816:
                        if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                            revert with 0, 'Address: call to non-contract'
                        mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                        var67001 = 192
                        mem[324 len 0] = 0
                        call address(totemLpSupplies[arg1 << 248].field_16) with:
                             gas gas_remaining wei
                            args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                            if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                else:
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                        else:
                            mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeBEP20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[292]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                mem[ceil32(return_data.size) + 371 len 22]
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                else:
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                            sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[ceil32(return_data.size) + 362 len 31]
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                    else:
                        if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                            if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                revert with 0, 'Address: call to non-contract'
                            mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                            mem[324 len 0] = 0
                            call address(totemLpSupplies[arg1 << 248].field_16) with:
                                 gas gas_remaining wei
                                args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                    revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                            else:
                                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeBEP20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[292]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[ceil32(return_data.size) + 371 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                        else:
                            idx = sub_76fa17d2[arg1 << 248][address(arg3)].field_0
                            while idx < ext_call.return_data[0]:
                                mem[mem[64] + 4] = 4
                                mem[mem[64] + 36] = idx
                                require ext_code.size(stor4)
                                staticcall stor4.0xcb4b3022 with:
                                        gas gas_remaining wei
                                       args 4, idx
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg3
                                mem[32] = 9
                                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                                    _24651 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24651] = 0
                                    mem[_24651 + 32] = 0
                                    mem[_24651 + 64] = 0
                                    mem[0] = idx
                                    mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                                    _24670 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24670] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                                    mem[_24670 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                                    mem[_24670 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                                    if idx != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        else:
                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                idx = idx + 1
                                continue 
                            _24546 = mem[64]
                            mem[mem[64] + 36] = arg3
                            mem[mem[64] + 68] = 0
                            _24547 = mem[64]
                            mem[mem[64]] = 68
                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                            mem[64] = mem[64] + 164
                            mem[_24546 + 100] = 32
                            mem[_24546 + 132] = 'SafeBEP20: low-level call failed'
                            if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                revert with 0, 'Address: call to non-contract'
                            _24720 = mem[_24547]
                            mem[_24546 + 164 len floor32(mem[_24547])] = mem[_24547 + 32 len floor32(mem[_24547])]
                            mem[_24546 + floor32(mem[_24547]) + -(mem[_24547] % 32) + 196 len mem[_24547] % 32] = mem[_24547 + floor32(mem[_24547]) + -(mem[_24547] % 32) + 64 len mem[_24547] % 32]
                            call address(totemLpSupplies[arg1 << 248].field_16) with:
                                 gas gas_remaining wei
                                args mem[_24546 + 168 len _24720 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeBEP20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[_24546 + 274 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24546 + 265 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24546 + 265 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24546 + 265 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                            else:
                                mem[_24546 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeBEP20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_24546 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[_24546 + ceil32(return_data.size) + 275 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_24546 + ceil32(return_data.size) + 266 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_24546 + ceil32(return_data.size) + 266 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[_24546 + ceil32(return_data.size) + 266 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                else:
                    if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_1280 != totemLpSupplies[arg1 << 248].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_1536 += 0 / totemLpSupplies[arg1 << 248].field_1024
                        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_2048 = (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048
                        idx = 0
                        while uint8(idx) < totemLpSupplies[arg1 << 248].field_2304:
                            require uint8(idx) < totemLpSupplies[arg1 << 248].field_1792
                            if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totemLpSupplies[arg1 << 248].field_1024
                                require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                                if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                                mem[0] = sha3(arg1 << 248, 7) + 9
                                stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                            else:
                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totemLpSupplies[arg1 << 248].field_1024
                                require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                                if ((block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(idx) < totemLpSupplies[arg1 << 248].field_2304
                                mem[0] = sha3(arg1 << 248, 7) + 9
                                stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0 += (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(idx)].field_0) / totemLpSupplies[arg1 << 248].field_1024
                            idx = idx + 1
                            continue 
                        totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
                        mem[0] = uint8(totemLpSupplies[arg1 << 248].field_0)
                        mem[32] = 6
                        if not stor6[uint8(stor7[arg1 << 248].field_0)]:
                            revert with 0, 'nPool doesnt exist'
                        mem[100] = 4
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        mem[96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= totemLpSupplies[arg1 << 248].field_2816:
                            if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                revert with 0, 'Address: call to non-contract'
                            mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                            mem[324 len 0] = 0
                            call address(totemLpSupplies[arg1 << 248].field_16) with:
                                 gas gas_remaining wei
                                args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                    revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                            else:
                                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeBEP20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[292]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[ceil32(return_data.size) + 371 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                        else:
                            if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                    revert with 0, 'Address: call to non-contract'
                                mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                mem[324 len 0] = 0
                                call address(totemLpSupplies[arg1 << 248].field_16) with:
                                     gas gas_remaining wei
                                    args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                    if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                        revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                                else:
                                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeBEP20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[292]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                        mem[ceil32(return_data.size) + 371 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[ceil32(return_data.size) + 362 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[ceil32(return_data.size) + 362 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                            else:
                                idx = sub_76fa17d2[arg1 << 248][address(arg3)].field_0
                                while idx < ext_call.return_data[0]:
                                    mem[mem[64] + 4] = 4
                                    mem[mem[64] + 36] = idx
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xcb4b3022 with:
                                            gas gas_remaining wei
                                           args 4, idx
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg3
                                    mem[32] = 9
                                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                                        _24650 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24650] = 0
                                        mem[_24650 + 32] = 0
                                        mem[_24650 + 64] = 0
                                        mem[0] = idx
                                        mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                                        _24663 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24663] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                                        mem[_24663 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                                        mem[_24663 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                                        if idx != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        else:
                                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            else:
                                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    idx = idx + 1
                                    continue 
                                _24542 = mem[64]
                                mem[mem[64] + 36] = arg3
                                mem[mem[64] + 68] = 0
                                _24543 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_24542 + 100] = 32
                                mem[_24542 + 132] = 'SafeBEP20: low-level call failed'
                                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                    revert with 0, 'Address: call to non-contract'
                                _24703 = mem[_24543]
                                mem[_24542 + 164 len floor32(mem[_24543])] = mem[_24543 + 32 len floor32(mem[_24543])]
                                mem[_24542 + floor32(mem[_24543]) + -(mem[_24543] % 32) + 196 len mem[_24543] % 32] = mem[_24543 + floor32(mem[_24543]) + -(mem[_24543] % 32) + 64 len mem[_24543] % 32]
                                call address(totemLpSupplies[arg1 << 248].field_16) with:
                                     gas gas_remaining wei
                                    args mem[_24542 + 168 len _24703 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeBEP20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                        mem[_24542 + 274 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24542 + 265 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24542 + 265 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24542 + 265 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                                else:
                                    mem[_24542 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeBEP20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_24542 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                        mem[_24542 + ceil32(return_data.size) + 275 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_24542 + ceil32(return_data.size) + 266 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_24542 + ceil32(return_data.size) + 266 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_24542 + ceil32(return_data.size) + 266 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                    else:
                        if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[arg1 << 248].field_1024
                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_1536 += (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024
                        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[arg1 << 248].field_2048 = (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048
                        if uint8(var63001) < totemLpSupplies[arg1 << 248].field_2304:
                            require uint8(var63001) < totemLpSupplies[arg1 << 248].field_1792
                            if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totemLpSupplies[arg1 << 248].field_1024
                                require uint8(var63001) < totemLpSupplies[arg1 << 248].field_2304
                                if (0 / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(var63001) < totemLpSupplies[arg1 << 248].field_2304
                                mem[0] = sha3(arg1 << 248, 7) + 9
                                stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0 += 0 / totemLpSupplies[arg1 << 248].field_1024
                            else:
                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totemLpSupplies[arg1 << 248].field_1024
                                require uint8(var63001) < totemLpSupplies[arg1 << 248].field_2304
                                if ((block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0) / totemLpSupplies[arg1 << 248].field_1024) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(var63001) < totemLpSupplies[arg1 << 248].field_2304
                                mem[0] = sha3(arg1 << 248, 7) + 9
                                stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0 += (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + uint8(var63001)].field_0) / totemLpSupplies[arg1 << 248].field_1024
                            var63001 = var63001 + 1
                            continue 
                        totemLpSupplies[arg1 << 248].field_1280 = block.timestamp
                        mem[0] = uint8(totemLpSupplies[arg1 << 248].field_0)
                        mem[32] = 6
                        if not stor6[uint8(stor7[arg1 << 248].field_0)]:
                            revert with 0, 'nPool doesnt exist'
                        mem[100] = 4
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        mem[96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= totemLpSupplies[arg1 << 248].field_2816:
                            if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                revert with 0, 'Address: call to non-contract'
                            mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                            mem[324 len 0] = 0
                            call address(totemLpSupplies[arg1 << 248].field_16) with:
                                 gas gas_remaining wei
                                args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                    revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                            else:
                                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeBEP20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[292]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                    mem[ceil32(return_data.size) + 371 len 22]
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                    else:
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[ceil32(return_data.size) + 362 len 31]
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                        else:
                            if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                    revert with 0, 'Address: call to non-contract'
                                mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                mem[324 len 0] = 0
                                call address(totemLpSupplies[arg1 << 248].field_16) with:
                                     gas gas_remaining wei
                                    args Mask(480, -256, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0) << 256, mem[324 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, 0
                                    if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                                        revert with 0, 32, 42, 0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500, mem[370 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[361 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                                else:
                                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeBEP20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[292]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                        mem[ceil32(return_data.size) + 371 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[ceil32(return_data.size) + 362 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[ceil32(return_data.size) + 362 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[ceil32(return_data.size) + 362 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                            else:
                                idx = sub_76fa17d2[arg1 << 248][address(arg3)].field_0
                                while idx < ext_call.return_data[0]:
                                    mem[mem[64] + 4] = 4
                                    mem[mem[64] + 36] = idx
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xcb4b3022 with:
                                            gas gas_remaining wei
                                           args 4, idx
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg3
                                    mem[32] = 9
                                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg3)]:
                                        _24649 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24649] = 0
                                        mem[_24649 + 32] = 0
                                        mem[_24649 + 64] = 0
                                        mem[0] = idx
                                        mem[32] = sha3(uint8(totemLpSupplies[arg1 << 248].field_0), 10)
                                        _24656 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24656] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0
                                        mem[_24656 + 32] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256
                                        mem[_24656 + 64] = sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512
                                        if idx != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_512:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        else:
                                            if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            else:
                                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg3)].field_768 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg3)].field_512 * sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_768 + (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 != sub_057a3048[uint8(stor7[arg1 << 248].field_0)][idx].field_256:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    idx = idx + 1
                                    continue 
                                _24538 = mem[64]
                                mem[mem[64] + 36] = arg3
                                mem[mem[64] + 68] = 0
                                _24539 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_24538 + 100] = 32
                                mem[_24538 + 132] = 'SafeBEP20: low-level call failed'
                                if not ext_code.size(address(totemLpSupplies[arg1 << 248].field_16)):
                                    revert with 0, 'Address: call to non-contract'
                                _24686 = mem[_24539]
                                mem[_24538 + 164 len floor32(mem[_24539])] = mem[_24539 + 32 len floor32(mem[_24539])]
                                mem[_24538 + floor32(mem[_24539]) + -(mem[_24539] % 32) + 196 len mem[_24539] % 32] = mem[_24539 + floor32(mem[_24539]) + -(mem[_24539] % 32) + 64 len mem[_24539] % 32]
                                call address(totemLpSupplies[arg1 << 248].field_16) with:
                                     gas gas_remaining wei
                                    args mem[_24538 + 168 len _24686 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeBEP20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                        mem[_24538 + 274 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24538 + 265 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24538 + 265 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_24538 + 265 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
                                else:
                                    mem[_24538 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeBEP20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_24538 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x5361666542455032303a204245503230206f7065726174696f6e20646964206e6f742073756363656500,
                                                        mem[_24538 + ceil32(return_data.size) + 275 len 22]
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg3)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = 0
                                        else:
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_24538 + ceil32(return_data.size) + 266 len 31]
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256) / 10^12
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if -sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 -= sub_76fa17d2[arg1 << 248][address(arg3)].field_512
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_24538 + ceil32(return_data.size) + 266 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg3)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768 < sub_76fa17d2[arg1 << 248][address(arg3)].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_76fa17d2[arg1 << 248][address(arg3)].field_768 = (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg3)].field_512 + sub_76fa17d2[arg1 << 248][address(arg3)].field_768
                                    sub_76fa17d2[arg1 << 248][address(arg3)].field_256 -= arg2
                                    if not sub_76fa17d2[arg1 << 248][address(arg3)].field_256:
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = 0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / sub_76fa17d2[arg1 << 248][address(arg3)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_24538 + ceil32(return_data.size) + 266 len 31]
                                        sub_76fa17d2[arg1 << 248][address(arg3)].field_512 = totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg3)].field_256 / 10^12
    sub_76fa17d2[arg1 << 248][address(arg3)].field_0 = ext_call.return_data[0]
    require ext_code.size(summitAddress)
    call summitAddress.0xa9059cbb with:
         gas gas_remaining wei
        args address(arg3), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require selectedTotem[address(arg3)] < totemLpSupplies[arg1 << 248].field_1792
    if arg2 > stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg3)]].field_0:
        revert with 0, 'SafeMath: subtraction overflow'
    require selectedTotem[address(arg3)] < totemLpSupplies[arg1 << 248].field_1792
    stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg3)]].field_0 -= arg2
    if arg2 > totemLpSupplies[arg1 << 248].field_1024:
        revert with 0, 'SafeMath: subtraction overflow'
    totemLpSupplies[arg1 << 248].field_1024 -= arg2
    require ext_code.size(stor4)
    staticcall stor4.0x8b02ea7b with:
            gas gas_remaining wei
           args 4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    sub_76fa17d2[arg1 << 248][address(arg3)].field_0 = ext_call.return_data[0]
    stor1 = 1
    return arg2
}

function hypotheticalRewards(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if not stor6[arg1 << 248]:
        revert with 0, 'nPool doesnt exist'
    if not arg2:
        revert with 0, 'User address is zero'
    if totemLpSupplies[arg1 << 248].field_1792:
        idx = 1024
        s = 0
        while (32 * totemLpSupplies[arg1 << 248].field_1792) + 992 > idx:
            mem[idx + 32] = totemLpSupplies[arg1 << 248][s + 7].field_256
            idx = idx + 32
            s = s + 1
            continue 
    if totemLpSupplies[arg1 << 248].field_2304:
        idx = (32 * totemLpSupplies[arg1 << 248].field_1792) + 1056
        s = 0
        while (32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1024 > idx:
            mem[idx + 32] = totemLpSupplies[arg1 << 248][s + 9].field_256
            idx = idx + 32
            s = s + 1
            continue 
    if block.timestamp <= totemLpSupplies[arg1 << 248].field_1280:
        if not stor6[arg1 << 248]:
            revert with 0, 'nPool doesnt exist'
        if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
            revert with 0, 'SafeMath: addition overflow'
        if not totemLpSupplies[arg1 << 248].field_1024:
            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                require ext_code.size(stor4)
                staticcall stor4.0x8b02ea7b with:
                        gas gas_remaining wei
                       args 4
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        return 0
                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                    if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                        return 0
                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                        return 0
                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                        return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                               (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                    if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                            return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                    else:
                        if totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                            return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                   totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            return 0
                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                            return 0
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                        else:
                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                    else:
                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            return 0
                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                            return 0
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                        else:
                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
        else:
            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                if 0 == stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                        require ext_code.size(stor4)
                        staticcall stor4.0x8b02ea7b with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                return 0
                            if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                            if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                return 0
                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return 0
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                            if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            else:
                                if totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return 0
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            else:
                                if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return 0
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                        ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                else:
                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if totemLpSupplies[arg1 << 248].field_1024:
                            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        return 0
                                    if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
    else:
        if totemLpSupplies[arg1 << 248].field_1024 <= 0:
            if not stor6[arg1 << 248]:
                revert with 0, 'nPool doesnt exist'
            if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                revert with 0, 'SafeMath: addition overflow'
            if not totemLpSupplies[arg1 << 248].field_1024:
                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                    require ext_code.size(stor4)
                    staticcall stor4.0x8b02ea7b with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            return 0
                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                        if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                            return 0
                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                            return 0
                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                            return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                   (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                        if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                        else:
                            if totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                return 0
                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return 0
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                        else:
                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                return 0
                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                return 0
                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                    ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
            else:
                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                    if 0 == stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                        if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    return 0
                                if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    return 0
                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return 0
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                    else:
                        if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if totemLpSupplies[arg1 << 248].field_1024:
                                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                            return 0
                                        if (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       totemLpSupplies[arg1 << 248].field_2048 * (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return 0
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return 0
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
        else:
            if totemLpSupplies[arg1 << 248].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - totemLpSupplies[arg1 << 248].field_1280:
                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                if totemLpSupplies[arg1 << 248].field_1024:
                    if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    if not stor6[arg1 << 248]:
                        revert with 0, 'nPool doesnt exist'
                    if totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                        revert with 0, 'SafeMath: addition overflow'
                    if not totemLpSupplies[arg1 << 248].field_1024:
                        if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                            require ext_code.size(stor4)
                            staticcall stor4.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    return 0
                                if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    return 0
                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    return 0
                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                    else:
                        if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                            if 0 == stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x8b02ea7b with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                            return 0
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return 0
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return 0
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                            else:
                                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                                    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if totemLpSupplies[arg1 << 248].field_1024:
                                        if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require ext_code.size(stor4)
                                            staticcall stor4.0x8b02ea7b with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                    return 0
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return 0
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                else:
                                                    if totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != totemLpSupplies[arg1 << 248].field_2048:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return 0
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                else:
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return 0
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != totemLpSupplies[arg1 << 248].field_2048:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
            else:
                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / block.timestamp - totemLpSupplies[arg1 << 248].field_1280 != totemLpSupplies[arg1 << 248].field_768:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    if totemLpSupplies[arg1 << 248].field_1024:
                        if (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor6[arg1 << 248]:
                            revert with 0, 'nPool doesnt exist'
                        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        if not totemLpSupplies[arg1 << 248].field_1024:
                            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        return 0
                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                        else:
                            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                                if 0 == stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x8b02ea7b with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                return 0
                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return 0
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return 0
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return 0
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                                else:
                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                                        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if totemLpSupplies[arg1 << 248].field_1024:
                                                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require ext_code.size(stor4)
                                                    staticcall stor4.0x8b02ea7b with:
                                                            gas gas_remaining wei
                                                           args 4
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                            return 0
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            return 0
                                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            return 0
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                            return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                   (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                    else:
                                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
                                        else:
                                            if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if totemLpSupplies[arg1 << 248].field_1024:
                                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require ext_code.size(stor4)
                                                        staticcall stor4.0x8b02ea7b with:
                                                                gas gas_remaining wei
                                                               args 4
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
                                            else:
                                                if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if totemLpSupplies[arg1 << 248].field_1024:
                                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require ext_code.size(stor4)
                                                        staticcall stor4.0x8b02ea7b with:
                                                                gas gas_remaining wei
                                                               args 4
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + ((0 / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        ('iszero', ('add', ('div', ('div', ('add', ('mul', 1000000000000, 'timestamp', ('field', 768, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7)))), ('field', 0, ('stor', ('add', ('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))), ('mul', -1000000000000, ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7)))), ('field', 768, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7)))), ('field', 0, ('stor', ('add', ('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))), ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
                else:
                    if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                    if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    if totemLpSupplies[arg1 << 248].field_1024:
                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 < totemLpSupplies[arg1 << 248].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor6[arg1 << 248]:
                            revert with 0, 'nPool doesnt exist'
                        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048 < totemLpSupplies[arg1 << 248].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        if not totemLpSupplies[arg1 << 248].field_1024:
                            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                require ext_code.size(stor4)
                                staticcall stor4.0x8b02ea7b with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        return 0
                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                    if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                        return 0
                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                        return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                    else:
                                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                            return 0
                                        if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                        else:
                            if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                                if 0 == stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x8b02ea7b with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                return 0
                                            if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                return 0
                                            if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        else:
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return 0
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                            else:
                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    return 0
                                                if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))
                                else:
                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_1792:
                                        if not (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                                            if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if totemLpSupplies[arg1 << 248].field_1024:
                                                if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require ext_code.size(stor4)
                                                    staticcall stor4.0x8b02ea7b with:
                                                            gas gas_remaining wei
                                                           args 4
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                        if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                            return 0
                                                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                        if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            return 0
                                                        if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            return 0
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                            return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                   ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                        if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                    else:
                                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
                                        else:
                                            if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                            if not (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768):
                                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if totemLpSupplies[arg1 << 248].field_1024:
                                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                                        if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require ext_code.size(stor4)
                                                        staticcall stor4.0x8b02ea7b with:
                                                                gas gas_remaining wei
                                                               args 4
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                return 0
                                                            if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / (0 / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        ('iszero', ('add', ('div', ('div', 0, ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
                                            else:
                                                if (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / (10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) != stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                if totemLpSupplies[arg1 << 248].field_1024 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if totemLpSupplies[arg1 << 248].field_1024:
                                                    if selectedTotem[address(arg2)] < totemLpSupplies[arg1 << 248].field_2304:
                                                        if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 < stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require ext_code.size(stor4)
                                                        staticcall stor4.0x8b02ea7b with:
                                                                gas gas_remaining wei
                                                               args 4
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                                            if sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                return 0
                                                            if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536 - sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                return 0
                                                            if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (block.timestamp * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (totemLpSupplies[arg1 << 248].field_2048 * ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[uint8(stor7[arg1 << 248].field_0)][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        else:
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                            else:
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024) + totemLpSupplies[arg1 << 248].field_1536:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                    return 0
                                                                if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != (block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + totemLpSupplies[arg1 << 248].field_2048:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * totemLpSupplies[arg1 << 248].field_1792) + (32 * totemLpSupplies[arg1 << 248].field_2304) + 1157 len 31]
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) - (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * totemLpSupplies[arg1 << 248].field_2048) + (((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768) / totemLpSupplies[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (totemLpSupplies[arg1 << 248].field_1536 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * totemLpSupplies[arg1 << 248].field_2048) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * totemLpSupplies[arg1 << 248].field_2048) / ((10^12 * block.timestamp * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) - (10^12 * totemLpSupplies[arg1 << 248].field_1280 * totemLpSupplies[arg1 << 248].field_768 * stor[('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0) / totemLpSupplies[arg1 << 248].field_1024 / 10^12) + stor[('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))) + stor9[address(arg2)]].field_0
                                                        ('iszero', ('add', ('div', ('div', ('add', ('mul', 1000000000000, 'timestamp', ('field', 768, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7)))), ('field', 0, ('stor', ('add', ('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))), ('mul', -1000000000000, ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7)))), ('field', 768, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7)))), ('field', 0, ('stor', ('add', ('array', 7, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9)))))))), ('field', 1024, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 9, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'totemLpSupplies', 7))), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor9', 9))))))))
    revert
}

function rollover(uint8 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor3 != msg.sender:
        revert with 0, 'rOnly cartographer'
    mem[100] = 4
    require ext_code.size(stor4)
    staticcall stor4.0x8b02ea7b with:
            gas gas_remaining wei
           args 4
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    idx = 0
    while uint8(idx) < stor5.length:
        if not uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8):
            mem[0] = stor('array', ('mask_shl', 3, 5, -5, ('var', 0)), ('name', 'stor5', 5))[uint8(idx)]
            mem[32] = 7
            if ext_call.return_data[0] + 1 >= totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816:
                mem[0] = stor('array', ('mask_shl', 3, 5, -5, ('var', 0)), ('name', 'stor5', 5))[uint8(idx)]
                mem[32] = 7
                uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 1
                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2560 = block.timestamp
        else:
            if not stor6[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)]:
                revert with 0, 'nPool doesnt exist'
            if not uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8):
                revert with 0, 'Pool not available yet'
            if block.timestamp == totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280:
                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                if sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 36] = ext_call.return_data[0]
                require ext_code.size(stor4)
                staticcall stor4.0xcb4b3022 with:
                        gas gas_remaining wei
                       args 4, ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require uint8(ext_call.return_data[0]) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                if not stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                    _1249 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_1249] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                    mem[_1249 + 32] = 0
                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                        mem[_1249 + 64] = 0
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1360 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1376 = mem[_1360]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1360]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1376:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1360 + 32
                                    while _1360 + (32 * _1376) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1376) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1360 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1394 = mem[_1360]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1360]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1394:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1360 + 32
                                    while _1360 + (32 * _1394) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1394) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1377 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1395 = mem[_1377]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1377]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1395:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1377 + 32
                                    while _1377 + (32 * _1395) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1395) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1377 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1413 = mem[_1377]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1377]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1413:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1377 + 32
                                    while _1377 + (32 * _1413) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1413) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                    else:
                        if 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        mem[_1249 + 64] = 0
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1374 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1391 = mem[_1374]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1374]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1391:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1374 + 32
                                    while _1374 + (32 * _1391) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1391) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1374 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1409 = mem[_1374]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1374]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1409:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1374 + 32
                                    while _1374 + (32 * _1409) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1409) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1392 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1410 = mem[_1392]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1392]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1410:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1392 + 32
                                    while _1392 + (32 * _1410) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1410) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1392 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1430 = mem[_1392]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1392]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1430:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1392 + 32
                                    while _1392 + (32 * _1430) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1430) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                    idx = idx + 1
                    continue 
                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                    if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                    _1288 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_1288] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                    mem[_1288 + 32] = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                        mem[_1288 + 64] = 0
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1591 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1622 = mem[_1591]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1591]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1622:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1591 + 32
                                    while _1591 + (32 * _1622) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1622) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1591 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1654 = mem[_1591]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1591]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1654:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1591 + 32
                                    while _1591 + (32 * _1654) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1654) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1623 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1655 = mem[_1623]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1623]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1655:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1623 + 32
                                    while _1623 + (32 * _1655) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1655) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1623 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1689 = mem[_1623]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1623]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1689:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1623 + 32
                                    while _1623 + (32 * _1689) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1689) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                    else:
                        if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        mem[_1288 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1620 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1651 = mem[_1620]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1620]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1651:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1620 + 32
                                    while _1620 + (32 * _1651) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1651) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1620 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1685 = mem[_1620]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1620]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1685:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1620 + 32
                                    while _1620 + (32 * _1685) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1685) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1652 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1686 = mem[_1652]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1652]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1686:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1652 + 32
                                    while _1652 + (32 * _1686) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1686) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1652 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1719 = mem[_1652]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1652]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1719:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1652 + 32
                                    while _1652 + (32 * _1719) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1719) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                    idx = idx + 1
                    continue 
                if 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 != 10^12:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                _1300 = mem[64]
                mem[64] = mem[64] + 96
                mem[_1300] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                mem[_1300 + 32] = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                    mem[_1300 + 64] = 0
                    mem[0] = ext_call.return_data[0]
                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                        mem[mem[64] + 4] = 4
                        require ext_code.size(stor4)
                        staticcall stor4.0xc416fa18 with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require uint8(ext_call.return_data[0]) <= test266151307()
                        _1618 = mem[64]
                        mem[mem[64]] = uint8(ext_call.return_data[0])
                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                        if not uint8(ext_call.return_data[0]):
                            _1649 = mem[_1618]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1618]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1649:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1618 + 32
                                while _1618 + (32 * _1649) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1649) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                        else:
                            mem[_1618 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                            _1682 = mem[_1618]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1618]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1682:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1618 + 32
                                while _1618 + (32 * _1682) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1682) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                        mem[mem[64] + 4] = 4
                        require ext_code.size(stor4)
                        staticcall stor4.0xc416fa18 with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require uint8(ext_call.return_data[0]) <= test266151307()
                        _1650 = mem[64]
                        mem[mem[64]] = uint8(ext_call.return_data[0])
                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                        if not uint8(ext_call.return_data[0]):
                            _1683 = mem[_1650]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1650]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1683:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1650 + 32
                                while _1650 + (32 * _1683) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1683) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                        else:
                            mem[_1650 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                            _1716 = mem[_1650]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1650]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1716:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1650 + 32
                                while _1650 + (32 * _1716) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1716) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                    idx = idx + 1
                    continue 
                if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                mem[_1300 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                mem[0] = ext_call.return_data[0]
                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                    mem[mem[64] + 4] = 4
                    require ext_code.size(stor4)
                    staticcall stor4.0xc416fa18 with:
                            gas gas_remaining wei
                           args 4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require uint8(ext_call.return_data[0]) <= test266151307()
                    _1647 = mem[64]
                    mem[mem[64]] = uint8(ext_call.return_data[0])
                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                    if not uint8(ext_call.return_data[0]):
                        _1679 = mem[_1647]
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1647]
                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                        if not _1679:
                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            s = _1647 + 32
                            while _1647 + (32 * _1679) + 32 > s:
                                stor[t] = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1679) + 31) >> 5)
                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    else:
                        mem[_1647 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                        _1712 = mem[_1647]
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1647]
                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                        if not _1712:
                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            s = _1647 + 32
                            while _1647 + (32 * _1712) + 32 > s:
                                stor[t] = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1712) + 31) >> 5)
                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    idx = idx + 1
                    continue 
                uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                mem[mem[64] + 4] = 4
                require ext_code.size(stor4)
                staticcall stor4.0xc416fa18 with:
                        gas gas_remaining wei
                       args 4
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require uint8(ext_call.return_data[0]) <= test266151307()
                _1680 = mem[64]
                mem[mem[64]] = uint8(ext_call.return_data[0])
                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                if not uint8(ext_call.return_data[0]):
                    _1713 = mem[_1680]
                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1680]
                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                    if not _1713:
                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                    else:
                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                        s = _1680 + 32
                        while _1680 + (32 * _1713) + 32 > s:
                            stor[t] = mem[s]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1713) + 31) >> 5)
                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                    idx = idx + 1
                    continue 
                mem[_1680 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                _1750 = mem[_1680]
                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1680]
                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                if not _1750:
                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                    idx = idx + 1
                    continue 
                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                s = _1680 + 32
                while _1680 + (32 * _1750) + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1750) + 31) >> 5)
                while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                continue 
            if not uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8):
                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 = block.timestamp
                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                if sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 36] = ext_call.return_data[0]
                require ext_code.size(stor4)
                staticcall stor4.0xcb4b3022 with:
                        gas gas_remaining wei
                       args 4, ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require uint8(ext_call.return_data[0]) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                if not stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                    _1253 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_1253] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                    mem[_1253 + 32] = 0
                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                        mem[_1253 + 64] = 0
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1380 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1398 = mem[_1380]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1380]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1398:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1380 + 32
                                    while _1380 + (32 * _1398) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1398) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1380 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1422 = mem[_1380]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1380]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1422:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1380 + 32
                                    while _1380 + (32 * _1422) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1422) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1399 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1423 = mem[_1399]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1399]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1423:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1399 + 32
                                    while _1399 + (32 * _1423) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1423) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1399 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1449 = mem[_1399]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1399]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1449:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1399 + 32
                                    while _1399 + (32 * _1449) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1449) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                    else:
                        if 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        mem[_1253 + 64] = 0
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1396 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1419 = mem[_1396]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1396]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1419:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1396 + 32
                                    while _1396 + (32 * _1419) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1419) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1396 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1445 = mem[_1396]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1396]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1445:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1396 + 32
                                    while _1396 + (32 * _1445) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1445) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1420 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1446 = mem[_1420]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1420]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1446:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1420 + 32
                                    while _1420 + (32 * _1446) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1446) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                mem[_1420 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1476 = mem[_1420]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1420]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1476:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1420 + 32
                                    while _1420 + (32 * _1476) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1476) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                else:
                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                        if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        _1306 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_1306] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        mem[_1306 + 32] = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                            mem[_1306 + 64] = 0
                            mem[0] = ext_call.return_data[0]
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                            if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1630 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1662 = mem[_1630]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1630]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1662:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1630 + 32
                                        while _1630 + (32 * _1662) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1662) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    mem[_1630 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1697 = mem[_1630]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1630]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1697:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1630 + 32
                                        while _1630 + (32 * _1697) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1697) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                idx = idx + 1
                                continue 
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1663 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1698 = mem[_1663]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1663]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1698:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1663 + 32
                                    while _1663 + (32 * _1698) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1698) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                idx = idx + 1
                                continue 
                            mem[_1663 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                            _1731 = mem[_1663]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1663]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1731:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                                idx = idx + 1
                                continue 
                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            s = _1663 + 32
                            while _1663 + (32 * _1731) + 32 > s:
                                stor[t] = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1731) + 31) >> 5)
                            while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                            continue 
                        if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        mem[_1306 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                        mem[0] = ext_call.return_data[0]
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1660 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1694 = mem[_1660]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1660]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1694:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1660 + 32
                                    while _1660 + (32 * _1694) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1694) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                idx = idx + 1
                                continue 
                            mem[_1660 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                            _1727 = mem[_1660]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1660]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1727:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                                idx = idx + 1
                                continue 
                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            s = _1660 + 32
                            while _1660 + (32 * _1727) + 32 > s:
                                stor[t] = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1727) + 31) >> 5)
                            while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                            continue 
                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                        mem[mem[64] + 4] = 4
                        require ext_code.size(stor4)
                        staticcall stor4.0xc416fa18 with:
                                gas gas_remaining wei
                               args 4
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require uint8(ext_call.return_data[0]) <= test266151307()
                        _1695 = mem[64]
                        mem[mem[64]] = uint8(ext_call.return_data[0])
                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                        if not uint8(ext_call.return_data[0]):
                            _1728 = mem[_1695]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1695]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1728:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                                idx = idx + 1
                                continue 
                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            s = _1695 + 32
                            while _1695 + (32 * _1728) + 32 > s:
                                stor[t] = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1728) + 31) >> 5)
                            while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                            continue 
                        mem[_1695 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                        _1762 = mem[_1695]
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1695]
                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                        if not _1762:
                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                            s = _1695 + 32
                            while _1695 + (32 * _1762) + 32 > s:
                                stor[t] = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1762) + 31) >> 5)
                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    else:
                        if 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 != 10^12:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        _1318 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_1318] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        mem[_1318 + 32] = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                        if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                            mem[_1318 + 64] = 0
                            mem[0] = ext_call.return_data[0]
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                            if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1658 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1692 = mem[_1658]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1658]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1692:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1658 + 32
                                        while _1658 + (32 * _1692) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1692) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    idx = idx + 1
                                    continue 
                                mem[_1658 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1724 = mem[_1658]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1658]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1724:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1658 + 32
                                while _1658 + (32 * _1724) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1724) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                continue 
                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                            mem[mem[64] + 4] = 4
                            require ext_code.size(stor4)
                            staticcall stor4.0xc416fa18 with:
                                    gas gas_remaining wei
                                   args 4
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) <= test266151307()
                            _1693 = mem[64]
                            mem[mem[64]] = uint8(ext_call.return_data[0])
                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                            if not uint8(ext_call.return_data[0]):
                                _1725 = mem[_1693]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1693]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1725:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1693 + 32
                                while _1693 + (32 * _1725) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1725) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                continue 
                            mem[_1693 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                            _1759 = mem[_1693]
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1693]
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not _1759:
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                s = _1693 + 32
                                while _1693 + (32 * _1759) + 32 > s:
                                    stor[t] = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1759) + 31) >> 5)
                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                    stor[s] = 0
                                    s = s + 1
                                    continue 
                        else:
                            if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            mem[_1318 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                            mem[0] = ext_call.return_data[0]
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                            if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1690 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1721 = mem[_1690]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1690]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1721:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                        idx = idx + 1
                                        continue 
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1690 + 32
                                    while _1690 + (32 * _1721) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1721) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                    continue 
                                mem[_1690 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1755 = mem[_1690]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1690]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1755:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1690 + 32
                                    while _1690 + (32 * _1755) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1755) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1722 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1756 = mem[_1722]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1722]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1756:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1722 + 32
                                        while _1722 + (32 * _1756) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1756) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    mem[_1722 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1787 = mem[_1722]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1722]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1787:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1722 + 32
                                        while _1722 + (32 * _1787) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1787) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
            else:
                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024:
                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 = block.timestamp
                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                    if sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[mem[64] + 36] = ext_call.return_data[0]
                    require ext_code.size(stor4)
                    staticcall stor4.0xcb4b3022 with:
                            gas gas_remaining wei
                           args 4, ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require uint8(ext_call.return_data[0]) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                    if not stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                        _1254 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_1254] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                        mem[_1254 + 32] = 0
                        if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                            mem[_1254 + 64] = 0
                            mem[0] = ext_call.return_data[0]
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                            if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1404 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1426 = mem[_1404]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1404]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1426:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1404 + 32
                                        while _1404 + (32 * _1426) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1426) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    mem[_1404 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1459 = mem[_1404]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1404]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1459:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1404 + 32
                                        while _1404 + (32 * _1459) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1459) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1427 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1460 = mem[_1427]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1427]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1460:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1427 + 32
                                        while _1427 + (32 * _1460) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1460) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    mem[_1427 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1499 = mem[_1427]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1427]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1499:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1427 + 32
                                        while _1427 + (32 * _1499) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1499) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                        else:
                            if 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            mem[_1254 + 64] = 0
                            mem[0] = ext_call.return_data[0]
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                            sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                            if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1424 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1456 = mem[_1424]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1424]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1456:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1424 + 32
                                        while _1424 + (32 * _1456) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1456) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    mem[_1424 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1495 = mem[_1424]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1424]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1495:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1424 + 32
                                        while _1424 + (32 * _1495) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1495) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1457 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1496 = mem[_1457]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1457]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1496:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1457 + 32
                                        while _1457 + (32 * _1496) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1496) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    mem[_1457 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1534 = mem[_1457]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1457]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1534:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1457 + 32
                                        while _1457 + (32 * _1534) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1534) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                    else:
                        if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                            if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            _1326 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_1326] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            mem[_1326 + 32] = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                mem[_1326 + 64] = 0
                                mem[0] = ext_call.return_data[0]
                                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1677 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1709 = mem[_1677]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1677]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1709:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1677 + 32
                                            while _1677 + (32 * _1709) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1709) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        idx = idx + 1
                                        continue 
                                    mem[_1677 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1746 = mem[_1677]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1677]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1746:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                        idx = idx + 1
                                        continue 
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1677 + 32
                                    while _1677 + (32 * _1746) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1746) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                    continue 
                                uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                mem[mem[64] + 4] = 4
                                require ext_code.size(stor4)
                                staticcall stor4.0xc416fa18 with:
                                        gas gas_remaining wei
                                       args 4
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require uint8(ext_call.return_data[0]) <= test266151307()
                                _1710 = mem[64]
                                mem[mem[64]] = uint8(ext_call.return_data[0])
                                mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                if not uint8(ext_call.return_data[0]):
                                    _1747 = mem[_1710]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1710]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1747:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                        idx = idx + 1
                                        continue 
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1710 + 32
                                    while _1710 + (32 * _1747) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1747) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                    continue 
                                mem[_1710 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                _1779 = mem[_1710]
                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1710]
                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                if not _1779:
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                    s = _1710 + 32
                                    while _1710 + (32 * _1779) + 32 > s:
                                        stor[t] = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1779) + 31) >> 5)
                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                        stor[s] = 0
                                        s = s + 1
                                        continue 
                            else:
                                if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                mem[_1326 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                mem[0] = ext_call.return_data[0]
                                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1707 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1743 = mem[_1707]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1707]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1743:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                            idx = idx + 1
                                            continue 
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1707 + 32
                                        while _1707 + (32 * _1743) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1743) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                        continue 
                                    mem[_1707 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1775 = mem[_1707]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1707]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1775:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1707 + 32
                                        while _1707 + (32 * _1775) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1775) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1744 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1776 = mem[_1744]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1744]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1776:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1744 + 32
                                            while _1744 + (32 * _1776) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1776) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_1744 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _1802 = mem[_1744]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1744]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1802:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1744 + 32
                                            while _1744 + (32 * _1802) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1802) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        else:
                            if 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 != 10^12:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            _1343 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_1343] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            mem[_1343 + 32] = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                            if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                mem[_1343 + 64] = 0
                                mem[0] = ext_call.return_data[0]
                                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1705 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1741 = mem[_1705]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1705]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1741:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                            idx = idx + 1
                                            continue 
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1705 + 32
                                        while _1705 + (32 * _1741) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1741) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                        continue 
                                    mem[_1705 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                    _1772 = mem[_1705]
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1705]
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    if not _1772:
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1705 + 32
                                        while _1705 + (32 * _1772) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1772) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                                else:
                                    uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1742 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1773 = mem[_1742]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1742]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1773:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1742 + 32
                                            while _1742 + (32 * _1773) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1773) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_1742 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _1799 = mem[_1742]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1742]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1799:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1742 + 32
                                            while _1742 + (32 * _1799) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1799) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                            else:
                                if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                mem[_1343 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                mem[0] = ext_call.return_data[0]
                                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1739 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1769 = mem[_1739]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1739]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1769:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1739 + 32
                                            while _1739 + (32 * _1769) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1769) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_1739 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _1795 = mem[_1739]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1739]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1795:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1739 + 32
                                            while _1739 + (32 * _1795) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1795) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _1770 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _1796 = mem[_1770]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1770]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1796:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _1770 + 32
                                            while _1770 + (32 * _1796) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1796) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_1770 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _1822 = mem[_1770]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_1770]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _1822:
                                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(s) / 32].field_(8 * s % 32) - 248)].field_2304 + 1
                                            continue 
                                        t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                        s = _1770 + 32
                                        while _1770 + (32 * _1822) + 32 > s:
                                            stor[t] = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _1822) + 31) >> 5)
                                        while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                            stor[s] = 0
                                            s = s + 1
                                            continue 
                else:
                    if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280:
                        if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                        if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                        if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                            revert with 0, 'SafeMath: addition overflow'
                        s = 0
                        while uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304:
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                            if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            s = s + 1
                            continue 
                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 = block.timestamp
                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                        if sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[mem[64] + 36] = ext_call.return_data[0]
                        require ext_code.size(stor4)
                        staticcall stor4.0xcb4b3022 with:
                                gas gas_remaining wei
                               args 4, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require uint8(ext_call.return_data[0]) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                        if not stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                            _2527 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_2527] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                            mem[_2527 + 32] = 0
                            if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                mem[_2527 + 64] = 0
                                mem[0] = ext_call.return_data[0]
                                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _2659 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _2673 = mem[_2659]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2659]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2673:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2659 + 32
                                            while _2659 + (32 * _2673) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2673) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_2659 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _2688 = mem[_2659]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2659]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2688:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2659 + 32
                                            while _2659 + (32 * _2688) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2688) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _2674 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _2689 = mem[_2674]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2674]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2689:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2674 + 32
                                            while _2674 + (32 * _2689) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2689) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_2674 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _2717 = mem[_2674]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2674]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2717:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2674 + 32
                                            while _2674 + (32 * _2717) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2717) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                            else:
                                if 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                mem[_2527 + 64] = 0
                                mem[0] = ext_call.return_data[0]
                                mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                                sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _2671 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _2685 = mem[_2671]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2671]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2685:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2671 + 32
                                            while _2671 + (32 * _2685) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2685) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_2671 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _2713 = mem[_2671]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2671]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2713:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2671 + 32
                                            while _2671 + (32 * _2713) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2713) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                else:
                                    uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                    totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                    mem[mem[64] + 4] = 4
                                    require ext_code.size(stor4)
                                    staticcall stor4.0xc416fa18 with:
                                            gas gas_remaining wei
                                           args 4
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require uint8(ext_call.return_data[0]) <= test266151307()
                                    _2686 = mem[64]
                                    mem[mem[64]] = uint8(ext_call.return_data[0])
                                    mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                    if not uint8(ext_call.return_data[0]):
                                        _2714 = mem[_2686]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2686]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2714:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2686 + 32
                                            while _2686 + (32 * _2714) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2714) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                    else:
                                        mem[_2686 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                        _2757 = mem[_2686]
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2686]
                                        mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                        if not _2757:
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                            s = _2686 + 32
                                            while _2686 + (32 * _2757) + 32 > s:
                                                stor[t] = mem[s]
                                                t = t + 1
                                                s = s + 32
                                                continue 
                                            s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2757) + 31) >> 5)
                                            while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                stor[s] = 0
                                                s = s + 1
                                                continue 
                        else:
                            if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                                if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                _2584 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2584] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                mem[_2584 + 32] = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                    mem[_2584 + 64] = 0
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2889 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2913 = mem[_2889]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2889]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2913:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2889 + 32
                                                while _2889 + (32 * _2913) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2913) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2889 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2940 = mem[_2889]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2889]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2940:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2889 + 32
                                                while _2889 + (32 * _2940) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2940) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2914 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2941 = mem[_2914]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2914]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2941:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2914 + 32
                                                while _2914 + (32 * _2941) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2941) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2914 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2974 = mem[_2914]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2914]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2974:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2914 + 32
                                                while _2914 + (32 * _2974) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2974) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                else:
                                    if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    mem[_2584 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2911 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2937 = mem[_2911]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2911]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2937:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2911 + 32
                                                while _2911 + (32 * _2937) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2937) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2911 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2970 = mem[_2911]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2911]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2970:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2911 + 32
                                                while _2911 + (32 * _2970) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2970) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2938 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2971 = mem[_2938]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2938]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2971:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2938 + 32
                                                while _2938 + (32 * _2971) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2971) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2938 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _3003 = mem[_2938]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2938]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _3003:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2938 + 32
                                                while _2938 + (32 * _3003) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _3003) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                            else:
                                if 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 != 10^12:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                _2608 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2608] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                mem[_2608 + 32] = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                    mem[_2608 + 64] = 0
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2909 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2935 = mem[_2909]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2909]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2935:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2909 + 32
                                                while _2909 + (32 * _2935) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2935) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2909 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2967 = mem[_2909]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2909]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2967:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2909 + 32
                                                while _2909 + (32 * _2967) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2967) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2936 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2968 = mem[_2936]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2936]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2968:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2936 + 32
                                                while _2936 + (32 * _2968) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2968) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2936 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _3000 = mem[_2936]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2936]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _3000:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2936 + 32
                                                while _2936 + (32 * _3000) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _3000) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                else:
                                    if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    mem[_2608 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2933 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2964 = mem[_2933]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2933]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2964:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2933 + 32
                                                while _2933 + (32 * _2964) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2964) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2933 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2996 = mem[_2933]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2933]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2996:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2933 + 32
                                                while _2933 + (32 * _2996) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2996) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2965 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2997 = mem[_2965]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2965]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2997:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2965 + 32
                                                while _2965 + (32 * _2997) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2997) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2965 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _3019 = mem[_2965]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2965]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _3019:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2965 + 32
                                                while _2965 + (32 * _3019) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _3019) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                    else:
                        if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / block.timestamp - totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 != totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768):
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                                revert with 0, 'SafeMath: addition overflow'
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048
                            s = 0
                            while uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304:
                                require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                                if not (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768):
                                    if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                else:
                                    if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) != stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    if ((block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                s = s + 1
                                continue 
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 = block.timestamp
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            if sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(stor4)
                            staticcall stor4.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args 4, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                _2525 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2525] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                mem[_2525 + 32] = 0
                                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                    mem[_2525 + 64] = 0
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2653 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2669 = mem[_2653]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2653]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2669:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2653 + 32
                                                while _2653 + (32 * _2669) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2669) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2653 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2683 = mem[_2653]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2653]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2683:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2653 + 32
                                                while _2653 + (32 * _2683) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2683) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2670 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2684 = mem[_2670]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2670]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2684:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2670 + 32
                                                while _2670 + (32 * _2684) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2684) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2670 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2706 = mem[_2670]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2670]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2706:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2670 + 32
                                                while _2670 + (32 * _2706) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2706) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                else:
                                    if 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    mem[_2525 + 64] = 0
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2667 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2680 = mem[_2667]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2667]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2680:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2667 + 32
                                                while _2667 + (32 * _2680) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2680) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2667 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2702 = mem[_2667]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2667]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2702:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2667 + 32
                                                while _2667 + (32 * _2702) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2702) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2681 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2703 = mem[_2681]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2681]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2703:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2681 + 32
                                                while _2681 + (32 * _2703) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2703) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2681 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2741 = mem[_2681]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2681]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2741:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2681 + 32
                                                while _2681 + (32 * _2741) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2741) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                            else:
                                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                                    if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    _2578 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2578] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    mem[_2578 + 32] = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                        mem[_2578 + 64] = 0
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2881 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2905 = mem[_2881]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2881]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2905:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2881 + 32
                                                    while _2881 + (32 * _2905) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2905) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2881 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2931 = mem[_2881]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2881]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2931:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2881 + 32
                                                    while _2881 + (32 * _2931) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2931) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2906 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2932 = mem[_2906]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2906]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2932:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2906 + 32
                                                    while _2906 + (32 * _2932) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2932) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2906 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2963 = mem[_2906]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2906]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2963:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2906 + 32
                                                    while _2906 + (32 * _2963) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2963) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                    else:
                                        if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        mem[_2578 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2903 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2928 = mem[_2903]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2903]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2928:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2903 + 32
                                                    while _2903 + (32 * _2928) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2928) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2903 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2959 = mem[_2903]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2903]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2959:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2903 + 32
                                                    while _2903 + (32 * _2959) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2959) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2929 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2960 = mem[_2929]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2929]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2960:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2929 + 32
                                                    while _2929 + (32 * _2960) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2960) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2929 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2993 = mem[_2929]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2929]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2993:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2929 + 32
                                                    while _2929 + (32 * _2993) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2993) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                else:
                                    if 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 != 10^12:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    _2600 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2600] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    mem[_2600 + 32] = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                        mem[_2600 + 64] = 0
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2901 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2926 = mem[_2901]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2901]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2926:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2901 + 32
                                                    while _2901 + (32 * _2926) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2926) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2901 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2956 = mem[_2901]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2901]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2956:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2901 + 32
                                                    while _2901 + (32 * _2956) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2956) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2927 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2957 = mem[_2927]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2927]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2957:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2927 + 32
                                                    while _2927 + (32 * _2957) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2957) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2927 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2990 = mem[_2927]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2927]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2990:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2927 + 32
                                                    while _2927 + (32 * _2990) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2990) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                    else:
                                        if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        mem[_2600 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2924 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2953 = mem[_2924]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2924]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2953:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2924 + 32
                                                    while _2924 + (32 * _2953) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2953) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2924 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2986 = mem[_2924]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2924]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2986:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2924 + 32
                                                    while _2924 + (32 * _2986) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2986) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2954 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2987 = mem[_2954]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2954]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2987:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2954 + 32
                                                    while _2954 + (32 * _2987) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2987) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2954 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _3013 = mem[_2954]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2954]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _3013:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2954 + 32
                                                    while _2954 + (32 * _3013) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _3013) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                        else:
                            if (10^12 * block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) != 10^12:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            if ((10^12 * block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 += (10^12 * block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                            if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                                revert with 0, 'SafeMath: addition overflow'
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048
                            s = 0
                            while uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304:
                                require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1792
                                if not (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768):
                                    if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    if (0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                else:
                                    if (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768) != stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    if ((block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024) + stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 < stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require uint8(s) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                                    mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                    stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0 += (block.timestamp * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) - (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_768 * stor[('array', 7, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(s)].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1024
                                s = s + 1
                                continue 
                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1280 = block.timestamp
                            mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                            if sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 > totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(stor4)
                            staticcall stor4.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args 4, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require uint8(ext_call.return_data[0]) < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304
                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                            if not stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                _2523 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2523] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                mem[_2523 + 32] = 0
                                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                    mem[_2523 + 64] = 0
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2647 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2665 = mem[_2647]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2647]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2665:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2647 + 32
                                                while _2647 + (32 * _2665) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2665) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2647 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2678 = mem[_2647]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2647]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2678:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2647 + 32
                                                while _2647 + (32 * _2678) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2678) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2666 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2679 = mem[_2666]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2666]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2679:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2666 + 32
                                                while _2666 + (32 * _2679) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2679) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2666 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2695 = mem[_2666]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2666]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2695:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2666 + 32
                                                while _2666 + (32 * _2695) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2695) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                else:
                                    if 0 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    mem[_2523 + 64] = 0
                                    mem[0] = ext_call.return_data[0]
                                    mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0
                                    sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                    if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2663 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2675 = mem[_2663]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2663]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2675:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2663 + 32
                                                while _2663 + (32 * _2675) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2675) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2663 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2691 = mem[_2663]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2663]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2691:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2663 + 32
                                                while _2663 + (32 * _2691) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2691) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                    else:
                                        uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                        totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                        mem[mem[64] + 4] = 4
                                        require ext_code.size(stor4)
                                        staticcall stor4.0xc416fa18 with:
                                                gas gas_remaining wei
                                               args 4
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require uint8(ext_call.return_data[0]) <= test266151307()
                                        _2676 = mem[64]
                                        mem[mem[64]] = uint8(ext_call.return_data[0])
                                        mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                        if not uint8(ext_call.return_data[0]):
                                            _2692 = mem[_2676]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2676]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2692:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2676 + 32
                                                while _2676 + (32 * _2692) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2692) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                        else:
                                            mem[_2676 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                            _2725 = mem[_2676]
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2676]
                                            mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                            if not _2725:
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                                            else:
                                                t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                s = _2676 + 32
                                                while _2676 + (32 * _2725) + 32 > s:
                                                    stor[t] = mem[s]
                                                    t = t + 1
                                                    s = s + 32
                                                    continue 
                                                s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2725) + 31) >> 5)
                                                while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                    stor[s] = 0
                                                    s = s + 1
                                                    continue 
                            else:
                                if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048:
                                    if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    _2572 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2572] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    mem[_2572 + 32] = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                        mem[_2572 + 64] = 0
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2873 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2897 = mem[_2873]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2873]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2897:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2873 + 32
                                                    while _2873 + (32 * _2897) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2897) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2873 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2922 = mem[_2873]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2873]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2922:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2873 + 32
                                                    while _2873 + (32 * _2922) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2922) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2898 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2923 = mem[_2898]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2898]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2923:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2898 + 32
                                                    while _2898 + (32 * _2923) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2923) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2898 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2952 = mem[_2898]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2898]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2952:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2898 + 32
                                                    while _2898 + (32 * _2952) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2952) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                    else:
                                        if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        mem[_2572 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 0 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2895 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2919 = mem[_2895]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2895]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2919:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2895 + 32
                                                    while _2895 + (32 * _2919) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2919) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2895 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2948 = mem[_2895]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2895]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2948:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2895 + 32
                                                    while _2895 + (32 * _2948) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2948) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2920 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2949 = mem[_2920]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2920]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2949:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2920 + 32
                                                    while _2920 + (32 * _2949) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2949) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2920 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2983 = mem[_2920]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2920]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2983:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2920 + 32
                                                    while _2920 + (32 * _2983) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2983) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                else:
                                    if 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 != 10^12:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    _2592 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2592] = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                    mem[_2592 + 32] = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                    if not totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0:
                                        mem[_2592 + 64] = 0
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = 0
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2893 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2917 = mem[_2893]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2893]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2917:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2893 + 32
                                                    while _2893 + (32 * _2917) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2917) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2893 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2945 = mem[_2893]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2893]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2945:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2893 + 32
                                                    while _2893 + (32 * _2945) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2945) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2918 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2946 = mem[_2918]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2918]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2946:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2918 + 32
                                                    while _2918 + (32 * _2946) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2946) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2918 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2980 = mem[_2918]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2918]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2980:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2918 + 32
                                                    while _2918 + (32 * _2980) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2980) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                    else:
                                        if (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 - sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 != 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        mem[_2592 + 64] = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        mem[0] = ext_call.return_data[0]
                                        mem[32] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 10)
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_0 = totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_256 = 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0
                                        sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0]].field_512 = (totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_1536 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) - (sub_057a3048[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)][ext_call.return_data[0] - 1].field_0 * 10^12 * totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 / stor[('array', 9, ('map', ('type', 8, ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor5', 5))))), ('name', 'totemLpSupplies', 7))) + uint8(ext_call.return_data[0])].field_0) / 10^12
                                        if ext_call.return_data[0] + 1 < totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2816 + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_256:
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2915 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2942 = mem[_2915]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2915]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2942:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2915 + 32
                                                    while _2915 + (32 * _2942) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2942) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2915 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _2976 = mem[_2915]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2915]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2976:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2915 + 32
                                                    while _2915 + (32 * _2976) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2976) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                        else:
                                            uint8(totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_8) = 0
                                            totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2048 = 0
                                            mem[mem[64] + 4] = 4
                                            require ext_code.size(stor4)
                                            staticcall stor4.0xc416fa18 with:
                                                    gas gas_remaining wei
                                                   args 4
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require uint8(ext_call.return_data[0]) <= test266151307()
                                            _2943 = mem[64]
                                            mem[mem[64]] = uint8(ext_call.return_data[0])
                                            mem[64] = mem[64] + (32 * uint8(ext_call.return_data[0])) + 32
                                            if not uint8(ext_call.return_data[0]):
                                                _2977 = mem[_2943]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2943]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _2977:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2943 + 32
                                                    while _2943 + (32 * _2977) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _2977) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                            else:
                                                mem[_2943 + 32 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
                                                _3007 = mem[_2943]
                                                totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 = mem[_2943]
                                                mem[0] = sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9
                                                if not _3007:
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
                                                else:
                                                    t = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9)
                                                    s = _2943 + 32
                                                    while _2943 + (32 * _3007) + 32 > s:
                                                        stor[t] = mem[s]
                                                        t = t + 1
                                                        s = s + 32
                                                        continue 
                                                    s = sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + (Mask(251, 0, (32 * _3007) + 31) >> 5)
                                                    while sha3(sha3(uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248), 7) + 9) + totemLpSupplies[uint8(stor5[uint8(idx) / 32].field_(8 * idx % 32) - 248)].field_2304 > s:
                                                        stor[s] = 0
                                                        s = s + 1
                                                        continue 
        idx = idx + 1
        continue 
}



}
