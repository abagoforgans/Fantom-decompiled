contract main {




// =====================  Runtime code  =====================


#
#  - executeOperation(address arg1, address arg2, uint256 arg3, uint256 arg4, bytes arg5)
#  - sub_770cc16e(?)
#
const _test = 0


address owner;

function owner() payable {
    return owner
}

function _fallback() payable {
    revert
}

function sub_aa118bae(?) payable {
    require calldata.size - 4 >= 160
    require cd[4] == address(cd[4])
    require cd[36] == cd[36]
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 'NH{q', 65
    if (32 * ('cd', 68).length) + 128 > test266151307() or (32 * ('cd', 68).length) + 128 < 96:
        revert with 'NH{q', 65
    mem[64] = (32 * ('cd', 68).length) + 128
    mem[96] = ('cd', 68).length
    idx = 0
    s = cd[68] + 36
    t = 128
    while idx < ('cd', 68).length:
        require calldata.size + -cd[68] + -cd[s] - 36 >= 160
        _37 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 160
        require cd[(cd[68] + cd[s] + 36)] == address(cd[(cd[68] + cd[s] + 36)])
        mem[_37] = cd[(cd[68] + cd[s] + 36)]
        require cd[(cd[68] + cd[s] + 68)] == cd[(cd[68] + cd[s] + 68)]
        mem[_37 + 32] = cd[(cd[68] + cd[s] + 68)]
        require cd[(cd[68] + cd[s] + 100)] == cd[(cd[68] + cd[s] + 100)]
        mem[_37 + 64] = cd[(cd[68] + cd[s] + 100)]
        require cd[(cd[68] + cd[s] + 132)] <= test266151307()
        require cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 67 < calldata.size
        if cd[(cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 36)] > test266151307():
            revert with 'NH{q', 65
        _43 = mem[64]
        if mem[64] + (32 * cd[(cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 36)]) + 32 > test266151307() or mem[64] + (32 * cd[(cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 36)]) + 32 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + (32 * cd[(cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 36)]) + 32
        mem[_43] = cd[(cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 36)]
        require cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + (32 * cd[(cd[68] + cd[s] + cd[(cd[68] + cd[s] + 132)] + 36)]) + 68 <= calldata.size
        u = 0
        v = cd[68] + cd[v] + cd[(cd[68] + cd[v] + 132)] + 68
        w = _43 + 32
        while u < cd[(cd[68] + cd[v] + cd[(cd[68] + cd[v] + 132)] + 36)]:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[_37 + 96] = _43
        require cd[(cd[68] + cd[v] + 164)] == cd[(cd[68] + cd[v] + 164)]
        mem[_37 + 128] = cd[(cd[68] + cd[v] + 164)]
        mem[w] = _37
        u = u + 1
        v = v + 32
        w = w + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 'NH{q', 65
    _38 = mem[64]
    if mem[64] + (32 * ('cd', 100).length) + 32 > test266151307() or mem[64] + (32 * ('cd', 100).length) + 32 < mem[64]:
        revert with 'NH{q', 65
    mem[64] = mem[64] + (32 * ('cd', 100).length) + 32
    mem[_38] = ('cd', 100).length
    idx = 0
    s = cd[100] + 36
    t = _38 + 32
    while idx < ('cd', 100).length:
        require calldata.size + -cd[100] + -cd[s] - 36 >= 160
        _72 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 160
        require cd[(cd[100] + cd[s] + 36)] == address(cd[(cd[100] + cd[s] + 36)])
        mem[_72] = cd[(cd[100] + cd[s] + 36)]
        require cd[(cd[100] + cd[s] + 68)] == cd[(cd[100] + cd[s] + 68)]
        mem[_72 + 32] = cd[(cd[100] + cd[s] + 68)]
        require cd[(cd[100] + cd[s] + 100)] == cd[(cd[100] + cd[s] + 100)]
        mem[_72 + 64] = cd[(cd[100] + cd[s] + 100)]
        require cd[(cd[100] + cd[s] + 132)] <= test266151307()
        require cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 67 < calldata.size
        if cd[(cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 36)] > test266151307():
            revert with 'NH{q', 65
        _81 = mem[64]
        if mem[64] + (32 * cd[(cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 36)]) + 32 > test266151307() or mem[64] + (32 * cd[(cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 36)]) + 32 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + (32 * cd[(cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 36)]) + 32
        mem[_81] = cd[(cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 36)]
        require cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + (32 * cd[(cd[100] + cd[s] + cd[(cd[100] + cd[s] + 132)] + 36)]) + 68 <= calldata.size
        u = 0
        v = cd[100] + cd[v] + cd[(cd[100] + cd[v] + 132)] + 68
        w = _81 + 32
        while u < cd[(cd[100] + cd[v] + cd[(cd[100] + cd[v] + 132)] + 36)]:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[_72 + 96] = _81
        require cd[(cd[100] + cd[v] + 164)] == cd[(cd[100] + cd[v] + 164)]
        mem[_72 + 128] = cd[(cd[100] + cd[v] + 164)]
        mem[w] = _72
        u = u + 1
        v = v + 32
        w = w + 32
        continue 
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    if ('cd', 132).length > test266151307():
        revert with 'NH{q', 65
    _73 = mem[64]
    if mem[64] + (32 * ('cd', 132).length) + 32 > test266151307() or mem[64] + (32 * ('cd', 132).length) + 32 < mem[64]:
        revert with 'NH{q', 65
    mem[64] = mem[64] + (32 * ('cd', 132).length) + 32
    mem[_73] = ('cd', 132).length
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    idx = 0
    s = cd[132] + 36
    t = _73 + 32
    while idx < ('cd', 132).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'not owner'
    _104 = mem[64]
    mem[mem[64] + 32] = 96
    _106 = mem[96]
    mem[mem[64] + 128] = mem[96]
    idx = 0
    s = 128
    t = mem[64] + (32 * _106) + 160
    u = mem[64] + 160
    while idx < _106:
        mem[u] = t + -_104 - 160
        _133 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = mem[_133 + 32]
        mem[t + 64] = mem[_133 + 64]
        _141 = mem[_133 + 96]
        mem[t + 96] = 160
        _143 = mem[_141]
        mem[t + 160] = mem[_141]
        v = 0
        w = _141 + 32
        x = t + 192
        while v < _143:
            mem[x] = mem[w + 12 len 20]
            v = v + 1
            w = w + 32
            x = x + 32
            continue 
        mem[t + 128] = mem[_133 + 128]
        idx = idx + 1
        s = s + 32
        t = t + (32 * _143) + 192
        u = u + 32
        continue 
    mem[_104 + 64] = t + -_104 - 32
    _135 = mem[_38]
    mem[t] = mem[_38]
    idx = 0
    s = _38 + 32
    u = t + (32 * _135) + 32
    v = t + 32
    while idx < _135:
        mem[v] = u + -t - 32
        _158 = mem[s]
        mem[u] = mem[mem[s] + 12 len 20]
        mem[u + 32] = mem[_158 + 32]
        mem[u + 64] = mem[_158 + 64]
        _168 = mem[_158 + 96]
        mem[u + 96] = 160
        _169 = mem[_168]
        mem[u + 160] = mem[_168]
        t = 0
        w = _168 + 32
        x = u + 192
        while t < _169:
            mem[x] = mem[w + 12 len 20]
            t = t + 1
            w = w + 32
            x = x + 32
            continue 
        mem[u + 128] = mem[_158 + 128]
        idx = idx + 1
        s = s + 32
        u = u + (32 * _169) + 192
        v = v + 32
        continue 
    mem[_104 + 96] = u + -_104 - 32
    _162 = mem[_73]
    mem[u] = mem[_73]
    idx = 0
    s = _73 + 32
    t = u + 32
    while idx < _162:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    _179 = mem[64]
    mem[64] = u + (32 * _162) + 32
    mem[u + (32 * _162) + 32] = 0xe0232b4200000000000000000000000000000000000000000000000000000000
    mem[u + (32 * _162) + 36] = this.address
    mem[u + (32 * _162) + 68] = cd[36]
    mem[u + (32 * _162) + 100] = 96
    _181 = mem[_179]
    mem[u + (32 * _162) + 132] = mem[_179]
    mem[u + (32 * _162) + 164 len ceil32(_181)] = mem[_179 + 32 len ceil32(_181)]
    if ceil32(_181) > _181:
        mem[u + (32 * _162) + _181 + 164] = 0
    require ext_code.size(address(cd[4]))
    call address(cd[4]).flashLoan(address arg1, uint256 arg2, bytes arg3) with:
         gas gas_remaining wei
        args address(this.address), cd[36], 96, mem[u + (32 * _162) + 132 len ceil32(_181) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}
