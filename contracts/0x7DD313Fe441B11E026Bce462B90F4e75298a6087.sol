contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1, uint256 arg2)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
array of uint256 stor1;
address sub_4365354eAddress;
address devAddress;
address feeAddress;
uint256 sub_e9e49c12;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startBlock;
mapping of uint8 stor10;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return address(poolInfo[arg1].field_0), 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           uint16(poolInfo[arg1].field_1024)
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function devAddress() payable {
    return devAddress
}

function feeAddress() payable {
    return feeAddress
}

function sub_4365354e(?) payable {
    return sub_4365354eAddress
}

function startBlock() payable {
    return startBlock
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function poolExistence(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor10[arg1])
}

function sub_e9e49c12(?) payable {
    return sub_e9e49c12
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > arg2:
        revert with 0, 'SafeMath: subtraction overflow'
    return (arg2 - arg1)
}

function setFeeAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    feeAddress = arg1
    emit SetFeeAddress(msg.sender, arg1);
}

function setDevAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    devAddress = arg1
    emit SetDevAddress(msg.sender, arg1);
}

function sub_3d906a88(?) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(sub_4365354eAddress)
    call sub_4365354eAddress.0xf2fde38b with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function updateStartBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if startBlock <= block.number:
        revert with 0, 'Farm already started'
    startBlock = arg1
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        poolInfo[idx].field_512 = arg1
        idx = idx + 1
        continue 
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function set(uint256 arg1, uint256 arg2, uint16 arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg3 > 500:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x777365743a20696e76616c6964206465706f7369742066656520626173697320706f696e74,
                    mem[201 len 27]
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
    uint16(poolInfo[arg1].field_1024) = arg3
}

function add(uint256 arg1, address arg2, uint16 arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor10[address(arg2)]:
        revert with 0, 'nonDuplicated: duplicated'
    if arg3 > 500:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0xfe6164643a20696e76616c6964206465706f7369742066656520626173697320706f696e74,
                    mem[201 len 27]
    if totalAllocPoint + arg1 < totalAllocPoint:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint += arg1
    stor10[address(arg2)] = 1
    poolInfo.length++
    address(poolInfo[poolInfo.length].field_0) = arg2
    poolInfo[poolInfo.length].field_256 = arg1
    if block.number > startBlock:
        poolInfo[poolInfo.length].field_512 = block.number
    else:
        poolInfo[poolInfo.length].field_512 = startBlock
    poolInfo[poolInfo.length].field_768 = 0
    uint16(poolInfo[poolInfo.length].field_1024) = arg3
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if stor1.length == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1.length = 2
    require arg1 < poolInfo.length
    userInfo[arg1][address(msg.sender)].field_0 = 0
    userInfo[arg1][address(msg.sender)].field_256 = 0
    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(address(poolInfo[arg1].field_0)):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 0, userInfo[arg1][address(msg.sender)].field_32)
    mem[324 len 0] = 0
    call address(poolInfo[arg1].field_0) with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args Mask(480, 0, userInfo[arg1][address(msg.sender)].field_0), mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][address(msg.sender)].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size > 0:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[arg1][address(msg.sender)].field_0, msg.sender, arg1);
    stor1.length = 1
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        require ext_code.size(sub_4365354eAddress)
        staticcall sub_4365354eAddress.0x8da5cb5b with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[12 len 20] == this.address:
            require ext_code.size(address(poolInfo[arg1].field_0))
            staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                if poolInfo[arg1].field_256:
                    require ext_code.size(sub_4365354eAddress)
                    staticcall sub_4365354eAddress.0x18160ddd with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < 7800 * 10^18:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            require ext_code.size(sub_4365354eAddress)
                            call sub_4365354eAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_4365354eAddress)
                            call sub_4365354eAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require block.number - poolInfo[arg1].field_512
                            if (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12) / block.number - poolInfo[arg1].field_512 != sub_e9e49c12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12):
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 10
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12)
                                if (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if 10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.number
}

function sub_f5f99cc0(?) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    require ext_code.size(address(poolInfo[arg1].field_0))
    staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - poolInfo[arg1].field_512:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
        require 0 / totalAllocPoint
        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    require block.number - poolInfo[arg1].field_512
    if (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12) / block.number - poolInfo[arg1].field_512 != sub_e9e49c12:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if not (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12):
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
        require 0 / totalAllocPoint
        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    require (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12)
    if (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12) != poolInfo[arg1].field_256:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalAllocPoint
    if not (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint:
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    require (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint
    if 10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if ext_call.return_data[0] <= 0:
        revert with 0, 'SafeMath: division by zero'
    require ext_call.return_data[0]
    if poolInfo[arg1].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256
    require userInfo[arg1][address(arg2)].field_0
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        require ext_code.size(sub_4365354eAddress)
        staticcall sub_4365354eAddress.0x8da5cb5b with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if address(ext_call.return_data[0]) != this.address:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(poolInfo[idx].field_0))
        staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        require ext_code.size(sub_4365354eAddress)
        staticcall sub_4365354eAddress.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= 7800 * 10^18:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _144 = mem[64]
        mem[64] = mem[64] + 64
        mem[_144] = 30
        mem[_144 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.number:
            _145 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_145 + idx + 68] = mem[_144 + idx + 32]
                idx = idx + 32
                continue 
            mem[_145 + 68] = mem[_145 + 70 len 30]
            revert with memory
              from mem[64]
               len _145 + -mem[64] + 100
        if not block.number - poolInfo[idx].field_512:
            _154 = mem[64]
            mem[64] = mem[64] + 64
            mem[_154] = 26
            mem[_154 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _158 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_158 + idx + 68] = mem[_154 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_158 + 68] = mem[_158 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _158 + -mem[64] + 100
            require totalAllocPoint
            _172 = mem[64]
            mem[64] = mem[64] + 64
            mem[_172] = 26
            mem[_172 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _197 = mem[64]
                mem[64] = mem[64] + 64
                mem[_197] = 26
                mem[_197 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _202 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_202 + idx + 68] = mem[_197 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_202 + 68] = mem[_202 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _202 + -mem[64] + 100
            require 0 / totalAllocPoint
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _201 = mem[64]
            mem[64] = mem[64] + 64
            mem[_201] = 26
            mem[_201 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _212 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_212 + idx + 68] = mem[_201 + idx + 32]
                idx = idx + 32
                continue 
            mem[_212 + 68] = mem[_212 + 74 len 26]
            revert with memory
              from mem[64]
               len _212 + -mem[64] + 100
        require block.number - poolInfo[idx].field_512
        if (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12) / block.number - poolInfo[idx].field_512 != sub_e9e49c12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12):
            _157 = mem[64]
            mem[64] = mem[64] + 64
            mem[_157] = 26
            mem[_157 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _162 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_162 + idx + 68] = mem[_157 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_162 + 68] = mem[_162 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _162 + -mem[64] + 100
            require totalAllocPoint
            _177 = mem[64]
            mem[64] = mem[64] + 64
            mem[_177] = 26
            mem[_177 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _200 = mem[64]
                mem[64] = mem[64] + 64
                mem[_200] = 26
                mem[_200 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _209 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_209 + idx + 68] = mem[_200 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_209 + 68] = mem[_209 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _209 + -mem[64] + 100
            require 0 / totalAllocPoint
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _208 = mem[64]
            mem[64] = mem[64] + 64
            mem[_208] = 26
            mem[_208 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _222 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_222 + idx + 68] = mem[_208 + idx + 32]
                idx = idx + 32
                continue 
            mem[_222 + 68] = mem[_222 + 74 len 26]
            revert with memory
              from mem[64]
               len _222 + -mem[64] + 100
        require (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12)
        if (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _161 = mem[64]
        mem[64] = mem[64] + 64
        mem[_161] = 26
        mem[_161 + 32] = 'SafeMath: division by zero'
        if totalAllocPoint <= 0:
            _168 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_168 + idx + 68] = mem[_161 + idx + 32]
                idx = idx + 32
                continue 
            mem[_168 + 68] = mem[_168 + 74 len 26]
            revert with memory
              from mem[64]
               len _168 + -mem[64] + 100
        require totalAllocPoint
        _181 = mem[64]
        mem[64] = mem[64] + 64
        mem[_181] = 26
        mem[_181 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sub_4365354eAddress)
        call sub_4365354eAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devAddress, (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / 10
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(sub_4365354eAddress)
        call sub_4365354eAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint:
            _207 = mem[64]
            mem[64] = mem[64] + 64
            mem[_207] = 26
            mem[_207 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _219 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_219 + idx + 68] = mem[_207 + idx + 32]
                idx = idx + 32
                continue 
            mem[_219 + 68] = mem[_219 + 74 len 26]
            revert with memory
              from mem[64]
               len _219 + -mem[64] + 100
        require (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint
        if 10^18 * (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _218 = mem[64]
        mem[64] = mem[64] + 64
        mem[_218] = 26
        mem[_218 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0] > 0:
            require ext_call.return_data[0]
            if poolInfo[idx].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^18 * (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _234 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[_234 + idx + 68] = mem[_218 + idx + 32]
            idx = idx + 32
            continue 
        mem[_234 + 68] = mem[_234 + 74 len 26]
        revert with memory
          from mem[64]
           len _234 + -mem[64] + 100
}

function updateEmissionRate(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        require ext_code.size(sub_4365354eAddress)
        staticcall sub_4365354eAddress.0x8da5cb5b with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if address(ext_call.return_data[0]) != this.address:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(poolInfo[idx].field_0))
        staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        require ext_code.size(sub_4365354eAddress)
        staticcall sub_4365354eAddress.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= 7800 * 10^18:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _150 = mem[64]
        mem[64] = mem[64] + 64
        mem[_150] = 30
        mem[_150 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.number:
            _151 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_151 + idx + 68] = mem[_150 + idx + 32]
                idx = idx + 32
                continue 
            mem[_151 + 68] = mem[_151 + 70 len 30]
            revert with memory
              from mem[64]
               len _151 + -mem[64] + 100
        if not block.number - poolInfo[idx].field_512:
            _160 = mem[64]
            mem[64] = mem[64] + 64
            mem[_160] = 26
            mem[_160 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _164 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_164 + idx + 68] = mem[_160 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_164 + 68] = mem[_164 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _164 + -mem[64] + 100
            require totalAllocPoint
            _178 = mem[64]
            mem[64] = mem[64] + 64
            mem[_178] = 26
            mem[_178 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_203] = 26
                mem[_203 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _208 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_208 + idx + 68] = mem[_203 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_208 + 68] = mem[_208 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _208 + -mem[64] + 100
            require 0 / totalAllocPoint
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _207 = mem[64]
            mem[64] = mem[64] + 64
            mem[_207] = 26
            mem[_207 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _218 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_218 + idx + 68] = mem[_207 + idx + 32]
                idx = idx + 32
                continue 
            mem[_218 + 68] = mem[_218 + 74 len 26]
            revert with memory
              from mem[64]
               len _218 + -mem[64] + 100
        require block.number - poolInfo[idx].field_512
        if (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12) / block.number - poolInfo[idx].field_512 != sub_e9e49c12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12):
            _163 = mem[64]
            mem[64] = mem[64] + 64
            mem[_163] = 26
            mem[_163 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _168 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_168 + idx + 68] = mem[_163 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_168 + 68] = mem[_168 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _168 + -mem[64] + 100
            require totalAllocPoint
            _183 = mem[64]
            mem[64] = mem[64] + 64
            mem[_183] = 26
            mem[_183 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_4365354eAddress)
            call sub_4365354eAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _206 = mem[64]
                mem[64] = mem[64] + 64
                mem[_206] = 26
                mem[_206 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _215 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_215 + idx + 68] = mem[_206 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_215 + 68] = mem[_215 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _215 + -mem[64] + 100
            require 0 / totalAllocPoint
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _214 = mem[64]
            mem[64] = mem[64] + 64
            mem[_214] = 26
            mem[_214 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _228 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_228 + idx + 68] = mem[_214 + idx + 32]
                idx = idx + 32
                continue 
            mem[_228 + 68] = mem[_228 + 74 len 26]
            revert with memory
              from mem[64]
               len _228 + -mem[64] + 100
        require (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12)
        if (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / (block.number * sub_e9e49c12) - (poolInfo[idx].field_512 * sub_e9e49c12) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _167 = mem[64]
        mem[64] = mem[64] + 64
        mem[_167] = 26
        mem[_167 + 32] = 'SafeMath: division by zero'
        if totalAllocPoint <= 0:
            _174 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_174 + idx + 68] = mem[_167 + idx + 32]
                idx = idx + 32
                continue 
            mem[_174 + 68] = mem[_174 + 74 len 26]
            revert with memory
              from mem[64]
               len _174 + -mem[64] + 100
        require totalAllocPoint
        _187 = mem[64]
        mem[64] = mem[64] + 64
        mem[_187] = 26
        mem[_187 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sub_4365354eAddress)
        call sub_4365354eAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devAddress, (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / 10
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(sub_4365354eAddress)
        call sub_4365354eAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint:
            _213 = mem[64]
            mem[64] = mem[64] + 64
            mem[_213] = 26
            mem[_213 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _225 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_225 + idx + 68] = mem[_213 + idx + 32]
                idx = idx + 32
                continue 
            mem[_225 + 68] = mem[_225 + 74 len 26]
            revert with memory
              from mem[64]
               len _225 + -mem[64] + 100
        require (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint
        if 10^18 * (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _224 = mem[64]
        mem[64] = mem[64] + 64
        mem[_224] = 26
        mem[_224 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0] > 0:
            require ext_call.return_data[0]
            if poolInfo[idx].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^18 * (block.number * sub_e9e49c12 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_e9e49c12 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _240 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[_240 + idx + 68] = mem[_224 + idx + 32]
            idx = idx + 32
            continue 
        mem[_240 + 68] = mem[_240 + 74 len 26]
        revert with memory
          from mem[64]
           len _240 + -mem[64] + 100
    sub_e9e49c12 = arg1
    emit UpdateEmissionRate(arg1, msg.sender);
}

function sub_5bbdf38e(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require cd[4] <= 4294967296
    require cd[4] + 36 <= calldata.size
    require ('cd', 4).length <= 4294967296 and cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= 4294967296
    require cd[36] + 36 <= calldata.size
    require ('cd', 36).length <= 4294967296 and cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] <= 4294967296
    require cd[68] + 36 <= calldata.size
    require ('cd', 68).length <= 4294967296 and cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require uint16(cd[((32 * idx) + cd[4] + 36)]) < poolInfo.length
        mem[0] = 6
        if block.number > poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512:
            require ext_code.size(sub_4365354eAddress)
            staticcall sub_4365354eAddress.0x8da5cb5b with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(ext_call.return_data[0]) == this.address:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_0))
                staticcall address(poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256:
                        require ext_code.size(sub_4365354eAddress)
                        staticcall sub_4365354eAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < 7800 * 10^18:
                            _163 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_163] = 30
                            mem[_163 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 > block.number:
                                _164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_164 + idx + 68] = mem[_163 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_164 + 68] = mem[_164 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _164 + -mem[64] + 100
                            if not block.number - poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512:
                                _174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_174] = 26
                                mem[_174 + 32] = 'SafeMath: division by zero'
                                if totalAllocPoint <= 0:
                                    _178 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[_178 + idx + 68] = mem[_174 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_178 + 68] = mem[_178 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _178 + -mem[64] + 100
                                require totalAllocPoint
                                _192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_192] = 26
                                mem[_192 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 10
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    _217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_217] = 26
                                    mem[_217 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0] <= 0:
                                        _222 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_222 + idx + 68] = mem[_217 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_222 + 68] = mem[_222 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _222 + -mem[64] + 100
                                    require ext_call.return_data[0]
                                    if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 + (0 / ext_call.return_data[0]) < poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _221 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_221] = 26
                                    mem[_221 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0] <= 0:
                                        _232 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_232 + idx + 68] = mem[_221 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_232 + 68] = mem[_232 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _232 + -mem[64] + 100
                                    require ext_call.return_data[0]
                                    if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512
                                if (block.number * sub_e9e49c12) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12) / block.number - poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 != sub_e9e49c12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (block.number * sub_e9e49c12) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12):
                                    _177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_177] = 26
                                    mem[_177 + 32] = 'SafeMath: division by zero'
                                    if totalAllocPoint <= 0:
                                        _182 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_182 + idx + 68] = mem[_177 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_182 + 68] = mem[_182 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _182 + -mem[64] + 100
                                    require totalAllocPoint
                                    _197 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_197] = 26
                                    mem[_197 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 10
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        _220 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_220] = 26
                                        mem[_220 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _229 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_229 + idx + 68] = mem[_220 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_229 + 68] = mem[_229 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _229 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 + (0 / ext_call.return_data[0]) < poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _228 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_228] = 26
                                        mem[_228 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _242 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_242 + idx + 68] = mem[_228 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_242 + 68] = mem[_242 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _242 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_e9e49c12) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12)
                                    if (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / (block.number * sub_e9e49c12) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12) != poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _181 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_181] = 26
                                    mem[_181 + 32] = 'SafeMath: division by zero'
                                    if totalAllocPoint <= 0:
                                        _188 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_188 + idx + 68] = mem[_181 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_188 + 68] = mem[_188 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _188 + -mem[64] + 100
                                    require totalAllocPoint
                                    _201 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_201] = 26
                                    mem[_201 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint / 10
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint:
                                        _227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_227] = 26
                                        mem[_227 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _239 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_239 + idx + 68] = mem[_227 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_239 + 68] = mem[_239 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _239 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 + (0 / ext_call.return_data[0]) < poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint
                                        if 10^18 * (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint / (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _238 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_238] = 26
                                        mem[_238 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _254 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_254 + idx + 68] = mem[_238 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_254 + 68] = mem[_254 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _254 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_768 += 10^18 * (block.number * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) - (poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 * sub_e9e49c12 * poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_512 = block.number
        require idx < ('cd', 4).length
        require uint16(cd[((32 * idx) + cd[4] + 36)]) < poolInfo.length
        mem[0] = 6
        poolInfo[uint16(cd[((32 * idx) + cd[4] + 36)])].field_256 = 0
        idx = idx + 1
        continue 
    idx = 0
    while idx < ('cd', 36).length:
        require uint16(cd[((32 * idx) + cd[36] + 36)]) < poolInfo.length
        mem[0] = 6
        require idx < ('cd', 68).length
        poolInfo[uint16(cd[((32 * idx) + cd[36] + 36)])].field_256 = cd[((32 * idx) + cd[68] + 36)]
        idx = idx + 1
        continue 
}

function sub_7492a94b(?) payable {
    require calldata.size - 4 >= 64
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[64] = (32 * arg2.length) + 128
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    mem[(32 * arg2.length) + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require arg1 < poolInfo.length
    mem[0] = 6
    if poolInfo[arg1].field_256:
        revert with 0, 'Alloc point is not 0'
    idx = 0
    while idx < arg2.length:
        require idx < mem[96]
        _6751 = mem[(32 * idx) + 128]
        require idx < mem[96]
        _6755 = sha3(mem[(32 * idx) + 140 len 20], sha3(arg1 << 240, 7))
        require arg1 < poolInfo.length
        mem[32] = sha3(arg1 << 240, 7)
        _6758 = sha3(address(mem[(32 * idx) + 128]), sha3(arg1 << 240, 7))
        if userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0 < userInfo[arg1 << 240][mem[(32 * idx) + 140 len 20]].field_0:
            revert with 0, 'withdraw: not good'
        require arg1 < poolInfo.length
        mem[0] = 6
        if block.number <= poolInfo[arg1].field_512:
            if not userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0:
                _6772 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6772] = 26
                mem[_6772 + 32] = 'SafeMath: division by zero'
                _6782 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6782] = 30
                mem[_6782 + 32] = 'SafeMath: subtraction overflow'
                if stor1[_6758] > 0:
                    _6786 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6786 + idx + 68] = mem[_6782 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6786 + 68] = mem[_6786 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _6786 + -mem[64] + 100
                if -stor1[_6758] <= 0:
                    if stor[_6755] <= 0:
                        if not stor[_6758]:
                            _6853 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6853] = 26
                            mem[_6853 + 32] = 'SafeMath: division by zero'
                            stor1[_6758] = 0
                        else:
                            require stor[_6758]
                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6882] = 26
                            mem[_6882 + 32] = 'SafeMath: division by zero'
                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        mem[mem[64]] = stor[_6755]
                    else:
                        _6818 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6818] = 30
                        mem[_6818 + 32] = 'SafeMath: subtraction overflow'
                        if stor[_6755] > stor[_6758]:
                            _6833 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6833 + idx + 68] = mem[_6818 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6833 + 68] = mem[_6833 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _6833 + -mem[64] + 100
                        stor[_6758] -= stor[_6755]
                        _6865 = mem[64]
                        mem[mem[64] + 36] = address(_6751)
                        mem[mem[64] + 68] = stor[_6755]
                        _6866 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_6866 + 32] = mem[_6866 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _6865 + 164
                        mem[_6865 + 100] = 32
                        mem[_6865 + 132] = 'SafeERC20: low-level call failed'
                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _7026 = mem[_6866]
                        t = _6866 + 32
                        u = _6865 + 164
                        s = mem[_6866]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[_6865 + floor32(mem[_6866]) + 164] = mem[_6866 + -(mem[_6866] % 32) + floor32(mem[_6866]) + 64 len mem[_6866] % 32] or Mask(8 * -(mem[_6866] % 32) + 32, -(8 * -(mem[_6866] % 32) + 32) + 256, mem[_6865 + floor32(mem[_6866]) + 164])
                        call address(poolInfo[arg1].field_0).mem[_6865 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_6865 + 168 len _7026 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_6865 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_6865 + 168] = 32
                                mem[_6865 + 200] = 32
                                idx = 0
                                while idx < 32:
                                    mem[_6865 + idx + 232] = mem[_6865 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                revert with memory
                                  from mem[64]
                                   len _6865 + -mem[64] + 264
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_6865 + 274 len 22]
                            if not stor[_6758]:
                                mem[64] = _6865 + 228
                                mem[_6865 + 164] = 26
                                mem[_6865 + 196] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_6865 + 265 len 31]
                                mem[64] = _6865 + 228
                                mem[_6865 + 164] = 26
                                mem[_6865 + 196] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[_6865 + 228] = stor[_6755]
                        else:
                            mem[_6865 + 164] = return_data.size
                            mem[_6865 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_6865 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_6865 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[_6865 + ceil32(return_data.size) + idx + 233] = mem[_6865 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_6865 + ceil32(return_data.size) + 233]
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_6865 + 196]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_6865 + ceil32(return_data.size) + 275 len 22]
                            if not stor[_6758]:
                                mem[64] = _6865 + ceil32(return_data.size) + 229
                                mem[_6865 + ceil32(return_data.size) + 165] = 26
                                mem[_6865 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[_6865 + ceil32(return_data.size) + 266 len 31]
                                mem[64] = _6865 + ceil32(return_data.size) + 229
                                mem[_6865 + ceil32(return_data.size) + 165] = 26
                                mem[_6865 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[_6865 + ceil32(return_data.size) + 229] = stor[_6755]
                else:
                    _6811 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6811] = 26
                    mem[_6811 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_4365354eAddress)
                    staticcall sub_4365354eAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 4] = address(_6751)
                    if -stor1[_6758] > ext_call.return_data[0]:
                        mem[mem[64] + 36] = ext_call.return_data[0]
                        require ext_code.size(sub_4365354eAddress)
                        call sub_4365354eAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(_6751), ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                        if stor[_6755] <= 0:
                            if not stor[_6758]:
                                _7335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7335] = 26
                                mem[_7335 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _7438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7438] = 26
                                mem[_7438 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[mem[64]] = stor[_6755]
                        else:
                            _7187 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7187] = 30
                            mem[_7187 + 32] = 'SafeMath: subtraction overflow'
                            if stor[_6755] > stor[_6758]:
                                _7253 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7253 + idx + 68] = mem[_7187 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7253 + 68] = mem[_7253 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7253 + -mem[64] + 100
                            stor[_6758] -= stor[_6755]
                            _7389 = mem[64]
                            mem[mem[64] + 36] = address(_6751)
                            mem[mem[64] + 68] = stor[_6755]
                            _7390 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_7390 + 32] = mem[_7390 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _7389 + 164
                            mem[_7389 + 100] = 32
                            mem[_7389 + 132] = 'SafeERC20: low-level call failed'
                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                revert with 0, 'Address: call to non-contract'
                            _7780 = mem[_7390]
                            t = _7390 + 32
                            u = _7389 + 164
                            s = mem[_7390]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[_7389 + floor32(mem[_7390]) + 164] = mem[_7390 + -(mem[_7390] % 32) + floor32(mem[_7390]) + 64 len mem[_7390] % 32] or Mask(8 * -(mem[_7390] % 32) + 32, -(8 * -(mem[_7390] % 32) + 32) + 256, mem[_7389 + floor32(mem[_7390]) + 164])
                            call address(poolInfo[arg1].field_0).mem[_7389 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_7389 + 168 len _7780 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_7389 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_7389 + 168] = 32
                                    mem[_7389 + 200] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[_7389 + idx + 232] = mem[_7389 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with memory
                                      from mem[64]
                                       len _7389 + -mem[64] + 264
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_7389 + 274 len 22]
                                if not stor[_6758]:
                                    mem[64] = _7389 + 228
                                    mem[_7389 + 164] = 26
                                    mem[_7389 + 196] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7389 + 265 len 31]
                                    mem[64] = _7389 + 228
                                    mem[_7389 + 164] = 26
                                    mem[_7389 + 196] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[_7389 + 228] = stor[_6755]
                            else:
                                mem[_7389 + 164] = return_data.size
                                mem[_7389 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_7389 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_7389 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[_7389 + ceil32(return_data.size) + idx + 233] = mem[_7389 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_7389 + ceil32(return_data.size) + 233]
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_7389 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_7389 + ceil32(return_data.size) + 275 len 22]
                                if not stor[_6758]:
                                    mem[64] = _7389 + ceil32(return_data.size) + 229
                                    mem[_7389 + ceil32(return_data.size) + 165] = 26
                                    mem[_7389 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[_7389 + ceil32(return_data.size) + 266 len 31]
                                    mem[64] = _7389 + ceil32(return_data.size) + 229
                                    mem[_7389 + ceil32(return_data.size) + 165] = 26
                                    mem[_7389 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[_7389 + ceil32(return_data.size) + 229] = stor[_6755]
                    else:
                        mem[mem[64] + 36] = -stor1[_6758]
                        require ext_code.size(sub_4365354eAddress)
                        call sub_4365354eAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(_6751), -stor1[_6758]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                        if stor[_6755] <= 0:
                            if not stor[_6758]:
                                _7333 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7333] = 26
                                mem[_7333 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _7435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7435] = 26
                                mem[_7435 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        else:
                            _7186 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7186] = 30
                            mem[_7186 + 32] = 'SafeMath: subtraction overflow'
                            if stor[_6755] > stor[_6758]:
                                _7250 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7250 + idx + 68] = mem[_7186 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7250 + 68] = mem[_7250 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7250 + -mem[64] + 100
                            stor[_6758] -= stor[_6755]
                            _7384 = mem[64]
                            mem[mem[64] + 36] = address(_6751)
                            mem[mem[64] + 68] = stor[_6755]
                            _7385 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_7385 + 32] = mem[_7385 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _7384 + 164
                            mem[_7384 + 100] = 32
                            mem[_7384 + 132] = 'SafeERC20: low-level call failed'
                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                revert with 0, 'Address: call to non-contract'
                            _7776 = mem[_7385]
                            t = _7385 + 32
                            u = mem[64]
                            s = mem[_7385]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_7385])] = mem[_7385 + floor32(mem[_7385]) + -(mem[_7385] % 32) + 64 len mem[_7385] % 32] or Mask(8 * -(mem[_7385] % 32) + 32, -(8 * -(mem[_7385] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_7385])])
                            call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _7776 + _7384 + -mem[64] + 160]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _14857 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_7384 + 100]
                                    _14859 = mem[_7384 + 100]
                                    idx = 0
                                    while idx < _14859:
                                        mem[_14857 + idx + 68] = mem[_7384 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _14859 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _14859 + _14857 + -mem[64] + 68
                                    mem[floor32(_14859) + _14857 + 68] = mem[floor32(_14859) + _14857 + -(_14859 % 32) + 100 len _14859 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_14859) + _14857 + -mem[64] + 100
                                if mem[96] <= 0:
                                    if not stor[_6758]:
                                        _16453 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16453] = 26
                                        mem[_16453 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16841 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16841] = 26
                                        mem[_16841 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                    if not stor[_6758]:
                                        _16981 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16981] = 26
                                        mem[_16981 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _17371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17371] = 26
                                        mem[_17371 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            else:
                                _14107 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_14107] = return_data.size
                                mem[_14107 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _14861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_7384 + 100]
                                    _14863 = mem[_7384 + 100]
                                    idx = 0
                                    while idx < _14863:
                                        mem[_14861 + idx + 68] = mem[_7384 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _14863 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _14863 + _14861 + -mem[64] + 68
                                    mem[floor32(_14863) + _14861 + 68] = mem[floor32(_14863) + _14861 + -(_14863 % 32) + 100 len _14863 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_14863) + _14861 + -mem[64] + 100
                                if return_data.size <= 0:
                                    if not stor[_6758]:
                                        _16454 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16454] = 26
                                        mem[_16454 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16844 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16844] = 26
                                        mem[_16844 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    require return_data.size >= 32
                                    if not mem[_14107 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                    if not stor[_6758]:
                                        _16982 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16982] = 26
                                        mem[_16982 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _17374 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17374] = 26
                                        mem[_17374 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        mem[mem[64]] = stor[_6755]
            else:
                require userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0
                if userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0 * poolInfo[arg1].field_768 / userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0 != poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6773 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6773] = 26
                mem[_6773 + 32] = 'SafeMath: division by zero'
                _6785 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6785] = 30
                mem[_6785 + 32] = 'SafeMath: subtraction overflow'
                if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                    _6795 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6795 + idx + 68] = mem[_6785 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6795 + 68] = mem[_6795 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _6795 + -mem[64] + 100
                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                    if stor[_6755] <= 0:
                        if not stor[_6758]:
                            _6880 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6880] = 26
                            mem[_6880 + 32] = 'SafeMath: division by zero'
                            stor1[_6758] = 0
                        else:
                            require stor[_6758]
                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6912 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6912] = 26
                            mem[_6912 + 32] = 'SafeMath: division by zero'
                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        mem[mem[64]] = stor[_6755]
                    else:
                        _6832 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6832] = 30
                        mem[_6832 + 32] = 'SafeMath: subtraction overflow'
                        if stor[_6755] > stor[_6758]:
                            _6850 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6850 + idx + 68] = mem[_6832 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6850 + 68] = mem[_6850 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _6850 + -mem[64] + 100
                        stor[_6758] -= stor[_6755]
                        _6894 = mem[64]
                        mem[mem[64] + 36] = address(_6751)
                        mem[mem[64] + 68] = stor[_6755]
                        _6895 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_6895 + 32] = mem[_6895 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _6894 + 164
                        mem[_6894 + 100] = 32
                        mem[_6894 + 132] = 'SafeERC20: low-level call failed'
                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _7089 = mem[_6895]
                        t = _6895 + 32
                        u = _6894 + 164
                        s = mem[_6895]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[_6894 + floor32(mem[_6895]) + 164] = mem[_6895 + -(mem[_6895] % 32) + floor32(mem[_6895]) + 64 len mem[_6895] % 32] or Mask(8 * -(mem[_6895] % 32) + 32, -(8 * -(mem[_6895] % 32) + 32) + 256, mem[_6894 + floor32(mem[_6895]) + 164])
                        call address(poolInfo[arg1].field_0).mem[_6894 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_6894 + 168 len _7089 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_6894 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_6894 + 168] = 32
                                mem[_6894 + 200] = 32
                                idx = 0
                                while idx < 32:
                                    mem[_6894 + idx + 232] = mem[_6894 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                revert with memory
                                  from mem[64]
                                   len _6894 + -mem[64] + 264
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_6894 + 274 len 22]
                            if not stor[_6758]:
                                mem[64] = _6894 + 228
                                mem[_6894 + 164] = 26
                                mem[_6894 + 196] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_6894 + 265 len 31]
                                mem[64] = _6894 + 228
                                mem[_6894 + 164] = 26
                                mem[_6894 + 196] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[_6894 + 228] = stor[_6755]
                        else:
                            mem[_6894 + 164] = return_data.size
                            mem[_6894 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_6894 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_6894 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[_6894 + ceil32(return_data.size) + idx + 233] = mem[_6894 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_6894 + ceil32(return_data.size) + 233]
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_6894 + 196]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_6894 + ceil32(return_data.size) + 275 len 22]
                            if not stor[_6758]:
                                mem[64] = _6894 + ceil32(return_data.size) + 229
                                mem[_6894 + ceil32(return_data.size) + 165] = 26
                                mem[_6894 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[_6894 + ceil32(return_data.size) + 266 len 31]
                                mem[64] = _6894 + ceil32(return_data.size) + 229
                                mem[_6894 + ceil32(return_data.size) + 165] = 26
                                mem[_6894 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[_6894 + ceil32(return_data.size) + 229] = stor[_6755]
                else:
                    _6826 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6826] = 26
                    mem[_6826 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_4365354eAddress)
                    staticcall sub_4365354eAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 4] = address(_6751)
                    if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                        mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                        require ext_code.size(sub_4365354eAddress)
                        call sub_4365354eAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                        if stor[_6755] <= 0:
                            if not stor[_6758]:
                                _7427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7427] = 26
                                mem[_7427 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _7531 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7531] = 26
                                mem[_7531 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[mem[64]] = stor[_6755]
                        else:
                            _7248 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7248] = 30
                            mem[_7248 + 32] = 'SafeMath: subtraction overflow'
                            if stor[_6755] > stor[_6758]:
                                _7321 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7321 + idx + 68] = mem[_7248 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7321 + 68] = mem[_7321 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7321 + -mem[64] + 100
                            stor[_6758] -= stor[_6755]
                            _7488 = mem[64]
                            mem[mem[64] + 36] = address(_6751)
                            mem[mem[64] + 68] = stor[_6755]
                            _7489 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_7489 + 32] = mem[_7489 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _7488 + 164
                            mem[_7488 + 100] = 32
                            mem[_7488 + 132] = 'SafeERC20: low-level call failed'
                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                revert with 0, 'Address: call to non-contract'
                            _7908 = mem[_7489]
                            t = _7489 + 32
                            u = _7488 + 164
                            s = mem[_7489]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[_7488 + floor32(mem[_7489]) + 164] = mem[_7489 + -(mem[_7489] % 32) + floor32(mem[_7489]) + 64 len mem[_7489] % 32] or Mask(8 * -(mem[_7489] % 32) + 32, -(8 * -(mem[_7489] % 32) + 32) + 256, mem[_7488 + floor32(mem[_7489]) + 164])
                            call address(poolInfo[arg1].field_0).mem[_7488 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_7488 + 168 len _7908 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_7488 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_7488 + 168] = 32
                                    mem[_7488 + 200] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[_7488 + idx + 232] = mem[_7488 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with memory
                                      from mem[64]
                                       len _7488 + -mem[64] + 264
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_7488 + 274 len 22]
                                if not stor[_6758]:
                                    mem[64] = _7488 + 228
                                    mem[_7488 + 164] = 26
                                    mem[_7488 + 196] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7488 + 265 len 31]
                                    mem[64] = _7488 + 228
                                    mem[_7488 + 164] = 26
                                    mem[_7488 + 196] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[_7488 + 228] = stor[_6755]
                            else:
                                mem[_7488 + 164] = return_data.size
                                mem[_7488 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_7488 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_7488 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[_7488 + ceil32(return_data.size) + idx + 233] = mem[_7488 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_7488 + ceil32(return_data.size) + 233]
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_7488 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_7488 + ceil32(return_data.size) + 275 len 22]
                                if not stor[_6758]:
                                    mem[64] = _7488 + ceil32(return_data.size) + 229
                                    mem[_7488 + ceil32(return_data.size) + 165] = 26
                                    mem[_7488 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[_7488 + ceil32(return_data.size) + 266 len 31]
                                    mem[64] = _7488 + ceil32(return_data.size) + 229
                                    mem[_7488 + ceil32(return_data.size) + 165] = 26
                                    mem[_7488 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[_7488 + ceil32(return_data.size) + 229] = stor[_6755]
                    else:
                        mem[mem[64] + 36] = ext_call.return_data[0]
                        require ext_code.size(sub_4365354eAddress)
                        call sub_4365354eAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(_6751), ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                        if stor[_6755] <= 0:
                            if not stor[_6758]:
                                _7429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7429] = 26
                                mem[_7429 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _7534 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7534] = 26
                                mem[_7534 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        else:
                            _7249 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7249] = 30
                            mem[_7249 + 32] = 'SafeMath: subtraction overflow'
                            if stor[_6755] > stor[_6758]:
                                _7324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_7324 + idx + 68] = mem[_7249 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7324 + 68] = mem[_7324 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7324 + -mem[64] + 100
                            stor[_6758] -= stor[_6755]
                            _7493 = mem[64]
                            mem[mem[64] + 36] = address(_6751)
                            mem[mem[64] + 68] = stor[_6755]
                            _7494 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_7494 + 32] = mem[_7494 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _7493 + 164
                            mem[_7493 + 100] = 32
                            mem[_7493 + 132] = 'SafeERC20: low-level call failed'
                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                revert with 0, 'Address: call to non-contract'
                            _7912 = mem[_7494]
                            t = _7494 + 32
                            u = mem[64]
                            s = mem[_7494]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_7494])] = mem[_7494 + floor32(mem[_7494]) + -(mem[_7494] % 32) + 64 len mem[_7494] % 32] or Mask(8 * -(mem[_7494] % 32) + 32, -(8 * -(mem[_7494] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_7494])])
                            call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _7912 + _7493 + -mem[64] + 160]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _14841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_7493 + 100]
                                    _14843 = mem[_7493 + 100]
                                    idx = 0
                                    while idx < _14843:
                                        mem[_14841 + idx + 68] = mem[_7493 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _14843 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _14843 + _14841 + -mem[64] + 68
                                    mem[floor32(_14843) + _14841 + 68] = mem[floor32(_14843) + _14841 + -(_14843 % 32) + 100 len _14843 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_14843) + _14841 + -mem[64] + 100
                                if mem[96] <= 0:
                                    if not stor[_6758]:
                                        _16449 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16449] = 26
                                        mem[_16449 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16829] = 26
                                        mem[_16829 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                    if not stor[_6758]:
                                        _16977 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16977] = 26
                                        mem[_16977 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _17359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17359] = 26
                                        mem[_17359 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            else:
                                _14099 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_14099] = return_data.size
                                mem[_14099 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _14845 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_7493 + 100]
                                    _14847 = mem[_7493 + 100]
                                    idx = 0
                                    while idx < _14847:
                                        mem[_14845 + idx + 68] = mem[_7493 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _14847 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _14847 + _14845 + -mem[64] + 68
                                    mem[floor32(_14847) + _14845 + 68] = mem[floor32(_14847) + _14845 + -(_14847 % 32) + 100 len _14847 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_14847) + _14845 + -mem[64] + 100
                                if return_data.size <= 0:
                                    if not stor[_6758]:
                                        _16450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16450] = 26
                                        mem[_16450 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16832] = 26
                                        mem[_16832 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    require return_data.size >= 32
                                    if not mem[_14099 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                    if not stor[_6758]:
                                        _16978 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16978] = 26
                                        mem[_16978 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _17362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17362] = 26
                                        mem[_17362 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        mem[mem[64]] = stor[_6755]
        else:
            require ext_code.size(sub_4365354eAddress)
            staticcall sub_4365354eAddress.0x8da5cb5b with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(ext_call.return_data[0]) != this.address:
                poolInfo[arg1].field_512 = block.number
                if not userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0:
                    _6778 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6778] = 26
                    mem[_6778 + 32] = 'SafeMath: division by zero'
                    _6794 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6794] = 30
                    mem[_6794 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[_6758] > 0:
                        _6807 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6807 + idx + 68] = mem[_6794 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6807 + 68] = mem[_6807 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _6807 + -mem[64] + 100
                    if -stor1[_6758] <= 0:
                        if stor[_6755] <= 0:
                            if not stor[_6758]:
                                _6910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6910] = 26
                                mem[_6910 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6950 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6950] = 26
                                mem[_6950 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        else:
                            _6849 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6849] = 30
                            mem[_6849 + 32] = 'SafeMath: subtraction overflow'
                            if stor[_6755] > stor[_6758]:
                                _6877 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6877 + idx + 68] = mem[_6849 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6877 + 68] = mem[_6877 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _6877 + -mem[64] + 100
                            stor[_6758] -= stor[_6755]
                            _6928 = mem[64]
                            mem[mem[64] + 36] = address(_6751)
                            mem[mem[64] + 68] = stor[_6755]
                            _6929 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_6929 + 32] = mem[_6929 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _6928 + 164
                            mem[_6928 + 100] = 32
                            mem[_6928 + 132] = 'SafeERC20: low-level call failed'
                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                revert with 0, 'Address: call to non-contract'
                            _7149 = mem[_6929]
                            t = _6929 + 32
                            u = mem[64]
                            s = mem[_6929]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_6929])] = mem[_6929 + floor32(mem[_6929]) + -(mem[_6929] % 32) + 64 len mem[_6929] % 32] or Mask(8 * -(mem[_6929] % 32) + 32, -(8 * -(mem[_6929] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_6929])])
                            call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _7149 + _6928 + -mem[64] + 160]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _14801 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_6928 + 100]
                                    _14803 = mem[_6928 + 100]
                                    idx = 0
                                    while idx < _14803:
                                        mem[_14801 + idx + 68] = mem[_6928 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _14803 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _14803 + _14801 + -mem[64] + 68
                                    mem[floor32(_14803) + _14801 + 68] = mem[floor32(_14803) + _14801 + -(_14803 % 32) + 100 len _14803 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_14803) + _14801 + -mem[64] + 100
                                if mem[96] <= 0:
                                    if not stor[_6758]:
                                        _16439 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16439] = 26
                                        mem[_16439 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16799 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16799] = 26
                                        mem[_16799 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                    if not stor[_6758]:
                                        _16967 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16967] = 26
                                        mem[_16967 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _17329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17329] = 26
                                        mem[_17329 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            else:
                                _14082 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_14082] = return_data.size
                                mem[_14082 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _14805 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_6928 + 100]
                                    _14807 = mem[_6928 + 100]
                                    idx = 0
                                    while idx < _14807:
                                        mem[_14805 + idx + 68] = mem[_6928 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _14807 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _14807 + _14805 + -mem[64] + 68
                                    mem[floor32(_14807) + _14805 + 68] = mem[floor32(_14807) + _14805 + -(_14807 % 32) + 100 len _14807 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_14807) + _14805 + -mem[64] + 100
                                if return_data.size <= 0:
                                    if not stor[_6758]:
                                        _16440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16440] = 26
                                        mem[_16440 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16802 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16802] = 26
                                        mem[_16802 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    require return_data.size >= 32
                                    if not mem[_14082 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                    if not stor[_6758]:
                                        _16968 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16968] = 26
                                        mem[_16968 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _17332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17332] = 26
                                        mem[_17332 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                        mem[mem[64]] = stor[_6755]
                    else:
                        _6839 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6839] = 26
                        mem[_6839 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_4365354eAddress)
                        staticcall sub_4365354eAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 4] = address(_6751)
                        if -stor1[_6758] <= ext_call.return_data[0]:
                            mem[mem[64] + 36] = -stor1[_6758]
                            require ext_code.size(sub_4365354eAddress)
                            call sub_4365354eAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_6751), -stor1[_6758]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                            if stor[_6755] <= 0:
                                if not stor[_6758]:
                                    _7523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7523] = 26
                                    mem[_7523 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7617 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7617] = 26
                                    mem[_7617 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[mem[64]] = stor[_6755]
                            else:
                                _7319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7319] = 30
                                mem[_7319 + 32] = 'SafeMath: subtraction overflow'
                                if stor[_6755] > stor[_6758]:
                                    _7415 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_7415 + idx + 68] = mem[_7319 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7415 + 68] = mem[_7415 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7415 + -mem[64] + 100
                                stor[_6758] -= stor[_6755]
                                _7568 = mem[64]
                                mem[mem[64] + 36] = address(_6751)
                                mem[mem[64] + 68] = stor[_6755]
                                _7569 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_7569 + 32] = mem[_7569 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _7568 + 164
                                mem[_7568 + 100] = 32
                                mem[_7568 + 132] = 'SafeERC20: low-level call failed'
                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                    revert with 0, 'Address: call to non-contract'
                                _8043 = mem[_7569]
                                t = _7569 + 32
                                u = _7568 + 164
                                s = mem[_7569]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[_7568 + floor32(mem[_7569]) + 164] = mem[_7569 + -(mem[_7569] % 32) + floor32(mem[_7569]) + 64 len mem[_7569] % 32] or Mask(8 * -(mem[_7569] % 32) + 32, -(8 * -(mem[_7569] % 32) + 32) + 256, mem[_7568 + floor32(mem[_7569]) + 164])
                                call address(poolInfo[arg1].field_0).mem[_7568 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_7568 + 168 len _8043 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96] > 0:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_7568 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7568 + 168] = 32
                                        mem[_7568 + 200] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7568 + idx + 232] = mem[_7568 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with memory
                                          from mem[64]
                                           len _7568 + -mem[64] + 264
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7568 + 274 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7568 + 228
                                        mem[_7568 + 164] = 26
                                        mem[_7568 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7568 + 265 len 31]
                                        mem[64] = _7568 + 228
                                        mem[_7568 + 164] = 26
                                        mem[_7568 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7568 + 228] = stor[_6755]
                                else:
                                    mem[_7568 + 164] = return_data.size
                                    mem[_7568 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_7568 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7568 + ceil32(return_data.size) + 169] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7568 + ceil32(return_data.size) + idx + 233] = mem[_7568 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_7568 + ceil32(return_data.size) + 233]
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_7568 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7568 + ceil32(return_data.size) + 275 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7568 + ceil32(return_data.size) + 229
                                        mem[_7568 + ceil32(return_data.size) + 165] = 26
                                        mem[_7568 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7568 + ceil32(return_data.size) + 266 len 31]
                                        mem[64] = _7568 + ceil32(return_data.size) + 229
                                        mem[_7568 + ceil32(return_data.size) + 165] = 26
                                        mem[_7568 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7568 + ceil32(return_data.size) + 229] = stor[_6755]
                        else:
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(sub_4365354eAddress)
                            call sub_4365354eAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_6751), ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                            if stor[_6755] <= 0:
                                if not stor[_6758]:
                                    _7525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7525] = 26
                                    mem[_7525 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7620 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7620] = 26
                                    mem[_7620 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[mem[64]] = stor[_6755]
                            else:
                                _7320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7320] = 30
                                mem[_7320 + 32] = 'SafeMath: subtraction overflow'
                                if stor[_6755] > stor[_6758]:
                                    _7418 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_7418 + idx + 68] = mem[_7320 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7418 + 68] = mem[_7418 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7418 + -mem[64] + 100
                                stor[_6758] -= stor[_6755]
                                _7573 = mem[64]
                                mem[mem[64] + 36] = address(_6751)
                                mem[mem[64] + 68] = stor[_6755]
                                _7574 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_7574 + 32] = mem[_7574 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _7573 + 164
                                mem[_7573 + 100] = 32
                                mem[_7573 + 132] = 'SafeERC20: low-level call failed'
                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                    revert with 0, 'Address: call to non-contract'
                                _8047 = mem[_7574]
                                t = _7574 + 32
                                u = _7573 + 164
                                s = mem[_7574]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[_7573 + floor32(mem[_7574]) + 164] = mem[_7574 + -(mem[_7574] % 32) + floor32(mem[_7574]) + 64 len mem[_7574] % 32] or Mask(8 * -(mem[_7574] % 32) + 32, -(8 * -(mem[_7574] % 32) + 32) + 256, mem[_7573 + floor32(mem[_7574]) + 164])
                                call address(poolInfo[arg1].field_0).mem[_7573 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_7573 + 168 len _8047 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96] > 0:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_7573 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7573 + 168] = 32
                                        mem[_7573 + 200] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7573 + idx + 232] = mem[_7573 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with memory
                                          from mem[64]
                                           len _7573 + -mem[64] + 264
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7573 + 274 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7573 + 228
                                        mem[_7573 + 164] = 26
                                        mem[_7573 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7573 + 265 len 31]
                                        mem[64] = _7573 + 228
                                        mem[_7573 + 164] = 26
                                        mem[_7573 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7573 + 228] = stor[_6755]
                                else:
                                    mem[_7573 + 164] = return_data.size
                                    mem[_7573 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_7573 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7573 + ceil32(return_data.size) + 169] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7573 + ceil32(return_data.size) + idx + 233] = mem[_7573 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_7573 + ceil32(return_data.size) + 233]
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_7573 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7573 + ceil32(return_data.size) + 275 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7573 + ceil32(return_data.size) + 229
                                        mem[_7573 + ceil32(return_data.size) + 165] = 26
                                        mem[_7573 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7573 + ceil32(return_data.size) + 266 len 31]
                                        mem[64] = _7573 + ceil32(return_data.size) + 229
                                        mem[_7573 + ceil32(return_data.size) + 165] = 26
                                        mem[_7573 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7573 + ceil32(return_data.size) + 229] = stor[_6755]
                else:
                    require userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0
                    if userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0 * poolInfo[arg1].field_768 / userInfo[arg1 << 240][address(mem[(32 * idx) + 128])].field_0 != poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6781 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6781] = 26
                    mem[_6781 + 32] = 'SafeMath: division by zero'
                    _6806 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6806] = 30
                    mem[_6806 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                        _6822 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6822 + idx + 68] = mem[_6806 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6822 + 68] = mem[_6822 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _6822 + -mem[64] + 100
                    if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                        if stor[_6755] <= 0:
                            if not stor[_6758]:
                                _6948 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6948] = 26
                                mem[_6948 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = 0
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6996 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6996] = 26
                                mem[_6996 + 32] = 'SafeMath: division by zero'
                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[mem[64]] = stor[_6755]
                        else:
                            _6876 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6876] = 30
                            mem[_6876 + 32] = 'SafeMath: subtraction overflow'
                            if stor[_6755] > stor[_6758]:
                                _6907 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6907 + idx + 68] = mem[_6876 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6907 + 68] = mem[_6907 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _6907 + -mem[64] + 100
                            stor[_6758] -= stor[_6755]
                            _6966 = mem[64]
                            mem[mem[64] + 36] = address(_6751)
                            mem[mem[64] + 68] = stor[_6755]
                            _6967 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_6967 + 32] = mem[_6967 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _6966 + 164
                            mem[_6966 + 100] = 32
                            mem[_6966 + 132] = 'SafeERC20: low-level call failed'
                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                revert with 0, 'Address: call to non-contract'
                            _7208 = mem[_6967]
                            t = _6967 + 32
                            u = _6966 + 164
                            s = mem[_6967]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[_6966 + floor32(mem[_6967]) + 164] = mem[_6967 + -(mem[_6967] % 32) + floor32(mem[_6967]) + 64 len mem[_6967] % 32] or Mask(8 * -(mem[_6967] % 32) + 32, -(8 * -(mem[_6967] % 32) + 32) + 256, mem[_6966 + floor32(mem[_6967]) + 164])
                            call address(poolInfo[arg1].field_0).mem[_6966 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_6966 + 168 len _7208 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_6966 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_6966 + 168] = 32
                                    mem[_6966 + 200] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[_6966 + idx + 232] = mem[_6966 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with memory
                                      from mem[64]
                                       len _6966 + -mem[64] + 264
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_6966 + 274 len 22]
                                if not stor[_6758]:
                                    mem[64] = _6966 + 228
                                    mem[_6966 + 164] = 26
                                    mem[_6966 + 196] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_6966 + 265 len 31]
                                    mem[64] = _6966 + 228
                                    mem[_6966 + 164] = 26
                                    mem[_6966 + 196] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[_6966 + 228] = stor[_6755]
                            else:
                                mem[_6966 + 164] = return_data.size
                                mem[_6966 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_6966 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_6966 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[_6966 + ceil32(return_data.size) + idx + 233] = mem[_6966 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_6966 + ceil32(return_data.size) + 233]
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_6966 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_6966 + ceil32(return_data.size) + 275 len 22]
                                if not stor[_6758]:
                                    mem[64] = _6966 + ceil32(return_data.size) + 229
                                    mem[_6966 + ceil32(return_data.size) + 165] = 26
                                    mem[_6966 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[_6966 + ceil32(return_data.size) + 266 len 31]
                                    mem[64] = _6966 + ceil32(return_data.size) + 229
                                    mem[_6966 + ceil32(return_data.size) + 165] = 26
                                    mem[_6966 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[_6966 + ceil32(return_data.size) + 229] = stor[_6755]
                    else:
                        _6861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6861] = 26
                        mem[_6861 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_4365354eAddress)
                        staticcall sub_4365354eAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 4] = address(_6751)
                        if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                            mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                            require ext_code.size(sub_4365354eAddress)
                            call sub_4365354eAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                            if stor[_6755] <= 0:
                                if not stor[_6758]:
                                    _7609 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7609] = 26
                                    mem[_7609 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7713 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7713] = 26
                                    mem[_7713 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[mem[64]] = stor[_6755]
                            else:
                                _7413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7413] = 30
                                mem[_7413 + 32] = 'SafeMath: subtraction overflow'
                                if stor[_6755] > stor[_6758]:
                                    _7511 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_7511 + idx + 68] = mem[_7413 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7511 + 68] = mem[_7511 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7511 + -mem[64] + 100
                                stor[_6758] -= stor[_6755]
                                _7655 = mem[64]
                                mem[mem[64] + 36] = address(_6751)
                                mem[mem[64] + 68] = stor[_6755]
                                _7656 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_7656 + 32] = mem[_7656 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _7655 + 164
                                mem[_7655 + 100] = 32
                                mem[_7655 + 132] = 'SafeERC20: low-level call failed'
                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                    revert with 0, 'Address: call to non-contract'
                                _8157 = mem[_7656]
                                t = _7656 + 32
                                u = _7655 + 164
                                s = mem[_7656]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[_7655 + floor32(mem[_7656]) + 164] = mem[_7656 + -(mem[_7656] % 32) + floor32(mem[_7656]) + 64 len mem[_7656] % 32] or Mask(8 * -(mem[_7656] % 32) + 32, -(8 * -(mem[_7656] % 32) + 32) + 256, mem[_7655 + floor32(mem[_7656]) + 164])
                                call address(poolInfo[arg1].field_0).mem[_7655 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_7655 + 168 len _8157 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96] > 0:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_7655 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7655 + 168] = 32
                                        mem[_7655 + 200] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7655 + idx + 232] = mem[_7655 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with memory
                                          from mem[64]
                                           len _7655 + -mem[64] + 264
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7655 + 274 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7655 + 228
                                        mem[_7655 + 164] = 26
                                        mem[_7655 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7655 + 265 len 31]
                                        mem[64] = _7655 + 228
                                        mem[_7655 + 164] = 26
                                        mem[_7655 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7655 + 228] = stor[_6755]
                                else:
                                    mem[_7655 + 164] = return_data.size
                                    mem[_7655 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_7655 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7655 + ceil32(return_data.size) + 169] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7655 + ceil32(return_data.size) + idx + 233] = mem[_7655 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_7655 + ceil32(return_data.size) + 233]
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_7655 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7655 + ceil32(return_data.size) + 275 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7655 + ceil32(return_data.size) + 229
                                        mem[_7655 + ceil32(return_data.size) + 165] = 26
                                        mem[_7655 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7655 + ceil32(return_data.size) + 266 len 31]
                                        mem[64] = _7655 + ceil32(return_data.size) + 229
                                        mem[_7655 + ceil32(return_data.size) + 165] = 26
                                        mem[_7655 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7655 + ceil32(return_data.size) + 229] = stor[_6755]
                        else:
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(sub_4365354eAddress)
                            call sub_4365354eAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_6751), ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                            if stor[_6755] <= 0:
                                if not stor[_6758]:
                                    _7611 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7611] = 26
                                    mem[_7611 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7716 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7716] = 26
                                    mem[_7716 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[mem[64]] = stor[_6755]
                            else:
                                _7414 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7414] = 30
                                mem[_7414 + 32] = 'SafeMath: subtraction overflow'
                                if stor[_6755] > stor[_6758]:
                                    _7514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_7514 + idx + 68] = mem[_7414 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7514 + 68] = mem[_7514 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7514 + -mem[64] + 100
                                stor[_6758] -= stor[_6755]
                                _7660 = mem[64]
                                mem[mem[64] + 36] = address(_6751)
                                mem[mem[64] + 68] = stor[_6755]
                                _7661 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_7661 + 32] = mem[_7661 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _7660 + 164
                                mem[_7660 + 100] = 32
                                mem[_7660 + 132] = 'SafeERC20: low-level call failed'
                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                    revert with 0, 'Address: call to non-contract'
                                _8161 = mem[_7661]
                                t = _7661 + 32
                                u = _7660 + 164
                                s = mem[_7661]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[_7660 + floor32(mem[_7661]) + 164] = mem[_7661 + -(mem[_7661] % 32) + floor32(mem[_7661]) + 64 len mem[_7661] % 32] or Mask(8 * -(mem[_7661] % 32) + 32, -(8 * -(mem[_7661] % 32) + 32) + 256, mem[_7660 + floor32(mem[_7661]) + 164])
                                call address(poolInfo[arg1].field_0).mem[_7660 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_7660 + 168 len _8161 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96] > 0:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_7660 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7660 + 168] = 32
                                        mem[_7660 + 200] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7660 + idx + 232] = mem[_7660 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with memory
                                          from mem[64]
                                           len _7660 + -mem[64] + 264
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7660 + 274 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7660 + 228
                                        mem[_7660 + 164] = 26
                                        mem[_7660 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7660 + 265 len 31]
                                        mem[64] = _7660 + 228
                                        mem[_7660 + 164] = 26
                                        mem[_7660 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7660 + 228] = stor[_6755]
                                else:
                                    mem[_7660 + 164] = return_data.size
                                    mem[_7660 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_7660 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7660 + ceil32(return_data.size) + 169] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7660 + ceil32(return_data.size) + idx + 233] = mem[_7660 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_7660 + ceil32(return_data.size) + 233]
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_7660 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7660 + ceil32(return_data.size) + 275 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7660 + ceil32(return_data.size) + 229
                                        mem[_7660 + ceil32(return_data.size) + 165] = 26
                                        mem[_7660 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7660 + ceil32(return_data.size) + 266 len 31]
                                        mem[64] = _7660 + ceil32(return_data.size) + 229
                                        mem[_7660 + ceil32(return_data.size) + 165] = 26
                                        mem[_7660 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7660 + ceil32(return_data.size) + 229] = stor[_6755]
            else:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[arg1].field_0))
                staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    poolInfo[arg1].field_512 = block.number
                    if not stor[_6758]:
                        _6789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6789] = 26
                        mem[_6789 + 32] = 'SafeMath: division by zero'
                        _6828 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6828] = 30
                        mem[_6828 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[_6758] > 0:
                            _6844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6844 + idx + 68] = mem[_6828 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6844 + 68] = mem[_6844 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _6844 + -mem[64] + 100
                        if -stor1[_6758] <= 0:
                            if stor[_6755] <= 0:
                                if not stor[_6758]:
                                    _7007 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7007] = 26
                                    mem[_7007 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7062 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7062] = 26
                                    mem[_7062 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                mem[mem[64]] = stor[_6755]
                            else:
                                _6918 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6918] = 30
                                mem[_6918 + 32] = 'SafeMath: subtraction overflow'
                                if stor[_6755] > stor[_6758]:
                                    _6955 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_6955 + idx + 68] = mem[_6918 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6955 + 68] = mem[_6955 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _6955 + -mem[64] + 100
                                stor[_6758] -= stor[_6755]
                                _7031 = mem[64]
                                mem[mem[64] + 36] = address(_6751)
                                mem[mem[64] + 68] = stor[_6755]
                                _7032 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_7032 + 32] = mem[_7032 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _7031 + 164
                                mem[_7031 + 100] = 32
                                mem[_7031 + 132] = 'SafeERC20: low-level call failed'
                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                    revert with 0, 'Address: call to non-contract'
                                _7305 = mem[_7032]
                                t = _7032 + 32
                                u = _7031 + 164
                                s = mem[_7032]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[_7031 + floor32(mem[_7032]) + 164] = mem[_7032 + -(mem[_7032] % 32) + floor32(mem[_7032]) + 64 len mem[_7032] % 32] or Mask(8 * -(mem[_7032] % 32) + 32, -(8 * -(mem[_7032] % 32) + 32) + 256, mem[_7031 + floor32(mem[_7032]) + 164])
                                call address(poolInfo[arg1].field_0).mem[_7031 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_7031 + 168 len _7305 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96] > 0:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_7031 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7031 + 168] = 32
                                        mem[_7031 + 200] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7031 + idx + 232] = mem[_7031 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with memory
                                          from mem[64]
                                           len _7031 + -mem[64] + 264
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7031 + 274 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7031 + 228
                                        mem[_7031 + 164] = 26
                                        mem[_7031 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7031 + 265 len 31]
                                        mem[64] = _7031 + 228
                                        mem[_7031 + 164] = 26
                                        mem[_7031 + 196] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7031 + 228] = stor[_6755]
                                else:
                                    mem[_7031 + 164] = return_data.size
                                    mem[_7031 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_7031 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_7031 + ceil32(return_data.size) + 169] = 32
                                        idx = 0
                                        while idx < 32:
                                            mem[_7031 + ceil32(return_data.size) + idx + 233] = mem[_7031 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_7031 + ceil32(return_data.size) + 233]
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_7031 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_7031 + ceil32(return_data.size) + 275 len 22]
                                    if not stor[_6758]:
                                        mem[64] = _7031 + ceil32(return_data.size) + 229
                                        mem[_7031 + ceil32(return_data.size) + 165] = 26
                                        mem[_7031 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7031 + ceil32(return_data.size) + 266 len 31]
                                        mem[64] = _7031 + ceil32(return_data.size) + 229
                                        mem[_7031 + ceil32(return_data.size) + 165] = 26
                                        mem[_7031 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[_7031 + ceil32(return_data.size) + 229] = stor[_6755]
                        else:
                            _6903 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6903] = 26
                            mem[_6903 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_4365354eAddress)
                            staticcall sub_4365354eAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[mem[64] + 4] = address(_6751)
                            if -stor1[_6758] <= ext_call.return_data[0]:
                                mem[mem[64] + 36] = -stor1[_6758]
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_6751), -stor1[_6758]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                if stor[_6755] <= 0:
                                    if not stor[_6758]:
                                        _7737 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7737] = 26
                                        mem[_7737 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7857] = 26
                                        mem[_7857 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                                else:
                                    _7540 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7540] = 30
                                    mem[_7540 + 32] = 'SafeMath: subtraction overflow'
                                    if stor[_6755] > stor[_6758]:
                                        _7627 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_7627 + idx + 68] = mem[_7540 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7627 + 68] = mem[_7627 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _7627 + -mem[64] + 100
                                    stor[_6758] -= stor[_6755]
                                    _7795 = mem[64]
                                    mem[mem[64] + 36] = address(_6751)
                                    mem[mem[64] + 68] = stor[_6755]
                                    _7796 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_7796 + 32] = mem[_7796 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                    mem[64] = _7795 + 164
                                    mem[_7795 + 100] = 32
                                    mem[_7795 + 132] = 'SafeERC20: low-level call failed'
                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                        revert with 0, 'Address: call to non-contract'
                                    _8348 = mem[_7796]
                                    t = _7796 + 32
                                    u = _7795 + 164
                                    s = mem[_7796]
                                    while s >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s - 32
                                        continue 
                                    mem[_7795 + floor32(mem[_7796]) + 164] = mem[_7796 + -(mem[_7796] % 32) + floor32(mem[_7796]) + 64 len mem[_7796] % 32] or Mask(8 * -(mem[_7796] % 32) + 32, -(8 * -(mem[_7796] % 32) + 32) + 256, mem[_7795 + floor32(mem[_7796]) + 164])
                                    call address(poolInfo[arg1].field_0).mem[_7795 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_7795 + 168 len _8348 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96] > 0:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_7795 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7795 + 168] = 32
                                            mem[_7795 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7795 + idx + 232] = mem[_7795 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with memory
                                              from mem[64]
                                               len _7795 + -mem[64] + 264
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7795 + 274 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7795 + 228
                                            mem[_7795 + 164] = 26
                                            mem[_7795 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7795 + 265 len 31]
                                            mem[64] = _7795 + 228
                                            mem[_7795 + 164] = 26
                                            mem[_7795 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7795 + 228] = stor[_6755]
                                    else:
                                        mem[_7795 + 164] = return_data.size
                                        mem[_7795 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_7795 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7795 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7795 + ceil32(return_data.size) + idx + 233] = mem[_7795 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_7795 + ceil32(return_data.size) + 233]
                                        if return_data.size > 0:
                                            require return_data.size >= 32
                                            if not mem[_7795 + 196]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7795 + ceil32(return_data.size) + 275 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7795 + ceil32(return_data.size) + 229
                                            mem[_7795 + ceil32(return_data.size) + 165] = 26
                                            mem[_7795 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7795 + ceil32(return_data.size) + 266 len 31]
                                            mem[64] = _7795 + ceil32(return_data.size) + 229
                                            mem[_7795 + ceil32(return_data.size) + 165] = 26
                                            mem[_7795 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7795 + ceil32(return_data.size) + 229] = stor[_6755]
                            else:
                                mem[mem[64] + 36] = ext_call.return_data[0]
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_6751), ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                if stor[_6755] <= 0:
                                    if not stor[_6758]:
                                        _7739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7739] = 26
                                        mem[_7739 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7860 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7860] = 26
                                        mem[_7860 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                                else:
                                    _7541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7541] = 30
                                    mem[_7541 + 32] = 'SafeMath: subtraction overflow'
                                    if stor[_6755] > stor[_6758]:
                                        _7630 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_7630 + idx + 68] = mem[_7541 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7630 + 68] = mem[_7630 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _7630 + -mem[64] + 100
                                    stor[_6758] -= stor[_6755]
                                    _7800 = mem[64]
                                    mem[mem[64] + 36] = address(_6751)
                                    mem[mem[64] + 68] = stor[_6755]
                                    _7801 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_7801 + 32] = mem[_7801 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                    mem[64] = _7800 + 164
                                    mem[_7800 + 100] = 32
                                    mem[_7800 + 132] = 'SafeERC20: low-level call failed'
                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                        revert with 0, 'Address: call to non-contract'
                                    _8352 = mem[_7801]
                                    t = _7801 + 32
                                    u = _7800 + 164
                                    s = mem[_7801]
                                    while s >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s - 32
                                        continue 
                                    mem[_7800 + floor32(mem[_7801]) + 164] = mem[_7801 + -(mem[_7801] % 32) + floor32(mem[_7801]) + 64 len mem[_7801] % 32] or Mask(8 * -(mem[_7801] % 32) + 32, -(8 * -(mem[_7801] % 32) + 32) + 256, mem[_7800 + floor32(mem[_7801]) + 164])
                                    call address(poolInfo[arg1].field_0).mem[_7800 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_7800 + 168 len _8352 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96] > 0:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_7800 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7800 + 168] = 32
                                            mem[_7800 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7800 + idx + 232] = mem[_7800 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with memory
                                              from mem[64]
                                               len _7800 + -mem[64] + 264
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7800 + 274 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7800 + 228
                                            mem[_7800 + 164] = 26
                                            mem[_7800 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7800 + 265 len 31]
                                            mem[64] = _7800 + 228
                                            mem[_7800 + 164] = 26
                                            mem[_7800 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7800 + 228] = stor[_6755]
                                    else:
                                        mem[_7800 + 164] = return_data.size
                                        mem[_7800 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_7800 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7800 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7800 + ceil32(return_data.size) + idx + 233] = mem[_7800 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_7800 + ceil32(return_data.size) + 233]
                                        if return_data.size > 0:
                                            require return_data.size >= 32
                                            if not mem[_7800 + 196]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7800 + ceil32(return_data.size) + 275 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7800 + ceil32(return_data.size) + 229
                                            mem[_7800 + ceil32(return_data.size) + 165] = 26
                                            mem[_7800 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7800 + ceil32(return_data.size) + 266 len 31]
                                            mem[64] = _7800 + ceil32(return_data.size) + 229
                                            mem[_7800 + ceil32(return_data.size) + 165] = 26
                                            mem[_7800 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7800 + ceil32(return_data.size) + 229] = stor[_6755]
                    else:
                        require stor[_6758]
                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6799 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6799] = 26
                        mem[_6799 + 32] = 'SafeMath: division by zero'
                        _6843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6843] = 30
                        mem[_6843 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                            _6872 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6872 + idx + 68] = mem[_6843 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6872 + 68] = mem[_6872 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _6872 + -mem[64] + 100
                        if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                            if stor[_6755] <= 0:
                                if not stor[_6758]:
                                    _7060 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7060] = 26
                                    mem[_7060 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = 0
                                else:
                                    require stor[_6758]
                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7128] = 26
                                    mem[_7128 + 32] = 'SafeMath: division by zero'
                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            else:
                                _6954 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6954] = 30
                                mem[_6954 + 32] = 'SafeMath: subtraction overflow'
                                if stor[_6755] > stor[_6758]:
                                    _7004 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_7004 + idx + 68] = mem[_6954 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7004 + 68] = mem[_7004 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7004 + -mem[64] + 100
                                stor[_6758] -= stor[_6755]
                                _7096 = mem[64]
                                mem[mem[64] + 36] = address(_6751)
                                mem[mem[64] + 68] = stor[_6755]
                                _7097 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_7097 + 32] = mem[_7097 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _7096 + 164
                                mem[_7096 + 100] = 32
                                mem[_7096 + 132] = 'SafeERC20: low-level call failed'
                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                    revert with 0, 'Address: call to non-contract'
                                _7395 = mem[_7097]
                                t = _7097 + 32
                                u = mem[64]
                                s = mem[_7097]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_7097])] = mem[_7097 + floor32(mem[_7097]) + -(mem[_7097] % 32) + 64 len mem[_7097] % 32] or Mask(8 * -(mem[_7097] % 32) + 32, -(8 * -(mem[_7097] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_7097])])
                                call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _7395 + _7096 + -mem[64] + 160]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96] > 0:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        _14345 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = mem[_7096 + 100]
                                        _14347 = mem[_7096 + 100]
                                        idx = 0
                                        while idx < _14347:
                                            mem[_14345 + idx + 68] = mem[_7096 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        if not _14347 % 32:
                                            revert with memory
                                              from mem[64]
                                               len _14347 + _14345 + -mem[64] + 68
                                        mem[floor32(_14347) + _14345 + 68] = mem[floor32(_14347) + _14345 + -(_14347 % 32) + 100 len _14347 % 32]
                                        revert with memory
                                          from mem[64]
                                           len floor32(_14347) + _14345 + -mem[64] + 100
                                    if mem[96] <= 0:
                                        if not stor[_6758]:
                                            _16325 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16325] = 26
                                            mem[_16325 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _16457 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16457] = 26
                                            mem[_16457 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        if not stor[_6758]:
                                            _16853 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16853] = 26
                                            mem[_16853 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _16987 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16987] = 26
                                            mem[_16987 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                else:
                                    _13853 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_13853] = return_data.size
                                    mem[_13853 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _14349 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = mem[_7096 + 100]
                                        _14351 = mem[_7096 + 100]
                                        idx = 0
                                        while idx < _14351:
                                            mem[_14349 + idx + 68] = mem[_7096 + idx + 132]
                                            idx = idx + 32
                                            continue 
                                        if not _14351 % 32:
                                            revert with memory
                                              from mem[64]
                                               len _14351 + _14349 + -mem[64] + 68
                                        mem[floor32(_14351) + _14349 + 68] = mem[floor32(_14351) + _14349 + -(_14351 % 32) + 100 len _14351 % 32]
                                        revert with memory
                                          from mem[64]
                                           len floor32(_14351) + _14349 + -mem[64] + 100
                                    if return_data.size <= 0:
                                        if not stor[_6758]:
                                            _16326 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16326] = 26
                                            mem[_16326 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _16460 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16460] = 26
                                            mem[_16460 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_13853 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        if not stor[_6758]:
                                            _16854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16854] = 26
                                            mem[_16854 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _16990 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16990] = 26
                                            mem[_16990 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                            mem[mem[64]] = stor[_6755]
                        else:
                            _6942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6942] = 26
                            mem[_6942 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_4365354eAddress)
                            staticcall sub_4365354eAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[mem[64] + 4] = address(_6751)
                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                if stor[_6755] <= 0:
                                    if not stor[_6758]:
                                        _7849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7849] = 26
                                        mem[_7849 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7996 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7996] = 26
                                        mem[_7996 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                                else:
                                    _7625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7625] = 30
                                    mem[_7625 + 32] = 'SafeMath: subtraction overflow'
                                    if stor[_6755] > stor[_6758]:
                                        _7725 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_7725 + idx + 68] = mem[_7625 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7725 + 68] = mem[_7725 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _7725 + -mem[64] + 100
                                    stor[_6758] -= stor[_6755]
                                    _7929 = mem[64]
                                    mem[mem[64] + 36] = address(_6751)
                                    mem[mem[64] + 68] = stor[_6755]
                                    _7930 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_7930 + 32] = mem[_7930 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                    mem[64] = _7929 + 164
                                    mem[_7929 + 100] = 32
                                    mem[_7929 + 132] = 'SafeERC20: low-level call failed'
                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                        revert with 0, 'Address: call to non-contract'
                                    _8481 = mem[_7930]
                                    t = _7930 + 32
                                    u = _7929 + 164
                                    s = mem[_7930]
                                    while s >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s - 32
                                        continue 
                                    mem[_7929 + floor32(mem[_7930]) + 164] = mem[_7930 + -(mem[_7930] % 32) + floor32(mem[_7930]) + 64 len mem[_7930] % 32] or Mask(8 * -(mem[_7930] % 32) + 32, -(8 * -(mem[_7930] % 32) + 32) + 256, mem[_7929 + floor32(mem[_7930]) + 164])
                                    call address(poolInfo[arg1].field_0).mem[_7929 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_7929 + 168 len _8481 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96] > 0:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_7929 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7929 + 168] = 32
                                            mem[_7929 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7929 + idx + 232] = mem[_7929 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with memory
                                              from mem[64]
                                               len _7929 + -mem[64] + 264
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7929 + 274 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7929 + 228
                                            mem[_7929 + 164] = 26
                                            mem[_7929 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7929 + 265 len 31]
                                            mem[64] = _7929 + 228
                                            mem[_7929 + 164] = 26
                                            mem[_7929 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7929 + 228] = stor[_6755]
                                    else:
                                        mem[_7929 + 164] = return_data.size
                                        mem[_7929 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_7929 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7929 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7929 + ceil32(return_data.size) + idx + 233] = mem[_7929 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_7929 + ceil32(return_data.size) + 233]
                                        if return_data.size > 0:
                                            require return_data.size >= 32
                                            if not mem[_7929 + 196]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7929 + ceil32(return_data.size) + 275 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7929 + ceil32(return_data.size) + 229
                                            mem[_7929 + ceil32(return_data.size) + 165] = 26
                                            mem[_7929 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7929 + ceil32(return_data.size) + 266 len 31]
                                            mem[64] = _7929 + ceil32(return_data.size) + 229
                                            mem[_7929 + ceil32(return_data.size) + 165] = 26
                                            mem[_7929 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7929 + ceil32(return_data.size) + 229] = stor[_6755]
                            else:
                                mem[mem[64] + 36] = ext_call.return_data[0]
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_6751), ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                if stor[_6755] <= 0:
                                    if not stor[_6758]:
                                        _7851 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7851] = 26
                                        mem[_7851 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7999 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7999] = 26
                                        mem[_7999 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                                else:
                                    _7626 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7626] = 30
                                    mem[_7626 + 32] = 'SafeMath: subtraction overflow'
                                    if stor[_6755] > stor[_6758]:
                                        _7728 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_7728 + idx + 68] = mem[_7626 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7728 + 68] = mem[_7728 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _7728 + -mem[64] + 100
                                    stor[_6758] -= stor[_6755]
                                    _7934 = mem[64]
                                    mem[mem[64] + 36] = address(_6751)
                                    mem[mem[64] + 68] = stor[_6755]
                                    _7935 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_7935 + 32] = mem[_7935 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                    mem[64] = _7934 + 164
                                    mem[_7934 + 100] = 32
                                    mem[_7934 + 132] = 'SafeERC20: low-level call failed'
                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                        revert with 0, 'Address: call to non-contract'
                                    _8485 = mem[_7935]
                                    t = _7935 + 32
                                    u = _7934 + 164
                                    s = mem[_7935]
                                    while s >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s - 32
                                        continue 
                                    mem[_7934 + floor32(mem[_7935]) + 164] = mem[_7935 + -(mem[_7935] % 32) + floor32(mem[_7935]) + 64 len mem[_7935] % 32] or Mask(8 * -(mem[_7935] % 32) + 32, -(8 * -(mem[_7935] % 32) + 32) + 256, mem[_7934 + floor32(mem[_7935]) + 164])
                                    call address(poolInfo[arg1].field_0).mem[_7934 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_7934 + 168 len _8485 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96] > 0:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_7934 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7934 + 168] = 32
                                            mem[_7934 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7934 + idx + 232] = mem[_7934 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with memory
                                              from mem[64]
                                               len _7934 + -mem[64] + 264
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7934 + 274 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7934 + 228
                                            mem[_7934 + 164] = 26
                                            mem[_7934 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7934 + 265 len 31]
                                            mem[64] = _7934 + 228
                                            mem[_7934 + 164] = 26
                                            mem[_7934 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7934 + 228] = stor[_6755]
                                    else:
                                        mem[_7934 + 164] = return_data.size
                                        mem[_7934 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_7934 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7934 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7934 + ceil32(return_data.size) + idx + 233] = mem[_7934 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_7934 + ceil32(return_data.size) + 233]
                                        if return_data.size > 0:
                                            require return_data.size >= 32
                                            if not mem[_7934 + 196]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7934 + ceil32(return_data.size) + 275 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7934 + ceil32(return_data.size) + 229
                                            mem[_7934 + ceil32(return_data.size) + 165] = 26
                                            mem[_7934 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7934 + ceil32(return_data.size) + 266 len 31]
                                            mem[64] = _7934 + ceil32(return_data.size) + 229
                                            mem[_7934 + ceil32(return_data.size) + 165] = 26
                                            mem[_7934 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7934 + ceil32(return_data.size) + 229] = stor[_6755]
                else:
                    if not poolInfo[arg1].field_256:
                        poolInfo[arg1].field_512 = block.number
                        if not stor[_6758]:
                            _6793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6793] = 26
                            mem[_6793 + 32] = 'SafeMath: division by zero'
                            _6837 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6837] = 30
                            mem[_6837 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[_6758] > 0:
                                _6858 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6858 + idx + 68] = mem[_6837 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6858 + 68] = mem[_6858 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _6858 + -mem[64] + 100
                            if -stor1[_6758] <= 0:
                                if stor[_6755] <= 0:
                                    if not stor[_6758]:
                                        _7049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7049] = 26
                                        mem[_7049 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7116] = 26
                                        mem[_7116 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                                else:
                                    _6947 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6947] = 30
                                    mem[_6947 + 32] = 'SafeMath: subtraction overflow'
                                    if stor[_6755] > stor[_6758]:
                                        _6993 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_6993 + idx + 68] = mem[_6947 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6993 + 68] = mem[_6993 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _6993 + -mem[64] + 100
                                    stor[_6758] -= stor[_6755]
                                    _7071 = mem[64]
                                    mem[mem[64] + 36] = address(_6751)
                                    mem[mem[64] + 68] = stor[_6755]
                                    _7072 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_7072 + 32] = mem[_7072 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                    mem[64] = _7071 + 164
                                    mem[_7071 + 100] = 32
                                    mem[_7071 + 132] = 'SafeERC20: low-level call failed'
                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                        revert with 0, 'Address: call to non-contract'
                                    _7361 = mem[_7072]
                                    t = _7072 + 32
                                    u = _7071 + 164
                                    s = mem[_7072]
                                    while s >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s - 32
                                        continue 
                                    mem[_7071 + floor32(mem[_7072]) + 164] = mem[_7072 + -(mem[_7072] % 32) + floor32(mem[_7072]) + 64 len mem[_7072] % 32] or Mask(8 * -(mem[_7072] % 32) + 32, -(8 * -(mem[_7072] % 32) + 32) + 256, mem[_7071 + floor32(mem[_7072]) + 164])
                                    call address(poolInfo[arg1].field_0).mem[_7071 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_7071 + 168 len _7361 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96] > 0:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_7071 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7071 + 168] = 32
                                            mem[_7071 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7071 + idx + 232] = mem[_7071 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with memory
                                              from mem[64]
                                               len _7071 + -mem[64] + 264
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7071 + 274 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7071 + 228
                                            mem[_7071 + 164] = 26
                                            mem[_7071 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7071 + 265 len 31]
                                            mem[64] = _7071 + 228
                                            mem[_7071 + 164] = 26
                                            mem[_7071 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7071 + 228] = stor[_6755]
                                    else:
                                        mem[_7071 + 164] = return_data.size
                                        mem[_7071 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_7071 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7071 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7071 + ceil32(return_data.size) + idx + 233] = mem[_7071 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_7071 + ceil32(return_data.size) + 233]
                                        if return_data.size > 0:
                                            require return_data.size >= 32
                                            if not mem[_7071 + 196]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7071 + ceil32(return_data.size) + 275 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7071 + ceil32(return_data.size) + 229
                                            mem[_7071 + ceil32(return_data.size) + 165] = 26
                                            mem[_7071 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7071 + ceil32(return_data.size) + 266 len 31]
                                            mem[64] = _7071 + ceil32(return_data.size) + 229
                                            mem[_7071 + ceil32(return_data.size) + 165] = 26
                                            mem[_7071 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7071 + ceil32(return_data.size) + 229] = stor[_6755]
                            else:
                                _6924 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6924] = 26
                                mem[_6924 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sub_4365354eAddress)
                                staticcall sub_4365354eAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = address(_6751)
                                if -stor1[_6758] <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = -stor1[_6758]
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_6751), -stor1[_6758]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                    if stor[_6755] <= 0:
                                        if not stor[_6758]:
                                            _7827 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7827] = 26
                                            mem[_7827 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _7972 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7972] = 26
                                            mem[_7972 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[mem[64]] = stor[_6755]
                                    else:
                                        _7601 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7601] = 30
                                        mem[_7601 + 32] = 'SafeMath: subtraction overflow'
                                        if stor[_6755] > stor[_6758]:
                                            _7703 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_7703 + idx + 68] = mem[_7601 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7703 + 68] = mem[_7703 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _7703 + -mem[64] + 100
                                        stor[_6758] -= stor[_6755]
                                        _7885 = mem[64]
                                        mem[mem[64] + 36] = address(_6751)
                                        mem[mem[64] + 68] = stor[_6755]
                                        _7886 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_7886 + 32] = mem[_7886 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                        mem[64] = _7885 + 164
                                        mem[_7885 + 100] = 32
                                        mem[_7885 + 132] = 'SafeERC20: low-level call failed'
                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                            revert with 0, 'Address: call to non-contract'
                                        _8431 = mem[_7886]
                                        t = _7886 + 32
                                        u = _7885 + 164
                                        s = mem[_7886]
                                        while s >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s - 32
                                            continue 
                                        mem[_7885 + floor32(mem[_7886]) + 164] = mem[_7886 + -(mem[_7886] % 32) + floor32(mem[_7886]) + 64 len mem[_7886] % 32] or Mask(8 * -(mem[_7886] % 32) + 32, -(8 * -(mem[_7886] % 32) + 32) + 256, mem[_7885 + floor32(mem[_7886]) + 164])
                                        call address(poolInfo[arg1].field_0).mem[_7885 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_7885 + 168 len _8431 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96] > 0:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_7885 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7885 + 168] = 32
                                                mem[_7885 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7885 + idx + 232] = mem[_7885 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with memory
                                                  from mem[64]
                                                   len _7885 + -mem[64] + 264
                                            if mem[96] > 0:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7885 + 274 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7885 + 228
                                                mem[_7885 + 164] = 26
                                                mem[_7885 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7885 + 265 len 31]
                                                mem[64] = _7885 + 228
                                                mem[_7885 + 164] = 26
                                                mem[_7885 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7885 + 228] = stor[_6755]
                                        else:
                                            mem[_7885 + 164] = return_data.size
                                            mem[_7885 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size > 0:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_7885 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7885 + ceil32(return_data.size) + 169] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7885 + ceil32(return_data.size) + idx + 233] = mem[_7885 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_7885 + ceil32(return_data.size) + 233]
                                            if return_data.size > 0:
                                                require return_data.size >= 32
                                                if not mem[_7885 + 196]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7885 + ceil32(return_data.size) + 275 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7885 + ceil32(return_data.size) + 229
                                                mem[_7885 + ceil32(return_data.size) + 165] = 26
                                                mem[_7885 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_7885 + ceil32(return_data.size) + 266 len 31]
                                                mem[64] = _7885 + ceil32(return_data.size) + 229
                                                mem[_7885 + ceil32(return_data.size) + 165] = 26
                                                mem[_7885 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7885 + ceil32(return_data.size) + 229] = stor[_6755]
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_6751), ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                    if stor[_6755] <= 0:
                                        if not stor[_6758]:
                                            _7829 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7829] = 26
                                            mem[_7829 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _7975 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7975] = 26
                                            mem[_7975 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[mem[64]] = stor[_6755]
                                    else:
                                        _7602 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7602] = 30
                                        mem[_7602 + 32] = 'SafeMath: subtraction overflow'
                                        if stor[_6755] > stor[_6758]:
                                            _7706 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_7706 + idx + 68] = mem[_7602 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7706 + 68] = mem[_7706 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _7706 + -mem[64] + 100
                                        stor[_6758] -= stor[_6755]
                                        _7890 = mem[64]
                                        mem[mem[64] + 36] = address(_6751)
                                        mem[mem[64] + 68] = stor[_6755]
                                        _7891 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_7891 + 32] = mem[_7891 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                        mem[64] = _7890 + 164
                                        mem[_7890 + 100] = 32
                                        mem[_7890 + 132] = 'SafeERC20: low-level call failed'
                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                            revert with 0, 'Address: call to non-contract'
                                        _8435 = mem[_7891]
                                        t = _7891 + 32
                                        u = _7890 + 164
                                        s = mem[_7891]
                                        while s >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s - 32
                                            continue 
                                        mem[_7890 + floor32(mem[_7891]) + 164] = mem[_7891 + -(mem[_7891] % 32) + floor32(mem[_7891]) + 64 len mem[_7891] % 32] or Mask(8 * -(mem[_7891] % 32) + 32, -(8 * -(mem[_7891] % 32) + 32) + 256, mem[_7890 + floor32(mem[_7891]) + 164])
                                        call address(poolInfo[arg1].field_0).mem[_7890 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_7890 + 168 len _8435 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96] > 0:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_7890 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7890 + 168] = 32
                                                mem[_7890 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7890 + idx + 232] = mem[_7890 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with memory
                                                  from mem[64]
                                                   len _7890 + -mem[64] + 264
                                            if mem[96] > 0:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7890 + 274 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7890 + 228
                                                mem[_7890 + 164] = 26
                                                mem[_7890 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7890 + 265 len 31]
                                                mem[64] = _7890 + 228
                                                mem[_7890 + 164] = 26
                                                mem[_7890 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7890 + 228] = stor[_6755]
                                        else:
                                            mem[_7890 + 164] = return_data.size
                                            mem[_7890 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size > 0:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_7890 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7890 + ceil32(return_data.size) + 169] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7890 + ceil32(return_data.size) + idx + 233] = mem[_7890 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_7890 + ceil32(return_data.size) + 233]
                                            if return_data.size > 0:
                                                require return_data.size >= 32
                                                if not mem[_7890 + 196]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7890 + ceil32(return_data.size) + 275 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7890 + ceil32(return_data.size) + 229
                                                mem[_7890 + ceil32(return_data.size) + 165] = 26
                                                mem[_7890 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_7890 + ceil32(return_data.size) + 266 len 31]
                                                mem[64] = _7890 + ceil32(return_data.size) + 229
                                                mem[_7890 + ceil32(return_data.size) + 165] = 26
                                                mem[_7890 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7890 + ceil32(return_data.size) + 229] = stor[_6755]
                        else:
                            require stor[_6758]
                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6805] = 26
                            mem[_6805 + 32] = 'SafeMath: division by zero'
                            _6857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6857] = 30
                            mem[_6857 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                _6888 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6888 + idx + 68] = mem[_6857 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6888 + 68] = mem[_6888 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _6888 + -mem[64] + 100
                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                if stor[_6755] <= 0:
                                    if not stor[_6758]:
                                        _7114 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7114] = 26
                                        mem[_7114 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = 0
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7171 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7171] = 26
                                        mem[_7171 + 32] = 'SafeMath: division by zero'
                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                                else:
                                    _6992 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6992] = 30
                                    mem[_6992 + 32] = 'SafeMath: subtraction overflow'
                                    if stor[_6755] > stor[_6758]:
                                        _7046 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_7046 + idx + 68] = mem[_6992 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7046 + 68] = mem[_7046 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _7046 + -mem[64] + 100
                                    stor[_6758] -= stor[_6755]
                                    _7136 = mem[64]
                                    mem[mem[64] + 36] = address(_6751)
                                    mem[mem[64] + 68] = stor[_6755]
                                    _7137 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_7137 + 32] = mem[_7137 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                    mem[64] = _7136 + 164
                                    mem[_7136 + 100] = 32
                                    mem[_7136 + 132] = 'SafeERC20: low-level call failed'
                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                        revert with 0, 'Address: call to non-contract'
                                    _7461 = mem[_7137]
                                    t = _7137 + 32
                                    u = _7136 + 164
                                    s = mem[_7137]
                                    while s >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s - 32
                                        continue 
                                    mem[_7136 + floor32(mem[_7137]) + 164] = mem[_7137 + -(mem[_7137] % 32) + floor32(mem[_7137]) + 64 len mem[_7137] % 32] or Mask(8 * -(mem[_7137] % 32) + 32, -(8 * -(mem[_7137] % 32) + 32) + 256, mem[_7136 + floor32(mem[_7137]) + 164])
                                    call address(poolInfo[arg1].field_0).mem[_7136 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_7136 + 168 len _7461 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96] > 0:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_7136 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7136 + 168] = 32
                                            mem[_7136 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7136 + idx + 232] = mem[_7136 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with memory
                                              from mem[64]
                                               len _7136 + -mem[64] + 264
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7136 + 274 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7136 + 228
                                            mem[_7136 + 164] = 26
                                            mem[_7136 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7136 + 265 len 31]
                                            mem[64] = _7136 + 228
                                            mem[_7136 + 164] = 26
                                            mem[_7136 + 196] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7136 + 228] = stor[_6755]
                                    else:
                                        mem[_7136 + 164] = return_data.size
                                        mem[_7136 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_7136 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_7136 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[_7136 + ceil32(return_data.size) + idx + 233] = mem[_7136 + idx + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_7136 + ceil32(return_data.size) + 233]
                                        if return_data.size > 0:
                                            require return_data.size >= 32
                                            if not mem[_7136 + 196]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_7136 + ceil32(return_data.size) + 275 len 22]
                                        if not stor[_6758]:
                                            mem[64] = _7136 + ceil32(return_data.size) + 229
                                            mem[_7136 + ceil32(return_data.size) + 165] = 26
                                            mem[_7136 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7136 + ceil32(return_data.size) + 266 len 31]
                                            mem[64] = _7136 + ceil32(return_data.size) + 229
                                            mem[_7136 + ceil32(return_data.size) + 165] = 26
                                            mem[_7136 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[_7136 + ceil32(return_data.size) + 229] = stor[_6755]
                            else:
                                _6964 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6964] = 26
                                mem[_6964 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sub_4365354eAddress)
                                staticcall sub_4365354eAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = address(_6751)
                                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                    if stor[_6755] <= 0:
                                        if not stor[_6758]:
                                            _7964 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7964] = 26
                                            mem[_7964 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8100 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8100] = 26
                                            mem[_8100 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[mem[64]] = stor[_6755]
                                    else:
                                        _7701 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7701] = 30
                                        mem[_7701 + 32] = 'SafeMath: subtraction overflow'
                                        if stor[_6755] > stor[_6758]:
                                            _7815 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_7815 + idx + 68] = mem[_7701 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7815 + 68] = mem[_7815 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _7815 + -mem[64] + 100
                                        stor[_6758] -= stor[_6755]
                                        _8024 = mem[64]
                                        mem[mem[64] + 36] = address(_6751)
                                        mem[mem[64] + 68] = stor[_6755]
                                        _8025 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_8025 + 32] = mem[_8025 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                        mem[64] = _8024 + 164
                                        mem[_8024 + 100] = 32
                                        mem[_8024 + 132] = 'SafeERC20: low-level call failed'
                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                            revert with 0, 'Address: call to non-contract'
                                        _8566 = mem[_8025]
                                        t = _8025 + 32
                                        u = _8024 + 164
                                        s = mem[_8025]
                                        while s >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s - 32
                                            continue 
                                        mem[_8024 + floor32(mem[_8025]) + 164] = mem[_8025 + -(mem[_8025] % 32) + floor32(mem[_8025]) + 64 len mem[_8025] % 32] or Mask(8 * -(mem[_8025] % 32) + 32, -(8 * -(mem[_8025] % 32) + 32) + 256, mem[_8024 + floor32(mem[_8025]) + 164])
                                        call address(poolInfo[arg1].field_0).mem[_8024 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_8024 + 168 len _8566 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96] > 0:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_8024 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_8024 + 168] = 32
                                                mem[_8024 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_8024 + idx + 232] = mem[_8024 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with memory
                                                  from mem[64]
                                                   len _8024 + -mem[64] + 264
                                            if mem[96] > 0:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_8024 + 274 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _8024 + 228
                                                mem[_8024 + 164] = 26
                                                mem[_8024 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_8024 + 265 len 31]
                                                mem[64] = _8024 + 228
                                                mem[_8024 + 164] = 26
                                                mem[_8024 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_8024 + 228] = stor[_6755]
                                        else:
                                            mem[_8024 + 164] = return_data.size
                                            mem[_8024 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size > 0:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_8024 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_8024 + ceil32(return_data.size) + 169] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_8024 + ceil32(return_data.size) + idx + 233] = mem[_8024 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_8024 + ceil32(return_data.size) + 233]
                                            if return_data.size > 0:
                                                require return_data.size >= 32
                                                if not mem[_8024 + 196]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_8024 + ceil32(return_data.size) + 275 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _8024 + ceil32(return_data.size) + 229
                                                mem[_8024 + ceil32(return_data.size) + 165] = 26
                                                mem[_8024 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8024 + ceil32(return_data.size) + 266 len 31]
                                                mem[64] = _8024 + ceil32(return_data.size) + 229
                                                mem[_8024 + ceil32(return_data.size) + 165] = 26
                                                mem[_8024 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_8024 + ceil32(return_data.size) + 229] = stor[_6755]
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_6751), ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                    if stor[_6755] <= 0:
                                        if not stor[_6758]:
                                            _7966 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7966] = 26
                                            mem[_7966 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8103 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8103] = 26
                                            mem[_8103 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    else:
                                        _7702 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7702] = 30
                                        mem[_7702 + 32] = 'SafeMath: subtraction overflow'
                                        if stor[_6755] > stor[_6758]:
                                            _7818 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_7818 + idx + 68] = mem[_7702 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7818 + 68] = mem[_7818 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _7818 + -mem[64] + 100
                                        stor[_6758] -= stor[_6755]
                                        _8029 = mem[64]
                                        mem[mem[64] + 36] = address(_6751)
                                        mem[mem[64] + 68] = stor[_6755]
                                        _8030 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_8030 + 32] = mem[_8030 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                        mem[64] = _8029 + 164
                                        mem[_8029 + 100] = 32
                                        mem[_8029 + 132] = 'SafeERC20: low-level call failed'
                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                            revert with 0, 'Address: call to non-contract'
                                        _8570 = mem[_8030]
                                        t = _8030 + 32
                                        u = mem[64]
                                        s = mem[_8030]
                                        while s >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_8030])] = mem[_8030 + floor32(mem[_8030]) + -(mem[_8030] % 32) + 64 len mem[_8030] % 32] or Mask(8 * -(mem[_8030] % 32) + 32, -(8 * -(mem[_8030] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_8030])])
                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8570 + _8029 + -mem[64] + 160]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96] > 0:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                _14745 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = mem[_8029 + 100]
                                                _14747 = mem[_8029 + 100]
                                                idx = 0
                                                while idx < _14747:
                                                    mem[_14745 + idx + 68] = mem[_8029 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                if not _14747 % 32:
                                                    revert with memory
                                                      from mem[64]
                                                       len _14747 + _14745 + -mem[64] + 68
                                                mem[floor32(_14747) + _14745 + 68] = mem[floor32(_14747) + _14745 + -(_14747 % 32) + 100 len _14747 % 32]
                                                revert with memory
                                                  from mem[64]
                                                   len floor32(_14747) + _14745 + -mem[64] + 100
                                            if mem[96] <= 0:
                                                if not stor[_6758]:
                                                    _16425 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16425] = 26
                                                    mem[_16425 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _16757 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16757] = 26
                                                    mem[_16757 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[mem[64] + 110 len 22]
                                                if not stor[_6758]:
                                                    _16953 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16953] = 26
                                                    mem[_16953 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _17287 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17287] = 26
                                                    mem[_17287 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        else:
                                            _14055 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_14055] = return_data.size
                                            mem[_14055 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size > 0:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _14749 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = mem[_8029 + 100]
                                                _14751 = mem[_8029 + 100]
                                                idx = 0
                                                while idx < _14751:
                                                    mem[_14749 + idx + 68] = mem[_8029 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                if not _14751 % 32:
                                                    revert with memory
                                                      from mem[64]
                                                       len _14751 + _14749 + -mem[64] + 68
                                                mem[floor32(_14751) + _14749 + 68] = mem[floor32(_14751) + _14749 + -(_14751 % 32) + 100 len _14751 % 32]
                                                revert with memory
                                                  from mem[64]
                                                   len floor32(_14751) + _14749 + -mem[64] + 100
                                            if return_data.size <= 0:
                                                if not stor[_6758]:
                                                    _16426 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16426] = 26
                                                    mem[_16426 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _16760 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16760] = 26
                                                    mem[_16760 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                require return_data.size >= 32
                                                if not mem[_14055 + 32]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[mem[64] + 110 len 22]
                                                if not stor[_6758]:
                                                    _16954 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16954] = 26
                                                    mem[_16954 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _17290 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17290] = 26
                                                    mem[_17290 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                    mem[mem[64]] = stor[_6755]
                    else:
                        require ext_code.size(sub_4365354eAddress)
                        staticcall sub_4365354eAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] >= 7800 * 10^18:
                            poolInfo[arg1].field_512 = block.number
                            if not stor[_6758]:
                                _6821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6821] = 26
                                mem[_6821 + 32] = 'SafeMath: division by zero'
                                _6887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6887] = 30
                                mem[_6887 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[_6758] > 0:
                                    _6920 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_6920 + idx + 68] = mem[_6887 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6920 + 68] = mem[_6920 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _6920 + -mem[64] + 100
                                if -stor1[_6758] <= 0:
                                    if stor[_6755] <= 0:
                                        if not stor[_6758]:
                                            _7169 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7169] = 26
                                            mem[_7169 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _7237 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7237] = 26
                                            mem[_7237 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[mem[64]] = stor[_6755]
                                    else:
                                        _7045 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7045] = 30
                                        mem[_7045 + 32] = 'SafeMath: subtraction overflow'
                                        if stor[_6755] > stor[_6758]:
                                            _7111 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_7111 + idx + 68] = mem[_7045 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7111 + 68] = mem[_7111 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _7111 + -mem[64] + 100
                                        stor[_6758] -= stor[_6755]
                                        _7193 = mem[64]
                                        mem[mem[64] + 36] = address(_6751)
                                        mem[mem[64] + 68] = stor[_6755]
                                        _7194 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_7194 + 32] = mem[_7194 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                        mem[64] = _7193 + 164
                                        mem[_7193 + 100] = 32
                                        mem[_7193 + 132] = 'SafeERC20: low-level call failed'
                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                            revert with 0, 'Address: call to non-contract'
                                        _7549 = mem[_7194]
                                        t = _7194 + 32
                                        u = _7193 + 164
                                        s = mem[_7194]
                                        while s >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s - 32
                                            continue 
                                        mem[_7193 + floor32(mem[_7194]) + 164] = mem[_7194 + -(mem[_7194] % 32) + floor32(mem[_7194]) + 64 len mem[_7194] % 32] or Mask(8 * -(mem[_7194] % 32) + 32, -(8 * -(mem[_7194] % 32) + 32) + 256, mem[_7193 + floor32(mem[_7194]) + 164])
                                        call address(poolInfo[arg1].field_0).mem[_7193 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_7193 + 168 len _7549 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96] > 0:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_7193 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7193 + 168] = 32
                                                mem[_7193 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7193 + idx + 232] = mem[_7193 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with memory
                                                  from mem[64]
                                                   len _7193 + -mem[64] + 264
                                            if mem[96] > 0:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7193 + 274 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7193 + 228
                                                mem[_7193 + 164] = 26
                                                mem[_7193 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7193 + 265 len 31]
                                                mem[64] = _7193 + 228
                                                mem[_7193 + 164] = 26
                                                mem[_7193 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7193 + 228] = stor[_6755]
                                        else:
                                            mem[_7193 + 164] = return_data.size
                                            mem[_7193 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size > 0:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_7193 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7193 + ceil32(return_data.size) + 169] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7193 + ceil32(return_data.size) + idx + 233] = mem[_7193 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_7193 + ceil32(return_data.size) + 233]
                                            if return_data.size > 0:
                                                require return_data.size >= 32
                                                if not mem[_7193 + 196]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7193 + ceil32(return_data.size) + 275 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7193 + ceil32(return_data.size) + 229
                                                mem[_7193 + ceil32(return_data.size) + 165] = 26
                                                mem[_7193 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_7193 + ceil32(return_data.size) + 266 len 31]
                                                mem[64] = _7193 + ceil32(return_data.size) + 229
                                                mem[_7193 + ceil32(return_data.size) + 165] = 26
                                                mem[_7193 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7193 + ceil32(return_data.size) + 229] = stor[_6755]
                                else:
                                    _7010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7010] = 26
                                    mem[_7010 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sub_4365354eAddress)
                                    staticcall sub_4365354eAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[mem[64] + 4] = address(_6751)
                                    if -stor1[_6758] <= ext_call.return_data[0]:
                                        mem[mem[64] + 36] = -stor1[_6758]
                                        require ext_code.size(sub_4365354eAddress)
                                        call sub_4365354eAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_6751), -stor1[_6758]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                        if stor[_6755] <= 0:
                                            if not stor[_6758]:
                                                _8092 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8092] = 26
                                                mem[_8092 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8233 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8233] = 26
                                                mem[_8233 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            _7813 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7813] = 30
                                            mem[_7813 + 32] = 'SafeMath: subtraction overflow'
                                            if stor[_6755] > stor[_6758]:
                                                _7952 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_7952 + idx + 68] = mem[_7813 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7952 + 68] = mem[_7952 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _7952 + -mem[64] + 100
                                            stor[_6758] -= stor[_6755]
                                            _8142 = mem[64]
                                            mem[mem[64] + 36] = address(_6751)
                                            mem[mem[64] + 68] = stor[_6755]
                                            _8143 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_8143 + 32] = mem[_8143 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                            mem[64] = _8142 + 164
                                            mem[_8142 + 100] = 32
                                            mem[_8142 + 132] = 'SafeERC20: low-level call failed'
                                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                revert with 0, 'Address: call to non-contract'
                                            _8695 = mem[_8143]
                                            t = _8143 + 32
                                            u = _8142 + 164
                                            s = mem[_8143]
                                            while s >= 32:
                                                mem[u] = mem[t]
                                                t = t + 32
                                                u = u + 32
                                                s = s - 32
                                                continue 
                                            mem[_8142 + floor32(mem[_8143]) + 164] = mem[_8143 + -(mem[_8143] % 32) + floor32(mem[_8143]) + 64 len mem[_8143] % 32] or Mask(8 * -(mem[_8143] % 32) + 32, -(8 * -(mem[_8143] % 32) + 32) + 256, mem[_8142 + floor32(mem[_8143]) + 164])
                                            call address(poolInfo[arg1].field_0).mem[_8142 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_8142 + 168 len _8695 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96] > 0:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_8142 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_8142 + 168] = 32
                                                    mem[_8142 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[_8142 + idx + 232] = mem[_8142 + idx + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with memory
                                                      from mem[64]
                                                       len _8142 + -mem[64] + 264
                                                if mem[96] > 0:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_8142 + 274 len 22]
                                                if not stor[_6758]:
                                                    mem[64] = _8142 + 228
                                                    mem[_8142 + 164] = 26
                                                    mem[_8142 + 196] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_8142 + 265 len 31]
                                                    mem[64] = _8142 + 228
                                                    mem[_8142 + 164] = 26
                                                    mem[_8142 + 196] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[_8142 + 228] = stor[_6755]
                                            else:
                                                mem[_8142 + 164] = return_data.size
                                                mem[_8142 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size > 0:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_8142 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_8142 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[_8142 + ceil32(return_data.size) + idx + 233] = mem[_8142 + idx + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_8142 + ceil32(return_data.size) + 233]
                                                if return_data.size > 0:
                                                    require return_data.size >= 32
                                                    if not mem[_8142 + 196]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_8142 + ceil32(return_data.size) + 275 len 22]
                                                if not stor[_6758]:
                                                    mem[64] = _8142 + ceil32(return_data.size) + 229
                                                    mem[_8142 + ceil32(return_data.size) + 165] = 26
                                                    mem[_8142 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_8142 + ceil32(return_data.size) + 266 len 31]
                                                    mem[64] = _8142 + ceil32(return_data.size) + 229
                                                    mem[_8142 + ceil32(return_data.size) + 165] = 26
                                                    mem[_8142 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[_8142 + ceil32(return_data.size) + 229] = stor[_6755]
                                    else:
                                        mem[mem[64] + 36] = ext_call.return_data[0]
                                        require ext_code.size(sub_4365354eAddress)
                                        call sub_4365354eAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_6751), ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                        if stor[_6755] <= 0:
                                            if not stor[_6758]:
                                                _8094 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8094] = 26
                                                mem[_8094 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8236 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8236] = 26
                                                mem[_8236 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            _7814 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7814] = 30
                                            mem[_7814 + 32] = 'SafeMath: subtraction overflow'
                                            if stor[_6755] > stor[_6758]:
                                                _7955 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_7955 + idx + 68] = mem[_7814 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7955 + 68] = mem[_7955 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _7955 + -mem[64] + 100
                                            stor[_6758] -= stor[_6755]
                                            _8147 = mem[64]
                                            mem[mem[64] + 36] = address(_6751)
                                            mem[mem[64] + 68] = stor[_6755]
                                            _8148 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_8148 + 32] = mem[_8148 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                            mem[64] = _8147 + 164
                                            mem[_8147 + 100] = 32
                                            mem[_8147 + 132] = 'SafeERC20: low-level call failed'
                                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                revert with 0, 'Address: call to non-contract'
                                            _8699 = mem[_8148]
                                            t = _8148 + 32
                                            u = _8147 + 164
                                            s = mem[_8148]
                                            while s >= 32:
                                                mem[u] = mem[t]
                                                t = t + 32
                                                u = u + 32
                                                s = s - 32
                                                continue 
                                            mem[_8147 + floor32(mem[_8148]) + 164] = mem[_8148 + -(mem[_8148] % 32) + floor32(mem[_8148]) + 64 len mem[_8148] % 32] or Mask(8 * -(mem[_8148] % 32) + 32, -(8 * -(mem[_8148] % 32) + 32) + 256, mem[_8147 + floor32(mem[_8148]) + 164])
                                            call address(poolInfo[arg1].field_0).mem[_8147 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_8147 + 168 len _8699 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96] > 0:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_8147 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_8147 + 168] = 32
                                                    mem[_8147 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[_8147 + idx + 232] = mem[_8147 + idx + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with memory
                                                      from mem[64]
                                                       len _8147 + -mem[64] + 264
                                                if mem[96] > 0:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_8147 + 274 len 22]
                                                if not stor[_6758]:
                                                    mem[64] = _8147 + 228
                                                    mem[_8147 + 164] = 26
                                                    mem[_8147 + 196] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_8147 + 265 len 31]
                                                    mem[64] = _8147 + 228
                                                    mem[_8147 + 164] = 26
                                                    mem[_8147 + 196] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[_8147 + 228] = stor[_6755]
                                            else:
                                                mem[_8147 + 164] = return_data.size
                                                mem[_8147 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size > 0:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_8147 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_8147 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[_8147 + ceil32(return_data.size) + idx + 233] = mem[_8147 + idx + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_8147 + ceil32(return_data.size) + 233]
                                                if return_data.size > 0:
                                                    require return_data.size >= 32
                                                    if not mem[_8147 + 196]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_8147 + ceil32(return_data.size) + 275 len 22]
                                                if not stor[_6758]:
                                                    mem[64] = _8147 + ceil32(return_data.size) + 229
                                                    mem[_8147 + ceil32(return_data.size) + 165] = 26
                                                    mem[_8147 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_8147 + ceil32(return_data.size) + 266 len 31]
                                                    mem[64] = _8147 + ceil32(return_data.size) + 229
                                                    mem[_8147 + ceil32(return_data.size) + 165] = 26
                                                    mem[_8147 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[_8147 + ceil32(return_data.size) + 229] = stor[_6755]
                            else:
                                require stor[_6758]
                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6836 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6836] = 26
                                mem[_6836 + 32] = 'SafeMath: division by zero'
                                _6919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6919] = 30
                                mem[_6919 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                    _6960 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_6960 + idx + 68] = mem[_6919 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6960 + 68] = mem[_6960 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _6960 + -mem[64] + 100
                                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                    if stor[_6755] <= 0:
                                        if not stor[_6758]:
                                            _7235 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7235] = 26
                                            mem[_7235 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = 0
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _7308 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7308] = 26
                                            mem[_7308 + 32] = 'SafeMath: division by zero'
                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[mem[64]] = stor[_6755]
                                    else:
                                        _7110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7110] = 30
                                        mem[_7110 + 32] = 'SafeMath: subtraction overflow'
                                        if stor[_6755] > stor[_6758]:
                                            _7166 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_7166 + idx + 68] = mem[_7110 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7166 + 68] = mem[_7166 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _7166 + -mem[64] + 100
                                        stor[_6758] -= stor[_6755]
                                        _7262 = mem[64]
                                        mem[mem[64] + 36] = address(_6751)
                                        mem[mem[64] + 68] = stor[_6755]
                                        _7263 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_7263 + 32] = mem[_7263 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                        mem[64] = _7262 + 164
                                        mem[_7262 + 100] = 32
                                        mem[_7262 + 132] = 'SafeERC20: low-level call failed'
                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                            revert with 0, 'Address: call to non-contract'
                                        _7636 = mem[_7263]
                                        t = _7263 + 32
                                        u = _7262 + 164
                                        s = mem[_7263]
                                        while s >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s - 32
                                            continue 
                                        mem[_7262 + floor32(mem[_7263]) + 164] = mem[_7263 + -(mem[_7263] % 32) + floor32(mem[_7263]) + 64 len mem[_7263] % 32] or Mask(8 * -(mem[_7263] % 32) + 32, -(8 * -(mem[_7263] % 32) + 32) + 256, mem[_7262 + floor32(mem[_7263]) + 164])
                                        call address(poolInfo[arg1].field_0).mem[_7262 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_7262 + 168 len _7636 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96] > 0:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_7262 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7262 + 168] = 32
                                                mem[_7262 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7262 + idx + 232] = mem[_7262 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with memory
                                                  from mem[64]
                                                   len _7262 + -mem[64] + 264
                                            if mem[96] > 0:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7262 + 274 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7262 + 228
                                                mem[_7262 + 164] = 26
                                                mem[_7262 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_7262 + 265 len 31]
                                                mem[64] = _7262 + 228
                                                mem[_7262 + 164] = 26
                                                mem[_7262 + 196] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7262 + 228] = stor[_6755]
                                        else:
                                            mem[_7262 + 164] = return_data.size
                                            mem[_7262 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size > 0:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_7262 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_7262 + ceil32(return_data.size) + 169] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[_7262 + ceil32(return_data.size) + idx + 233] = mem[_7262 + idx + 132]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_7262 + ceil32(return_data.size) + 233]
                                            if return_data.size > 0:
                                                require return_data.size >= 32
                                                if not mem[_7262 + 196]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_7262 + ceil32(return_data.size) + 275 len 22]
                                            if not stor[_6758]:
                                                mem[64] = _7262 + ceil32(return_data.size) + 229
                                                mem[_7262 + ceil32(return_data.size) + 165] = 26
                                                mem[_7262 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_7262 + ceil32(return_data.size) + 266 len 31]
                                                mem[64] = _7262 + ceil32(return_data.size) + 229
                                                mem[_7262 + ceil32(return_data.size) + 165] = 26
                                                mem[_7262 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[_7262 + ceil32(return_data.size) + 229] = stor[_6755]
                                else:
                                    _7067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7067] = 26
                                    mem[_7067 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sub_4365354eAddress)
                                    staticcall sub_4365354eAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[mem[64] + 4] = address(_6751)
                                    if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] > ext_call.return_data[0]:
                                        mem[mem[64] + 36] = ext_call.return_data[0]
                                        require ext_code.size(sub_4365354eAddress)
                                        call sub_4365354eAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_6751), ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                        if stor[_6755] <= 0:
                                            if not stor[_6758]:
                                                _8227 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8227] = 26
                                                mem[_8227 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8365 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8365] = 26
                                                mem[_8365 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            _7951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7951] = 30
                                            mem[_7951 + 32] = 'SafeMath: subtraction overflow'
                                            if stor[_6755] > stor[_6758]:
                                                _8083 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_8083 + idx + 68] = mem[_7951 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_8083 + 68] = mem[_8083 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _8083 + -mem[64] + 100
                                            stor[_6758] -= stor[_6755]
                                            _8278 = mem[64]
                                            mem[mem[64] + 36] = address(_6751)
                                            mem[mem[64] + 68] = stor[_6755]
                                            _8279 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_8279 + 32] = mem[_8279 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                            mem[64] = _8278 + 164
                                            mem[_8278 + 100] = 32
                                            mem[_8278 + 132] = 'SafeERC20: low-level call failed'
                                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                revert with 0, 'Address: call to non-contract'
                                            _8822 = mem[_8279]
                                            t = _8279 + 32
                                            u = _8278 + 164
                                            s = mem[_8279]
                                            while s >= 32:
                                                mem[u] = mem[t]
                                                t = t + 32
                                                u = u + 32
                                                s = s - 32
                                                continue 
                                            mem[_8278 + floor32(mem[_8279]) + 164] = mem[_8279 + -(mem[_8279] % 32) + floor32(mem[_8279]) + 64 len mem[_8279] % 32] or Mask(8 * -(mem[_8279] % 32) + 32, -(8 * -(mem[_8279] % 32) + 32) + 256, mem[_8278 + floor32(mem[_8279]) + 164])
                                            call address(poolInfo[arg1].field_0).mem[_8278 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_8278 + 168 len _8822 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96] > 0:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_8278 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_8278 + 168] = 32
                                                    mem[_8278 + 200] = 32
                                                    s = 0
                                                    while s < 32:
                                                        mem[_8278 + s + 232] = mem[_8278 + s + 132]
                                                        s = s + 32
                                                        continue 
                                                    revert with memory
                                                      from mem[64]
                                                       len _8278 + -mem[64] + 264
                                                if mem[96] > 0:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_8278 + 274 len 22]
                                                if not stor[_6758]:
                                                    mem[64] = _8278 + 228
                                                    mem[_8278 + 164] = 26
                                                    mem[_8278 + 196] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_8278 + 265 len 31]
                                                    mem[64] = _8278 + 228
                                                    mem[_8278 + 164] = 26
                                                    mem[_8278 + 196] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[_8278 + 228] = stor[_6755]
                                            else:
                                                mem[_8278 + 164] = return_data.size
                                                mem[_8278 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size > 0:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_8278 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_8278 + ceil32(return_data.size) + 169] = 32
                                                    s = 0
                                                    while s < 32:
                                                        mem[_8278 + ceil32(return_data.size) + s + 233] = mem[_8278 + s + 132]
                                                        s = s + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_8278 + ceil32(return_data.size) + 233]
                                                if return_data.size > 0:
                                                    require return_data.size >= 32
                                                    if not mem[_8278 + 196]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_8278 + ceil32(return_data.size) + 275 len 22]
                                                if not stor[_6758]:
                                                    mem[64] = _8278 + ceil32(return_data.size) + 229
                                                    mem[_8278 + ceil32(return_data.size) + 165] = 26
                                                    mem[_8278 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_8278 + ceil32(return_data.size) + 266 len 31]
                                                    mem[64] = _8278 + ceil32(return_data.size) + 229
                                                    mem[_8278 + ceil32(return_data.size) + 165] = 26
                                                    mem[_8278 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[_8278 + ceil32(return_data.size) + 229] = stor[_6755]
                                    else:
                                        mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                        require ext_code.size(sub_4365354eAddress)
                                        call sub_4365354eAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                        if stor[_6755] <= 0:
                                            if not stor[_6758]:
                                                _8225 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8225] = 26
                                                mem[_8225 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = 0
                                            else:
                                                require stor[_6758]
                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8362 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8362] = 26
                                                mem[_8362 + 32] = 'SafeMath: division by zero'
                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        else:
                                            _7950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7950] = 30
                                            mem[_7950 + 32] = 'SafeMath: subtraction overflow'
                                            if stor[_6755] > stor[_6758]:
                                                _8080 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_8080 + idx + 68] = mem[_7950 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_8080 + 68] = mem[_8080 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _8080 + -mem[64] + 100
                                            stor[_6758] -= stor[_6755]
                                            _8273 = mem[64]
                                            mem[mem[64] + 36] = address(_6751)
                                            mem[mem[64] + 68] = stor[_6755]
                                            _8274 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_8274 + 32] = mem[_8274 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                            mem[64] = _8273 + 164
                                            mem[_8273 + 100] = 32
                                            mem[_8273 + 132] = 'SafeERC20: low-level call failed'
                                            if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                revert with 0, 'Address: call to non-contract'
                                            _8818 = mem[_8274]
                                            t = _8274 + 32
                                            u = mem[64]
                                            s = mem[_8274]
                                            while s >= 32:
                                                mem[u] = mem[t]
                                                t = t + 32
                                                u = u + 32
                                                s = s - 32
                                                continue 
                                            mem[mem[64] + floor32(mem[_8274])] = mem[_8274 + floor32(mem[_8274]) + -(mem[_8274] % 32) + 64 len mem[_8274] % 32] or Mask(8 * -(mem[_8274] % 32) + 32, -(8 * -(mem[_8274] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_8274])])
                                            call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _8818 + _8273 + -mem[64] + 160]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96] > 0:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    _14689 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = mem[_8273 + 100]
                                                    _14691 = mem[_8273 + 100]
                                                    s = 0
                                                    while s < _14691:
                                                        mem[_14689 + s + 68] = mem[_8273 + s + 132]
                                                        s = s + 32
                                                        continue 
                                                    if not _14691 % 32:
                                                        revert with memory
                                                          from mem[64]
                                                           len _14691 + _14689 + -mem[64] + 68
                                                    mem[floor32(_14691) + _14689 + 68] = mem[floor32(_14691) + _14689 + -(_14691 % 32) + 100 len _14691 % 32]
                                                    revert with memory
                                                      from mem[64]
                                                       len floor32(_14691) + _14689 + -mem[64] + 100
                                                if mem[96] <= 0:
                                                    if not stor[_6758]:
                                                        _16411 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16411] = 26
                                                        mem[_16411 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _16715 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16715] = 26
                                                        mem[_16715 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[mem[64] + 110 len 22]
                                                    if not stor[_6758]:
                                                        _16939 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16939] = 26
                                                        mem[_16939 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _17245 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17245] = 26
                                                        mem[_17245 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                _14030 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                mem[_14030] = return_data.size
                                                mem[_14030 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size > 0:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _14693 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = mem[_8273 + 100]
                                                    _14695 = mem[_8273 + 100]
                                                    s = 0
                                                    while s < _14695:
                                                        mem[_14693 + s + 68] = mem[_8273 + s + 132]
                                                        s = s + 32
                                                        continue 
                                                    if not _14695 % 32:
                                                        revert with memory
                                                          from mem[64]
                                                           len _14695 + _14693 + -mem[64] + 68
                                                    mem[floor32(_14695) + _14693 + 68] = mem[floor32(_14695) + _14693 + -(_14695 % 32) + 100 len _14695 % 32]
                                                    revert with memory
                                                      from mem[64]
                                                       len floor32(_14695) + _14693 + -mem[64] + 100
                                                if return_data.size <= 0:
                                                    if not stor[_6758]:
                                                        _16412 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16412] = 26
                                                        mem[_16412 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _16718 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16718] = 26
                                                        mem[_16718 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    require return_data.size >= 32
                                                    if not mem[_14030 + 32]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[mem[64] + 110 len 22]
                                                    if not stor[_6758]:
                                                        _16940 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16940] = 26
                                                        mem[_16940 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _17248 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17248] = 26
                                                        mem[_17248 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                        mem[mem[64]] = stor[_6755]
                        else:
                            _6790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6790] = 30
                            mem[_6790 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[arg1].field_512 > block.number:
                                _6800 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_6800 + idx + 68] = mem[_6790 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6800 + 68] = mem[_6800 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _6800 + -mem[64] + 100
                            if not block.number - poolInfo[arg1].field_512:
                                _6944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6944] = 26
                                mem[_6944 + 32] = 'SafeMath: division by zero'
                                if totalAllocPoint <= 0:
                                    _6987 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[_6987 + idx + 68] = mem[_6944 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6987 + 68] = mem[_6987 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _6987 + -mem[64] + 100
                                require totalAllocPoint
                                _7108 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7108] = 26
                                mem[_7108 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 10
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(sub_4365354eAddress)
                                call sub_4365354eAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    _7693 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7693] = 26
                                    mem[_7693 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0] <= 0:
                                        _7807 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_7807 + idx + 68] = mem[_7693 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7807 + 68] = mem[_7807 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _7807 + -mem[64] + 100
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if stor[_6758]:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _8816 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8816] = 26
                                        mem[_8816 + 32] = 'SafeMath: division by zero'
                                        _9222 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9222] = 30
                                        mem[_9222 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                            _9340 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_9340 + idx + 68] = mem[_9222 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9340 + 68] = mem[_9340 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _9340 + -mem[64] + 100
                                        if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                            if stor[_6755] <= 0:
                                                if not stor[_6758]:
                                                    _9861 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9861] = 26
                                                    mem[_9861 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _9986 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9986] = 26
                                                    mem[_9986 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                            else:
                                                _9623 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9623] = 30
                                                mem[_9623 + 32] = 'SafeMath: subtraction overflow'
                                                if stor[_6755] > stor[_6758]:
                                                    _9739 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_9739 + idx + 68] = mem[_9623 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_9739 + 68] = mem[_9739 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _9739 + -mem[64] + 100
                                                stor[_6758] -= stor[_6755]
                                                _9922 = mem[64]
                                                mem[mem[64] + 36] = address(_6751)
                                                mem[mem[64] + 68] = stor[_6755]
                                                _9923 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_9923 + 32] = mem[_9923 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                mem[64] = _9922 + 164
                                                mem[_9922 + 100] = 32
                                                mem[_9922 + 132] = 'SafeERC20: low-level call failed'
                                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _10385 = mem[_9923]
                                                t = _9923 + 32
                                                u = _9922 + 164
                                                s = mem[_9923]
                                                while s >= 32:
                                                    mem[u] = mem[t]
                                                    t = t + 32
                                                    u = u + 32
                                                    s = s - 32
                                                    continue 
                                                mem[_9922 + floor32(mem[_9923]) + 164] = mem[_9923 + -(mem[_9923] % 32) + floor32(mem[_9923]) + 64 len mem[_9923] % 32] or Mask(8 * -(mem[_9923] % 32) + 32, -(8 * -(mem[_9923] % 32) + 32) + 256, mem[_9922 + floor32(mem[_9923]) + 164])
                                                call address(poolInfo[arg1].field_0).mem[_9922 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_9922 + 168 len _10385 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96] > 0:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_9922 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_9922 + 168] = 32
                                                        mem[_9922 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[_9922 + idx + 232] = mem[_9922 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with memory
                                                          from mem[64]
                                                           len _9922 + -mem[64] + 264
                                                    if mem[96] > 0:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_9922 + 274 len 22]
                                                    if not stor[_6758]:
                                                        mem[64] = _9922 + 228
                                                        mem[_9922 + 164] = 26
                                                        mem[_9922 + 196] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_9922 + 265 len 31]
                                                        mem[64] = _9922 + 228
                                                        mem[_9922 + 164] = 26
                                                        mem[_9922 + 196] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[_9922 + 228] = stor[_6755]
                                                else:
                                                    mem[_9922 + 164] = return_data.size
                                                    mem[_9922 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size > 0:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_9922 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_9922 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[_9922 + ceil32(return_data.size) + idx + 233] = mem[_9922 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_9922 + ceil32(return_data.size) + 233]
                                                    if return_data.size > 0:
                                                        require return_data.size >= 32
                                                        if not mem[_9922 + 196]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_9922 + ceil32(return_data.size) + 275 len 22]
                                                    if not stor[_6758]:
                                                        mem[64] = _9922 + ceil32(return_data.size) + 229
                                                        mem[_9922 + ceil32(return_data.size) + 165] = 26
                                                        mem[_9922 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9922 + ceil32(return_data.size) + 266 len 31]
                                                        mem[64] = _9922 + ceil32(return_data.size) + 229
                                                        mem[_9922 + ceil32(return_data.size) + 165] = 26
                                                        mem[_9922 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[_9922 + ceil32(return_data.size) + 229] = stor[_6755]
                                        else:
                                            _9579 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9579] = 26
                                            mem[_9579 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(sub_4365354eAddress)
                                            staticcall sub_4365354eAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[mem[64] + 4] = address(_6751)
                                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                                mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10825 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10825] = 26
                                                        mem[_10825 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _11023 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11023] = 26
                                                        mem[_11023 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _10581 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10581] = 30
                                                    mem[_10581 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10672 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10672 + idx + 68] = mem[_10581 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10672 + 68] = mem[_10672 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10672 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10927 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10928 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10928 + 32] = mem[_10928 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10927 + 164
                                                    mem[_10927 + 100] = 32
                                                    mem[_10927 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11470 = mem[_10928]
                                                    t = _10928 + 32
                                                    u = _10927 + 164
                                                    s = mem[_10928]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10927 + floor32(mem[_10928]) + 164] = mem[_10928 + -(mem[_10928] % 32) + floor32(mem[_10928]) + 64 len mem[_10928] % 32] or Mask(8 * -(mem[_10928] % 32) + 32, -(8 * -(mem[_10928] % 32) + 32) + 256, mem[_10927 + floor32(mem[_10928]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10927 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10927 + 168 len _11470 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10927 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10927 + 168] = 32
                                                            mem[_10927 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10927 + idx + 232] = mem[_10927 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10927 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10927 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10927 + 228
                                                            mem[_10927 + 164] = 26
                                                            mem[_10927 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10927 + 265 len 31]
                                                            mem[64] = _10927 + 228
                                                            mem[_10927 + 164] = 26
                                                            mem[_10927 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10927 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10927 + 164] = return_data.size
                                                        mem[_10927 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10927 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10927 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10927 + ceil32(return_data.size) + idx + 233] = mem[_10927 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10927 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10927 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10927 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10927 + ceil32(return_data.size) + 229
                                                            mem[_10927 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10927 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10927 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10927 + ceil32(return_data.size) + 229
                                                            mem[_10927 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10927 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10927 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                mem[mem[64] + 36] = ext_call.return_data[0]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10827 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10827] = 26
                                                        mem[_10827 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _11026 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11026] = 26
                                                        mem[_11026 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _10582 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10582] = 30
                                                    mem[_10582 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10675 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10675 + idx + 68] = mem[_10582 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10675 + 68] = mem[_10675 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10675 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10932 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10933 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10933 + 32] = mem[_10933 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10932 + 164
                                                    mem[_10932 + 100] = 32
                                                    mem[_10932 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11474 = mem[_10933]
                                                    t = _10933 + 32
                                                    u = _10932 + 164
                                                    s = mem[_10933]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10932 + floor32(mem[_10933]) + 164] = mem[_10933 + -(mem[_10933] % 32) + floor32(mem[_10933]) + 64 len mem[_10933] % 32] or Mask(8 * -(mem[_10933] % 32) + 32, -(8 * -(mem[_10933] % 32) + 32) + 256, mem[_10932 + floor32(mem[_10933]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10932 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10932 + 168 len _11474 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10932 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10932 + 168] = 32
                                                            mem[_10932 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10932 + idx + 232] = mem[_10932 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10932 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10932 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10932 + 228
                                                            mem[_10932 + 164] = 26
                                                            mem[_10932 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10932 + 265 len 31]
                                                            mem[64] = _10932 + 228
                                                            mem[_10932 + 164] = 26
                                                            mem[_10932 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10932 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10932 + 164] = return_data.size
                                                        mem[_10932 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10932 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10932 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10932 + ceil32(return_data.size) + idx + 233] = mem[_10932 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10932 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10932 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10932 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10932 + ceil32(return_data.size) + 229
                                                            mem[_10932 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10932 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10932 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10932 + ceil32(return_data.size) + 229
                                                            mem[_10932 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10932 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10932 + ceil32(return_data.size) + 229] = stor[_6755]
                                    else:
                                        _8685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8685] = 26
                                        mem[_8685 + 32] = 'SafeMath: division by zero'
                                        _9100 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9100] = 30
                                        mem[_9100 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[_6758] > 0:
                                            _9223 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_9223 + idx + 68] = mem[_9100 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9223 + 68] = mem[_9223 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _9223 + -mem[64] + 100
                                        if -stor1[_6758] <= 0:
                                            if stor[_6755] <= 0:
                                                if not stor[_6758]:
                                                    _9742 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9742] = 26
                                                    mem[_9742 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _9863 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9863] = 26
                                                    mem[_9863 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                _9516 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9516] = 30
                                                mem[_9516 + 32] = 'SafeMath: subtraction overflow'
                                                if stor[_6755] > stor[_6758]:
                                                    _9624 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_9624 + idx + 68] = mem[_9516 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_9624 + 68] = mem[_9624 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _9624 + -mem[64] + 100
                                                stor[_6758] -= stor[_6755]
                                                _9789 = mem[64]
                                                mem[mem[64] + 36] = address(_6751)
                                                mem[mem[64] + 68] = stor[_6755]
                                                _9790 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_9790 + 32] = mem[_9790 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                mem[64] = _9789 + 164
                                                mem[_9789 + 100] = 32
                                                mem[_9789 + 132] = 'SafeERC20: low-level call failed'
                                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _10292 = mem[_9790]
                                                t = _9790 + 32
                                                u = mem[64]
                                                s = mem[_9790]
                                                while s >= 32:
                                                    mem[u] = mem[t]
                                                    t = t + 32
                                                    u = u + 32
                                                    s = s - 32
                                                    continue 
                                                mem[mem[64] + floor32(mem[_9790])] = mem[_9790 + floor32(mem[_9790]) + -(mem[_9790] % 32) + 64 len mem[_9790] % 32] or Mask(8 * -(mem[_9790] % 32) + 32, -(8 * -(mem[_9790] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_9790])])
                                                call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _10292 + _9789 + -mem[64] + 160]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96] > 0:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        _14657 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = mem[_9789 + 100]
                                                        _14659 = mem[_9789 + 100]
                                                        idx = 0
                                                        while idx < _14659:
                                                            mem[_14657 + idx + 68] = mem[_9789 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        if not _14659 % 32:
                                                            revert with memory
                                                              from mem[64]
                                                               len _14659 + _14657 + -mem[64] + 68
                                                        mem[floor32(_14659) + _14657 + 68] = mem[floor32(_14659) + _14657 + -(_14659 % 32) + 100 len _14659 % 32]
                                                        revert with memory
                                                          from mem[64]
                                                           len floor32(_14659) + _14657 + -mem[64] + 100
                                                    if mem[96] <= 0:
                                                        if not stor[_6758]:
                                                            _16403 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16403] = 26
                                                            mem[_16403 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _16691 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16691] = 26
                                                            mem[_16691 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[mem[64] + 110 len 22]
                                                        if not stor[_6758]:
                                                            _16931 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16931] = 26
                                                            mem[_16931 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _17221 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17221] = 26
                                                            mem[_17221 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _14010 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                    mem[_14010] = return_data.size
                                                    mem[_14010 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size > 0:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _14661 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = mem[_9789 + 100]
                                                        _14663 = mem[_9789 + 100]
                                                        idx = 0
                                                        while idx < _14663:
                                                            mem[_14661 + idx + 68] = mem[_9789 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        if not _14663 % 32:
                                                            revert with memory
                                                              from mem[64]
                                                               len _14663 + _14661 + -mem[64] + 68
                                                        mem[floor32(_14663) + _14661 + 68] = mem[floor32(_14663) + _14661 + -(_14663 % 32) + 100 len _14663 % 32]
                                                        revert with memory
                                                          from mem[64]
                                                           len floor32(_14663) + _14661 + -mem[64] + 100
                                                    if return_data.size <= 0:
                                                        if not stor[_6758]:
                                                            _16404 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16404] = 26
                                                            mem[_16404 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _16694 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16694] = 26
                                                            mem[_16694 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        require return_data.size >= 32
                                                        if not mem[_14010 + 32]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[mem[64] + 110 len 22]
                                                        if not stor[_6758]:
                                                            _16932 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16932] = 26
                                                            mem[_16932 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _17224 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17224] = 26
                                                            mem[_17224 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            _9460 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9460] = 26
                                            mem[_9460 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(sub_4365354eAddress)
                                            staticcall sub_4365354eAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[mem[64] + 4] = address(_6751)
                                            if -stor1[_6758] <= ext_call.return_data[0]:
                                                mem[mem[64] + 36] = -stor1[_6758]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), -stor1[_6758]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10684 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10684] = 26
                                                        mem[_10684 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10833 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10833] = 26
                                                        mem[_10833 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _10509 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10509] = 30
                                                    mem[_10509 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10583 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10583 + idx + 68] = mem[_10509 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10583 + 68] = mem[_10583 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10583 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10752 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10753 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10753 + 32] = mem[_10753 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10752 + 164
                                                    mem[_10752 + 100] = 32
                                                    mem[_10752 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11368 = mem[_10753]
                                                    t = _10753 + 32
                                                    u = _10752 + 164
                                                    s = mem[_10753]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10752 + floor32(mem[_10753]) + 164] = mem[_10753 + -(mem[_10753] % 32) + floor32(mem[_10753]) + 64 len mem[_10753] % 32] or Mask(8 * -(mem[_10753] % 32) + 32, -(8 * -(mem[_10753] % 32) + 32) + 256, mem[_10752 + floor32(mem[_10753]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10752 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10752 + 168 len _11368 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10752 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10752 + 168] = 32
                                                            mem[_10752 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10752 + idx + 232] = mem[_10752 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10752 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10752 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10752 + 228
                                                            mem[_10752 + 164] = 26
                                                            mem[_10752 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10752 + 265 len 31]
                                                            mem[64] = _10752 + 228
                                                            mem[_10752 + 164] = 26
                                                            mem[_10752 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10752 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10752 + 164] = return_data.size
                                                        mem[_10752 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10752 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10752 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10752 + ceil32(return_data.size) + idx + 233] = mem[_10752 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10752 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10752 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10752 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10752 + ceil32(return_data.size) + 229
                                                            mem[_10752 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10752 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10752 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10752 + ceil32(return_data.size) + 229
                                                            mem[_10752 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10752 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10752 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                mem[mem[64] + 36] = ext_call.return_data[0]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10686 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10686] = 26
                                                        mem[_10686 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10836 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10836] = 26
                                                        mem[_10836 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _10510 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10510] = 30
                                                    mem[_10510 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10586 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10586 + idx + 68] = mem[_10510 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10586 + 68] = mem[_10586 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10586 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10757 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10758 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10758 + 32] = mem[_10758 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10757 + 164
                                                    mem[_10757 + 100] = 32
                                                    mem[_10757 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11372 = mem[_10758]
                                                    t = _10758 + 32
                                                    u = mem[64]
                                                    s = mem[_10758]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[mem[64] + floor32(mem[_10758])] = mem[_10758 + floor32(mem[_10758]) + -(mem[_10758] % 32) + 64 len mem[_10758] % 32] or Mask(8 * -(mem[_10758] % 32) + 32, -(8 * -(mem[_10758] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_10758])])
                                                    call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _11372 + _10757 + -mem[64] + 160]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            _14673 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10757 + 100]
                                                            _14675 = mem[_10757 + 100]
                                                            idx = 0
                                                            while idx < _14675:
                                                                mem[_14673 + idx + 68] = mem[_10757 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14675 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14675 + _14673 + -mem[64] + 68
                                                            mem[floor32(_14675) + _14673 + 68] = mem[floor32(_14675) + _14673 + -(_14675 % 32) + 100 len _14675 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14675) + _14673 + -mem[64] + 100
                                                        if mem[96] <= 0:
                                                            if not stor[_6758]:
                                                                _16407 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16407] = 26
                                                                mem[_16407 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16703 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16703] = 26
                                                                mem[_16703 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16935 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16935] = 26
                                                                mem[_16935 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17233 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17233] = 26
                                                                mem[_17233 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _14016 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_14016] = return_data.size
                                                        mem[_14016 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _14677 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10757 + 100]
                                                            _14679 = mem[_10757 + 100]
                                                            idx = 0
                                                            while idx < _14679:
                                                                mem[_14677 + idx + 68] = mem[_10757 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14679 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14679 + _14677 + -mem[64] + 68
                                                            mem[floor32(_14679) + _14677 + 68] = mem[floor32(_14679) + _14677 + -(_14679 % 32) + 100 len _14679 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14679) + _14677 + -mem[64] + 100
                                                        if return_data.size <= 0:
                                                            if not stor[_6758]:
                                                                _16408 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16408] = 26
                                                                mem[_16408 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16706 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16706] = 26
                                                                mem[_16706 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require return_data.size >= 32
                                                            if not mem[_14016 + 32]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16936 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16936] = 26
                                                                mem[_16936 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17236 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17236] = 26
                                                                mem[_17236 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7806 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7806] = 26
                                    mem[_7806 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0] <= 0:
                                        _7944 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_7944 + idx + 68] = mem[_7806 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7944 + 68] = mem[_7944 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _7944 + -mem[64] + 100
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not stor[_6758]:
                                        _8815 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8815] = 26
                                        mem[_8815 + 32] = 'SafeMath: division by zero'
                                        _9221 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9221] = 30
                                        mem[_9221 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[_6758] > 0:
                                            _9337 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_9337 + idx + 68] = mem[_9221 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9337 + 68] = mem[_9337 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _9337 + -mem[64] + 100
                                        if -stor1[_6758] <= 0:
                                            if stor[_6755] <= 0:
                                                if not stor[_6758]:
                                                    _9859 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9859] = 26
                                                    mem[_9859 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _9983 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9983] = 26
                                                    mem[_9983 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                _9622 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9622] = 30
                                                mem[_9622 + 32] = 'SafeMath: subtraction overflow'
                                                if stor[_6755] > stor[_6758]:
                                                    _9736 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_9736 + idx + 68] = mem[_9622 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_9736 + 68] = mem[_9736 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _9736 + -mem[64] + 100
                                                stor[_6758] -= stor[_6755]
                                                _9915 = mem[64]
                                                mem[mem[64] + 36] = address(_6751)
                                                mem[mem[64] + 68] = stor[_6755]
                                                _9916 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_9916 + 32] = mem[_9916 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                mem[64] = _9915 + 164
                                                mem[_9915 + 100] = 32
                                                mem[_9915 + 132] = 'SafeERC20: low-level call failed'
                                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _10381 = mem[_9916]
                                                t = _9916 + 32
                                                u = mem[64]
                                                s = mem[_9916]
                                                while s >= 32:
                                                    mem[u] = mem[t]
                                                    t = t + 32
                                                    u = u + 32
                                                    s = s - 32
                                                    continue 
                                                mem[mem[64] + floor32(mem[_9916])] = mem[_9916 + floor32(mem[_9916]) + -(mem[_9916] % 32) + 64 len mem[_9916] % 32] or Mask(8 * -(mem[_9916] % 32) + 32, -(8 * -(mem[_9916] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_9916])])
                                                call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _10381 + _9915 + -mem[64] + 160]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96] > 0:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        _14609 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = mem[_9915 + 100]
                                                        _14611 = mem[_9915 + 100]
                                                        idx = 0
                                                        while idx < _14611:
                                                            mem[_14609 + idx + 68] = mem[_9915 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        if not _14611 % 32:
                                                            revert with memory
                                                              from mem[64]
                                                               len _14611 + _14609 + -mem[64] + 68
                                                        mem[floor32(_14611) + _14609 + 68] = mem[floor32(_14611) + _14609 + -(_14611 % 32) + 100 len _14611 % 32]
                                                        revert with memory
                                                          from mem[64]
                                                           len floor32(_14611) + _14609 + -mem[64] + 100
                                                    if mem[96] <= 0:
                                                        if not stor[_6758]:
                                                            _16391 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16391] = 26
                                                            mem[_16391 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _16655 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16655] = 26
                                                            mem[_16655 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[mem[64] + 110 len 22]
                                                        if not stor[_6758]:
                                                            _16919 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16919] = 26
                                                            mem[_16919 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _17185 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17185] = 26
                                                            mem[_17185 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _13986 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                    mem[_13986] = return_data.size
                                                    mem[_13986 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size > 0:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _14613 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = mem[_9915 + 100]
                                                        _14615 = mem[_9915 + 100]
                                                        idx = 0
                                                        while idx < _14615:
                                                            mem[_14613 + idx + 68] = mem[_9915 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        if not _14615 % 32:
                                                            revert with memory
                                                              from mem[64]
                                                               len _14615 + _14613 + -mem[64] + 68
                                                        mem[floor32(_14615) + _14613 + 68] = mem[floor32(_14615) + _14613 + -(_14615 % 32) + 100 len _14615 % 32]
                                                        revert with memory
                                                          from mem[64]
                                                           len floor32(_14615) + _14613 + -mem[64] + 100
                                                    if return_data.size <= 0:
                                                        if not stor[_6758]:
                                                            _16392 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16392] = 26
                                                            mem[_16392 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _16658 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16658] = 26
                                                            mem[_16658 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        require return_data.size >= 32
                                                        if not mem[_13986 + 32]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[mem[64] + 110 len 22]
                                                        if not stor[_6758]:
                                                            _16920 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16920] = 26
                                                            mem[_16920 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _17188 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17188] = 26
                                                            mem[_17188 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            _9577 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9577] = 26
                                            mem[_9577 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(sub_4365354eAddress)
                                            staticcall sub_4365354eAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[mem[64] + 4] = address(_6751)
                                            if -stor1[_6758] > ext_call.return_data[0]:
                                                mem[mem[64] + 36] = ext_call.return_data[0]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10817 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10817] = 26
                                                        mem[_10817 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _11016 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11016] = 26
                                                        mem[_11016 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _10578 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10578] = 30
                                                    mem[_10578 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10669 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10669 + idx + 68] = mem[_10578 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10669 + 68] = mem[_10669 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10669 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10918 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10919 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10919 + 32] = mem[_10919 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10918 + 164
                                                    mem[_10918 + 100] = 32
                                                    mem[_10918 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11466 = mem[_10919]
                                                    t = _10919 + 32
                                                    u = _10918 + 164
                                                    s = mem[_10919]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10918 + floor32(mem[_10919]) + 164] = mem[_10919 + -(mem[_10919] % 32) + floor32(mem[_10919]) + 64 len mem[_10919] % 32] or Mask(8 * -(mem[_10919] % 32) + 32, -(8 * -(mem[_10919] % 32) + 32) + 256, mem[_10918 + floor32(mem[_10919]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10918 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10918 + 168 len _11466 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10918 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10918 + 168] = 32
                                                            mem[_10918 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10918 + idx + 232] = mem[_10918 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10918 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10918 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10918 + 228
                                                            mem[_10918 + 164] = 26
                                                            mem[_10918 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10918 + 265 len 31]
                                                            mem[64] = _10918 + 228
                                                            mem[_10918 + 164] = 26
                                                            mem[_10918 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10918 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10918 + 164] = return_data.size
                                                        mem[_10918 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10918 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10918 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10918 + ceil32(return_data.size) + idx + 233] = mem[_10918 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10918 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10918 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10918 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10918 + ceil32(return_data.size) + 229
                                                            mem[_10918 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10918 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10918 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10918 + ceil32(return_data.size) + 229
                                                            mem[_10918 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10918 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10918 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                mem[mem[64] + 36] = -stor1[_6758]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), -stor1[_6758]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10815 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10815] = 26
                                                        mem[_10815 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _11013 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11013] = 26
                                                        mem[_11013 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _10577 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10577] = 30
                                                    mem[_10577 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10666 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10666 + idx + 68] = mem[_10577 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10666 + 68] = mem[_10666 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10666 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10913 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10914 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10914 + 32] = mem[_10914 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10913 + 164
                                                    mem[_10913 + 100] = 32
                                                    mem[_10913 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11462 = mem[_10914]
                                                    t = _10914 + 32
                                                    u = mem[64]
                                                    s = mem[_10914]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[mem[64] + floor32(mem[_10914])] = mem[_10914 + floor32(mem[_10914]) + -(mem[_10914] % 32) + 64 len mem[_10914] % 32] or Mask(8 * -(mem[_10914] % 32) + 32, -(8 * -(mem[_10914] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_10914])])
                                                    call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _11462 + _10913 + -mem[64] + 160]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            _14617 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10913 + 100]
                                                            _14619 = mem[_10913 + 100]
                                                            idx = 0
                                                            while idx < _14619:
                                                                mem[_14617 + idx + 68] = mem[_10913 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14619 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14619 + _14617 + -mem[64] + 68
                                                            mem[floor32(_14619) + _14617 + 68] = mem[floor32(_14619) + _14617 + -(_14619 % 32) + 100 len _14619 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14619) + _14617 + -mem[64] + 100
                                                        if mem[96] <= 0:
                                                            if not stor[_6758]:
                                                                _16393 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16393] = 26
                                                                mem[_16393 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16661 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16661] = 26
                                                                mem[_16661 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16921 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16921] = 26
                                                                mem[_16921 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17191 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17191] = 26
                                                                mem[_17191 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _13989 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_13989] = return_data.size
                                                        mem[_13989 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _14621 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10913 + 100]
                                                            _14623 = mem[_10913 + 100]
                                                            idx = 0
                                                            while idx < _14623:
                                                                mem[_14621 + idx + 68] = mem[_10913 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14623 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14623 + _14621 + -mem[64] + 68
                                                            mem[floor32(_14623) + _14621 + 68] = mem[floor32(_14623) + _14621 + -(_14623 % 32) + 100 len _14623 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14623) + _14621 + -mem[64] + 100
                                                        if return_data.size <= 0:
                                                            if not stor[_6758]:
                                                                _16394 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16394] = 26
                                                                mem[_16394 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16664 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16664] = 26
                                                                mem[_16664 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require return_data.size >= 32
                                                            if not mem[_13989 + 32]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16922 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16922] = 26
                                                                mem[_16922 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17194 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17194] = 26
                                                                mem[_17194 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                    else:
                                        require stor[_6758]
                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _8960 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8960] = 26
                                        mem[_8960 + 32] = 'SafeMath: division by zero'
                                        _9336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9336] = 30
                                        mem[_9336 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                            _9455 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_9455 + idx + 68] = mem[_9336 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9455 + 68] = mem[_9455 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _9455 + -mem[64] + 100
                                        if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                            if stor[_6755] <= 0:
                                                if not stor[_6758]:
                                                    _9981 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9981] = 26
                                                    mem[_9981 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = 0
                                                else:
                                                    require stor[_6758]
                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _10112 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10112] = 26
                                                    mem[_10112 + 32] = 'SafeMath: division by zero'
                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                _9735 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9735] = 30
                                                mem[_9735 + 32] = 'SafeMath: subtraction overflow'
                                                if stor[_6755] > stor[_6758]:
                                                    _9856 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_9856 + idx + 68] = mem[_9735 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_9856 + 68] = mem[_9856 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _9856 + -mem[64] + 100
                                                stor[_6758] -= stor[_6755]
                                                _10054 = mem[64]
                                                mem[mem[64] + 36] = address(_6751)
                                                mem[mem[64] + 68] = stor[_6755]
                                                _10055 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_10055 + 32] = mem[_10055 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                mem[64] = _10054 + 164
                                                mem[_10054 + 100] = 32
                                                mem[_10054 + 132] = 'SafeERC20: low-level call failed'
                                                if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _10465 = mem[_10055]
                                                t = _10055 + 32
                                                u = mem[64]
                                                s = mem[_10055]
                                                while s >= 32:
                                                    mem[u] = mem[t]
                                                    t = t + 32
                                                    u = u + 32
                                                    s = s - 32
                                                    continue 
                                                mem[mem[64] + floor32(mem[_10055])] = mem[_10055 + floor32(mem[_10055]) + -(mem[_10055] % 32) + 64 len mem[_10055] % 32] or Mask(8 * -(mem[_10055] % 32) + 32, -(8 * -(mem[_10055] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_10055])])
                                                call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _10465 + _10054 + -mem[64] + 160]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96] > 0:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        _14585 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = mem[_10054 + 100]
                                                        _14587 = mem[_10054 + 100]
                                                        idx = 0
                                                        while idx < _14587:
                                                            mem[_14585 + idx + 68] = mem[_10054 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        if not _14587 % 32:
                                                            revert with memory
                                                              from mem[64]
                                                               len _14587 + _14585 + -mem[64] + 68
                                                        mem[floor32(_14587) + _14585 + 68] = mem[floor32(_14587) + _14585 + -(_14587 % 32) + 100 len _14587 % 32]
                                                        revert with memory
                                                          from mem[64]
                                                           len floor32(_14587) + _14585 + -mem[64] + 100
                                                    if mem[96] <= 0:
                                                        if not stor[_6758]:
                                                            _16385 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16385] = 26
                                                            mem[_16385 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _16637 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16637] = 26
                                                            mem[_16637 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[mem[64] + 110 len 22]
                                                        if not stor[_6758]:
                                                            _16913 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16913] = 26
                                                            mem[_16913 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _17167 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17167] = 26
                                                            mem[_17167 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _13975 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                    mem[_13975] = return_data.size
                                                    mem[_13975 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size > 0:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _14589 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = mem[_10054 + 100]
                                                        _14591 = mem[_10054 + 100]
                                                        idx = 0
                                                        while idx < _14591:
                                                            mem[_14589 + idx + 68] = mem[_10054 + idx + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        if not _14591 % 32:
                                                            revert with memory
                                                              from mem[64]
                                                               len _14591 + _14589 + -mem[64] + 68
                                                        mem[floor32(_14591) + _14589 + 68] = mem[floor32(_14591) + _14589 + -(_14591 % 32) + 100 len _14591 % 32]
                                                        revert with memory
                                                          from mem[64]
                                                           len floor32(_14591) + _14589 + -mem[64] + 100
                                                    if return_data.size <= 0:
                                                        if not stor[_6758]:
                                                            _16386 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16386] = 26
                                                            mem[_16386 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _16640 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16640] = 26
                                                            mem[_16640 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        require return_data.size >= 32
                                                        if not mem[_13975 + 32]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[mem[64] + 110 len 22]
                                                        if not stor[_6758]:
                                                            _16914 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16914] = 26
                                                            mem[_16914 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _17170 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17170] = 26
                                                            mem[_17170 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            _9683 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9683] = 26
                                            mem[_9683 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(sub_4365354eAddress)
                                            staticcall sub_4365354eAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[mem[64] + 4] = address(_6751)
                                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] > ext_call.return_data[0]:
                                                mem[mem[64] + 36] = ext_call.return_data[0]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _11007 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11007] = 26
                                                        mem[_11007 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _11194 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11194] = 26
                                                        mem[_11194 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _10665 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10665] = 30
                                                    mem[_10665 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10806 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10806 + idx + 68] = mem[_10665 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10806 + 68] = mem[_10806 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10806 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _11112 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _11113 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_11113 + 32] = mem[_11113 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _11112 + 164
                                                    mem[_11112 + 100] = 32
                                                    mem[_11112 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11598 = mem[_11113]
                                                    t = _11113 + 32
                                                    u = _11112 + 164
                                                    s = mem[_11113]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_11112 + floor32(mem[_11113]) + 164] = mem[_11113 + -(mem[_11113] % 32) + floor32(mem[_11113]) + 64 len mem[_11113] % 32] or Mask(8 * -(mem[_11113] % 32) + 32, -(8 * -(mem[_11113] % 32) + 32) + 256, mem[_11112 + floor32(mem[_11113]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_11112 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_11112 + 168 len _11598 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_11112 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_11112 + 168] = 32
                                                            mem[_11112 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_11112 + idx + 232] = mem[_11112 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _11112 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_11112 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _11112 + 228
                                                            mem[_11112 + 164] = 26
                                                            mem[_11112 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_11112 + 265 len 31]
                                                            mem[64] = _11112 + 228
                                                            mem[_11112 + 164] = 26
                                                            mem[_11112 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_11112 + 228] = stor[_6755]
                                                    else:
                                                        mem[_11112 + 164] = return_data.size
                                                        mem[_11112 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_11112 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_11112 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_11112 + ceil32(return_data.size) + idx + 233] = mem[_11112 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_11112 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_11112 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_11112 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _11112 + ceil32(return_data.size) + 229
                                                            mem[_11112 + ceil32(return_data.size) + 165] = 26
                                                            mem[_11112 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_11112 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _11112 + ceil32(return_data.size) + 229
                                                            mem[_11112 + ceil32(return_data.size) + 165] = 26
                                                            mem[_11112 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_11112 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                require ext_code.size(sub_4365354eAddress)
                                                call sub_4365354eAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _11005 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11005] = 26
                                                        mem[_11005 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _11191 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_11191] = 26
                                                        mem[_11191 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _10664 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10664] = 30
                                                    mem[_10664 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10803 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10803 + idx + 68] = mem[_10664 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10803 + 68] = mem[_10803 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10803 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _11107 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _11108 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_11108 + 32] = mem[_11108 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _11107 + 164
                                                    mem[_11107 + 100] = 32
                                                    mem[_11107 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _11594 = mem[_11108]
                                                    t = _11108 + 32
                                                    u = mem[64]
                                                    s = mem[_11108]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[mem[64] + floor32(mem[_11108])] = mem[_11108 + floor32(mem[_11108]) + -(mem[_11108] % 32) + 64 len mem[_11108] % 32] or Mask(8 * -(mem[_11108] % 32) + 32, -(8 * -(mem[_11108] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11108])])
                                                    call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _11594 + _11107 + -mem[64] + 160]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            _14593 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_11107 + 100]
                                                            _14595 = mem[_11107 + 100]
                                                            idx = 0
                                                            while idx < _14595:
                                                                mem[_14593 + idx + 68] = mem[_11107 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14595 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14595 + _14593 + -mem[64] + 68
                                                            mem[floor32(_14595) + _14593 + 68] = mem[floor32(_14595) + _14593 + -(_14595 % 32) + 100 len _14595 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14595) + _14593 + -mem[64] + 100
                                                        if mem[96] <= 0:
                                                            if not stor[_6758]:
                                                                _16387 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16387] = 26
                                                                mem[_16387 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16643 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16643] = 26
                                                                mem[_16643 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16915 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16915] = 26
                                                                mem[_16915 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17173 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17173] = 26
                                                                mem[_17173 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _13978 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_13978] = return_data.size
                                                        mem[_13978 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _14597 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_11107 + 100]
                                                            _14599 = mem[_11107 + 100]
                                                            idx = 0
                                                            while idx < _14599:
                                                                mem[_14597 + idx + 68] = mem[_11107 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14599 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14599 + _14597 + -mem[64] + 68
                                                            mem[floor32(_14599) + _14597 + 68] = mem[floor32(_14599) + _14597 + -(_14599 % 32) + 100 len _14599 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14599) + _14597 + -mem[64] + 100
                                                        if return_data.size <= 0:
                                                            if not stor[_6758]:
                                                                _16388 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16388] = 26
                                                                mem[_16388 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16646 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16646] = 26
                                                                mem[_16646 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require return_data.size >= 32
                                                            if not mem[_13978 + 32]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16916 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16916] = 26
                                                                mem[_16916 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17176 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17176] = 26
                                                                mem[_17176 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                            else:
                                require block.number - poolInfo[arg1].field_512
                                if (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12) / block.number - poolInfo[arg1].field_512 != sub_e9e49c12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12):
                                    _6986 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6986] = 26
                                    mem[_6986 + 32] = 'SafeMath: division by zero'
                                    if totalAllocPoint <= 0:
                                        _7039 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_7039 + idx + 68] = mem[_6986 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7039 + 68] = mem[_7039 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _7039 + -mem[64] + 100
                                    require totalAllocPoint
                                    _7164 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7164] = 26
                                    mem[_7164 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 10
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        _7805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7805] = 26
                                        mem[_7805 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _7941 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_7941 + idx + 68] = mem[_7805 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7941 + 68] = mem[_7941 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _7941 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                                        if not stor[_6758]:
                                            _8814 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8814] = 26
                                            mem[_8814 + 32] = 'SafeMath: division by zero'
                                            _9220 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9220] = 30
                                            mem[_9220 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > 0:
                                                _9333 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9333 + idx + 68] = mem[_9220 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9333 + 68] = mem[_9333 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9333 + -mem[64] + 100
                                            if -stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _9854 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9854] = 26
                                                        mem[_9854 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _9978 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9978] = 26
                                                        mem[_9978 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _9619 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9619] = 30
                                                    mem[_9619 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9732 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9732 + idx + 68] = mem[_9619 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9732 + 68] = mem[_9732 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9732 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _9906 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _9907 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_9907 + 32] = mem[_9907 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _9906 + 164
                                                    mem[_9906 + 100] = 32
                                                    mem[_9906 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10373 = mem[_9907]
                                                    t = _9907 + 32
                                                    u = mem[64]
                                                    s = mem[_9907]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[mem[64] + floor32(mem[_9907])] = mem[_9907 + floor32(mem[_9907]) + -(mem[_9907] % 32) + 64 len mem[_9907] % 32] or Mask(8 * -(mem[_9907] % 32) + 32, -(8 * -(mem[_9907] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_9907])])
                                                    call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _10373 + _9906 + -mem[64] + 160]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            _14561 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_9906 + 100]
                                                            _14563 = mem[_9906 + 100]
                                                            idx = 0
                                                            while idx < _14563:
                                                                mem[_14561 + idx + 68] = mem[_9906 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14563 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14563 + _14561 + -mem[64] + 68
                                                            mem[floor32(_14563) + _14561 + 68] = mem[floor32(_14563) + _14561 + -(_14563 % 32) + 100 len _14563 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14563) + _14561 + -mem[64] + 100
                                                        if mem[96] <= 0:
                                                            if not stor[_6758]:
                                                                _16379 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16379] = 26
                                                                mem[_16379 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16619 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16619] = 26
                                                                mem[_16619 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16907 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16907] = 26
                                                                mem[_16907 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17149 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17149] = 26
                                                                mem[_17149 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _13960 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_13960] = return_data.size
                                                        mem[_13960 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _14565 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_9906 + 100]
                                                            _14567 = mem[_9906 + 100]
                                                            idx = 0
                                                            while idx < _14567:
                                                                mem[_14565 + idx + 68] = mem[_9906 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14567 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14567 + _14565 + -mem[64] + 68
                                                            mem[floor32(_14567) + _14565 + 68] = mem[floor32(_14567) + _14565 + -(_14567 % 32) + 100 len _14567 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14567) + _14565 + -mem[64] + 100
                                                        if return_data.size <= 0:
                                                            if not stor[_6758]:
                                                                _16380 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16380] = 26
                                                                mem[_16380 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16622 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16622] = 26
                                                                mem[_16622 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require return_data.size >= 32
                                                            if not mem[_13960 + 32]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16908 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16908] = 26
                                                                mem[_16908 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17152 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17152] = 26
                                                                mem[_17152 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                            else:
                                                _9574 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9574] = 26
                                                mem[_9574 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if -stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = -stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), -stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10799 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10799] = 26
                                                            mem[_10799 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _10993 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10993] = 26
                                                            mem[_10993 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10572 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10572] = 30
                                                        mem[_10572 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10656 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10656 + idx + 68] = mem[_10572 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10656 + 68] = mem[_10656 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10656 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _10891 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _10892 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_10892 + 32] = mem[_10892 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _10891 + 164
                                                        mem[_10891 + 100] = 32
                                                        mem[_10891 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11446 = mem[_10892]
                                                        t = _10892 + 32
                                                        u = _10891 + 164
                                                        s = mem[_10892]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_10891 + floor32(mem[_10892]) + 164] = mem[_10892 + -(mem[_10892] % 32) + floor32(mem[_10892]) + 64 len mem[_10892] % 32] or Mask(8 * -(mem[_10892] % 32) + 32, -(8 * -(mem[_10892] % 32) + 32) + 256, mem[_10891 + floor32(mem[_10892]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_10891 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_10891 + 168 len _11446 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_10891 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10891 + 168] = 32
                                                                mem[_10891 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_10891 + idx + 232] = mem[_10891 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _10891 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_10891 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _10891 + 228
                                                                mem[_10891 + 164] = 26
                                                                mem[_10891 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10891 + 265 len 31]
                                                                mem[64] = _10891 + 228
                                                                mem[_10891 + 164] = 26
                                                                mem[_10891 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_10891 + 228] = stor[_6755]
                                                        else:
                                                            mem[_10891 + 164] = return_data.size
                                                            mem[_10891 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10891 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10891 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_10891 + ceil32(return_data.size) + idx + 233] = mem[_10891 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10891 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_10891 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_10891 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _10891 + ceil32(return_data.size) + 229
                                                                mem[_10891 + ceil32(return_data.size) + 165] = 26
                                                                mem[_10891 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_10891 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _10891 + ceil32(return_data.size) + 229
                                                                mem[_10891 + ceil32(return_data.size) + 165] = 26
                                                                mem[_10891 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_10891 + ceil32(return_data.size) + 229] = stor[_6755]
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10801 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10801] = 26
                                                            mem[_10801 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _10996 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10996] = 26
                                                            mem[_10996 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10573 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10573] = 30
                                                        mem[_10573 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10659 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10659 + idx + 68] = mem[_10573 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10659 + 68] = mem[_10659 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10659 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _10896 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _10897 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_10897 + 32] = mem[_10897 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _10896 + 164
                                                        mem[_10896 + 100] = 32
                                                        mem[_10896 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11450 = mem[_10897]
                                                        t = _10897 + 32
                                                        u = _10896 + 164
                                                        s = mem[_10897]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_10896 + floor32(mem[_10897]) + 164] = mem[_10897 + -(mem[_10897] % 32) + floor32(mem[_10897]) + 64 len mem[_10897] % 32] or Mask(8 * -(mem[_10897] % 32) + 32, -(8 * -(mem[_10897] % 32) + 32) + 256, mem[_10896 + floor32(mem[_10897]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_10896 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_10896 + 168 len _11450 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_10896 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10896 + 168] = 32
                                                                mem[_10896 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_10896 + idx + 232] = mem[_10896 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _10896 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_10896 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _10896 + 228
                                                                mem[_10896 + 164] = 26
                                                                mem[_10896 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10896 + 265 len 31]
                                                                mem[64] = _10896 + 228
                                                                mem[_10896 + 164] = 26
                                                                mem[_10896 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_10896 + 228] = stor[_6755]
                                                        else:
                                                            mem[_10896 + 164] = return_data.size
                                                            mem[_10896 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10896 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10896 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_10896 + ceil32(return_data.size) + idx + 233] = mem[_10896 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10896 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_10896 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_10896 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _10896 + ceil32(return_data.size) + 229
                                                                mem[_10896 + ceil32(return_data.size) + 165] = 26
                                                                mem[_10896 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_10896 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _10896 + ceil32(return_data.size) + 229
                                                                mem[_10896 + ceil32(return_data.size) + 165] = 26
                                                                mem[_10896 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_10896 + ceil32(return_data.size) + 229] = stor[_6755]
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8959 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8959] = 26
                                            mem[_8959 + 32] = 'SafeMath: division by zero'
                                            _9332 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9332] = 30
                                            mem[_9332 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                                _9451 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9451 + idx + 68] = mem[_9332 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9451 + 68] = mem[_9451 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9451 + -mem[64] + 100
                                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _9976 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9976] = 26
                                                        mem[_9976 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10108 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10108] = 26
                                                        mem[_10108 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _9731 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9731] = 30
                                                    mem[_9731 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9851 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9851 + idx + 68] = mem[_9731 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9851 + 68] = mem[_9851 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9851 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10046 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10047 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10047 + 32] = mem[_10047 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10046 + 164
                                                    mem[_10046 + 100] = 32
                                                    mem[_10046 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10457 = mem[_10047]
                                                    t = _10047 + 32
                                                    u = _10046 + 164
                                                    s = mem[_10047]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10046 + floor32(mem[_10047]) + 164] = mem[_10047 + -(mem[_10047] % 32) + floor32(mem[_10047]) + 64 len mem[_10047] % 32] or Mask(8 * -(mem[_10047] % 32) + 32, -(8 * -(mem[_10047] % 32) + 32) + 256, mem[_10046 + floor32(mem[_10047]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10046 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10046 + 168 len _10457 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10046 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10046 + 168] = 32
                                                            mem[_10046 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10046 + idx + 232] = mem[_10046 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10046 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10046 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10046 + 228
                                                            mem[_10046 + 164] = 26
                                                            mem[_10046 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10046 + 265 len 31]
                                                            mem[64] = _10046 + 228
                                                            mem[_10046 + 164] = 26
                                                            mem[_10046 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10046 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10046 + 164] = return_data.size
                                                        mem[_10046 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10046 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10046 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10046 + ceil32(return_data.size) + idx + 233] = mem[_10046 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10046 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10046 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10046 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10046 + ceil32(return_data.size) + 229
                                                            mem[_10046 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10046 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10046 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10046 + ceil32(return_data.size) + 229
                                                            mem[_10046 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10046 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10046 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                _9681 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9681] = 26
                                                mem[_9681 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10985 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10985] = 26
                                                            mem[_10985 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11181 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11181] = 26
                                                            mem[_11181 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10654 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10654] = 30
                                                        mem[_10654 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10787 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10787 + idx + 68] = mem[_10654 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10787 + 68] = mem[_10787 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10787 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11093 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11094 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11094 + 32] = mem[_11094 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11093 + 164
                                                        mem[_11093 + 100] = 32
                                                        mem[_11093 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11576 = mem[_11094]
                                                        t = _11094 + 32
                                                        u = mem[64]
                                                        s = mem[_11094]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11094])] = mem[_11094 + floor32(mem[_11094]) + -(mem[_11094] % 32) + 64 len mem[_11094] % 32] or Mask(8 * -(mem[_11094] % 32) + 32, -(8 * -(mem[_11094] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11094])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11576 + _11093 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14545 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11093 + 100]
                                                                _14547 = mem[_11093 + 100]
                                                                idx = 0
                                                                while idx < _14547:
                                                                    mem[_14545 + idx + 68] = mem[_11093 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14547 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14547 + _14545 + -mem[64] + 68
                                                                mem[floor32(_14547) + _14545 + 68] = mem[floor32(_14547) + _14545 + -(_14547 % 32) + 100 len _14547 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14547) + _14545 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16375 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16375] = 26
                                                                    mem[_16375 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16607 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16607] = 26
                                                                    mem[_16607 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16903 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16903] = 26
                                                                    mem[_16903 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17137 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17137] = 26
                                                                    mem[_17137 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13952 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13952] = return_data.size
                                                            mem[_13952 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14549 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11093 + 100]
                                                                _14551 = mem[_11093 + 100]
                                                                idx = 0
                                                                while idx < _14551:
                                                                    mem[_14549 + idx + 68] = mem[_11093 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14551 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14551 + _14549 + -mem[64] + 68
                                                                mem[floor32(_14551) + _14549 + 68] = mem[floor32(_14551) + _14549 + -(_14551 % 32) + 100 len _14551 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14551) + _14549 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16376 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16376] = 26
                                                                    mem[_16376 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16610 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16610] = 26
                                                                    mem[_16610 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13952 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16904 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16904] = 26
                                                                    mem[_16904 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17140 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17140] = 26
                                                                    mem[_17140 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10987 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10987] = 26
                                                            mem[_10987 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11184 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11184] = 26
                                                            mem[_11184 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10655 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10655] = 30
                                                        mem[_10655 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10790 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10790 + idx + 68] = mem[_10655 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10790 + 68] = mem[_10790 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10790 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11098 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11099 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11099 + 32] = mem[_11099 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11098 + 164
                                                        mem[_11098 + 100] = 32
                                                        mem[_11098 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11580 = mem[_11099]
                                                        t = _11099 + 32
                                                        u = mem[64]
                                                        s = mem[_11099]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11099])] = mem[_11099 + floor32(mem[_11099]) + -(mem[_11099] % 32) + 64 len mem[_11099] % 32] or Mask(8 * -(mem[_11099] % 32) + 32, -(8 * -(mem[_11099] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11099])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11580 + _11098 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14553 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11098 + 100]
                                                                _14555 = mem[_11098 + 100]
                                                                idx = 0
                                                                while idx < _14555:
                                                                    mem[_14553 + idx + 68] = mem[_11098 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14555 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14555 + _14553 + -mem[64] + 68
                                                                mem[floor32(_14555) + _14553 + 68] = mem[floor32(_14555) + _14553 + -(_14555 % 32) + 100 len _14555 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14555) + _14553 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16377 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16377] = 26
                                                                    mem[_16377 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16613 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16613] = 26
                                                                    mem[_16613 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16905 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16905] = 26
                                                                    mem[_16905 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17143 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17143] = 26
                                                                    mem[_17143 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13955 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13955] = return_data.size
                                                            mem[_13955 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14557 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11098 + 100]
                                                                _14559 = mem[_11098 + 100]
                                                                idx = 0
                                                                while idx < _14559:
                                                                    mem[_14557 + idx + 68] = mem[_11098 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14559 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14559 + _14557 + -mem[64] + 68
                                                                mem[floor32(_14559) + _14557 + 68] = mem[floor32(_14559) + _14557 + -(_14559 % 32) + 100 len _14559 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14559) + _14557 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16378 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16378] = 26
                                                                    mem[_16378 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16616 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16616] = 26
                                                                    mem[_16616 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13955 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16906 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16906] = 26
                                                                    mem[_16906 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17146 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17146] = 26
                                                                    mem[_17146 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7940 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7940] = 26
                                        mem[_7940 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _8074 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_8074 + idx + 68] = mem[_7940 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_8074 + 68] = mem[_8074 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _8074 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                                        if not stor[_6758]:
                                            _8958 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8958] = 26
                                            mem[_8958 + 32] = 'SafeMath: division by zero'
                                            _9331 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9331] = 30
                                            mem[_9331 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > 0:
                                                _9448 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9448 + idx + 68] = mem[_9331 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9448 + 68] = mem[_9448 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9448 + -mem[64] + 100
                                            if -stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _9974 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9974] = 26
                                                        mem[_9974 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10105 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10105] = 26
                                                        mem[_10105 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _9730 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9730] = 30
                                                    mem[_9730 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9848 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9848 + idx + 68] = mem[_9730 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9848 + 68] = mem[_9848 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9848 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10039 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10040 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10040 + 32] = mem[_10040 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10039 + 164
                                                    mem[_10039 + 100] = 32
                                                    mem[_10039 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10453 = mem[_10040]
                                                    t = _10040 + 32
                                                    u = _10039 + 164
                                                    s = mem[_10040]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10039 + floor32(mem[_10040]) + 164] = mem[_10040 + -(mem[_10040] % 32) + floor32(mem[_10040]) + 64 len mem[_10040] % 32] or Mask(8 * -(mem[_10040] % 32) + 32, -(8 * -(mem[_10040] % 32) + 32) + 256, mem[_10039 + floor32(mem[_10040]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10039 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10039 + 168 len _10453 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10039 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10039 + 168] = 32
                                                            mem[_10039 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10039 + idx + 232] = mem[_10039 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10039 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10039 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10039 + 228
                                                            mem[_10039 + 164] = 26
                                                            mem[_10039 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10039 + 265 len 31]
                                                            mem[64] = _10039 + 228
                                                            mem[_10039 + 164] = 26
                                                            mem[_10039 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10039 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10039 + 164] = return_data.size
                                                        mem[_10039 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10039 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10039 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10039 + ceil32(return_data.size) + idx + 233] = mem[_10039 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10039 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10039 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10039 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10039 + ceil32(return_data.size) + 229
                                                            mem[_10039 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10039 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10039 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10039 + ceil32(return_data.size) + 229
                                                            mem[_10039 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10039 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10039 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                _9679 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9679] = 26
                                                mem[_9679 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if -stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = -stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), -stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10975 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10975] = 26
                                                            mem[_10975 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11171 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11171] = 26
                                                            mem[_11171 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10650 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10650] = 30
                                                        mem[_10650 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10781 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10781 + idx + 68] = mem[_10650 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10781 + 68] = mem[_10781 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10781 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11079 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11080 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11080 + 32] = mem[_11080 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11079 + 164
                                                        mem[_11079 + 100] = 32
                                                        mem[_11079 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11568 = mem[_11080]
                                                        t = _11080 + 32
                                                        u = mem[64]
                                                        s = mem[_11080]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11080])] = mem[_11080 + floor32(mem[_11080]) + -(mem[_11080] % 32) + 64 len mem[_11080] % 32] or Mask(8 * -(mem[_11080] % 32) + 32, -(8 * -(mem[_11080] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11080])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11568 + _11079 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14521 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11079 + 100]
                                                                _14523 = mem[_11079 + 100]
                                                                idx = 0
                                                                while idx < _14523:
                                                                    mem[_14521 + idx + 68] = mem[_11079 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14523 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14523 + _14521 + -mem[64] + 68
                                                                mem[floor32(_14523) + _14521 + 68] = mem[floor32(_14523) + _14521 + -(_14523 % 32) + 100 len _14523 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14523) + _14521 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16369 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16369] = 26
                                                                    mem[_16369 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16589 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16589] = 26
                                                                    mem[_16589 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16897 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16897] = 26
                                                                    mem[_16897 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17119 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17119] = 26
                                                                    mem[_17119 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13939 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13939] = return_data.size
                                                            mem[_13939 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14525 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11079 + 100]
                                                                _14527 = mem[_11079 + 100]
                                                                idx = 0
                                                                while idx < _14527:
                                                                    mem[_14525 + idx + 68] = mem[_11079 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14527 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14527 + _14525 + -mem[64] + 68
                                                                mem[floor32(_14527) + _14525 + 68] = mem[floor32(_14527) + _14525 + -(_14527 % 32) + 100 len _14527 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14527) + _14525 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16370 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16370] = 26
                                                                    mem[_16370 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16592 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16592] = 26
                                                                    mem[_16592 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13939 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16898 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16898] = 26
                                                                    mem[_16898 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17122 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17122] = 26
                                                                    mem[_17122 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10977 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10977] = 26
                                                            mem[_10977 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11174 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11174] = 26
                                                            mem[_11174 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10651 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10651] = 30
                                                        mem[_10651 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10784 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10784 + idx + 68] = mem[_10651 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10784 + 68] = mem[_10784 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10784 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11084 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11085 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11085 + 32] = mem[_11085 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11084 + 164
                                                        mem[_11084 + 100] = 32
                                                        mem[_11084 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11572 = mem[_11085]
                                                        t = _11085 + 32
                                                        u = mem[64]
                                                        s = mem[_11085]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11085])] = mem[_11085 + floor32(mem[_11085]) + -(mem[_11085] % 32) + 64 len mem[_11085] % 32] or Mask(8 * -(mem[_11085] % 32) + 32, -(8 * -(mem[_11085] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11085])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11572 + _11084 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14529 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11084 + 100]
                                                                _14531 = mem[_11084 + 100]
                                                                idx = 0
                                                                while idx < _14531:
                                                                    mem[_14529 + idx + 68] = mem[_11084 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14531 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14531 + _14529 + -mem[64] + 68
                                                                mem[floor32(_14531) + _14529 + 68] = mem[floor32(_14531) + _14529 + -(_14531 % 32) + 100 len _14531 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14531) + _14529 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16371 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16371] = 26
                                                                    mem[_16371 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16595 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16595] = 26
                                                                    mem[_16595 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16899 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16899] = 26
                                                                    mem[_16899 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17125 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17125] = 26
                                                                    mem[_17125 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13942 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13942] = return_data.size
                                                            mem[_13942 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14533 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11084 + 100]
                                                                _14535 = mem[_11084 + 100]
                                                                idx = 0
                                                                while idx < _14535:
                                                                    mem[_14533 + idx + 68] = mem[_11084 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14535 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14535 + _14533 + -mem[64] + 68
                                                                mem[floor32(_14535) + _14533 + 68] = mem[floor32(_14535) + _14533 + -(_14535 % 32) + 100 len _14535 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14535) + _14533 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16372 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16372] = 26
                                                                    mem[_16372 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16598 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16598] = 26
                                                                    mem[_16598 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13942 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16900 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16900] = 26
                                                                    mem[_16900 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17128 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17128] = 26
                                                                    mem[_17128 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _9099 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9099] = 26
                                            mem[_9099 + 32] = 'SafeMath: division by zero'
                                            _9447 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9447] = 30
                                            mem[_9447 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                                _9569 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9569 + idx + 68] = mem[_9447 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9569 + 68] = mem[_9569 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9569 + -mem[64] + 100
                                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10103 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10103] = 26
                                                        mem[_10103 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10219 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10219] = 26
                                                        mem[_10219 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _9847 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9847] = 30
                                                    mem[_9847 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9971 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9971 + idx + 68] = mem[_9847 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9971 + 68] = mem[_9971 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9971 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10158 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10159 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10159 + 32] = mem[_10159 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10158 + 164
                                                    mem[_10158 + 100] = 32
                                                    mem[_10158 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10528 = mem[_10159]
                                                    t = _10159 + 32
                                                    u = _10158 + 164
                                                    s = mem[_10159]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10158 + floor32(mem[_10159]) + 164] = mem[_10159 + -(mem[_10159] % 32) + floor32(mem[_10159]) + 64 len mem[_10159] % 32] or Mask(8 * -(mem[_10159] % 32) + 32, -(8 * -(mem[_10159] % 32) + 32) + 256, mem[_10158 + floor32(mem[_10159]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10158 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10158 + 168 len _10528 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10158 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10158 + 168] = 32
                                                            mem[_10158 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10158 + idx + 232] = mem[_10158 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10158 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10158 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10158 + 228
                                                            mem[_10158 + 164] = 26
                                                            mem[_10158 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10158 + 265 len 31]
                                                            mem[64] = _10158 + 228
                                                            mem[_10158 + 164] = 26
                                                            mem[_10158 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10158 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10158 + 164] = return_data.size
                                                        mem[_10158 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10158 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10158 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10158 + ceil32(return_data.size) + idx + 233] = mem[_10158 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10158 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10158 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10158 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10158 + ceil32(return_data.size) + 229
                                                            mem[_10158 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10158 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10158 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10158 + ceil32(return_data.size) + 229
                                                            mem[_10158 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10158 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10158 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                _9781 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9781] = 26
                                                mem[_9781 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11163 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11163] = 26
                                                            mem[_11163 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11301 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11301] = 26
                                                            mem[_11301 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10779 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10779] = 30
                                                        mem[_10779 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10963 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10963 + idx + 68] = mem[_10779 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10963 + 68] = mem[_10963 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10963 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11237 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11238 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11238 + 32] = mem[_11238 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11237 + 164
                                                        mem[_11237 + 100] = 32
                                                        mem[_11237 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11714 = mem[_11238]
                                                        t = _11238 + 32
                                                        u = _11237 + 164
                                                        s = mem[_11238]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_11237 + floor32(mem[_11238]) + 164] = mem[_11238 + -(mem[_11238] % 32) + floor32(mem[_11238]) + 64 len mem[_11238] % 32] or Mask(8 * -(mem[_11238] % 32) + 32, -(8 * -(mem[_11238] % 32) + 32) + 256, mem[_11237 + floor32(mem[_11238]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_11237 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_11237 + 168 len _11714 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_11237 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11237 + 168] = 32
                                                                mem[_11237 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11237 + idx + 232] = mem[_11237 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _11237 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11237 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11237 + 228
                                                                mem[_11237 + 164] = 26
                                                                mem[_11237 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_11237 + 265 len 31]
                                                                mem[64] = _11237 + 228
                                                                mem[_11237 + 164] = 26
                                                                mem[_11237 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11237 + 228] = stor[_6755]
                                                        else:
                                                            mem[_11237 + 164] = return_data.size
                                                            mem[_11237 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_11237 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11237 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11237 + ceil32(return_data.size) + idx + 233] = mem[_11237 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_11237 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_11237 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11237 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11237 + ceil32(return_data.size) + 229
                                                                mem[_11237 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11237 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_11237 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _11237 + ceil32(return_data.size) + 229
                                                                mem[_11237 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11237 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11237 + ceil32(return_data.size) + 229] = stor[_6755]
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11165 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11165] = 26
                                                            mem[_11165 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11304 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11304] = 26
                                                            mem[_11304 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10780 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10780] = 30
                                                        mem[_10780 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10966 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10966 + idx + 68] = mem[_10780 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10966 + 68] = mem[_10966 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10966 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11242 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11243 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11243 + 32] = mem[_11243 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11242 + 164
                                                        mem[_11242 + 100] = 32
                                                        mem[_11242 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11718 = mem[_11243]
                                                        t = _11243 + 32
                                                        u = mem[64]
                                                        s = mem[_11243]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11243])] = mem[_11243 + floor32(mem[_11243]) + -(mem[_11243] % 32) + 64 len mem[_11243] % 32] or Mask(8 * -(mem[_11243] % 32) + 32, -(8 * -(mem[_11243] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11243])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11718 + _11242 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14505 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11242 + 100]
                                                                _14507 = mem[_11242 + 100]
                                                                idx = 0
                                                                while idx < _14507:
                                                                    mem[_14505 + idx + 68] = mem[_11242 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14507 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14507 + _14505 + -mem[64] + 68
                                                                mem[floor32(_14507) + _14505 + 68] = mem[floor32(_14507) + _14505 + -(_14507 % 32) + 100 len _14507 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14507) + _14505 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16365 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16365] = 26
                                                                    mem[_16365 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16577 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16577] = 26
                                                                    mem[_16577 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16893 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16893] = 26
                                                                    mem[_16893 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17107 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17107] = 26
                                                                    mem[_17107 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13931 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13931] = return_data.size
                                                            mem[_13931 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14509 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11242 + 100]
                                                                _14511 = mem[_11242 + 100]
                                                                idx = 0
                                                                while idx < _14511:
                                                                    mem[_14509 + idx + 68] = mem[_11242 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14511 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14511 + _14509 + -mem[64] + 68
                                                                mem[floor32(_14511) + _14509 + 68] = mem[floor32(_14511) + _14509 + -(_14511 % 32) + 100 len _14511 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14511) + _14509 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16366 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16366] = 26
                                                                    mem[_16366 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16580 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16580] = 26
                                                                    mem[_16580 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13931 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16894 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16894] = 26
                                                                    mem[_16894 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17110 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17110] = 26
                                                                    mem[_17110 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                else:
                                    require (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12)
                                    if (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / (block.number * sub_e9e49c12) - (poolInfo[arg1].field_512 * sub_e9e49c12) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7038 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7038] = 26
                                    mem[_7038 + 32] = 'SafeMath: division by zero'
                                    if totalAllocPoint <= 0:
                                        _7104 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[_7104 + idx + 68] = mem[_7038 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7104 + 68] = mem[_7104 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _7104 + -mem[64] + 100
                                    require totalAllocPoint
                                    _7233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7233] = 26
                                    mem[_7233 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint
                                    require ext_code.size(sub_4365354eAddress)
                                    call sub_4365354eAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        _7939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7939] = 26
                                        mem[_7939 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _8071 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_8071 + idx + 68] = mem[_7939 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_8071 + 68] = mem[_8071 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _8071 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                                        if stor[_6758]:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _9098 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9098] = 26
                                            mem[_9098 + 32] = 'SafeMath: division by zero'
                                            _9443 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9443] = 30
                                            mem[_9443 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                                _9565 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9565 + idx + 68] = mem[_9443 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9565 + 68] = mem[_9565 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9565 + -mem[64] + 100
                                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10098 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10098] = 26
                                                        mem[_10098 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10215 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10215] = 26
                                                        mem[_10215 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _9843 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9843] = 30
                                                    mem[_9843 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9966 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9966 + idx + 68] = mem[_9843 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9966 + 68] = mem[_9966 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9966 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10150 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10151 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10151 + 32] = mem[_10151 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10150 + 164
                                                    mem[_10150 + 100] = 32
                                                    mem[_10150 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10520 = mem[_10151]
                                                    t = _10151 + 32
                                                    u = _10150 + 164
                                                    s = mem[_10151]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10150 + floor32(mem[_10151]) + 164] = mem[_10151 + -(mem[_10151] % 32) + floor32(mem[_10151]) + 64 len mem[_10151] % 32] or Mask(8 * -(mem[_10151] % 32) + 32, -(8 * -(mem[_10151] % 32) + 32) + 256, mem[_10150 + floor32(mem[_10151]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10150 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10150 + 168 len _10520 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10150 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10150 + 168] = 32
                                                            mem[_10150 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10150 + idx + 232] = mem[_10150 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10150 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10150 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10150 + 228
                                                            mem[_10150 + 164] = 26
                                                            mem[_10150 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10150 + 265 len 31]
                                                            mem[64] = _10150 + 228
                                                            mem[_10150 + 164] = 26
                                                            mem[_10150 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10150 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10150 + 164] = return_data.size
                                                        mem[_10150 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10150 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10150 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10150 + ceil32(return_data.size) + idx + 233] = mem[_10150 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10150 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10150 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10150 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10150 + ceil32(return_data.size) + 229
                                                            mem[_10150 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10150 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10150 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10150 + ceil32(return_data.size) + 229
                                                            mem[_10150 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10150 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10150 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                _9779 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9779] = 26
                                                mem[_9779 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11143 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11143] = 26
                                                            mem[_11143 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11291 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11291] = 26
                                                            mem[_11291 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10769 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10769] = 30
                                                        mem[_10769 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10947 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10947 + idx + 68] = mem[_10769 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10947 + 68] = mem[_10947 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10947 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11223 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11224 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11224 + 32] = mem[_11224 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11223 + 164
                                                        mem[_11223 + 100] = 32
                                                        mem[_11223 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11696 = mem[_11224]
                                                        t = _11224 + 32
                                                        u = _11223 + 164
                                                        s = mem[_11224]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_11223 + floor32(mem[_11224]) + 164] = mem[_11224 + -(mem[_11224] % 32) + floor32(mem[_11224]) + 64 len mem[_11224] % 32] or Mask(8 * -(mem[_11224] % 32) + 32, -(8 * -(mem[_11224] % 32) + 32) + 256, mem[_11223 + floor32(mem[_11224]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_11223 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_11223 + 168 len _11696 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_11223 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11223 + 168] = 32
                                                                mem[_11223 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11223 + idx + 232] = mem[_11223 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _11223 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11223 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11223 + 228
                                                                mem[_11223 + 164] = 26
                                                                mem[_11223 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_11223 + 265 len 31]
                                                                mem[64] = _11223 + 228
                                                                mem[_11223 + 164] = 26
                                                                mem[_11223 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11223 + 228] = stor[_6755]
                                                        else:
                                                            mem[_11223 + 164] = return_data.size
                                                            mem[_11223 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_11223 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11223 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11223 + ceil32(return_data.size) + idx + 233] = mem[_11223 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_11223 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_11223 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11223 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11223 + ceil32(return_data.size) + 229
                                                                mem[_11223 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11223 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_11223 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _11223 + ceil32(return_data.size) + 229
                                                                mem[_11223 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11223 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11223 + ceil32(return_data.size) + 229] = stor[_6755]
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11145 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11145] = 26
                                                            mem[_11145 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11294 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11294] = 26
                                                            mem[_11294 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10770 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10770] = 30
                                                        mem[_10770 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10950 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10950 + idx + 68] = mem[_10770 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10950 + 68] = mem[_10950 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10950 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11228 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11229 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11229 + 32] = mem[_11229 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11228 + 164
                                                        mem[_11228 + 100] = 32
                                                        mem[_11228 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11700 = mem[_11229]
                                                        t = _11229 + 32
                                                        u = _11228 + 164
                                                        s = mem[_11229]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_11228 + floor32(mem[_11229]) + 164] = mem[_11229 + -(mem[_11229] % 32) + floor32(mem[_11229]) + 64 len mem[_11229] % 32] or Mask(8 * -(mem[_11229] % 32) + 32, -(8 * -(mem[_11229] % 32) + 32) + 256, mem[_11228 + floor32(mem[_11229]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_11228 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_11228 + 168 len _11700 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_11228 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11228 + 168] = 32
                                                                mem[_11228 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11228 + idx + 232] = mem[_11228 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _11228 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11228 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11228 + 228
                                                                mem[_11228 + 164] = 26
                                                                mem[_11228 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_11228 + 265 len 31]
                                                                mem[64] = _11228 + 228
                                                                mem[_11228 + 164] = 26
                                                                mem[_11228 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11228 + 228] = stor[_6755]
                                                        else:
                                                            mem[_11228 + 164] = return_data.size
                                                            mem[_11228 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_11228 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11228 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11228 + ceil32(return_data.size) + idx + 233] = mem[_11228 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_11228 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_11228 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11228 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11228 + ceil32(return_data.size) + 229
                                                                mem[_11228 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11228 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_11228 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _11228 + ceil32(return_data.size) + 229
                                                                mem[_11228 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11228 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11228 + ceil32(return_data.size) + 229] = stor[_6755]
                                        else:
                                            _8957 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8957] = 26
                                            mem[_8957 + 32] = 'SafeMath: division by zero'
                                            _9330 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9330] = 30
                                            mem[_9330 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > 0:
                                                _9444 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9444 + idx + 68] = mem[_9330 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9444 + 68] = mem[_9444 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9444 + -mem[64] + 100
                                            if -stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _9969 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9969] = 26
                                                        mem[_9969 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10100 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10100] = 26
                                                        mem[_10100 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _9727 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9727] = 30
                                                    mem[_9727 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9844 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9844 + idx + 68] = mem[_9727 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9844 + 68] = mem[_9844 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9844 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10030 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10031 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10031 + 32] = mem[_10031 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10030 + 164
                                                    mem[_10030 + 100] = 32
                                                    mem[_10030 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10445 = mem[_10031]
                                                    t = _10031 + 32
                                                    u = mem[64]
                                                    s = mem[_10031]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[mem[64] + floor32(mem[_10031])] = mem[_10031 + floor32(mem[_10031]) + -(mem[_10031] % 32) + 64 len mem[_10031] % 32] or Mask(8 * -(mem[_10031] % 32) + 32, -(8 * -(mem[_10031] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_10031])])
                                                    call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _10445 + _10030 + -mem[64] + 160]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            _14465 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10030 + 100]
                                                            _14467 = mem[_10030 + 100]
                                                            idx = 0
                                                            while idx < _14467:
                                                                mem[_14465 + idx + 68] = mem[_10030 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14467 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14467 + _14465 + -mem[64] + 68
                                                            mem[floor32(_14467) + _14465 + 68] = mem[floor32(_14467) + _14465 + -(_14467 % 32) + 100 len _14467 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14467) + _14465 + -mem[64] + 100
                                                        if mem[96] <= 0:
                                                            if not stor[_6758]:
                                                                _16355 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16355] = 26
                                                                mem[_16355 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16547 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16547] = 26
                                                                mem[_16547 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16883 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16883] = 26
                                                                mem[_16883 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17077 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17077] = 26
                                                                mem[_17077 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _13910 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_13910] = return_data.size
                                                        mem[_13910 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _14469 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10030 + 100]
                                                            _14471 = mem[_10030 + 100]
                                                            idx = 0
                                                            while idx < _14471:
                                                                mem[_14469 + idx + 68] = mem[_10030 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14471 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14471 + _14469 + -mem[64] + 68
                                                            mem[floor32(_14471) + _14469 + 68] = mem[floor32(_14471) + _14469 + -(_14471 % 32) + 100 len _14471 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14471) + _14469 + -mem[64] + 100
                                                        if return_data.size <= 0:
                                                            if not stor[_6758]:
                                                                _16356 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16356] = 26
                                                                mem[_16356 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16550 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16550] = 26
                                                                mem[_16550 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require return_data.size >= 32
                                                            if not mem[_13910 + 32]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16884 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16884] = 26
                                                                mem[_16884 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17080 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17080] = 26
                                                                mem[_17080 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                mem[mem[64]] = stor[_6755]
                                            else:
                                                _9676 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9676] = 26
                                                mem[_9676 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if -stor1[_6758] > ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10961 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10961] = 26
                                                            mem[_10961 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11154 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11154] = 26
                                                            mem[_11154 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10646 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10646] = 30
                                                        mem[_10646 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10774 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10774 + idx + 68] = mem[_10646 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10774 + 68] = mem[_10774 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10774 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11062 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11063 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11063 + 32] = mem[_11063 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11062 + 164
                                                        mem[_11062 + 100] = 32
                                                        mem[_11062 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11556 = mem[_11063]
                                                        t = _11063 + 32
                                                        u = _11062 + 164
                                                        s = mem[_11063]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_11062 + floor32(mem[_11063]) + 164] = mem[_11063 + -(mem[_11063] % 32) + floor32(mem[_11063]) + 64 len mem[_11063] % 32] or Mask(8 * -(mem[_11063] % 32) + 32, -(8 * -(mem[_11063] % 32) + 32) + 256, mem[_11062 + floor32(mem[_11063]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_11062 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_11062 + 168 len _11556 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_11062 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11062 + 168] = 32
                                                                mem[_11062 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11062 + idx + 232] = mem[_11062 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _11062 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11062 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11062 + 228
                                                                mem[_11062 + 164] = 26
                                                                mem[_11062 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_11062 + 265 len 31]
                                                                mem[64] = _11062 + 228
                                                                mem[_11062 + 164] = 26
                                                                mem[_11062 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11062 + 228] = stor[_6755]
                                                        else:
                                                            mem[_11062 + 164] = return_data.size
                                                            mem[_11062 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_11062 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11062 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11062 + ceil32(return_data.size) + idx + 233] = mem[_11062 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_11062 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_11062 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11062 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11062 + ceil32(return_data.size) + 229
                                                                mem[_11062 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11062 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_11062 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _11062 + ceil32(return_data.size) + 229
                                                                mem[_11062 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11062 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11062 + ceil32(return_data.size) + 229] = stor[_6755]
                                                else:
                                                    mem[mem[64] + 36] = -stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), -stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _10959 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_10959] = 26
                                                            mem[_10959 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11151 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11151] = 26
                                                            mem[_11151 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10645 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10645] = 30
                                                        mem[_10645 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10771 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10771 + idx + 68] = mem[_10645 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10771 + 68] = mem[_10771 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10771 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11057 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11058 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11058 + 32] = mem[_11058 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11057 + 164
                                                        mem[_11057 + 100] = 32
                                                        mem[_11057 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11552 = mem[_11058]
                                                        t = _11058 + 32
                                                        u = mem[64]
                                                        s = mem[_11058]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11058])] = mem[_11058 + floor32(mem[_11058]) + -(mem[_11058] % 32) + 64 len mem[_11058] % 32] or Mask(8 * -(mem[_11058] % 32) + 32, -(8 * -(mem[_11058] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11058])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11552 + _11057 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14473 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11057 + 100]
                                                                _14475 = mem[_11057 + 100]
                                                                idx = 0
                                                                while idx < _14475:
                                                                    mem[_14473 + idx + 68] = mem[_11057 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14475 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14475 + _14473 + -mem[64] + 68
                                                                mem[floor32(_14475) + _14473 + 68] = mem[floor32(_14475) + _14473 + -(_14475 % 32) + 100 len _14475 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14475) + _14473 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16357 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16357] = 26
                                                                    mem[_16357 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16553 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16553] = 26
                                                                    mem[_16553 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16885 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16885] = 26
                                                                    mem[_16885 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17083 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17083] = 26
                                                                    mem[_17083 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13913 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13913] = return_data.size
                                                            mem[_13913 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14477 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11057 + 100]
                                                                _14479 = mem[_11057 + 100]
                                                                idx = 0
                                                                while idx < _14479:
                                                                    mem[_14477 + idx + 68] = mem[_11057 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14479 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14479 + _14477 + -mem[64] + 68
                                                                mem[floor32(_14479) + _14477 + 68] = mem[floor32(_14479) + _14477 + -(_14479 % 32) + 100 len _14479 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14479) + _14477 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16358 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16358] = 26
                                                                    mem[_16358 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16556 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16556] = 26
                                                                    mem[_16556 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13913 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16886 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16886] = 26
                                                                    mem[_16886 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17086 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17086] = 26
                                                                    mem[_17086 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                    else:
                                        require (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _8070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8070] = 26
                                        mem[_8070 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0] <= 0:
                                            _8212 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[_8212 + idx + 68] = mem[_8070 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_8212 + 68] = mem[_8212 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _8212 + -mem[64] + 100
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * (block.number * sub_e9e49c12 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_e9e49c12 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                                        if not stor[_6758]:
                                            _9097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9097] = 26
                                            mem[_9097 + 32] = 'SafeMath: division by zero'
                                            _9442 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9442] = 30
                                            mem[_9442 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > 0:
                                                _9562 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9562 + idx + 68] = mem[_9442 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9562 + 68] = mem[_9562 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9562 + -mem[64] + 100
                                            if -stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10096 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10096] = 26
                                                        mem[_10096 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10212 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10212] = 26
                                                        mem[_10212 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    _9842 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9842] = 30
                                                    mem[_9842 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _9963 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_9963 + idx + 68] = mem[_9842 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_9963 + 68] = mem[_9963 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _9963 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10143 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10144 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10144 + 32] = mem[_10144 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10143 + 164
                                                    mem[_10143 + 100] = 32
                                                    mem[_10143 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10516 = mem[_10144]
                                                    t = _10144 + 32
                                                    u = mem[64]
                                                    s = mem[_10144]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[mem[64] + floor32(mem[_10144])] = mem[_10144 + floor32(mem[_10144]) + -(mem[_10144] % 32) + 64 len mem[_10144] % 32] or Mask(8 * -(mem[_10144] % 32) + 32, -(8 * -(mem[_10144] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_10144])])
                                                    call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _10516 + _10143 + -mem[64] + 160]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            _14417 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10143 + 100]
                                                            _14419 = mem[_10143 + 100]
                                                            idx = 0
                                                            while idx < _14419:
                                                                mem[_14417 + idx + 68] = mem[_10143 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14419 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14419 + _14417 + -mem[64] + 68
                                                            mem[floor32(_14419) + _14417 + 68] = mem[floor32(_14419) + _14417 + -(_14419 % 32) + 100 len _14419 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14419) + _14417 + -mem[64] + 100
                                                        if mem[96] <= 0:
                                                            if not stor[_6758]:
                                                                _16343 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16343] = 26
                                                                mem[_16343 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16511 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16511] = 26
                                                                mem[_16511 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16871 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16871] = 26
                                                                mem[_16871 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17041 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17041] = 26
                                                                mem[_17041 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _13886 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_13886] = return_data.size
                                                        mem[_13886 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _14421 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = mem[_10143 + 100]
                                                            _14423 = mem[_10143 + 100]
                                                            idx = 0
                                                            while idx < _14423:
                                                                mem[_14421 + idx + 68] = mem[_10143 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            if not _14423 % 32:
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14423 + _14421 + -mem[64] + 68
                                                            mem[floor32(_14423) + _14421 + 68] = mem[floor32(_14423) + _14421 + -(_14423 % 32) + 100 len _14423 % 32]
                                                            revert with memory
                                                              from mem[64]
                                                               len floor32(_14423) + _14421 + -mem[64] + 100
                                                        if return_data.size <= 0:
                                                            if not stor[_6758]:
                                                                _16344 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16344] = 26
                                                                mem[_16344 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _16514 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16514] = 26
                                                                mem[_16514 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            require return_data.size >= 32
                                                            if not mem[_13886 + 32]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[mem[64] + 110 len 22]
                                                            if not stor[_6758]:
                                                                _16872 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16872] = 26
                                                                mem[_16872 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                _17044 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17044] = 26
                                                                mem[_17044 + 32] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            else:
                                                _9777 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9777] = 26
                                                mem[_9777 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if -stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = -stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), -stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11133 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11133] = 26
                                                            mem[_11133 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11281 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11281] = 26
                                                            mem[_11281 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10765 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10765] = 30
                                                        mem[_10765 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10941 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10941 + idx + 68] = mem[_10765 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10941 + 68] = mem[_10941 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10941 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11209 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11210 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11210 + 32] = mem[_11210 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11209 + 164
                                                        mem[_11209 + 100] = 32
                                                        mem[_11209 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11688 = mem[_11210]
                                                        t = _11210 + 32
                                                        u = mem[64]
                                                        s = mem[_11210]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11210])] = mem[_11210 + floor32(mem[_11210]) + -(mem[_11210] % 32) + 64 len mem[_11210] % 32] or Mask(8 * -(mem[_11210] % 32) + 32, -(8 * -(mem[_11210] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11210])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11688 + _11209 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14425 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11209 + 100]
                                                                _14427 = mem[_11209 + 100]
                                                                idx = 0
                                                                while idx < _14427:
                                                                    mem[_14425 + idx + 68] = mem[_11209 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14427 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14427 + _14425 + -mem[64] + 68
                                                                mem[floor32(_14427) + _14425 + 68] = mem[floor32(_14427) + _14425 + -(_14427 % 32) + 100 len _14427 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14427) + _14425 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16345 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16345] = 26
                                                                    mem[_16345 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16517 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16517] = 26
                                                                    mem[_16517 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16873 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16873] = 26
                                                                    mem[_16873 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17047 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17047] = 26
                                                                    mem[_17047 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13889 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13889] = return_data.size
                                                            mem[_13889 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14429 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11209 + 100]
                                                                _14431 = mem[_11209 + 100]
                                                                idx = 0
                                                                while idx < _14431:
                                                                    mem[_14429 + idx + 68] = mem[_11209 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14431 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14431 + _14429 + -mem[64] + 68
                                                                mem[floor32(_14431) + _14429 + 68] = mem[floor32(_14431) + _14429 + -(_14431 % 32) + 100 len _14431 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14431) + _14429 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16346 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16346] = 26
                                                                    mem[_16346 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16520 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16520] = 26
                                                                    mem[_16520 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13889 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16874 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16874] = 26
                                                                    mem[_16874 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17050 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17050] = 26
                                                                    mem[_17050 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11135 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11135] = 26
                                                            mem[_11135 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11284 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11284] = 26
                                                            mem[_11284 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10766 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10766] = 30
                                                        mem[_10766 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _10944 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_10944 + idx + 68] = mem[_10766 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_10944 + 68] = mem[_10944 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _10944 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11214 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11215 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11215 + 32] = mem[_11215 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11214 + 164
                                                        mem[_11214 + 100] = 32
                                                        mem[_11214 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11692 = mem[_11215]
                                                        t = _11215 + 32
                                                        u = mem[64]
                                                        s = mem[_11215]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11215])] = mem[_11215 + floor32(mem[_11215]) + -(mem[_11215] % 32) + 64 len mem[_11215] % 32] or Mask(8 * -(mem[_11215] % 32) + 32, -(8 * -(mem[_11215] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11215])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11692 + _11214 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14433 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11214 + 100]
                                                                _14435 = mem[_11214 + 100]
                                                                idx = 0
                                                                while idx < _14435:
                                                                    mem[_14433 + idx + 68] = mem[_11214 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14435 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14435 + _14433 + -mem[64] + 68
                                                                mem[floor32(_14435) + _14433 + 68] = mem[floor32(_14435) + _14433 + -(_14435 % 32) + 100 len _14435 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14435) + _14433 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16347 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16347] = 26
                                                                    mem[_16347 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16523 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16523] = 26
                                                                    mem[_16523 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16875 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16875] = 26
                                                                    mem[_16875 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17053 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17053] = 26
                                                                    mem[_17053 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13892 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13892] = return_data.size
                                                            mem[_13892 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14437 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11214 + 100]
                                                                _14439 = mem[_11214 + 100]
                                                                idx = 0
                                                                while idx < _14439:
                                                                    mem[_14437 + idx + 68] = mem[_11214 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14439 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14439 + _14437 + -mem[64] + 68
                                                                mem[floor32(_14439) + _14437 + 68] = mem[floor32(_14439) + _14437 + -(_14439 % 32) + 100 len _14439 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14439) + _14437 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16348 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16348] = 26
                                                                    mem[_16348 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16526 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16526] = 26
                                                                    mem[_16526 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13892 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16876 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16876] = 26
                                                                    mem[_16876 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17056 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17056] = 26
                                                                    mem[_17056 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                            mem[mem[64]] = stor[_6755]
                                        else:
                                            require stor[_6758]
                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _9219 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9219] = 26
                                            mem[_9219 + 32] = 'SafeMath: division by zero'
                                            _9561 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9561] = 30
                                            mem[_9561 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[_6758] > stor[_6758] * poolInfo[arg1].field_768 / 10^18:
                                                _9671 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_9671 + idx + 68] = mem[_9561 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_9671 + 68] = mem[_9671 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _9671 + -mem[64] + 100
                                            if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= 0:
                                                if stor[_6755] <= 0:
                                                    if not stor[_6758]:
                                                        _10210 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10210] = 26
                                                        mem[_10210 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = 0
                                                    else:
                                                        require stor[_6758]
                                                        if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        _10303 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10303] = 26
                                                        mem[_10303 + 32] = 'SafeMath: division by zero'
                                                        stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
                                                else:
                                                    _9962 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9962] = 30
                                                    mem[_9962 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor[_6755] > stor[_6758]:
                                                        _10093 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_10093 + idx + 68] = mem[_9962 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_10093 + 68] = mem[_10093 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _10093 + -mem[64] + 100
                                                    stor[_6758] -= stor[_6755]
                                                    _10245 = mem[64]
                                                    mem[mem[64] + 36] = address(_6751)
                                                    mem[mem[64] + 68] = stor[_6755]
                                                    _10246 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10246 + 32] = mem[_10246 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                    mem[64] = _10245 + 164
                                                    mem[_10245 + 100] = 32
                                                    mem[_10245 + 132] = 'SafeERC20: low-level call failed'
                                                    if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                        revert with 0, 'Address: call to non-contract'
                                                    if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10590 = mem[_10246]
                                                    t = _10246 + 32
                                                    u = _10245 + 164
                                                    s = mem[_10246]
                                                    while s >= 32:
                                                        mem[u] = mem[t]
                                                        t = t + 32
                                                        u = u + 32
                                                        s = s - 32
                                                        continue 
                                                    mem[_10245 + floor32(mem[_10246]) + 164] = mem[_10246 + -(mem[_10246] % 32) + floor32(mem[_10246]) + 64 len mem[_10246] % 32] or Mask(8 * -(mem[_10246] % 32) + 32, -(8 * -(mem[_10246] % 32) + 32) + 256, mem[_10245 + floor32(mem[_10246]) + 164])
                                                    call address(poolInfo[arg1].field_0).mem[_10245 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_10245 + 168 len _10590 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96] > 0:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_10245 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10245 + 168] = 32
                                                            mem[_10245 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10245 + idx + 232] = mem[_10245 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with memory
                                                              from mem[64]
                                                               len _10245 + -mem[64] + 264
                                                        if mem[96] > 0:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10245 + 274 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10245 + 228
                                                            mem[_10245 + 164] = 26
                                                            mem[_10245 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_10245 + 265 len 31]
                                                            mem[64] = _10245 + 228
                                                            mem[_10245 + 164] = 26
                                                            mem[_10245 + 196] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10245 + 228] = stor[_6755]
                                                    else:
                                                        mem[_10245 + 164] = return_data.size
                                                        mem[_10245 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size > 0:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_10245 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_10245 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[_10245 + ceil32(return_data.size) + idx + 233] = mem[_10245 + idx + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_10245 + ceil32(return_data.size) + 233]
                                                        if return_data.size > 0:
                                                            require return_data.size >= 32
                                                            if not mem[_10245 + 196]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_10245 + ceil32(return_data.size) + 275 len 22]
                                                        if not stor[_6758]:
                                                            mem[64] = _10245 + ceil32(return_data.size) + 229
                                                            mem[_10245 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10245 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[_10245 + ceil32(return_data.size) + 266 len 31]
                                                            mem[64] = _10245 + ceil32(return_data.size) + 229
                                                            mem[_10245 + ceil32(return_data.size) + 165] = 26
                                                            mem[_10245 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[_10245 + ceil32(return_data.size) + 229] = stor[_6755]
                                            else:
                                                _9898 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9898] = 26
                                                mem[_9898 + 32] = 'SafeMath: division by zero'
                                                require ext_code.size(sub_4365354eAddress)
                                                staticcall sub_4365354eAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(this.address)
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[mem[64] + 4] = address(_6751)
                                                if (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758] <= ext_call.return_data[0]:
                                                    mem[mem[64] + 36] = (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), (stor[_6758] * poolInfo[arg1].field_768 / 10^18) - stor1[_6758]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11273 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11273] = 26
                                                            mem[_11273 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11379 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11379] = 26
                                                            mem[_11379 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        mem[mem[64]] = stor[_6755]
                                                    else:
                                                        _10939 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10939] = 30
                                                        mem[_10939 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _11121 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_11121 + idx + 68] = mem[_10939 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_11121 + 68] = mem[_11121 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _11121 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11317 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11318 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11318 + 32] = mem[_11318 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11317 + 164
                                                        mem[_11317 + 100] = 32
                                                        mem[_11317 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11838 = mem[_11318]
                                                        t = _11318 + 32
                                                        u = _11317 + 164
                                                        s = mem[_11318]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[_11317 + floor32(mem[_11318]) + 164] = mem[_11318 + -(mem[_11318] % 32) + floor32(mem[_11318]) + 64 len mem[_11318] % 32] or Mask(8 * -(mem[_11318] % 32) + 32, -(8 * -(mem[_11318] % 32) + 32) + 256, mem[_11317 + floor32(mem[_11318]) + 164])
                                                        call address(poolInfo[arg1].field_0).mem[_11317 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_11317 + 168 len _11838 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_11317 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11317 + 168] = 32
                                                                mem[_11317 + 200] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11317 + idx + 232] = mem[_11317 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _11317 + -mem[64] + 264
                                                            if mem[96] > 0:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11317 + 274 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11317 + 228
                                                                mem[_11317 + 164] = 26
                                                                mem[_11317 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[_11317 + 265 len 31]
                                                                mem[64] = _11317 + 228
                                                                mem[_11317 + 164] = 26
                                                                mem[_11317 + 196] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11317 + 228] = stor[_6755]
                                                        else:
                                                            mem[_11317 + 164] = return_data.size
                                                            mem[_11317 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_11317 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_11317 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[_11317 + ceil32(return_data.size) + idx + 233] = mem[_11317 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_11317 + ceil32(return_data.size) + 233]
                                                            if return_data.size > 0:
                                                                require return_data.size >= 32
                                                                if not mem[_11317 + 196]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[_11317 + ceil32(return_data.size) + 275 len 22]
                                                            if not stor[_6758]:
                                                                mem[64] = _11317 + ceil32(return_data.size) + 229
                                                                mem[_11317 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11317 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = 0
                                                            else:
                                                                require stor[_6758]
                                                                if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[_11317 + ceil32(return_data.size) + 266 len 31]
                                                                mem[64] = _11317 + ceil32(return_data.size) + 229
                                                                mem[_11317 + ceil32(return_data.size) + 165] = 26
                                                                mem[_11317 + ceil32(return_data.size) + 197] = 'SafeMath: division by zero'
                                                                stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            mem[_11317 + ceil32(return_data.size) + 229] = stor[_6755]
                                                else:
                                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                                    require ext_code.size(sub_4365354eAddress)
                                                    call sub_4365354eAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args address(_6751), ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 32, 34, 0x737361666546676f61745472616e736665723a205472616e73666572206661696c65, mem[mem[64] + 102 len 30]
                                                    if stor[_6755] <= 0:
                                                        if not stor[_6758]:
                                                            _11275 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11275] = 26
                                                            mem[_11275 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = 0
                                                        else:
                                                            require stor[_6758]
                                                            if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            _11382 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_11382] = 26
                                                            mem[_11382 + 32] = 'SafeMath: division by zero'
                                                            stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    else:
                                                        _10940 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10940] = 30
                                                        mem[_10940 + 32] = 'SafeMath: subtraction overflow'
                                                        if stor[_6755] > stor[_6758]:
                                                            _11124 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_11124 + idx + 68] = mem[_10940 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_11124 + 68] = mem[_11124 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _11124 + -mem[64] + 100
                                                        stor[_6758] -= stor[_6755]
                                                        _11322 = mem[64]
                                                        mem[mem[64] + 36] = address(_6751)
                                                        mem[mem[64] + 68] = stor[_6755]
                                                        _11323 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_11323 + 32] = mem[_11323 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                                        mem[64] = _11322 + 164
                                                        mem[_11322 + 100] = 32
                                                        mem[_11322 + 132] = 'SafeERC20: low-level call failed'
                                                        if ext_code.hash(address(poolInfo[arg1].field_0)) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                                            revert with 0, 'Address: call to non-contract'
                                                        if not ext_code.hash(address(poolInfo[arg1].field_0)):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _11842 = mem[_11323]
                                                        t = _11323 + 32
                                                        u = mem[64]
                                                        s = mem[_11323]
                                                        while s >= 32:
                                                            mem[u] = mem[t]
                                                            t = t + 32
                                                            u = u + 32
                                                            s = s - 32
                                                            continue 
                                                        mem[mem[64] + floor32(mem[_11323])] = mem[_11323 + floor32(mem[_11323]) + -(mem[_11323] % 32) + 64 len mem[_11323] % 32] or Mask(8 * -(mem[_11323] % 32) + 32, -(8 * -(mem[_11323] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11323])])
                                                        call address(poolInfo[arg1].field_0).mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _11842 + _11322 + -mem[64] + 160]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96] > 0:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                _14409 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11322 + 100]
                                                                _14411 = mem[_11322 + 100]
                                                                idx = 0
                                                                while idx < _14411:
                                                                    mem[_14409 + idx + 68] = mem[_11322 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14411 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14411 + _14409 + -mem[64] + 68
                                                                mem[floor32(_14411) + _14409 + 68] = mem[floor32(_14411) + _14409 + -(_14411 % 32) + 100 len _14411 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14411) + _14409 + -mem[64] + 100
                                                            if mem[96] <= 0:
                                                                if not stor[_6758]:
                                                                    _16341 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16341] = 26
                                                                    mem[_16341 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16505 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16505] = 26
                                                                    mem[_16505 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require mem[96] >= 32
                                                                if not mem[128]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16869 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16869] = 26
                                                                    mem[_16869 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17035 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17035] = 26
                                                                    mem[_17035 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                        else:
                                                            _13881 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                            mem[_13881] = return_data.size
                                                            mem[_13881 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size > 0:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _14413 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = mem[_11322 + 100]
                                                                _14415 = mem[_11322 + 100]
                                                                idx = 0
                                                                while idx < _14415:
                                                                    mem[_14413 + idx + 68] = mem[_11322 + idx + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if not _14415 % 32:
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _14415 + _14413 + -mem[64] + 68
                                                                mem[floor32(_14415) + _14413 + 68] = mem[floor32(_14415) + _14413 + -(_14415 % 32) + 100 len _14415 % 32]
                                                                revert with memory
                                                                  from mem[64]
                                                                   len floor32(_14415) + _14413 + -mem[64] + 100
                                                            if return_data.size <= 0:
                                                                if not stor[_6758]:
                                                                    _16342 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16342] = 26
                                                                    mem[_16342 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _16508 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16508] = 26
                                                                    mem[_16508 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                            else:
                                                                require return_data.size >= 32
                                                                if not mem[_13881 + 32]:
                                                                    revert with 0, 
                                                                                32,
                                                                                42,
                                                                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                                mem[mem[64] + 110 len 22]
                                                                if not stor[_6758]:
                                                                    _16870 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16870] = 26
                                                                    mem[_16870 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = 0
                                                                else:
                                                                    require stor[_6758]
                                                                    if stor[_6758] * poolInfo[arg1].field_768 / stor[_6758] != poolInfo[arg1].field_768:
                                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    _17038 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17038] = 26
                                                                    mem[_17038 + 32] = 'SafeMath: division by zero'
                                                                    stor1[_6758] = stor[_6758] * poolInfo[arg1].field_768 / 10^18
                                                    mem[mem[64]] = stor[_6755]
        emit Withdraw(stor[_6755], address(_6751), arg1);
        idx = idx + 1
        continue 
}



}
