contract main {




// =====================  Runtime code  =====================


#
#  - unstakeAll()
#  - sub_5400c9e8(?)
#  - sub_6055537b(?)
#  - sub_71d28e2e(?)
#  - sub_80fcd3a3(?)
#  - harvestAll()
#  - sub_aa3419da(?)
#  - sub_b37f105b(?)
#  - sub_d2a9c181(?)
#  - harvest(uint256 arg1)
#  - sub_f02b0e64(?)
#  - _fallback()
#
const sub_2aedba85(?) = 0


address owner;
mapping of struct stor1;
array of uint256 stor2;
mapping of uint256 stor3;
array of uint256 stor4;
array of struct stor5;
array of uint256 stor6;
uint256 stor8;
array of address stor9;
array of struct stor10;
address stor11;
address stor13;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699761;

function owner() {
    return owner
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_1ad7ddcb(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    stor6[arg2] = arg1
}

function sub_d9873603(?) {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    if not stor1[arg1][3][address(arg2)].field_0:
        revert with 0, 'No bonus NFT of this type staked'
    return (stor1[arg1][3][address(arg2)].field_0 - 1)
}

function sub_17e4f906(?) {
    require calldata.size - 4 >= 32
    if block.timestamp < stor1[arg1].field_0:
        revert with 0, 17
    if block.timestamp - stor1[arg1].field_0 <= 24 * 3600:
        return (block.timestamp - stor1[arg1].field_0)
    return (24 * 3600)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function sub_c1700844(?) {
    if stor2.length > test266151307():
        revert with 0, 65
    if stor2.length:
        mem[128 len 32 * stor2.length] = call.data[calldata.size len 32 * stor2.length]
    idx = 0
    while idx < stor2.length:
        mem[0] = 2
        if idx >= stor2.length:
            revert with 0, 50
        mem[(32 * idx) + 128] = stor2[idx]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    return Array(len=stor2.length, data=mem[128 len 32 * stor2.length])
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function sub_4bd3692a(?) {
    require calldata.size - 4 >= 32
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    if ext_call.return_data[31 len 1] >= 7:
        revert with 0, 33
    return ext_call.return_data[31 len 1]
}

function sub_a6db553b(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg4 == uint8(arg4)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not uint8(arg4):
        if arg3 >= stor5.length:
            revert with 0, 50
        address(stor5[arg3].field_0) = address(arg1)
        address(stor5[arg3].field_256) = address(arg2)
    else:
        if 1 == uint8(arg4):
            stor5.length++
            stor36B6[stor5.length] = address(arg1)
            stor36B6[stor5.length] = address(arg2)
}

function sub_6ffbb5dc(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 == uint8(arg3)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not uint8(arg3):
        if arg2 >= stor9.length:
            revert with 0, 50
        stor9[arg2] = address(arg1)
    else:
        if 1 == uint8(arg3):
            stor9.length++
            stor9[stor9.length] = address(arg1)
        else:
            if 2 == uint8(arg3):
                if not stor9.length:
                    revert with 0, 49
                stor9[stor9.length] = 0
                stor9.length--
}

function sub_5f56a31a(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor4[address(arg1)] > test266151307():
        revert with 0, 65
    if stor4[address(arg1)]:
        mem[128 len 32 * stor4[address(arg1)]] = call.data[calldata.size len 32 * stor4[address(arg1)]]
    idx = 0
    while idx < stor4[address(arg1)]:
        mem[32] = 4
        if idx >= stor4[address(arg1)]:
            revert with 0, 50
        mem[0] = sha3(address(arg1), 4)
        if idx >= stor4[address(arg1)]:
            revert with 0, 50
        mem[(32 * idx) + 128] = stor4[address(arg1)][idx]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    return Array(len=stor4[address(arg1)], data=mem[128 len 32 * stor4[address(arg1)]])
}

function sub_78e1a01e(?) {
    require calldata.size - 4 >= 32
    require ext_code.size(stor13)
    call stor13.0x42842e0e with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if not stor1[arg1].field_512:
        stor1[arg1].field_512 = sha3(arg1, stor6.length)
    if not stor3[arg1]:
        stor2.length++
        stor2[stor2.length] = arg1
        stor3[arg1] = stor2.length
    if not stor4[msg.sender][1][arg1]:
        stor4[msg.sender]++
        stor4[msg.sender][stor4[msg.sender]] = arg1
        stor4[msg.sender][1][arg1] = stor4[msg.sender]
    stor1[arg1].field_256 = msg.sender or Mask(96, 160, stor1[arg1].field_256)
    stor1[arg1].field_0 = block.timestamp
}

function sub_85e53e27(?) {
    require calldata.size - 4 >= 32
    mem[96] = 0x85e53e2700000000000000000000000000000000000000000000000000000000
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0x85e53e27 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    _4 = mem[96 len 4], Mask(224, 32, arg1) >> 32
    require mem[96 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, arg1) >> 32 + 127
    _5 = mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96]
    if mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96])) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96])) + 97
    mem[ceil32(return_data.size) + 96] = _5
    require _4 + _5 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 128 len ceil32(_5)] = mem[_4 + 128 len ceil32(_5)]
    if ceil32(_5) <= _5:
        _19 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _5
        mem[mem[64] + 64 len ceil32(_5)] = mem[ceil32(return_data.size) + 128 len ceil32(_5)]
        if ceil32(_5) <= _5:
            return Array(len=_5, data=mem[mem[64] + 64 len ceil32(_5)])
        mem[_5 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_5) + _19 + -mem[64] + 64
    mem[_5 + ceil32(return_data.size) + 128] = 0
    _20 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _5
    mem[mem[64] + 64 len ceil32(_5)] = mem[ceil32(return_data.size) + 128 len ceil32(_5)]
    if ceil32(_5) <= _5:
        return Array(len=_5, data=mem[mem[64] + 64 len ceil32(_5)])
    mem[_5 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_5) + _20 + -mem[64] + 64
}

function sub_4949a3f6(?) {
    require calldata.size - 4 >= 32
    idx = 0
    s = 0
    while idx < stor5.length:
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    if s > test266151307():
        revert with 0, 65
    mem[96] = s
    if s:
        mem[128 len 32 * s] = call.data[calldata.size len 32 * s]
    if s > test266151307():
        revert with 0, 65
    mem[(32 * s) + 128] = s
    mem[64] = (64 * s) + 160
    if s:
        mem[(32 * s) + 160 len 32 * s] = call.data[calldata.size len 32 * s]
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t
            continue 
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        if t == -1:
            revert with 0, 17
        if t >= s:
            revert with 0, 50
        mem[(32 * t) + 128] = address(stor5[idx].field_0)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + 1
        continue 
    t = 0
    while t < s:
        if t >= s:
            revert with 0, 50
        mem[0] = mem[(32 * t) + 140 len 20]
        mem[32] = sha3(arg1, 1) + 3
        if stor1[arg1][3][mem[(32 * t) + 140 len 20]].field_0 < 1:
            revert with 0, 17
        if t >= mem[(32 * s) + 128]:
            revert with 0, 50
        mem[(32 * t) + (32 * s) + 160] = stor1[arg1][3][mem[(32 * t) + 140 len 20]].field_0 - 1
        if t == -1:
            revert with 0, 17
        t = t + 1
        continue 
    mem[(64 * s) + 160] = 64
    mem[(64 * s) + 224] = s
    t = 0
    u = 128
    v = mem[64] + 96
    while t < s:
        mem[v] = mem[u + 12 len 20]
        t = t + 1
        u = u + 32
        v = v + 32
        continue 
    mem[(64 * s) + 192] = (32 * s) + 96
    mem[(98 * s) + 256] = mem[(32 * s) + 128]
    mem[(98 * s) + 288 len 32 * mem[(32 * s) + 128]] = mem[(32 * s) + 160 len 32 * mem[(32 * s) + 128]]
    return memory
      from mem[64]
       len (98 * s) + (32 * mem[(32 * s) + 128]) + -mem[64] + 288
}

function sub_5f9e80d0(?) {
    require calldata.size - 4 >= 64
    require arg2 < stor5.length
    mem[96] = address(stor5[arg2].field_0)
    mem[128] = address(stor5[arg2].field_256)
    mem[0] = address(stor5[arg2].field_0)
    mem[32] = sha3(arg1, 1) + 3
    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
        return 64, 96, 0, 0
    mem[160] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
    mem[164] = arg1
    mem[196] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
    require ext_code.size(address(stor5[arg2].field_256))
    staticcall address(stor5[arg2].field_256).0x5f9e80d0 with:
            gas gas_remaining wei
           args arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[160 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 160
    require return_data.size >= 64
    _14 = mem[160 len 4], Mask(224, 32, arg1) >> 32
    require mem[160 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require mem[160 len 4], Mask(224, 32, arg1) >> 32 + 191 < return_data.size + 160
    _16 = mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]
    if mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]) + 161 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]) + 161
    mem[ceil32(return_data.size) + 160] = mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]
    require _14 + (32 * _16) + 32 <= return_data.size
    mem[ceil32(return_data.size) + 192 len 32 * _16] = mem[_14 + 192 len 32 * _16]
    require uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 <= test266151307()
    require uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 191 < return_data.size + 160
    _35 = mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]
    if mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160] > test266151307():
        revert with 0, 65
    _38 = mem[64]
    if mem[64] + ceil32(32 * mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]) + 1
    mem[_38] = mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]
    require uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + (32 * _35) + 32 <= return_data.size
    mem[_38 + 32 len 32 * _35] = mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 192 len 32 * _35]
    _49 = mem[64]
    mem[mem[64]] = 64
    _50 = mem[ceil32(return_data.size) + 160]
    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 160]
    mem[mem[64] + 96 len 32 * _50] = mem[ceil32(return_data.size) + 192 len 32 * _50]
    mem[mem[64] + 32] = (32 * _50) + 96
    _56 = mem[_38]
    mem[_49 + (32 * _50) + 96] = mem[_38]
    mem[_49 + (32 * _50) + 128 len 32 * _56] = mem[_38 + 32 len 32 * _56]
    return memory
      from mem[64]
       len _49 + (32 * _50) + (32 * _56) + -mem[64] + 128
}

function sub_d9fe3288(?) {
    require calldata.size - 4 >= 128
    require cd[4] == uint8(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 98 < 97 or ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 36).length) + 97] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 36).length) + 129
    while idx < ('cd', 68).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 100).length) + 99 < 98 or ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 98] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 130
    while idx < ('cd', 100).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 99] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 131] = ceil32(32 * ('cd', 36).length) + 97
    if uint8(cd[4]) > 6:
        revert with 0, 33
    stor10[cd[4] << 248].field_0 = ('cd', 36).length
    if not ('cd', 36).length:
        idx = 0
        while stor10[cd[4] << 248].field_0 > idx:
            stor10[cd[4] << 248][idx].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * ('cd', 36).length) + 128 > idx:
            stor10[cd[4] << 248][s].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 36).length) + 31) >> 5
        while stor10[cd[4] << 248].field_0 > idx:
            stor10[cd[4] << 248][idx].field_0 = 0
            idx = idx + 1
            continue 
    stor10[cd[4] << 248].field_256 = ('cd', 68).length
    if not ('cd', 68).length:
        idx = 0
        while stor10[cd[4] << 248].field_256 > idx:
            stor10[cd[4] << 248][idx + 1].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = ceil32(32 * ('cd', 36).length) + 129
        while ceil32(32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 129 > idx:
            stor10[cd[4] << 248][s + 1].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 68).length) + 31) >> 5
        while stor10[cd[4] << 248].field_256 > idx:
            stor10[cd[4] << 248][idx + 1].field_0 = 0
            idx = idx + 1
            continue 
    stor10[cd[4] << 248].field_512 = ('cd', 100).length
    if not ('cd', 100).length:
        idx = 0
        while stor10[cd[4] << 248].field_512 > idx:
            stor10[cd[4] << 248][idx + 2].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 130
        while ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 130 > idx:
            stor10[cd[4] << 248][s + 2].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 100).length) + 31) >> 5
        while stor10[cd[4] << 248].field_512 > idx:
            stor10[cd[4] << 248][idx + 2].field_0 = 0
            idx = idx + 1
            continue 
}

function sub_28140527(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    mem[64] = 320
    require cd[4] + 228 <= calldata.size
    idx = 0
    s = cd[4] + 4
    t = 96
    while idx < 7:
        require cd[s] <= test266151307()
        require cd[4] + cd[s] + 35 < calldata.size
        if cd[(cd[4] + cd[s] + 4)] > test266151307():
            revert with 0, 65
        _4 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[4] + cd[s] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[4] + cd[s] + 4)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[4] + cd[s] + 4)]) + 1
        mem[_4] = cd[(cd[4] + cd[s] + 4)]
        require cd[4] + cd[s] + (32 * cd[(cd[4] + cd[s] + 4)]) + 36 <= calldata.size
        u = 0
        v = cd[4] + cd[s] + 36
        w = _4 + 32
        while u < cd[(cd[4] + cd[s] + 4)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _4
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    _3 = mem[64]
    if mem[64] + 224 > test266151307() or mem[64] + 224 < mem[64]:
        revert with 0, 65
    mem[64] = mem[64] + 224
    require cd[36] + 228 <= calldata.size
    idx = 0
    s = cd[36] + 4
    t = _3
    while idx < 7:
        require cd[s] <= test266151307()
        require cd[36] + cd[s] + 35 < calldata.size
        if cd[(cd[36] + cd[s] + 4)] > test266151307():
            revert with 0, 65
        _7 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[36] + cd[s] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[36] + cd[s] + 4)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[36] + cd[s] + 4)]) + 1
        mem[_7] = cd[(cd[36] + cd[s] + 4)]
        require cd[36] + cd[s] + (32 * cd[(cd[36] + cd[s] + 4)]) + 36 <= calldata.size
        u = 0
        v = cd[36] + cd[s] + 36
        w = _7 + 32
        while u < cd[(cd[36] + cd[s] + 4)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _7
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    _6 = mem[64]
    if mem[64] + 224 > test266151307() or mem[64] + 224 < mem[64]:
        revert with 0, 65
    mem[64] = mem[64] + 224
    require cd[68] + 228 <= calldata.size
    idx = 0
    s = cd[68] + 4
    t = _6
    while idx < 7:
        require cd[s] <= test266151307()
        require cd[68] + cd[s] + 35 < calldata.size
        if cd[(cd[68] + cd[s] + 4)] > test266151307():
            revert with 0, 65
        _12 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[68] + cd[s] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[68] + cd[s] + 4)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[68] + cd[s] + 4)]) + 1
        mem[_12] = cd[(cd[68] + cd[s] + 4)]
        require cd[68] + cd[s] + (32 * cd[(cd[68] + cd[s] + 4)]) + 36 <= calldata.size
        u = 0
        v = cd[68] + cd[s] + 36
        w = _12 + 32
        while u < cd[(cd[68] + cd[s] + 4)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _12
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < 7:
        _53 = mem[(32 * idx) + 96]
        _54 = mem[(32 * idx) + _3]
        _55 = mem[(32 * idx) + _6]
        if mem[mem[(32 * idx) + 96]] != mem[mem[(32 * idx) + _3]]:
            revert with 0, 'Length mismatch'
        if mem[mem[(32 * idx) + 96]] != mem[mem[(32 * idx) + _6]]:
            revert with 0, 'Length mismatch'
        _62 = mem[64]
        mem[64] = mem[64] + 96
        mem[_62] = mem[(32 * idx) + 96]
        mem[_62 + 32] = _54
        mem[_62 + 64] = _55
        if idx > 6:
            revert with 0, 33
        mem[0] = idx
        mem[32] = 10
        _67 = mem[_53]
        stor10[idx].field_0 = mem[_53]
        mem[0] = sha3(idx, 10)
        if not _67:
            s = sha3(sha3(idx, 10))
            while sha3(sha3(idx, 10)) + stor10[idx].field_0 > s:
                stor[s] = 0
                s = s + 1
                continue 
            _96 = mem[_54]
            stor10[idx].field_256 = mem[_54]
            mem[0] = sha3(idx, 10) + 1
            if not _96:
                s = sha3(sha3(idx, 10) + 1)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _121 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _121:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _121) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _121) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
            else:
                t = sha3(sha3(idx, 10) + 1)
                s = _54 + 32
                while _54 + (32 * _96) + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(idx, 10) + 1) + (Mask(251, 0, (32 * _96) + 31) >> 5)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _143 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _143:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _143) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _143) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
        else:
            t = sha3(sha3(idx, 10))
            s = _53 + 32
            while _53 + (32 * _67) + 32 > s:
                stor[t] = mem[s]
                t = t + 1
                s = s + 32
                continue 
            s = sha3(sha3(idx, 10)) + (Mask(251, 0, (32 * _67) + 31) >> 5)
            while sha3(sha3(idx, 10)) + stor10[idx].field_0 > s:
                stor[s] = 0
                s = s + 1
                continue 
            _123 = mem[_54]
            stor10[idx].field_256 = mem[_54]
            mem[0] = sha3(idx, 10) + 1
            if not _123:
                s = sha3(sha3(idx, 10) + 1)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _145 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _145:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _145) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _145) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
            else:
                t = sha3(sha3(idx, 10) + 1)
                s = _54 + 32
                while _54 + (32 * _123) + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(idx, 10) + 1) + (Mask(251, 0, (32 * _123) + 31) >> 5)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _157 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _157:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _157) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _157) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function stakeAll() {
    mem[100] = msg.sender
    require ext_code.size(stor13)
    staticcall stor13.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if ext_call.success:
        mem[64] = ceil32(return_data.size) + 96
        require return_data.size >= 32
        if ext_call.return_data[0] < 1:
            revert with 0, 17
        mem[ceil32(return_data.size) + 96] = 0x2f745c5900000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = var42001
        require ext_code.size(stor13)
        staticcall stor13.mem[var44003 len 4] with:
                gas gas_remaining wei
               args mem[var44003 + 4 len var44004 - 4]
        mem[var44005] = ext_call.return_data[0]
        if ext_call.success:
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require var48002 - var48001 >= 32
            _288 = mem[var50002]
            mem[(2 * ceil32(return_data.size)) + 96] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
            mem[(2 * ceil32(return_data.size)) + 132] = this.address
            mem[(2 * ceil32(return_data.size)) + 164] = _288
            require ext_code.size(stor13)
            call stor13.0x42842e0e with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), _288
            s = _288
            t = var50006
            while ext_call.success:
                mem[0] = s
                mem[32] = 1
                if stor1[s].field_512:
                    if stor3[s]:
                        if stor4[msg.sender][1][s]:
                            mem[0] = s
                            mem[32] = 1
                            stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                            stor1[s].field_0 = block.timestamp
                            if not t:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = t - 1
                            require ext_code.size(stor13)
                            staticcall stor13.0x2f745c59 with:
                                    gas gas_remaining wei
                                   args msg.sender, t - 1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _413 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _421 = mem[_413]
                            mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                            mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                            mem[(2 * ceil32(return_data.size)) + 132] = this.address
                            mem[(2 * ceil32(return_data.size)) + 164] = _421
                            require ext_code.size(stor13)
                            call stor13.0x42842e0e with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                            s = _421
                            t = t - 1
                            continue 
                        stor4[msg.sender]++
                        stor4[msg.sender][stor4[msg.sender]] = s
                        stor4[msg.sender][1][s] = stor4[msg.sender]
                        mem[0] = s
                        mem[32] = 1
                        stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                        stor1[s].field_0 = block.timestamp
                        if not t:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = t - 1
                        require ext_code.size(stor13)
                        staticcall stor13.0x2f745c59 with:
                                gas gas_remaining wei
                               args msg.sender, t - 1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _414 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _422 = mem[_414]
                        mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                        mem[(2 * ceil32(return_data.size)) + 132] = this.address
                        mem[(2 * ceil32(return_data.size)) + 164] = _422
                        require ext_code.size(stor13)
                        call stor13.0x42842e0e with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                        s = _422
                        t = t - 1
                        continue 
                    stor2.length++
                    stor2[stor2.length] = s
                    stor3[s] = stor2.length
                    if stor4[msg.sender][1][s]:
                        mem[0] = s
                        mem[32] = 1
                        stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                        stor1[s].field_0 = block.timestamp
                        if not t:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = t - 1
                        require ext_code.size(stor13)
                        staticcall stor13.0x2f745c59 with:
                                gas gas_remaining wei
                               args msg.sender, t - 1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _415 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _423 = mem[_415]
                        mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                        mem[(2 * ceil32(return_data.size)) + 132] = this.address
                        mem[(2 * ceil32(return_data.size)) + 164] = _423
                        require ext_code.size(stor13)
                        call stor13.0x42842e0e with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                        s = _423
                        t = t - 1
                        continue 
                    stor4[msg.sender]++
                    stor4[msg.sender][stor4[msg.sender]] = s
                    stor4[msg.sender][1][s] = stor4[msg.sender]
                    mem[0] = s
                    mem[32] = 1
                    stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                    stor1[s].field_0 = block.timestamp
                    if not t:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = t - 1
                    require ext_code.size(stor13)
                    staticcall stor13.0x2f745c59 with:
                            gas gas_remaining wei
                           args msg.sender, t - 1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _416 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _424 = mem[_416]
                    mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                    mem[(2 * ceil32(return_data.size)) + 132] = this.address
                    mem[(2 * ceil32(return_data.size)) + 164] = _424
                    require ext_code.size(stor13)
                    call stor13.0x42842e0e with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                    s = _424
                    t = t - 1
                    continue 
                _362 = mem[64]
                mem[mem[64] + 32] = s
                mem[mem[64] + 64] = stor6.length
                _363 = mem[64]
                mem[mem[64]] = 64
                mem[64] = mem[64] + 96
                stor1[s].field_512 = sha3(mem[_363 + 32 len mem[_363]])
                if not stor3[s]:
                    stor2.length++
                    stor2[stor2.length] = s
                    stor3[s] = stor2.length
                if not stor4[msg.sender][1][s]:
                    stor4[msg.sender]++
                    stor4[msg.sender][stor4[msg.sender]] = s
                    stor4[msg.sender][1][s] = stor4[msg.sender]
                mem[0] = s
                mem[32] = 1
                stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                stor1[s].field_0 = block.timestamp
                if not t:
                mem[_362 + 100] = msg.sender
                mem[_362 + 132] = t - 1
                require ext_code.size(stor13)
                staticcall stor13.0x2f745c59 with:
                        gas gas_remaining wei
                       args msg.sender, t - 1
                mem[_362 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _362 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                mem[_362 + ceil32(return_data.size) + 96] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                mem[(2 * ceil32(return_data.size)) + 132] = this.address
                mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
                require ext_code.size(stor13)
                call stor13.0x42842e0e with:
                     gas gas_remaining wei
                    args mem[_362 + ceil32(return_data.size) + 100 len (2 * ceil32(return_data.size)) + -_362 + 96]
                s = ext_call.return_data[0]
                t = t - 1
                continue 
    revert with ext_call.return_data[0 len return_data.size]
}

function sub_06b64c3a(?) {
    require calldata.size - 4 >= 32
    if not stor1[arg1].field_512:
        return 64, 96, 0, 0
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    mem[0] = ext_call.return_data[31 len 1]
    mem[32] = 10
    mem[ceil32(return_data.size) + 192] = stor10[ext_call.return_data[31 len 1]].field_0
    if not stor10[ext_call.return_data[31 len 1]].field_0:
        mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
        if not stor10[ext_call.return_data[31 len 1]].field_256:
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
            mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
            if not stor10[ext_call.return_data[31 len 1]].field_512:
                mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
                idx = 0
                s = 0
                while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _113 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_113 + 32 len mem[_113]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                idx = 0
                t = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _400 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_400] = address(stor5[idx].field_0)
                    mem[_400 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _413 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        if t > !mem[_413]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + mem[_413]
                        continue 
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _439 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _450 = mem[_439]
                    require mem[_439] <= test266151307()
                    require _439 + mem[_439] + 31 < _439 + return_data.size
                    _499 = mem[_439 + mem[_439]]
                    if mem[_439 + mem[_439]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_439 + mem[_439]]) + 1 < 0 or _439 + ceil32(return_data.size) + ceil32(32 * mem[_439 + mem[_439]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _439 + ceil32(return_data.size) + ceil32(32 * mem[_439 + mem[_439]]) + 1
                    mem[_439 + ceil32(return_data.size)] = _499
                    require _450 + (32 * _499) + 32 <= return_data.size
                    s = 0
                    u = _439 + _450 + 32
                    v = _439 + ceil32(return_data.size) + 32
                    while s < _499:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    _957 = mem[_439 + 32]
                    require mem[_439 + 32] <= test266151307()
                    require _439 + mem[_439 + 32] + 31 < _439 + return_data.size
                    _961 = mem[_439 + mem[_439 + 32]]
                    if mem[_439 + mem[_439 + 32]] > test266151307():
                        revert with 0, 65
                    _1043 = mem[64]
                    if mem[64] + ceil32(32 * mem[_439 + mem[_439 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_439 + mem[_439 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_439 + mem[_439 + 32]]) + 1
                    mem[_1043] = _961
                    require _957 + (32 * _961) + 32 <= return_data.size
                    s = 0
                    u = _439 + _957 + 32
                    v = _1043 + 32
                    while s < _961:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    if t > !mem[_439 + ceil32(return_data.size)]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_439 + ceil32(return_data.size)]
                    continue 
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _412 = mem[64]
                mem[mem[64]] = s + t
                if not s + t:
                    if s > !t:
                        revert with 0, 17
                    if s + t > test266151307():
                        revert with 0, 65
                    _438 = mem[64] + (32 * s + t) + 32
                    mem[mem[64] + (32 * s + t) + 32] = s + t
                    mem[64] = _438 + (32 * s + t) + 32
                    if not s + t:
                        _890 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = 0
                        u = 0
                        while idx < _890:
                            mem[0] = arg1
                            mem[32] = 1
                            mem[mem[64] + 32] = idx
                            mem[mem[64] + 64] = stor1[arg1].field_512
                            mem[mem[64] + 96] = stor8
                            _905 = mem[64]
                            mem[mem[64]] = 96
                            mem[64] = mem[64] + 128
                            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                                revert with 0, 50
                            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                revert with 0, 18
                            if sha3(mem[_905 + 32 len mem[_905]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                u = u
                                continue 
                            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                                revert with 0, 50
                            if u >= mem[_412]:
                                revert with 0, 50
                            mem[(32 * u) + _412 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            if u >= mem[_438]:
                                revert with 0, 50
                            mem[(32 * u) + _438 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if u == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u + 1
                            continue 
                        idx = 0
                        while idx < stor5.length:
                            mem[0] = 5
                            _1923 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1923] = address(stor5[idx].field_0)
                            mem[_1923 + 32] = address(stor5[idx].field_256)
                            mem[0] = address(stor5[idx].field_0)
                            mem[32] = sha3(arg1, 1) + 3
                            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                                _1958 = mem[64]
                                mem[mem[64]] = 0
                                mem[mem[64] + 32] = 0
                                mem[64] = mem[64] + 64
                                _3051 = mem[_1958]
                                s = 0
                                t = u
                                while s < _3051:
                                    if s >= mem[_1958]:
                                        revert with 0, 50
                                    if t >= mem[_412]:
                                        revert with 0, 50
                                    mem[(32 * t) + _412 + 32] = mem[(32 * s) + _1958 + 32]
                                    if s >= mem[_1958 + 32]:
                                        revert with 0, 50
                                    if t >= mem[_438]:
                                        revert with 0, 50
                                    mem[(32 * t) + _438 + 32] = mem[(32 * s) + _1958 + 64]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            else:
                                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = arg1
                                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                require ext_code.size(address(stor5[idx].field_256))
                                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                        gas gas_remaining wei
                                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2031 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _2069 = mem[_2031]
                                require mem[_2031] <= test266151307()
                                require _2031 + mem[_2031] + 31 < _2031 + return_data.size
                                _2190 = mem[_2031 + mem[_2031]]
                                if mem[_2031 + mem[_2031]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2031 + mem[_2031]]) + 1 < 0 or _2031 + ceil32(return_data.size) + ceil32(32 * mem[_2031 + mem[_2031]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2031 + ceil32(return_data.size) + ceil32(32 * mem[_2031 + mem[_2031]]) + 1
                                mem[_2031 + ceil32(return_data.size)] = _2190
                                require _2069 + (32 * _2190) + 32 <= return_data.size
                                s = 0
                                t = _2031 + _2069 + 32
                                v = _2031 + ceil32(return_data.size) + 32
                                while s < _2190:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _3205 = mem[_2031 + 32]
                                require mem[_2031 + 32] <= test266151307()
                                require _2031 + mem[_2031 + 32] + 31 < _2031 + return_data.size
                                _3252 = mem[_2031 + mem[_2031 + 32]]
                                if mem[_2031 + mem[_2031 + 32]] > test266151307():
                                    revert with 0, 65
                                _3443 = mem[64]
                                if mem[64] + ceil32(32 * mem[_2031 + mem[_2031 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2031 + mem[_2031 + 32]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + ceil32(32 * mem[_2031 + mem[_2031 + 32]]) + 1
                                mem[_3443] = _3252
                                require _3205 + (32 * _3252) + 32 <= return_data.size
                                s = 0
                                t = _2031 + _3205 + 32
                                v = _3443 + 32
                                while s < _3252:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _5935 = mem[_2031 + ceil32(return_data.size)]
                                s = 0
                                t = u
                                while s < _5935:
                                    if s >= mem[_2031 + ceil32(return_data.size)]:
                                        revert with 0, 50
                                    if t >= mem[_412]:
                                        revert with 0, 50
                                    mem[(32 * t) + _412 + 32] = mem[(32 * s) + _2031 + ceil32(return_data.size) + 32]
                                    if s >= mem[_3443]:
                                        revert with 0, 50
                                    if t >= mem[_438]:
                                        revert with 0, 50
                                    mem[(32 * t) + _438 + 32] = mem[(32 * s) + _3443 + 32]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    _5935 = mem[_2031 + ceil32(return_data.size)]
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if s > !t:
                            revert with 0, 17
                        if u != s + t:
                            revert with 0, 1
                        _1969 = mem[64]
                        mem[mem[64]] = 64
                        _1986 = mem[_412]
                        mem[mem[64] + 64] = mem[_412]
                        mem[mem[64] + 96 len 32 * _1986] = mem[_412 + 32 len 32 * _1986]
                        mem[mem[64] + 32] = (32 * _1986) + 96
                        _3235 = mem[_438]
                        mem[_1969 + (32 * _1986) + 96] = mem[_438]
                        mem[_1969 + (32 * _1986) + 128 len 32 * _3235] = mem[_438 + 32 len 32 * _3235]
                        return memory
                          from mem[64]
                           len _1969 + (32 * _1986) + (32 * _3235) + -mem[64] + 128
                    mem[_438 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _892 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _892:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _912 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_912 + 32 len mem[_912]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_412]:
                            revert with 0, 50
                        mem[(32 * u) + _412 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_438]:
                            revert with 0, 50
                        mem[(32 * u) + _438 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _1928 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1928] = address(stor5[idx].field_0)
                        mem[_1928 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _1959 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3052 = mem[_1959]
                            s = 0
                            t = u
                            while s < _3052:
                                if s >= mem[_1959]:
                                    revert with 0, 50
                                if t >= mem[_412]:
                                    revert with 0, 50
                                mem[(32 * t) + _412 + 32] = mem[(32 * s) + _1959 + 32]
                                if s >= mem[_1959 + 32]:
                                    revert with 0, 50
                                if t >= mem[_438]:
                                    revert with 0, 50
                                mem[(32 * t) + _438 + 32] = mem[(32 * s) + _1959 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2035 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2073 = mem[_2035]
                            require mem[_2035] <= test266151307()
                            require _2035 + mem[_2035] + 31 < _2035 + return_data.size
                            _2191 = mem[_2035 + mem[_2035]]
                            if mem[_2035 + mem[_2035]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2035 + mem[_2035]]) + 1 < 0 or _2035 + ceil32(return_data.size) + ceil32(32 * mem[_2035 + mem[_2035]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2035 + ceil32(return_data.size) + ceil32(32 * mem[_2035 + mem[_2035]]) + 1
                            mem[_2035 + ceil32(return_data.size)] = _2191
                            require _2073 + (32 * _2191) + 32 <= return_data.size
                            s = 0
                            t = _2035 + _2073 + 32
                            v = _2035 + ceil32(return_data.size) + 32
                            while s < _2191:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _3208 = mem[_2035 + 32]
                            require mem[_2035 + 32] <= test266151307()
                            require _2035 + mem[_2035 + 32] + 31 < _2035 + return_data.size
                            _3254 = mem[_2035 + mem[_2035 + 32]]
                            if mem[_2035 + mem[_2035 + 32]] > test266151307():
                                revert with 0, 65
                            _3444 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2035 + mem[_2035 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2035 + mem[_2035 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2035 + mem[_2035 + 32]]) + 1
                            mem[_3444] = _3254
                            require _3208 + (32 * _3254) + 32 <= return_data.size
                            s = 0
                            t = _2035 + _3208 + 32
                            v = _3444 + 32
                            while s < _3254:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _5936 = mem[_2035 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _5936:
                                if s >= mem[_2035 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_412]:
                                    revert with 0, 50
                                mem[(32 * t) + _412 + 32] = mem[(32 * s) + _2035 + ceil32(return_data.size) + 32]
                                if s >= mem[_3444]:
                                    revert with 0, 50
                                if t >= mem[_438]:
                                    revert with 0, 50
                                mem[(32 * t) + _438 + 32] = mem[(32 * s) + _3444 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _5936 = mem[_2035 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    _1970 = mem[64]
                    mem[mem[64]] = 64
                    _1991 = mem[_412]
                    mem[mem[64] + 64] = mem[_412]
                    mem[mem[64] + 96 len 32 * _1991] = mem[_412 + 32 len 32 * _1991]
                    mem[mem[64] + 32] = (32 * _1991) + 96
                    _3237 = mem[_438]
                    mem[_1970 + (32 * _1991) + 96] = mem[_438]
                    mem[_1970 + (32 * _1991) + 128 len 32 * _3237] = mem[_438 + 32 len 32 * _3237]
                    return memory
                      from mem[64]
                       len _1970 + (32 * _1991) + (32 * _3237) + -mem[64] + 128
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _412 + (64 * s + t) + 64
                if not s + t:
                    _894 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _894:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _919 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_919 + 32 len mem[_919]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_412]:
                            revert with 0, 50
                        mem[(32 * u) + _412 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_412 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _412 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _1933 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1933] = address(stor5[idx].field_0)
                        mem[_1933 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _1960 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3053 = mem[_1960]
                            v = 0
                            w = u
                            while v < _3053:
                                if v >= mem[_1960]:
                                    revert with 0, 50
                                if w >= mem[_412]:
                                    revert with 0, 50
                                mem[(32 * w) + _412 + 32] = mem[(32 * v) + _1960 + 32]
                                if v >= mem[_1960 + 32]:
                                    revert with 0, 50
                                if w >= mem[_412 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _412 + (32 * s + t) + 64] = mem[(32 * v) + _1960 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2039 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2077 = mem[_2039]
                            require mem[_2039] <= test266151307()
                            require _2039 + mem[_2039] + 31 < _2039 + return_data.size
                            _2192 = mem[_2039 + mem[_2039]]
                            if mem[_2039 + mem[_2039]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2039 + mem[_2039]]) + 1 < 0 or _2039 + ceil32(return_data.size) + ceil32(32 * mem[_2039 + mem[_2039]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2039 + ceil32(return_data.size) + ceil32(32 * mem[_2039 + mem[_2039]]) + 1
                            mem[_2039 + ceil32(return_data.size)] = _2192
                            require _2077 + (32 * _2192) + 32 <= return_data.size
                            v = 0
                            w = _2039 + _2077 + 32
                            x = _2039 + ceil32(return_data.size) + 32
                            while v < _2192:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _3211 = mem[_2039 + 32]
                            require mem[_2039 + 32] <= test266151307()
                            require _2039 + mem[_2039 + 32] + 31 < _2039 + return_data.size
                            _3256 = mem[_2039 + mem[_2039 + 32]]
                            if mem[_2039 + mem[_2039 + 32]] > test266151307():
                                revert with 0, 65
                            _3445 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2039 + mem[_2039 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2039 + mem[_2039 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2039 + mem[_2039 + 32]]) + 1
                            mem[_3445] = _3256
                            require _3211 + (32 * _3256) + 32 <= return_data.size
                            v = 0
                            w = _2039 + _3211 + 32
                            x = _3445 + 32
                            while v < _3256:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _5937 = mem[_2039 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _5937:
                                if v >= mem[_2039 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_412]:
                                    revert with 0, 50
                                mem[(32 * w) + _412 + 32] = mem[(32 * v) + _2039 + ceil32(return_data.size) + 32]
                                if v >= mem[_3445]:
                                    revert with 0, 50
                                if w >= mem[_412 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _412 + (32 * s + t) + 64] = mem[(32 * v) + _3445 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _5937 = mem[_2039 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    _1971 = mem[64]
                    mem[mem[64]] = 64
                    _1996 = mem[_412]
                    mem[mem[64] + 64] = mem[_412]
                    mem[mem[64] + 96 len 32 * _1996] = mem[_412 + 32 len 32 * _1996]
                    mem[mem[64] + 32] = (32 * _1996) + 96
                    _3239 = mem[_412 + (32 * s + t) + 32]
                    mem[_1971 + (32 * _1996) + 96] = mem[_412 + (32 * s + t) + 32]
                    mem[_1971 + (32 * _1996) + 128 len 32 * _3239] = mem[_412 + (32 * s + t) + 64 len 32 * _3239]
                    return memory
                      from mem[64]
                       len _1971 + (32 * _1996) + (32 * _3239) + -mem[64] + 128
                mem[_412 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _896 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _896:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _926 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_926 + 32 len mem[_926]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_412]:
                        revert with 0, 50
                    mem[(32 * u) + _412 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_412 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _412 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _1938 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1938] = address(stor5[idx].field_0)
                    mem[_1938 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _1961 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _3054 = mem[_1961]
                        v = 0
                        w = u
                        while v < _3054:
                            if v >= mem[_1961]:
                                revert with 0, 50
                            if w >= mem[_412]:
                                revert with 0, 50
                            mem[(32 * w) + _412 + 32] = mem[(32 * v) + _1961 + 32]
                            if v >= mem[_1961 + 32]:
                                revert with 0, 50
                            if w >= mem[_412 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _412 + (32 * s + t) + 64] = mem[(32 * v) + _1961 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2043 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _2081 = mem[_2043]
                        require mem[_2043] <= test266151307()
                        require _2043 + mem[_2043] + 31 < _2043 + return_data.size
                        _2193 = mem[_2043 + mem[_2043]]
                        if mem[_2043 + mem[_2043]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2043 + mem[_2043]]) + 1 < 0 or _2043 + ceil32(return_data.size) + ceil32(32 * mem[_2043 + mem[_2043]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2043 + ceil32(return_data.size) + ceil32(32 * mem[_2043 + mem[_2043]]) + 1
                        mem[_2043 + ceil32(return_data.size)] = _2193
                        require _2081 + (32 * _2193) + 32 <= return_data.size
                        v = 0
                        w = _2043 + _2081 + 32
                        x = _2043 + ceil32(return_data.size) + 32
                        while v < _2193:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _3214 = mem[_2043 + 32]
                        require mem[_2043 + 32] <= test266151307()
                        require _2043 + mem[_2043 + 32] + 31 < _2043 + return_data.size
                        _3258 = mem[_2043 + mem[_2043 + 32]]
                        if mem[_2043 + mem[_2043 + 32]] > test266151307():
                            revert with 0, 65
                        _3446 = mem[64]
                        if mem[64] + ceil32(32 * mem[_2043 + mem[_2043 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2043 + mem[_2043 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_2043 + mem[_2043 + 32]]) + 1
                        mem[_3446] = _3258
                        require _3214 + (32 * _3258) + 32 <= return_data.size
                        v = 0
                        w = _2043 + _3214 + 32
                        x = _3446 + 32
                        while v < _3258:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _5938 = mem[_2043 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _5938:
                            if v >= mem[_2043 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_412]:
                                revert with 0, 50
                            mem[(32 * w) + _412 + 32] = mem[(32 * v) + _2043 + ceil32(return_data.size) + 32]
                            if v >= mem[_3446]:
                                revert with 0, 50
                            if w >= mem[_412 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _412 + (32 * s + t) + 64] = mem[(32 * v) + _3446 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _5938 = mem[_2043 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _1972 = mem[64]
                mem[mem[64]] = 64
                _2001 = mem[_412]
                mem[mem[64] + 64] = mem[_412]
                mem[mem[64] + 96 len 32 * _2001] = mem[_412 + 32 len 32 * _2001]
                mem[mem[64] + 32] = (32 * _2001) + 96
                _3241 = mem[_412 + (32 * s + t) + 32]
                mem[_1972 + (32 * _2001) + 96] = mem[_412 + (32 * s + t) + 32]
                mem[_1972 + (32 * _2001) + 128 len 32 * _3241] = mem[_412 + (32 * s + t) + 64 len 32 * _3241]
                return memory
                  from mem[64]
                   len _1972 + (32 * _2001) + (32 * _3241) + -mem[64] + 128
            mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
            idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
            s = 0
            while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
                mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _934 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_934 + 32 len mem[_934]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _1943 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1943] = address(stor5[idx].field_0)
                mem[_1943 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _1964 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_1964]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_1964]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2047 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2086 = mem[_2047]
                require mem[_2047] <= test266151307()
                require _2047 + mem[_2047] + 31 < _2047 + return_data.size
                _2203 = mem[_2047 + mem[_2047]]
                if mem[_2047 + mem[_2047]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2047 + mem[_2047]]) + 1 < 0 or _2047 + ceil32(return_data.size) + ceil32(32 * mem[_2047 + mem[_2047]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2047 + ceil32(return_data.size) + ceil32(32 * mem[_2047 + mem[_2047]]) + 1
                mem[_2047 + ceil32(return_data.size)] = _2203
                require _2086 + (32 * _2203) + 32 <= return_data.size
                s = 0
                u = _2047 + _2086 + 32
                v = _2047 + ceil32(return_data.size) + 32
                while s < _2203:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3221 = mem[_2047 + 32]
                require mem[_2047 + 32] <= test266151307()
                require _2047 + mem[_2047 + 32] + 31 < _2047 + return_data.size
                _3259 = mem[_2047 + mem[_2047 + 32]]
                if mem[_2047 + mem[_2047 + 32]] > test266151307():
                    revert with 0, 65
                _3455 = mem[64]
                if mem[64] + ceil32(32 * mem[_2047 + mem[_2047 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2047 + mem[_2047 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2047 + mem[_2047 + 32]]) + 1
                mem[_3455] = _3259
                require _3221 + (32 * _3259) + 32 <= return_data.size
                s = 0
                u = _2047 + _3221 + 32
                v = _3455 + 32
                while s < _3259:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2047 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2047 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _1963 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2046 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2046 + (32 * s + t) + 32
                if not s + t:
                    _3056 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3056:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3099 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3099 + 32 len mem[_3099]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3056 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_1963]:
                            revert with 0, 50
                        mem[(32 * u) + _1963 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2046]:
                            revert with 0, 50
                        mem[(32 * u) + _2046 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3056 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _4630 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4630] = address(stor5[idx].field_0)
                        mem[_4630 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _4704 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _5939 = mem[_4704]
                            s = 0
                            t = u
                            while s < _5939:
                                if s >= mem[_4704]:
                                    revert with 0, 50
                                if t >= mem[_1963]:
                                    revert with 0, 50
                                mem[(32 * t) + _1963 + 32] = mem[(32 * s) + _4704 + 32]
                                if s >= mem[_4704 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2046]:
                                    revert with 0, 50
                                mem[(32 * t) + _2046 + 32] = mem[(32 * s) + _4704 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _5939 = mem[_4704]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4857 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _4930 = mem[_4857]
                            require mem[_4857] <= test266151307()
                            require _4857 + mem[_4857] + 31 < _4857 + return_data.size
                            _5084 = mem[_4857 + mem[_4857]]
                            if mem[_4857 + mem[_4857]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4857 + mem[_4857]]) + 1 < 0 or _4857 + ceil32(return_data.size) + ceil32(32 * mem[_4857 + mem[_4857]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4857 + ceil32(return_data.size) + ceil32(32 * mem[_4857 + mem[_4857]]) + 1
                            mem[_4857 + ceil32(return_data.size)] = _5084
                            require _4930 + (32 * _5084) + 32 <= return_data.size
                            s = 0
                            t = _4857 + _4930 + 32
                            v = _4857 + ceil32(return_data.size) + 32
                            while s < _5084:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6119 = mem[_4857 + 32]
                            require mem[_4857 + 32] <= test266151307()
                            require _4857 + mem[_4857 + 32] + 31 < _4857 + return_data.size
                            _6232 = mem[_4857 + mem[_4857 + 32]]
                            if mem[_4857 + mem[_4857 + 32]] > test266151307():
                                revert with 0, 65
                            _6433 = mem[64]
                            if mem[64] + ceil32(32 * mem[_4857 + mem[_4857 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4857 + mem[_4857 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_4857 + mem[_4857 + 32]]) + 1
                            mem[_6433] = _6232
                            require _6119 + (32 * _6232) + 32 <= return_data.size
                            s = 0
                            t = _4857 + _6119 + 32
                            v = _6433 + 32
                            while s < _6232:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _8015 = mem[_4857 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _8015:
                                if s >= mem[_4857 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_1963]:
                                    revert with 0, 50
                                mem[(32 * t) + _1963 + 32] = mem[(32 * s) + _4857 + ceil32(return_data.size) + 32]
                                if s >= mem[_6433]:
                                    revert with 0, 50
                                if t >= mem[_2046]:
                                    revert with 0, 50
                                mem[(32 * t) + _2046 + 32] = mem[(32 * s) + _6433 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _8015 = mem[_4857 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    _4729 = mem[64]
                    mem[mem[64]] = 64
                    _4761 = mem[_1963]
                    mem[mem[64] + 64] = mem[_1963]
                    mem[mem[64] + 96 len 32 * _4761] = mem[_1963 + 32 len 32 * _4761]
                    mem[mem[64] + 32] = (32 * _4761) + 96
                    _6175 = mem[_2046]
                    mem[_4729 + (32 * _4761) + 96] = mem[_2046]
                    mem[_4729 + (32 * _4761) + 128 len 32 * _6175] = mem[_2046 + 32 len 32 * _6175]
                    var64001 = _6175
                    var64002 = _2046 + (32 * _6175) + 32
                    return memory
                      from mem[64]
                       len _4729 + (32 * _4761) + (32 * _6175) + -mem[64] + 128
                mem[_2046 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3058 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3058:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3106 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3106 + 32 len mem[_3106]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3058 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_1963]:
                        revert with 0, 50
                    mem[(32 * u) + _1963 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2046]:
                        revert with 0, 50
                    mem[(32 * u) + _2046 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3058 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _4635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4635] = address(stor5[idx].field_0)
                    mem[_4635 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _4705 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _5940 = mem[_4705]
                        s = 0
                        t = u
                        while s < _5940:
                            if s >= mem[_4705]:
                                revert with 0, 50
                            if t >= mem[_1963]:
                                revert with 0, 50
                            mem[(32 * t) + _1963 + 32] = mem[(32 * s) + _4705 + 32]
                            if s >= mem[_4705 + 32]:
                                revert with 0, 50
                            if t >= mem[_2046]:
                                revert with 0, 50
                            mem[(32 * t) + _2046 + 32] = mem[(32 * s) + _4705 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _5940 = mem[_4705]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4861 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _4934 = mem[_4861]
                        require mem[_4861] <= test266151307()
                        require _4861 + mem[_4861] + 31 < _4861 + return_data.size
                        _5085 = mem[_4861 + mem[_4861]]
                        if mem[_4861 + mem[_4861]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4861 + mem[_4861]]) + 1 < 0 or _4861 + ceil32(return_data.size) + ceil32(32 * mem[_4861 + mem[_4861]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4861 + ceil32(return_data.size) + ceil32(32 * mem[_4861 + mem[_4861]]) + 1
                        mem[_4861 + ceil32(return_data.size)] = _5085
                        require _4934 + (32 * _5085) + 32 <= return_data.size
                        s = 0
                        t = _4861 + _4934 + 32
                        v = _4861 + ceil32(return_data.size) + 32
                        while s < _5085:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _6122 = mem[_4861 + 32]
                        require mem[_4861 + 32] <= test266151307()
                        require _4861 + mem[_4861 + 32] + 31 < _4861 + return_data.size
                        _6234 = mem[_4861 + mem[_4861 + 32]]
                        if mem[_4861 + mem[_4861 + 32]] > test266151307():
                            revert with 0, 65
                        _6434 = mem[64]
                        if mem[64] + ceil32(32 * mem[_4861 + mem[_4861 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4861 + mem[_4861 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_4861 + mem[_4861 + 32]]) + 1
                        mem[_6434] = _6234
                        require _6122 + (32 * _6234) + 32 <= return_data.size
                        s = 0
                        t = _4861 + _6122 + 32
                        v = _6434 + 32
                        while s < _6234:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8016 = mem[_4861 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _8016:
                            if s >= mem[_4861 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_1963]:
                                revert with 0, 50
                            mem[(32 * t) + _1963 + 32] = mem[(32 * s) + _4861 + ceil32(return_data.size) + 32]
                            if s >= mem[_6434]:
                                revert with 0, 50
                            if t >= mem[_2046]:
                                revert with 0, 50
                            mem[(32 * t) + _2046 + 32] = mem[(32 * s) + _6434 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8016 = mem[_4861 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _4730 = mem[64]
                mem[mem[64]] = 64
                _4766 = mem[_1963]
                mem[mem[64] + 64] = mem[_1963]
                mem[mem[64] + 96 len 32 * _4766] = mem[_1963 + 32 len 32 * _4766]
                var60001 = _4766
                mem[mem[64] + 32] = (32 * _4766) + 96
                _6177 = mem[_2046]
                mem[_4730 + (32 * _4766) + 96] = mem[_2046]
                mem[_4730 + (32 * _4766) + 128 len 32 * _6177] = mem[_2046 + 32 len 32 * _6177]
                return memory
                  from mem[64]
                   len _4730 + (32 * _4766) + (32 * _6177) + -mem[64] + 128
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _1963 + (64 * s + t) + 64
            if not s + t:
                _3060 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3060:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3113 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3113 + 32 len mem[_3113]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3060 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_1963]:
                        revert with 0, 50
                    mem[(32 * u) + _1963 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_1963 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _1963 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3060 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _4640 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4640] = address(stor5[idx].field_0)
                    mem[_4640 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _4706 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _5941 = mem[_4706]
                        v = 0
                        w = u
                        while v < _5941:
                            if v >= mem[_4706]:
                                revert with 0, 50
                            if w >= mem[_1963]:
                                revert with 0, 50
                            mem[(32 * w) + _1963 + 32] = mem[(32 * v) + _4706 + 32]
                            if v >= mem[_4706 + 32]:
                                revert with 0, 50
                            if w >= mem[_1963 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _1963 + (32 * s + t) + 64] = mem[(32 * v) + _4706 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _5941 = mem[_4706]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4865 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _4938 = mem[_4865]
                        require mem[_4865] <= test266151307()
                        require _4865 + mem[_4865] + 31 < _4865 + return_data.size
                        _5086 = mem[_4865 + mem[_4865]]
                        if mem[_4865 + mem[_4865]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4865 + mem[_4865]]) + 1 < 0 or _4865 + ceil32(return_data.size) + ceil32(32 * mem[_4865 + mem[_4865]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4865 + ceil32(return_data.size) + ceil32(32 * mem[_4865 + mem[_4865]]) + 1
                        mem[_4865 + ceil32(return_data.size)] = _5086
                        require _4938 + (32 * _5086) + 32 <= return_data.size
                        v = 0
                        w = _4865 + _4938 + 32
                        x = _4865 + ceil32(return_data.size) + 32
                        while v < _5086:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6125 = mem[_4865 + 32]
                        require mem[_4865 + 32] <= test266151307()
                        require _4865 + mem[_4865 + 32] + 31 < _4865 + return_data.size
                        _6236 = mem[_4865 + mem[_4865 + 32]]
                        if mem[_4865 + mem[_4865 + 32]] > test266151307():
                            revert with 0, 65
                        _6435 = mem[64]
                        if mem[64] + ceil32(32 * mem[_4865 + mem[_4865 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4865 + mem[_4865 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_4865 + mem[_4865 + 32]]) + 1
                        mem[_6435] = _6236
                        require _6125 + (32 * _6236) + 32 <= return_data.size
                        v = 0
                        w = _4865 + _6125 + 32
                        x = _6435 + 32
                        while v < _6236:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _8017 = mem[_4865 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _8017:
                            if v >= mem[_4865 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_1963]:
                                revert with 0, 50
                            mem[(32 * w) + _1963 + 32] = mem[(32 * v) + _4865 + ceil32(return_data.size) + 32]
                            if v >= mem[_6435]:
                                revert with 0, 50
                            if w >= mem[_1963 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _1963 + (32 * s + t) + 64] = mem[(32 * v) + _6435 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _8017 = mem[_4865 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _4731 = mem[64]
                mem[mem[64]] = 64
                _4771 = mem[_1963]
                mem[mem[64] + 64] = mem[_1963]
                mem[mem[64] + 96 len 32 * _4771] = mem[_1963 + 32 len 32 * _4771]
                var60001 = _4771
                mem[mem[64] + 32] = (32 * _4771) + 96
                _6179 = mem[_1963 + (32 * s + t) + 32]
                mem[_4731 + (32 * _4771) + 96] = mem[_1963 + (32 * s + t) + 32]
                mem[_4731 + (32 * _4771) + 128 len 32 * _6179] = mem[_1963 + (32 * s + t) + 64 len 32 * _6179]
                return memory
                  from mem[64]
                   len _4731 + (32 * _4771) + (32 * _6179) + -mem[64] + 128
            mem[_1963 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3062 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3062:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3120 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3120 + 32 len mem[_3120]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3062 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_1963]:
                    revert with 0, 50
                mem[(32 * u) + _1963 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_1963 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _1963 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3062 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _4645 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4645] = address(stor5[idx].field_0)
                mem[_4645 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _4707 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _5942 = mem[_4707]
                    v = 0
                    w = u
                    while v < _5942:
                        if v >= mem[_4707]:
                            revert with 0, 50
                        if w >= mem[_1963]:
                            revert with 0, 50
                        mem[(32 * w) + _1963 + 32] = mem[(32 * v) + _4707 + 32]
                        if v >= mem[_4707 + 32]:
                            revert with 0, 50
                        if w >= mem[_1963 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _1963 + (32 * s + t) + 64] = mem[(32 * v) + _4707 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _5942 = mem[_4707]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4869 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _4942 = mem[_4869]
                    require mem[_4869] <= test266151307()
                    require _4869 + mem[_4869] + 31 < _4869 + return_data.size
                    _5087 = mem[_4869 + mem[_4869]]
                    if mem[_4869 + mem[_4869]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4869 + mem[_4869]]) + 1 < 0 or _4869 + ceil32(return_data.size) + ceil32(32 * mem[_4869 + mem[_4869]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4869 + ceil32(return_data.size) + ceil32(32 * mem[_4869 + mem[_4869]]) + 1
                    mem[_4869 + ceil32(return_data.size)] = _5087
                    require _4942 + (32 * _5087) + 32 <= return_data.size
                    v = 0
                    w = _4869 + _4942 + 32
                    x = _4869 + ceil32(return_data.size) + 32
                    while v < _5087:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _6128 = mem[_4869 + 32]
                    require mem[_4869 + 32] <= test266151307()
                    require _4869 + mem[_4869 + 32] + 31 < _4869 + return_data.size
                    _6238 = mem[_4869 + mem[_4869 + 32]]
                    if mem[_4869 + mem[_4869 + 32]] > test266151307():
                        revert with 0, 65
                    _6436 = mem[64]
                    if mem[64] + ceil32(32 * mem[_4869 + mem[_4869 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4869 + mem[_4869 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_4869 + mem[_4869 + 32]]) + 1
                    mem[_6436] = _6238
                    require _6128 + (32 * _6238) + 32 <= return_data.size
                    v = 0
                    w = _4869 + _6128 + 32
                    x = _6436 + 32
                    while v < _6238:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8018 = mem[_4869 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _8018:
                        if v >= mem[_4869 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_1963]:
                            revert with 0, 50
                        mem[(32 * w) + _1963 + 32] = mem[(32 * v) + _4869 + ceil32(return_data.size) + 32]
                        if v >= mem[_6436]:
                            revert with 0, 50
                        if w >= mem[_1963 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _1963 + (32 * s + t) + 64] = mem[(32 * v) + _6436 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8018 = mem[_4869 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _4732 = mem[64]
            mem[mem[64]] = 64
            _4776 = mem[_1963]
            mem[mem[64] + 64] = mem[_1963]
            mem[mem[64] + 96 len 32 * _4776] = mem[_1963 + 32 len 32 * _4776]
            var61001 = _4776
            mem[mem[64] + 32] = (32 * _4776) + 96
            _6181 = mem[_1963 + (32 * s + t) + 32]
            mem[_4732 + (32 * _4776) + 96] = mem[_1963 + (32 * s + t) + 32]
            mem[_4732 + (32 * _4776) + 128 len 32 * _6181] = mem[_1963 + (32 * s + t) + 64 len 32 * _6181]
            return memory
              from mem[64]
               len _4732 + (32 * _4776) + (32 * _6181) + -mem[64] + 128
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _941 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_941 + 32 len mem[_941]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _1948 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1948] = address(stor5[idx].field_0)
                mem[_1948 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _1966 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_1966]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_1966]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2049 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2089 = mem[_2049]
                require mem[_2049] <= test266151307()
                require _2049 + mem[_2049] + 31 < _2049 + return_data.size
                _2213 = mem[_2049 + mem[_2049]]
                if mem[_2049 + mem[_2049]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2049 + mem[_2049]]) + 1 < 0 or _2049 + ceil32(return_data.size) + ceil32(32 * mem[_2049 + mem[_2049]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2049 + ceil32(return_data.size) + ceil32(32 * mem[_2049 + mem[_2049]]) + 1
                mem[_2049 + ceil32(return_data.size)] = _2213
                require _2089 + (32 * _2213) + 32 <= return_data.size
                s = 0
                u = _2049 + _2089 + 32
                v = _2049 + ceil32(return_data.size) + 32
                while s < _2213:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3226 = mem[_2049 + 32]
                require mem[_2049 + 32] <= test266151307()
                require _2049 + mem[_2049 + 32] + 31 < _2049 + return_data.size
                _3260 = mem[_2049 + mem[_2049 + 32]]
                if mem[_2049 + mem[_2049 + 32]] > test266151307():
                    revert with 0, 65
                _3464 = mem[64]
                if mem[64] + ceil32(32 * mem[_2049 + mem[_2049 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2049 + mem[_2049 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2049 + mem[_2049 + 32]]) + 1
                mem[_3464] = _3260
                require _3226 + (32 * _3260) + 32 <= return_data.size
                s = 0
                u = _2049 + _3226 + 32
                v = _3464 + 32
                while s < _3260:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2049 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2049 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _1965 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2048 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2048 + (32 * s + t) + 32
                if not s + t:
                    _3064 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3064:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3128 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3128 + 32 len mem[_3128]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3064 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_1965]:
                            revert with 0, 50
                        mem[(32 * u) + _1965 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2048]:
                            revert with 0, 50
                        mem[(32 * u) + _2048 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3064 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _4650 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4650] = address(stor5[idx].field_0)
                        mem[_4650 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _4709 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _5943 = mem[_4709]
                            s = 0
                            t = u
                            while s < _5943:
                                if s >= mem[_4709]:
                                    revert with 0, 50
                                if t >= mem[_1965]:
                                    revert with 0, 50
                                mem[(32 * t) + _1965 + 32] = mem[(32 * s) + _4709 + 32]
                                if s >= mem[_4709 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2048]:
                                    revert with 0, 50
                                mem[(32 * t) + _2048 + 32] = mem[(32 * s) + _4709 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _5943 = mem[_4709]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4873 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _4946 = mem[_4873]
                            require mem[_4873] <= test266151307()
                            require _4873 + mem[_4873] + 31 < _4873 + return_data.size
                            _5088 = mem[_4873 + mem[_4873]]
                            if mem[_4873 + mem[_4873]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4873 + mem[_4873]]) + 1 < 0 or _4873 + ceil32(return_data.size) + ceil32(32 * mem[_4873 + mem[_4873]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4873 + ceil32(return_data.size) + ceil32(32 * mem[_4873 + mem[_4873]]) + 1
                            mem[_4873 + ceil32(return_data.size)] = _5088
                            require _4946 + (32 * _5088) + 32 <= return_data.size
                            s = 0
                            t = _4873 + _4946 + 32
                            v = _4873 + ceil32(return_data.size) + 32
                            while s < _5088:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6131 = mem[_4873 + 32]
                            require mem[_4873 + 32] <= test266151307()
                            require _4873 + mem[_4873 + 32] + 31 < _4873 + return_data.size
                            _6240 = mem[_4873 + mem[_4873 + 32]]
                            if mem[_4873 + mem[_4873 + 32]] > test266151307():
                                revert with 0, 65
                            _6437 = mem[64]
                            if mem[64] + ceil32(32 * mem[_4873 + mem[_4873 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4873 + mem[_4873 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_4873 + mem[_4873 + 32]]) + 1
                            mem[_6437] = _6240
                            require _6131 + (32 * _6240) + 32 <= return_data.size
                            s = 0
                            t = _4873 + _6131 + 32
                            v = _6437 + 32
                            while s < _6240:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _8019 = mem[_4873 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _8019:
                                if s >= mem[_4873 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_1965]:
                                    revert with 0, 50
                                mem[(32 * t) + _1965 + 32] = mem[(32 * s) + _4873 + ceil32(return_data.size) + 32]
                                if s >= mem[_6437]:
                                    revert with 0, 50
                                if t >= mem[_2048]:
                                    revert with 0, 50
                                mem[(32 * t) + _2048 + 32] = mem[(32 * s) + _6437 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _8019 = mem[_4873 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    _4733 = mem[64]
                    mem[mem[64]] = 64
                    _4781 = mem[_1965]
                    mem[mem[64] + 64] = mem[_1965]
                    mem[mem[64] + 96 len 32 * _4781] = mem[_1965 + 32 len 32 * _4781]
                    mem[mem[64] + 32] = (32 * _4781) + 96
                    _6183 = mem[_2048]
                    mem[_4733 + (32 * _4781) + 96] = mem[_2048]
                    mem[_4733 + (32 * _4781) + 128 len 32 * _6183] = mem[_2048 + 32 len 32 * _6183]
                    var64001 = _6183
                    var64002 = _2048 + (32 * _6183) + 32
                    return memory
                      from mem[64]
                       len _4733 + (32 * _4781) + (32 * _6183) + -mem[64] + 128
                mem[_2048 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3066 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3066:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3135 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3135 + 32 len mem[_3135]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3066 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_1965]:
                        revert with 0, 50
                    mem[(32 * u) + _1965 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2048]:
                        revert with 0, 50
                    mem[(32 * u) + _2048 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3066 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _4655 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4655] = address(stor5[idx].field_0)
                    mem[_4655 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _4710 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _5944 = mem[_4710]
                        s = 0
                        t = u
                        while s < _5944:
                            if s >= mem[_4710]:
                                revert with 0, 50
                            if t >= mem[_1965]:
                                revert with 0, 50
                            mem[(32 * t) + _1965 + 32] = mem[(32 * s) + _4710 + 32]
                            if s >= mem[_4710 + 32]:
                                revert with 0, 50
                            if t >= mem[_2048]:
                                revert with 0, 50
                            mem[(32 * t) + _2048 + 32] = mem[(32 * s) + _4710 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _5944 = mem[_4710]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4877 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _4950 = mem[_4877]
                        require mem[_4877] <= test266151307()
                        require _4877 + mem[_4877] + 31 < _4877 + return_data.size
                        _5089 = mem[_4877 + mem[_4877]]
                        if mem[_4877 + mem[_4877]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4877 + mem[_4877]]) + 1 < 0 or _4877 + ceil32(return_data.size) + ceil32(32 * mem[_4877 + mem[_4877]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4877 + ceil32(return_data.size) + ceil32(32 * mem[_4877 + mem[_4877]]) + 1
                        mem[_4877 + ceil32(return_data.size)] = _5089
                        require _4950 + (32 * _5089) + 32 <= return_data.size
                        s = 0
                        t = _4877 + _4950 + 32
                        v = _4877 + ceil32(return_data.size) + 32
                        while s < _5089:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _6134 = mem[_4877 + 32]
                        require mem[_4877 + 32] <= test266151307()
                        require _4877 + mem[_4877 + 32] + 31 < _4877 + return_data.size
                        _6242 = mem[_4877 + mem[_4877 + 32]]
                        if mem[_4877 + mem[_4877 + 32]] > test266151307():
                            revert with 0, 65
                        _6438 = mem[64]
                        if mem[64] + ceil32(32 * mem[_4877 + mem[_4877 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4877 + mem[_4877 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_4877 + mem[_4877 + 32]]) + 1
                        mem[_6438] = _6242
                        require _6134 + (32 * _6242) + 32 <= return_data.size
                        s = 0
                        t = _4877 + _6134 + 32
                        v = _6438 + 32
                        while s < _6242:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8020 = mem[_4877 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _8020:
                            if s >= mem[_4877 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_1965]:
                                revert with 0, 50
                            mem[(32 * t) + _1965 + 32] = mem[(32 * s) + _4877 + ceil32(return_data.size) + 32]
                            if s >= mem[_6438]:
                                revert with 0, 50
                            if t >= mem[_2048]:
                                revert with 0, 50
                            mem[(32 * t) + _2048 + 32] = mem[(32 * s) + _6438 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8020 = mem[_4877 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _4734 = mem[64]
                mem[mem[64]] = 64
                _4786 = mem[_1965]
                mem[mem[64] + 64] = mem[_1965]
                mem[mem[64] + 96 len 32 * _4786] = mem[_1965 + 32 len 32 * _4786]
                var60001 = _4786
                mem[mem[64] + 32] = (32 * _4786) + 96
                _6185 = mem[_2048]
                mem[_4734 + (32 * _4786) + 96] = mem[_2048]
                mem[_4734 + (32 * _4786) + 128 len 32 * _6185] = mem[_2048 + 32 len 32 * _6185]
                var65001 = _6185
                return memory
                  from mem[64]
                   len _4734 + (32 * _4786) + (32 * _6185) + -mem[64] + 128
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _1965 + (64 * s + t) + 64
            if not s + t:
                _3068 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3068:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3142 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3142 + 32 len mem[_3142]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3068 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_1965]:
                        revert with 0, 50
                    mem[(32 * u) + _1965 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_1965 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _1965 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3068 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _4660 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4660] = address(stor5[idx].field_0)
                    mem[_4660 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _4711 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _5945 = mem[_4711]
                        v = 0
                        w = u
                        while v < _5945:
                            if v >= mem[_4711]:
                                revert with 0, 50
                            if w >= mem[_1965]:
                                revert with 0, 50
                            mem[(32 * w) + _1965 + 32] = mem[(32 * v) + _4711 + 32]
                            if v >= mem[_4711 + 32]:
                                revert with 0, 50
                            if w >= mem[_1965 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _1965 + (32 * s + t) + 64] = mem[(32 * v) + _4711 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _5945 = mem[_4711]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4881 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _4954 = mem[_4881]
                        require mem[_4881] <= test266151307()
                        require _4881 + mem[_4881] + 31 < _4881 + return_data.size
                        _5090 = mem[_4881 + mem[_4881]]
                        if mem[_4881 + mem[_4881]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4881 + mem[_4881]]) + 1 < 0 or _4881 + ceil32(return_data.size) + ceil32(32 * mem[_4881 + mem[_4881]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4881 + ceil32(return_data.size) + ceil32(32 * mem[_4881 + mem[_4881]]) + 1
                        mem[_4881 + ceil32(return_data.size)] = _5090
                        require _4954 + (32 * _5090) + 32 <= return_data.size
                        v = 0
                        w = _4881 + _4954 + 32
                        x = _4881 + ceil32(return_data.size) + 32
                        while v < _5090:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6137 = mem[_4881 + 32]
                        require mem[_4881 + 32] <= test266151307()
                        require _4881 + mem[_4881 + 32] + 31 < _4881 + return_data.size
                        _6244 = mem[_4881 + mem[_4881 + 32]]
                        if mem[_4881 + mem[_4881 + 32]] > test266151307():
                            revert with 0, 65
                        _6439 = mem[64]
                        if mem[64] + ceil32(32 * mem[_4881 + mem[_4881 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4881 + mem[_4881 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_4881 + mem[_4881 + 32]]) + 1
                        mem[_6439] = _6244
                        require _6137 + (32 * _6244) + 32 <= return_data.size
                        v = 0
                        w = _4881 + _6137 + 32
                        x = _6439 + 32
                        while v < _6244:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _8021 = mem[_4881 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _8021:
                            if v >= mem[_4881 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_1965]:
                                revert with 0, 50
                            mem[(32 * w) + _1965 + 32] = mem[(32 * v) + _4881 + ceil32(return_data.size) + 32]
                            if v >= mem[_6439]:
                                revert with 0, 50
                            if w >= mem[_1965 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _1965 + (32 * s + t) + 64] = mem[(32 * v) + _6439 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _8021 = mem[_4881 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _4735 = mem[64]
                mem[mem[64]] = 64
                _4791 = mem[_1965]
                mem[mem[64] + 64] = mem[_1965]
                mem[mem[64] + 96 len 32 * _4791] = mem[_1965 + 32 len 32 * _4791]
                var60001 = _4791
                mem[mem[64] + 32] = (32 * _4791) + 96
                _6187 = mem[_1965 + (32 * s + t) + 32]
                mem[_4735 + (32 * _4791) + 96] = mem[_1965 + (32 * s + t) + 32]
                mem[_4735 + (32 * _4791) + 128 len 32 * _6187] = mem[_1965 + (32 * s + t) + 64 len 32 * _6187]
                var65001 = _6187
                return memory
                  from mem[64]
                   len _4735 + (32 * _4791) + (32 * _6187) + -mem[64] + 128
            mem[_1965 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3070 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3070:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3149 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3149 + 32 len mem[_3149]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3070 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_1965]:
                    revert with 0, 50
                mem[(32 * u) + _1965 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_1965 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _1965 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3070 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _4665 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4665] = address(stor5[idx].field_0)
                mem[_4665 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _4712 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _5946 = mem[_4712]
                    v = 0
                    w = u
                    while v < _5946:
                        if v >= mem[_4712]:
                            revert with 0, 50
                        if w >= mem[_1965]:
                            revert with 0, 50
                        mem[(32 * w) + _1965 + 32] = mem[(32 * v) + _4712 + 32]
                        if v >= mem[_4712 + 32]:
                            revert with 0, 50
                        if w >= mem[_1965 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _1965 + (32 * s + t) + 64] = mem[(32 * v) + _4712 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _5946 = mem[_4712]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4885 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _4958 = mem[_4885]
                    require mem[_4885] <= test266151307()
                    require _4885 + mem[_4885] + 31 < _4885 + return_data.size
                    _5091 = mem[_4885 + mem[_4885]]
                    if mem[_4885 + mem[_4885]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4885 + mem[_4885]]) + 1 < 0 or _4885 + ceil32(return_data.size) + ceil32(32 * mem[_4885 + mem[_4885]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4885 + ceil32(return_data.size) + ceil32(32 * mem[_4885 + mem[_4885]]) + 1
                    mem[_4885 + ceil32(return_data.size)] = _5091
                    require _4958 + (32 * _5091) + 32 <= return_data.size
                    v = 0
                    w = _4885 + _4958 + 32
                    x = _4885 + ceil32(return_data.size) + 32
                    while v < _5091:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _6140 = mem[_4885 + 32]
                    require mem[_4885 + 32] <= test266151307()
                    require _4885 + mem[_4885 + 32] + 31 < _4885 + return_data.size
                    _6246 = mem[_4885 + mem[_4885 + 32]]
                    if mem[_4885 + mem[_4885 + 32]] > test266151307():
                        revert with 0, 65
                    _6440 = mem[64]
                    if mem[64] + ceil32(32 * mem[_4885 + mem[_4885 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4885 + mem[_4885 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_4885 + mem[_4885 + 32]]) + 1
                    mem[_6440] = _6246
                    require _6140 + (32 * _6246) + 32 <= return_data.size
                    v = 0
                    w = _4885 + _6140 + 32
                    x = _6440 + 32
                    while v < _6246:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8022 = mem[_4885 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _8022:
                        if v >= mem[_4885 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_1965]:
                            revert with 0, 50
                        mem[(32 * w) + _1965 + 32] = mem[(32 * v) + _4885 + ceil32(return_data.size) + 32]
                        if v >= mem[_6440]:
                            revert with 0, 50
                        if w >= mem[_1965 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _1965 + (32 * s + t) + 64] = mem[(32 * v) + _6440 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8022 = mem[_4885 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _4736 = mem[64]
            mem[mem[64]] = 64
            _4796 = mem[_1965]
            mem[mem[64] + 64] = mem[_1965]
            mem[mem[64] + 96 len 32 * _4796] = mem[_1965 + 32 len 32 * _4796]
            var61001 = _4796
            var61002 = _1965 + (32 * _4796) + 32
            mem[mem[64] + 32] = (32 * _4796) + 96
            _6189 = mem[_1965 + (32 * s + t) + 32]
            mem[_4736 + (32 * _4796) + 96] = mem[_1965 + (32 * s + t) + 32]
            mem[_4736 + (32 * _4796) + 128 len 32 * _6189] = mem[_1965 + (32 * s + t) + 64 len 32 * _6189]
            var66001 = _6189
            var66002 = _1965 + (32 * s + t) + (32 * _6189) + 64
            return memory
              from mem[64]
               len _4736 + (32 * _4796) + (32 * _6189) + -mem[64] + 128
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3157 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3157 + 32 len mem[_3157]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _4670 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4670] = address(stor5[idx].field_0)
            mem[_4670 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _4715 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_4715]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_4715]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4889 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _4963 = mem[_4889]
            require mem[_4889] <= test266151307()
            require _4889 + mem[_4889] + 31 < _4889 + return_data.size
            _5101 = mem[_4889 + mem[_4889]]
            if mem[_4889 + mem[_4889]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_4889 + mem[_4889]]) + 1 < 0 or _4889 + ceil32(return_data.size) + ceil32(32 * mem[_4889 + mem[_4889]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _4889 + ceil32(return_data.size) + ceil32(32 * mem[_4889 + mem[_4889]]) + 1
            mem[_4889 + ceil32(return_data.size)] = _5101
            require _4963 + (32 * _5101) + 32 <= return_data.size
            s = 0
            u = _4889 + _4963 + 32
            v = _4889 + ceil32(return_data.size) + 32
            while s < _5101:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _6147 = mem[_4889 + 32]
            require mem[_4889 + 32] <= test266151307()
            require _4889 + mem[_4889 + 32] + 31 < _4889 + return_data.size
            _6247 = mem[_4889 + mem[_4889 + 32]]
            if mem[_4889 + mem[_4889 + 32]] > test266151307():
                revert with 0, 65
            _6449 = mem[64]
            if mem[64] + ceil32(32 * mem[_4889 + mem[_4889 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4889 + mem[_4889 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_4889 + mem[_4889 + 32]]) + 1
            mem[_6449] = _6247
            require _6147 + (32 * _6247) + 32 <= return_data.size
            s = 0
            u = _4889 + _6147 + 32
            v = _6449 + 32
            while s < _6247:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_4889 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_4889 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _4714 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _4714 + (64 * s + t) + 64
            if not s + t:
                _5952 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _5952:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6021 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6021 + 32 len mem[_6021]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _5952 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_4714]:
                        revert with 0, 50
                    mem[(32 * u) + _4714 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_4714 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _4714 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5952 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _7236 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7236] = address(stor5[idx].field_0)
                    mem[_7236 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _7292 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _8025 = mem[_7292]
                        v = 0
                        w = u
                        while v < _8025:
                            if v >= mem[_7292]:
                                revert with 0, 50
                            if w >= mem[_4714]:
                                revert with 0, 50
                            mem[(32 * w) + _4714 + 32] = mem[(32 * v) + _7292 + 32]
                            if v >= mem[_7292 + 32]:
                                revert with 0, 50
                            if w >= mem[_4714 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _4714 + (32 * s + t) + 64] = mem[(32 * v) + _7292 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _8025 = mem[_7292]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7480 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _7551 = mem[_7480]
                        require mem[_7480] <= test266151307()
                        require _7480 + mem[_7480] + 31 < _7480 + return_data.size
                        _7635 = mem[_7480 + mem[_7480]]
                        if mem[_7480 + mem[_7480]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_7480 + mem[_7480]]) + 1 < 0 or _7480 + ceil32(return_data.size) + ceil32(32 * mem[_7480 + mem[_7480]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _7480 + ceil32(return_data.size) + ceil32(32 * mem[_7480 + mem[_7480]]) + 1
                        mem[_7480 + ceil32(return_data.size)] = _7635
                        require _7551 + (32 * _7635) + 32 <= return_data.size
                        v = 0
                        w = _7480 + _7551 + 32
                        x = _7480 + ceil32(return_data.size) + 32
                        while v < _7635:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _8146 = mem[_7480 + 32]
                        require mem[_7480 + 32] <= test266151307()
                        require _7480 + mem[_7480 + 32] + 31 < _7480 + return_data.size
                        _8278 = mem[_7480 + mem[_7480 + 32]]
                        if mem[_7480 + mem[_7480 + 32]] > test266151307():
                            revert with 0, 65
                        _8364 = mem[64]
                        if mem[64] + ceil32(32 * mem[_7480 + mem[_7480 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7480 + mem[_7480 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_7480 + mem[_7480 + 32]]) + 1
                        mem[_8364] = _8278
                        require _8146 + (32 * _8278) + 32 <= return_data.size
                        v = 0
                        w = _7480 + _8146 + 32
                        x = _8364 + 32
                        while v < _8278:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _8881 = mem[_7480 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _8881:
                            if v >= mem[_7480 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_4714]:
                                revert with 0, 50
                            mem[(32 * w) + _4714 + 32] = mem[(32 * v) + _7480 + ceil32(return_data.size) + 32]
                            if v >= mem[_8364]:
                                revert with 0, 50
                            if w >= mem[_4714 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _4714 + (32 * s + t) + 64] = mem[(32 * v) + _8364 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _8881 = mem[_7480 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _7317 = mem[64]
                mem[mem[64]] = 64
                _7370 = mem[_4714]
                mem[mem[64] + 64] = mem[_4714]
                mem[mem[64] + 96 len 32 * _7370] = mem[_4714 + 32 len 32 * _7370]
                var64001 = _7370
                var64002 = _4714 + (32 * _7370) + 32
                mem[mem[64] + 32] = (32 * _7370) + 96
                _8201 = mem[_4714 + (32 * s + t) + 32]
                mem[_7317 + (32 * _7370) + 96] = mem[_4714 + (32 * s + t) + 32]
                mem[_7317 + (32 * _7370) + 128 len 32 * _8201] = mem[_4714 + (32 * s + t) + 64 len 32 * _8201]
                var69001 = _8201
                return memory
                  from mem[64]
                   len _7317 + (32 * _7370) + (32 * _8201) + -mem[64] + 128
            mem[_4714 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _5954 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _5954:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6028 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6028 + 32 len mem[_6028]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _5954 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_4714]:
                    revert with 0, 50
                mem[(32 * u) + _4714 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_4714 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _4714 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5954 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _7241 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7241] = address(stor5[idx].field_0)
                mem[_7241 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _7293 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8026 = mem[_7293]
                    v = 0
                    w = u
                    while v < _8026:
                        if v >= mem[_7293]:
                            revert with 0, 50
                        if w >= mem[_4714]:
                            revert with 0, 50
                        mem[(32 * w) + _4714 + 32] = mem[(32 * v) + _7293 + 32]
                        if v >= mem[_7293 + 32]:
                            revert with 0, 50
                        if w >= mem[_4714 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _4714 + (32 * s + t) + 64] = mem[(32 * v) + _7293 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8026 = mem[_7293]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7484 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _7555 = mem[_7484]
                    require mem[_7484] <= test266151307()
                    require _7484 + mem[_7484] + 31 < _7484 + return_data.size
                    _7636 = mem[_7484 + mem[_7484]]
                    if mem[_7484 + mem[_7484]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7484 + mem[_7484]]) + 1 < 0 or _7484 + ceil32(return_data.size) + ceil32(32 * mem[_7484 + mem[_7484]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7484 + ceil32(return_data.size) + ceil32(32 * mem[_7484 + mem[_7484]]) + 1
                    mem[_7484 + ceil32(return_data.size)] = _7636
                    require _7555 + (32 * _7636) + 32 <= return_data.size
                    v = 0
                    w = _7484 + _7555 + 32
                    x = _7484 + ceil32(return_data.size) + 32
                    while v < _7636:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8149 = mem[_7484 + 32]
                    require mem[_7484 + 32] <= test266151307()
                    require _7484 + mem[_7484 + 32] + 31 < _7484 + return_data.size
                    _8280 = mem[_7484 + mem[_7484 + 32]]
                    if mem[_7484 + mem[_7484 + 32]] > test266151307():
                        revert with 0, 65
                    _8365 = mem[64]
                    if mem[64] + ceil32(32 * mem[_7484 + mem[_7484 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7484 + mem[_7484 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_7484 + mem[_7484 + 32]]) + 1
                    mem[_8365] = _8280
                    require _8149 + (32 * _8280) + 32 <= return_data.size
                    v = 0
                    w = _7484 + _8149 + 32
                    x = _8365 + 32
                    while v < _8280:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8882 = mem[_7484 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _8882:
                        if v >= mem[_7484 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_4714]:
                            revert with 0, 50
                        mem[(32 * w) + _4714 + 32] = mem[(32 * v) + _7484 + ceil32(return_data.size) + 32]
                        if v >= mem[_8365]:
                            revert with 0, 50
                        if w >= mem[_4714 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _4714 + (32 * s + t) + 64] = mem[(32 * v) + _8365 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8882 = mem[_7484 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _7318 = mem[64]
            mem[mem[64]] = 64
            _7375 = mem[_4714]
            mem[mem[64] + 64] = mem[_4714]
            mem[mem[64] + 96 len 32 * _7375] = mem[_4714 + 32 len 32 * _7375]
            var65001 = _7375
            mem[mem[64] + 32] = (32 * _7375) + 96
            _8203 = mem[_4714 + (32 * s + t) + 32]
            mem[_7318 + (32 * _7375) + 96] = mem[_4714 + (32 * s + t) + 32]
            mem[_7318 + (32 * _7375) + 128 len 32 * _8203] = mem[_4714 + (32 * s + t) + 64 len 32 * _8203]
            var70001 = _8203
            return memory
              from mem[64]
               len _7318 + (32 * _7375) + (32 * _8203) + -mem[64] + 128
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _4888 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _4888 + (32 * s + t) + 32
        if not s + t:
            _5948 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _5948:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6007 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6007 + 32 len mem[_6007]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _5948 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_4714]:
                    revert with 0, 50
                mem[(32 * u) + _4714 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_4888]:
                    revert with 0, 50
                mem[(32 * u) + _4888 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5948 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _7226 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7226] = address(stor5[idx].field_0)
                mem[_7226 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _7290 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8023 = mem[_7290]
                    s = 0
                    t = u
                    while s < _8023:
                        if s >= mem[_7290]:
                            revert with 0, 50
                        if t >= mem[_4714]:
                            revert with 0, 50
                        mem[(32 * t) + _4714 + 32] = mem[(32 * s) + _7290 + 32]
                        if s >= mem[_7290 + 32]:
                            revert with 0, 50
                        if t >= mem[_4888]:
                            revert with 0, 50
                        mem[(32 * t) + _4888 + 32] = mem[(32 * s) + _7290 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _8023 = mem[_7290]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7472 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _7543 = mem[_7472]
                    require mem[_7472] <= test266151307()
                    require _7472 + mem[_7472] + 31 < _7472 + return_data.size
                    _7633 = mem[_7472 + mem[_7472]]
                    if mem[_7472 + mem[_7472]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7472 + mem[_7472]]) + 1 < 0 or _7472 + ceil32(return_data.size) + ceil32(32 * mem[_7472 + mem[_7472]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7472 + ceil32(return_data.size) + ceil32(32 * mem[_7472 + mem[_7472]]) + 1
                    mem[_7472 + ceil32(return_data.size)] = _7633
                    require _7543 + (32 * _7633) + 32 <= return_data.size
                    s = 0
                    t = _7472 + _7543 + 32
                    v = _7472 + ceil32(return_data.size) + 32
                    while s < _7633:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _8140 = mem[_7472 + 32]
                    require mem[_7472 + 32] <= test266151307()
                    require _7472 + mem[_7472 + 32] + 31 < _7472 + return_data.size
                    _8274 = mem[_7472 + mem[_7472 + 32]]
                    if mem[_7472 + mem[_7472 + 32]] > test266151307():
                        revert with 0, 65
                    _8362 = mem[64]
                    if mem[64] + ceil32(32 * mem[_7472 + mem[_7472 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7472 + mem[_7472 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_7472 + mem[_7472 + 32]]) + 1
                    mem[_8362] = _8274
                    require _8140 + (32 * _8274) + 32 <= return_data.size
                    s = 0
                    t = _7472 + _8140 + 32
                    v = _8362 + 32
                    while s < _8274:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _8879 = mem[_7472 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _8879:
                        if s >= mem[_7472 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_4714]:
                            revert with 0, 50
                        mem[(32 * t) + _4714 + 32] = mem[(32 * s) + _7472 + ceil32(return_data.size) + 32]
                        if s >= mem[_8362]:
                            revert with 0, 50
                        if t >= mem[_4888]:
                            revert with 0, 50
                        mem[(32 * t) + _4888 + 32] = mem[(32 * s) + _8362 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _8879 = mem[_7472 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _7315 = mem[64]
            mem[mem[64]] = 64
            _7360 = mem[_4714]
            mem[mem[64] + 64] = mem[_4714]
            mem[mem[64] + 96 len 32 * _7360] = mem[_4714 + 32 len 32 * _7360]
            var63001 = _7360
            var63002 = _4714 + (32 * _7360) + 32
            mem[mem[64] + 32] = (32 * _7360) + 96
            _8197 = mem[_4888]
            mem[_7315 + (32 * _7360) + 96] = mem[_4888]
            mem[_7315 + (32 * _7360) + 128 len 32 * _8197] = mem[_4888 + 32 len 32 * _8197]
            var68001 = _8197
            var68002 = _4888 + (32 * _8197) + 32
            return memory
              from mem[64]
               len _7315 + (32 * _7360) + (32 * _8197) + -mem[64] + 128
        mem[_4888 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _5950 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _5950:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6014 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6014 + 32 len mem[_6014]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _5950 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_4714]:
                revert with 0, 50
            mem[(32 * u) + _4714 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_4888]:
                revert with 0, 50
            mem[(32 * u) + _4888 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _5950 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _7231 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7231] = address(stor5[idx].field_0)
            mem[_7231 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _7291 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _8024 = mem[_7291]
                s = 0
                t = u
                while s < _8024:
                    if s >= mem[_7291]:
                        revert with 0, 50
                    if t >= mem[_4714]:
                        revert with 0, 50
                    mem[(32 * t) + _4714 + 32] = mem[(32 * s) + _7291 + 32]
                    if s >= mem[_7291 + 32]:
                        revert with 0, 50
                    if t >= mem[_4888]:
                        revert with 0, 50
                    mem[(32 * t) + _4888 + 32] = mem[(32 * s) + _7291 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _8024 = mem[_7291]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7476 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _7547 = mem[_7476]
                require mem[_7476] <= test266151307()
                require _7476 + mem[_7476] + 31 < _7476 + return_data.size
                _7634 = mem[_7476 + mem[_7476]]
                if mem[_7476 + mem[_7476]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7476 + mem[_7476]]) + 1 < 0 or _7476 + ceil32(return_data.size) + ceil32(32 * mem[_7476 + mem[_7476]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7476 + ceil32(return_data.size) + ceil32(32 * mem[_7476 + mem[_7476]]) + 1
                mem[_7476 + ceil32(return_data.size)] = _7634
                require _7547 + (32 * _7634) + 32 <= return_data.size
                s = 0
                t = _7476 + _7547 + 32
                v = _7476 + ceil32(return_data.size) + 32
                while s < _7634:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _8143 = mem[_7476 + 32]
                require mem[_7476 + 32] <= test266151307()
                require _7476 + mem[_7476 + 32] + 31 < _7476 + return_data.size
                _8276 = mem[_7476 + mem[_7476 + 32]]
                if mem[_7476 + mem[_7476 + 32]] > test266151307():
                    revert with 0, 65
                _8363 = mem[64]
                if mem[64] + ceil32(32 * mem[_7476 + mem[_7476 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7476 + mem[_7476 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_7476 + mem[_7476 + 32]]) + 1
                mem[_8363] = _8276
                require _8143 + (32 * _8276) + 32 <= return_data.size
                s = 0
                t = _7476 + _8143 + 32
                v = _8363 + 32
                while s < _8276:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _8880 = mem[_7476 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _8880:
                    if s >= mem[_7476 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_4714]:
                        revert with 0, 50
                    mem[(32 * t) + _4714 + 32] = mem[(32 * s) + _7476 + ceil32(return_data.size) + 32]
                    if s >= mem[_8363]:
                        revert with 0, 50
                    if t >= mem[_4888]:
                        revert with 0, 50
                    mem[(32 * t) + _4888 + 32] = mem[(32 * s) + _8363 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _8880 = mem[_7476 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        _7316 = mem[64]
        mem[mem[64]] = 64
        _7365 = mem[_4714]
        mem[mem[64] + 64] = mem[_4714]
        mem[mem[64] + 96 len 32 * _7365] = mem[_4714 + 32 len 32 * _7365]
        var64001 = _7365
        var64002 = _4714 + (32 * _7365) + 32
        mem[mem[64] + 32] = (32 * _7365) + 96
        _8199 = mem[_4888]
        mem[_7316 + (32 * _7365) + 96] = mem[_4888]
        mem[_7316 + (32 * _7365) + 128 len 32 * _8199] = mem[_4888 + 32 len 32 * _8199]
        var69001 = _8199
        return memory
          from mem[64]
           len _7316 + (32 * _7365) + (32 * _8199) + -mem[64] + 128
    mem[0] = sha3(ext_call.return_data[31 len 1], 10)
    mem[ceil32(return_data.size) + 224] = stor10[ext_call.return_data[31 len 1]].field_0
    idx = ceil32(return_data.size) + 224
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 192 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
    if not stor10[ext_call.return_data[31 len 1]].field_256:
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _948 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_948 + 32 len mem[_948]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _1953 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1953] = address(stor5[idx].field_0)
                mem[_1953 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _1968 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_1968]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_1968]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2052 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2092 = mem[_2052]
                require mem[_2052] <= test266151307()
                require _2052 + mem[_2052] + 31 < _2052 + return_data.size
                _2226 = mem[_2052 + mem[_2052]]
                if mem[_2052 + mem[_2052]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2052 + mem[_2052]]) + 1 < 0 or _2052 + ceil32(return_data.size) + ceil32(32 * mem[_2052 + mem[_2052]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2052 + ceil32(return_data.size) + ceil32(32 * mem[_2052 + mem[_2052]]) + 1
                mem[_2052 + ceil32(return_data.size)] = _2226
                require _2092 + (32 * _2226) + 32 <= return_data.size
                s = 0
                u = _2052 + _2092 + 32
                v = _2052 + ceil32(return_data.size) + 32
                while s < _2226:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3232 = mem[_2052 + 32]
                require mem[_2052 + 32] <= test266151307()
                require _2052 + mem[_2052 + 32] + 31 < _2052 + return_data.size
                _3261 = mem[_2052 + mem[_2052 + 32]]
                if mem[_2052 + mem[_2052 + 32]] > test266151307():
                    revert with 0, 65
                _3474 = mem[64]
                if mem[64] + ceil32(32 * mem[_2052 + mem[_2052 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2052 + mem[_2052 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2052 + mem[_2052 + 32]]) + 1
                mem[_3474] = _3261
                require _3232 + (32 * _3261) + 32 <= return_data.size
                s = 0
                u = _2052 + _3232 + 32
                v = _3474 + 32
                while s < _3261:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2052 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2052 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _1967 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2051 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2051 + (32 * s + t) + 32
                if not s + t:
                    _3074 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3074:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3164 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3164 + 32 len mem[_3164]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3074 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_1967]:
                            revert with 0, 50
                        mem[(32 * u) + _1967 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2051]:
                            revert with 0, 50
                        mem[(32 * u) + _2051 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3074 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _4675 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4675] = address(stor5[idx].field_0)
                        mem[_4675 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _4716 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _5955 = mem[_4716]
                            s = 0
                            t = u
                            while s < _5955:
                                if s >= mem[_4716]:
                                    revert with 0, 50
                                if t >= mem[_1967]:
                                    revert with 0, 50
                                mem[(32 * t) + _1967 + 32] = mem[(32 * s) + _4716 + 32]
                                if s >= mem[_4716 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2051]:
                                    revert with 0, 50
                                mem[(32 * t) + _2051 + 32] = mem[(32 * s) + _4716 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _5955 = mem[_4716]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4891 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _4965 = mem[_4891]
                            require mem[_4891] <= test266151307()
                            require _4891 + mem[_4891] + 31 < _4891 + return_data.size
                            _5102 = mem[_4891 + mem[_4891]]
                            if mem[_4891 + mem[_4891]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4891 + mem[_4891]]) + 1 < 0 or _4891 + ceil32(return_data.size) + ceil32(32 * mem[_4891 + mem[_4891]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4891 + ceil32(return_data.size) + ceil32(32 * mem[_4891 + mem[_4891]]) + 1
                            mem[_4891 + ceil32(return_data.size)] = _5102
                            require _4965 + (32 * _5102) + 32 <= return_data.size
                            s = 0
                            t = _4891 + _4965 + 32
                            v = _4891 + ceil32(return_data.size) + 32
                            while s < _5102:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6148 = mem[_4891 + 32]
                            require mem[_4891 + 32] <= test266151307()
                            require _4891 + mem[_4891 + 32] + 31 < _4891 + return_data.size
                            _6249 = mem[_4891 + mem[_4891 + 32]]
                            if mem[_4891 + mem[_4891 + 32]] > test266151307():
                                revert with 0, 65
                            _6450 = mem[64]
                            if mem[64] + ceil32(32 * mem[_4891 + mem[_4891 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4891 + mem[_4891 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_4891 + mem[_4891 + 32]]) + 1
                            mem[_6450] = _6249
                            require _6148 + (32 * _6249) + 32 <= return_data.size
                            s = 0
                            t = _4891 + _6148 + 32
                            v = _6450 + 32
                            while s < _6249:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _8027 = mem[_4891 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _8027:
                                if s >= mem[_4891 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_1967]:
                                    revert with 0, 50
                                mem[(32 * t) + _1967 + 32] = mem[(32 * s) + _4891 + ceil32(return_data.size) + 32]
                                if s >= mem[_6450]:
                                    revert with 0, 50
                                if t >= mem[_2051]:
                                    revert with 0, 50
                                mem[(32 * t) + _2051 + 32] = mem[(32 * s) + _6450 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _8027 = mem[_4891 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    _4737 = mem[64]
                    mem[mem[64]] = 64
                    _4804 = mem[_1967]
                    mem[mem[64] + 64] = mem[_1967]
                    mem[mem[64] + 96 len 32 * _4804] = mem[_1967 + 32 len 32 * _4804]
                    mem[mem[64] + 32] = (32 * _4804) + 96
                    _6191 = mem[_2051]
                    mem[_4737 + (32 * _4804) + 96] = mem[_2051]
                    mem[_4737 + (32 * _4804) + 128 len 32 * _6191] = mem[_2051 + 32 len 32 * _6191]
                    var64001 = _6191
                    var64002 = _2051 + (32 * _6191) + 32
                    return memory
                      from mem[64]
                       len _4737 + (32 * _4804) + (32 * _6191) + -mem[64] + 128
                mem[_2051 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3076 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3076:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3171 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3171 + 32 len mem[_3171]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3076 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_1967]:
                        revert with 0, 50
                    mem[(32 * u) + _1967 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2051]:
                        revert with 0, 50
                    mem[(32 * u) + _2051 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3076 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _4680 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4680] = address(stor5[idx].field_0)
                    mem[_4680 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _4717 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _5956 = mem[_4717]
                        s = 0
                        t = u
                        while s < _5956:
                            if s >= mem[_4717]:
                                revert with 0, 50
                            if t >= mem[_1967]:
                                revert with 0, 50
                            mem[(32 * t) + _1967 + 32] = mem[(32 * s) + _4717 + 32]
                            if s >= mem[_4717 + 32]:
                                revert with 0, 50
                            if t >= mem[_2051]:
                                revert with 0, 50
                            mem[(32 * t) + _2051 + 32] = mem[(32 * s) + _4717 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _5956 = mem[_4717]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4895 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _4969 = mem[_4895]
                        require mem[_4895] <= test266151307()
                        require _4895 + mem[_4895] + 31 < _4895 + return_data.size
                        _5103 = mem[_4895 + mem[_4895]]
                        if mem[_4895 + mem[_4895]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4895 + mem[_4895]]) + 1 < 0 or _4895 + ceil32(return_data.size) + ceil32(32 * mem[_4895 + mem[_4895]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4895 + ceil32(return_data.size) + ceil32(32 * mem[_4895 + mem[_4895]]) + 1
                        mem[_4895 + ceil32(return_data.size)] = _5103
                        require _4969 + (32 * _5103) + 32 <= return_data.size
                        s = 0
                        t = _4895 + _4969 + 32
                        v = _4895 + ceil32(return_data.size) + 32
                        while s < _5103:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _6151 = mem[_4895 + 32]
                        require mem[_4895 + 32] <= test266151307()
                        require _4895 + mem[_4895 + 32] + 31 < _4895 + return_data.size
                        _6251 = mem[_4895 + mem[_4895 + 32]]
                        if mem[_4895 + mem[_4895 + 32]] > test266151307():
                            revert with 0, 65
                        _6451 = mem[64]
                        if mem[64] + ceil32(32 * mem[_4895 + mem[_4895 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4895 + mem[_4895 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_4895 + mem[_4895 + 32]]) + 1
                        mem[_6451] = _6251
                        require _6151 + (32 * _6251) + 32 <= return_data.size
                        s = 0
                        t = _4895 + _6151 + 32
                        v = _6451 + 32
                        while s < _6251:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8028 = mem[_4895 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _8028:
                            if s >= mem[_4895 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_1967]:
                                revert with 0, 50
                            mem[(32 * t) + _1967 + 32] = mem[(32 * s) + _4895 + ceil32(return_data.size) + 32]
                            if s >= mem[_6451]:
                                revert with 0, 50
                            if t >= mem[_2051]:
                                revert with 0, 50
                            mem[(32 * t) + _2051 + 32] = mem[(32 * s) + _6451 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8028 = mem[_4895 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _4738 = mem[64]
                mem[mem[64]] = 64
                _4809 = mem[_1967]
                mem[mem[64] + 64] = mem[_1967]
                mem[mem[64] + 96 len 32 * _4809] = mem[_1967 + 32 len 32 * _4809]
                var60001 = _4809
                mem[mem[64] + 32] = (32 * _4809) + 96
                _6193 = mem[_2051]
                mem[_4738 + (32 * _4809) + 96] = mem[_2051]
                mem[_4738 + (32 * _4809) + 128 len 32 * _6193] = mem[_2051 + 32 len 32 * _6193]
                var65001 = _6193
                var65002 = _2051 + (32 * _6193) + 32
                return memory
                  from mem[64]
                   len _4738 + (32 * _4809) + (32 * _6193) + -mem[64] + 128
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _1967 + (64 * s + t) + 64
            if not s + t:
                _3078 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3078:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3178 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3178 + 32 len mem[_3178]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3078 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_1967]:
                        revert with 0, 50
                    mem[(32 * u) + _1967 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_1967 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _1967 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3078 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _4685 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4685] = address(stor5[idx].field_0)
                    mem[_4685 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _4718 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _5957 = mem[_4718]
                        v = 0
                        w = u
                        while v < _5957:
                            if v >= mem[_4718]:
                                revert with 0, 50
                            if w >= mem[_1967]:
                                revert with 0, 50
                            mem[(32 * w) + _1967 + 32] = mem[(32 * v) + _4718 + 32]
                            if v >= mem[_4718 + 32]:
                                revert with 0, 50
                            if w >= mem[_1967 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _1967 + (32 * s + t) + 64] = mem[(32 * v) + _4718 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _5957 = mem[_4718]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4899 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _4973 = mem[_4899]
                        require mem[_4899] <= test266151307()
                        require _4899 + mem[_4899] + 31 < _4899 + return_data.size
                        _5104 = mem[_4899 + mem[_4899]]
                        if mem[_4899 + mem[_4899]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4899 + mem[_4899]]) + 1 < 0 or _4899 + ceil32(return_data.size) + ceil32(32 * mem[_4899 + mem[_4899]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4899 + ceil32(return_data.size) + ceil32(32 * mem[_4899 + mem[_4899]]) + 1
                        mem[_4899 + ceil32(return_data.size)] = _5104
                        require _4973 + (32 * _5104) + 32 <= return_data.size
                        v = 0
                        w = _4899 + _4973 + 32
                        x = _4899 + ceil32(return_data.size) + 32
                        while v < _5104:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6154 = mem[_4899 + 32]
                        require mem[_4899 + 32] <= test266151307()
                        require _4899 + mem[_4899 + 32] + 31 < _4899 + return_data.size
                        _6253 = mem[_4899 + mem[_4899 + 32]]
                        if mem[_4899 + mem[_4899 + 32]] > test266151307():
                            revert with 0, 65
                        _6452 = mem[64]
                        if mem[64] + ceil32(32 * mem[_4899 + mem[_4899 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4899 + mem[_4899 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_4899 + mem[_4899 + 32]]) + 1
                        mem[_6452] = _6253
                        require _6154 + (32 * _6253) + 32 <= return_data.size
                        v = 0
                        w = _4899 + _6154 + 32
                        x = _6452 + 32
                        while v < _6253:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _8029 = mem[_4899 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _8029:
                            if v >= mem[_4899 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_1967]:
                                revert with 0, 50
                            mem[(32 * w) + _1967 + 32] = mem[(32 * v) + _4899 + ceil32(return_data.size) + 32]
                            if v >= mem[_6452]:
                                revert with 0, 50
                            if w >= mem[_1967 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _1967 + (32 * s + t) + 64] = mem[(32 * v) + _6452 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _8029 = mem[_4899 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _4739 = mem[64]
                mem[mem[64]] = 64
                _4814 = mem[_1967]
                mem[mem[64] + 64] = mem[_1967]
                mem[mem[64] + 96 len 32 * _4814] = mem[_1967 + 32 len 32 * _4814]
                var60001 = _4814
                mem[mem[64] + 32] = (32 * _4814) + 96
                _6195 = mem[_1967 + (32 * s + t) + 32]
                mem[_4739 + (32 * _4814) + 96] = mem[_1967 + (32 * s + t) + 32]
                mem[_4739 + (32 * _4814) + 128 len 32 * _6195] = mem[_1967 + (32 * s + t) + 64 len 32 * _6195]
                var65001 = _6195
                var65002 = _1967 + (32 * s + t) + (32 * _6195) + 64
                return memory
                  from mem[64]
                   len _4739 + (32 * _4814) + (32 * _6195) + -mem[64] + 128
            mem[_1967 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3080 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3080:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3185 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3185 + 32 len mem[_3185]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3080 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_1967]:
                    revert with 0, 50
                mem[(32 * u) + _1967 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_1967 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _1967 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3080 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _4690 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4690] = address(stor5[idx].field_0)
                mem[_4690 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _4719 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _5958 = mem[_4719]
                    v = 0
                    w = u
                    while v < _5958:
                        if v >= mem[_4719]:
                            revert with 0, 50
                        if w >= mem[_1967]:
                            revert with 0, 50
                        mem[(32 * w) + _1967 + 32] = mem[(32 * v) + _4719 + 32]
                        if v >= mem[_4719 + 32]:
                            revert with 0, 50
                        if w >= mem[_1967 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _1967 + (32 * s + t) + 64] = mem[(32 * v) + _4719 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _5958 = mem[_4719]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4903 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _4977 = mem[_4903]
                    require mem[_4903] <= test266151307()
                    require _4903 + mem[_4903] + 31 < _4903 + return_data.size
                    _5105 = mem[_4903 + mem[_4903]]
                    if mem[_4903 + mem[_4903]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4903 + mem[_4903]]) + 1 < 0 or _4903 + ceil32(return_data.size) + ceil32(32 * mem[_4903 + mem[_4903]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4903 + ceil32(return_data.size) + ceil32(32 * mem[_4903 + mem[_4903]]) + 1
                    mem[_4903 + ceil32(return_data.size)] = _5105
                    require _4977 + (32 * _5105) + 32 <= return_data.size
                    v = 0
                    w = _4903 + _4977 + 32
                    x = _4903 + ceil32(return_data.size) + 32
                    while v < _5105:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _6157 = mem[_4903 + 32]
                    require mem[_4903 + 32] <= test266151307()
                    require _4903 + mem[_4903 + 32] + 31 < _4903 + return_data.size
                    _6255 = mem[_4903 + mem[_4903 + 32]]
                    if mem[_4903 + mem[_4903 + 32]] > test266151307():
                        revert with 0, 65
                    _6453 = mem[64]
                    if mem[64] + ceil32(32 * mem[_4903 + mem[_4903 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4903 + mem[_4903 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_4903 + mem[_4903 + 32]]) + 1
                    mem[_6453] = _6255
                    require _6157 + (32 * _6255) + 32 <= return_data.size
                    v = 0
                    w = _4903 + _6157 + 32
                    x = _6453 + 32
                    while v < _6255:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8030 = mem[_4903 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _8030:
                        if v >= mem[_4903 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_1967]:
                            revert with 0, 50
                        mem[(32 * w) + _1967 + 32] = mem[(32 * v) + _4903 + ceil32(return_data.size) + 32]
                        if v >= mem[_6453]:
                            revert with 0, 50
                        if w >= mem[_1967 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _1967 + (32 * s + t) + 64] = mem[(32 * v) + _6453 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8030 = mem[_4903 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _4740 = mem[64]
            mem[mem[64]] = 64
            _4819 = mem[_1967]
            mem[mem[64] + 64] = mem[_1967]
            mem[mem[64] + 96 len 32 * _4819] = mem[_1967 + 32 len 32 * _4819]
            var61001 = _4819
            var61002 = _1967 + (32 * _4819) + 32
            mem[mem[64] + 32] = (32 * _4819) + 96
            _6197 = mem[_1967 + (32 * s + t) + 32]
            mem[_4740 + (32 * _4819) + 96] = mem[_1967 + (32 * s + t) + 32]
            mem[_4740 + (32 * _4819) + 128 len 32 * _6197] = mem[_1967 + (32 * s + t) + 64 len 32 * _6197]
            var66001 = _6197
            var66002 = _1967 + (32 * s + t) + (32 * _6197) + 64
            return memory
              from mem[64]
               len _4740 + (32 * _4819) + (32 * _6197) + -mem[64] + 128
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3193 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3193 + 32 len mem[_3193]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _4695 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4695] = address(stor5[idx].field_0)
            mem[_4695 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _4722 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_4722]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_4722]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4907 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _4982 = mem[_4907]
            require mem[_4907] <= test266151307()
            require _4907 + mem[_4907] + 31 < _4907 + return_data.size
            _5115 = mem[_4907 + mem[_4907]]
            if mem[_4907 + mem[_4907]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_4907 + mem[_4907]]) + 1 < 0 or _4907 + ceil32(return_data.size) + ceil32(32 * mem[_4907 + mem[_4907]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _4907 + ceil32(return_data.size) + ceil32(32 * mem[_4907 + mem[_4907]]) + 1
            mem[_4907 + ceil32(return_data.size)] = _5115
            require _4982 + (32 * _5115) + 32 <= return_data.size
            s = 0
            u = _4907 + _4982 + 32
            v = _4907 + ceil32(return_data.size) + 32
            while s < _5115:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _6164 = mem[_4907 + 32]
            require mem[_4907 + 32] <= test266151307()
            require _4907 + mem[_4907 + 32] + 31 < _4907 + return_data.size
            _6256 = mem[_4907 + mem[_4907 + 32]]
            if mem[_4907 + mem[_4907 + 32]] > test266151307():
                revert with 0, 65
            _6462 = mem[64]
            if mem[64] + ceil32(32 * mem[_4907 + mem[_4907 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4907 + mem[_4907 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_4907 + mem[_4907 + 32]]) + 1
            mem[_6462] = _6256
            require _6164 + (32 * _6256) + 32 <= return_data.size
            s = 0
            u = _4907 + _6164 + 32
            v = _6462 + 32
            while s < _6256:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_4907 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_4907 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _4721 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _4906 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _4906 + (32 * s + t) + 32
            if not s + t:
                _5960 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _5960:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6048 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6048 + 32 len mem[_6048]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _5960 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_4721]:
                        revert with 0, 50
                    mem[(32 * u) + _4721 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_4906]:
                        revert with 0, 50
                    mem[(32 * u) + _4906 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5960 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _7246 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7246] = address(stor5[idx].field_0)
                    mem[_7246 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _7295 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _8031 = mem[_7295]
                        s = 0
                        t = u
                        while s < _8031:
                            if s >= mem[_7295]:
                                revert with 0, 50
                            if t >= mem[_4721]:
                                revert with 0, 50
                            mem[(32 * t) + _4721 + 32] = mem[(32 * s) + _7295 + 32]
                            if s >= mem[_7295 + 32]:
                                revert with 0, 50
                            if t >= mem[_4906]:
                                revert with 0, 50
                            mem[(32 * t) + _4906 + 32] = mem[(32 * s) + _7295 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8031 = mem[_7295]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7496 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _7559 = mem[_7496]
                        require mem[_7496] <= test266151307()
                        require _7496 + mem[_7496] + 31 < _7496 + return_data.size
                        _7637 = mem[_7496 + mem[_7496]]
                        if mem[_7496 + mem[_7496]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_7496 + mem[_7496]]) + 1 < 0 or _7496 + ceil32(return_data.size) + ceil32(32 * mem[_7496 + mem[_7496]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _7496 + ceil32(return_data.size) + ceil32(32 * mem[_7496 + mem[_7496]]) + 1
                        mem[_7496 + ceil32(return_data.size)] = _7637
                        require _7559 + (32 * _7637) + 32 <= return_data.size
                        s = 0
                        t = _7496 + _7559 + 32
                        v = _7496 + ceil32(return_data.size) + 32
                        while s < _7637:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8160 = mem[_7496 + 32]
                        require mem[_7496 + 32] <= test266151307()
                        require _7496 + mem[_7496 + 32] + 31 < _7496 + return_data.size
                        _8282 = mem[_7496 + mem[_7496 + 32]]
                        if mem[_7496 + mem[_7496 + 32]] > test266151307():
                            revert with 0, 65
                        _8366 = mem[64]
                        if mem[64] + ceil32(32 * mem[_7496 + mem[_7496 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7496 + mem[_7496 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_7496 + mem[_7496 + 32]]) + 1
                        mem[_8366] = _8282
                        require _8160 + (32 * _8282) + 32 <= return_data.size
                        s = 0
                        t = _7496 + _8160 + 32
                        v = _8366 + 32
                        while s < _8282:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8883 = mem[_7496 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _8883:
                            if s >= mem[_7496 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_4721]:
                                revert with 0, 50
                            mem[(32 * t) + _4721 + 32] = mem[(32 * s) + _7496 + ceil32(return_data.size) + 32]
                            if s >= mem[_8366]:
                                revert with 0, 50
                            if t >= mem[_4906]:
                                revert with 0, 50
                            mem[(32 * t) + _4906 + 32] = mem[(32 * s) + _8366 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8883 = mem[_7496 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _7323 = mem[64]
                mem[mem[64]] = 64
                _7388 = mem[_4721]
                mem[mem[64] + 64] = mem[_4721]
                mem[mem[64] + 96 len 32 * _7388] = mem[_4721 + 32 len 32 * _7388]
                var63001 = _7388
                var63002 = _4721 + (32 * _7388) + 32
                mem[mem[64] + 32] = (32 * _7388) + 96
                _8209 = mem[_4906]
                mem[_7323 + (32 * _7388) + 96] = mem[_4906]
                mem[_7323 + (32 * _7388) + 128 len 32 * _8209] = mem[_4906 + 32 len 32 * _8209]
                var68001 = _8209
                var68002 = _4906 + (32 * _8209) + 32
                return memory
                  from mem[64]
                   len _7323 + (32 * _7388) + (32 * _8209) + -mem[64] + 128
            mem[_4906 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _5962 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _5962:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6055 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6055 + 32 len mem[_6055]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _5962 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_4721]:
                    revert with 0, 50
                mem[(32 * u) + _4721 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_4906]:
                    revert with 0, 50
                mem[(32 * u) + _4906 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5962 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _7251 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7251] = address(stor5[idx].field_0)
                mem[_7251 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _7296 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8032 = mem[_7296]
                    s = 0
                    t = u
                    while s < _8032:
                        if s >= mem[_7296]:
                            revert with 0, 50
                        if t >= mem[_4721]:
                            revert with 0, 50
                        mem[(32 * t) + _4721 + 32] = mem[(32 * s) + _7296 + 32]
                        if s >= mem[_7296 + 32]:
                            revert with 0, 50
                        if t >= mem[_4906]:
                            revert with 0, 50
                        mem[(32 * t) + _4906 + 32] = mem[(32 * s) + _7296 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _8032 = mem[_7296]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7500 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _7563 = mem[_7500]
                    require mem[_7500] <= test266151307()
                    require _7500 + mem[_7500] + 31 < _7500 + return_data.size
                    _7638 = mem[_7500 + mem[_7500]]
                    if mem[_7500 + mem[_7500]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7500 + mem[_7500]]) + 1 < 0 or _7500 + ceil32(return_data.size) + ceil32(32 * mem[_7500 + mem[_7500]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7500 + ceil32(return_data.size) + ceil32(32 * mem[_7500 + mem[_7500]]) + 1
                    mem[_7500 + ceil32(return_data.size)] = _7638
                    require _7563 + (32 * _7638) + 32 <= return_data.size
                    s = 0
                    t = _7500 + _7563 + 32
                    v = _7500 + ceil32(return_data.size) + 32
                    while s < _7638:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _8163 = mem[_7500 + 32]
                    require mem[_7500 + 32] <= test266151307()
                    require _7500 + mem[_7500 + 32] + 31 < _7500 + return_data.size
                    _8284 = mem[_7500 + mem[_7500 + 32]]
                    if mem[_7500 + mem[_7500 + 32]] > test266151307():
                        revert with 0, 65
                    _8367 = mem[64]
                    if mem[64] + ceil32(32 * mem[_7500 + mem[_7500 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7500 + mem[_7500 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_7500 + mem[_7500 + 32]]) + 1
                    mem[_8367] = _8284
                    require _8163 + (32 * _8284) + 32 <= return_data.size
                    s = 0
                    t = _7500 + _8163 + 32
                    v = _8367 + 32
                    while s < _8284:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _8884 = mem[_7500 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _8884:
                        if s >= mem[_7500 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_4721]:
                            revert with 0, 50
                        mem[(32 * t) + _4721 + 32] = mem[(32 * s) + _7500 + ceil32(return_data.size) + 32]
                        if s >= mem[_8367]:
                            revert with 0, 50
                        if t >= mem[_4906]:
                            revert with 0, 50
                        mem[(32 * t) + _4906 + 32] = mem[(32 * s) + _8367 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _8884 = mem[_7500 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _7324 = mem[64]
            mem[mem[64]] = 64
            _7393 = mem[_4721]
            mem[mem[64] + 64] = mem[_4721]
            mem[mem[64] + 96 len 32 * _7393] = mem[_4721 + 32 len 32 * _7393]
            var64001 = _7393
            var64002 = _4721 + (32 * _7393) + 32
            mem[mem[64] + 32] = (32 * _7393) + 96
            _8211 = mem[_4906]
            mem[_7324 + (32 * _7393) + 96] = mem[_4906]
            mem[_7324 + (32 * _7393) + 128 len 32 * _8211] = mem[_4906 + 32 len 32 * _8211]
            var69001 = _8211
            return memory
              from mem[64]
               len _7324 + (32 * _7393) + (32 * _8211) + -mem[64] + 128
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _4721 + (64 * s + t) + 64
        if not s + t:
            _5964 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _5964:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6062 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6062 + 32 len mem[_6062]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _5964 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_4721]:
                    revert with 0, 50
                mem[(32 * u) + _4721 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_4721 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _4721 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5964 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _7256 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7256] = address(stor5[idx].field_0)
                mem[_7256 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _7297 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8033 = mem[_7297]
                    v = 0
                    w = u
                    while v < _8033:
                        if v >= mem[_7297]:
                            revert with 0, 50
                        if w >= mem[_4721]:
                            revert with 0, 50
                        mem[(32 * w) + _4721 + 32] = mem[(32 * v) + _7297 + 32]
                        if v >= mem[_7297 + 32]:
                            revert with 0, 50
                        if w >= mem[_4721 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _4721 + (32 * s + t) + 64] = mem[(32 * v) + _7297 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8033 = mem[_7297]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7504 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _7567 = mem[_7504]
                    require mem[_7504] <= test266151307()
                    require _7504 + mem[_7504] + 31 < _7504 + return_data.size
                    _7639 = mem[_7504 + mem[_7504]]
                    if mem[_7504 + mem[_7504]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7504 + mem[_7504]]) + 1 < 0 or _7504 + ceil32(return_data.size) + ceil32(32 * mem[_7504 + mem[_7504]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7504 + ceil32(return_data.size) + ceil32(32 * mem[_7504 + mem[_7504]]) + 1
                    mem[_7504 + ceil32(return_data.size)] = _7639
                    require _7567 + (32 * _7639) + 32 <= return_data.size
                    v = 0
                    w = _7504 + _7567 + 32
                    x = _7504 + ceil32(return_data.size) + 32
                    while v < _7639:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8166 = mem[_7504 + 32]
                    require mem[_7504 + 32] <= test266151307()
                    require _7504 + mem[_7504 + 32] + 31 < _7504 + return_data.size
                    _8286 = mem[_7504 + mem[_7504 + 32]]
                    if mem[_7504 + mem[_7504 + 32]] > test266151307():
                        revert with 0, 65
                    _8368 = mem[64]
                    if mem[64] + ceil32(32 * mem[_7504 + mem[_7504 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7504 + mem[_7504 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_7504 + mem[_7504 + 32]]) + 1
                    mem[_8368] = _8286
                    require _8166 + (32 * _8286) + 32 <= return_data.size
                    v = 0
                    w = _7504 + _8166 + 32
                    x = _8368 + 32
                    while v < _8286:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8885 = mem[_7504 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _8885:
                        if v >= mem[_7504 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_4721]:
                            revert with 0, 50
                        mem[(32 * w) + _4721 + 32] = mem[(32 * v) + _7504 + ceil32(return_data.size) + 32]
                        if v >= mem[_8368]:
                            revert with 0, 50
                        if w >= mem[_4721 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _4721 + (32 * s + t) + 64] = mem[(32 * v) + _8368 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8885 = mem[_7504 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _7325 = mem[64]
            mem[mem[64]] = 64
            _7398 = mem[_4721]
            mem[mem[64] + 64] = mem[_4721]
            mem[mem[64] + 96 len 32 * _7398] = mem[_4721 + 32 len 32 * _7398]
            var64001 = _7398
            var64002 = _4721 + (32 * _7398) + 32
            mem[mem[64] + 32] = (32 * _7398) + 96
            _8213 = mem[_4721 + (32 * s + t) + 32]
            mem[_7325 + (32 * _7398) + 96] = mem[_4721 + (32 * s + t) + 32]
            mem[_7325 + (32 * _7398) + 128 len 32 * _8213] = mem[_4721 + (32 * s + t) + 64 len 32 * _8213]
            var69001 = _8213
            return memory
              from mem[64]
               len _7325 + (32 * _7398) + (32 * _8213) + -mem[64] + 128
        mem[_4721 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _5966 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _5966:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6069 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6069 + 32 len mem[_6069]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _5966 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_4721]:
                revert with 0, 50
            mem[(32 * u) + _4721 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_4721 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _4721 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _5966 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _7261 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7261] = address(stor5[idx].field_0)
            mem[_7261 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _7298 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _8034 = mem[_7298]
                v = 0
                w = u
                while v < _8034:
                    if v >= mem[_7298]:
                        revert with 0, 50
                    if w >= mem[_4721]:
                        revert with 0, 50
                    mem[(32 * w) + _4721 + 32] = mem[(32 * v) + _7298 + 32]
                    if v >= mem[_7298 + 32]:
                        revert with 0, 50
                    if w >= mem[_4721 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _4721 + (32 * s + t) + 64] = mem[(32 * v) + _7298 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _8034 = mem[_7298]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7508 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _7571 = mem[_7508]
                require mem[_7508] <= test266151307()
                require _7508 + mem[_7508] + 31 < _7508 + return_data.size
                _7640 = mem[_7508 + mem[_7508]]
                if mem[_7508 + mem[_7508]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7508 + mem[_7508]]) + 1 < 0 or _7508 + ceil32(return_data.size) + ceil32(32 * mem[_7508 + mem[_7508]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7508 + ceil32(return_data.size) + ceil32(32 * mem[_7508 + mem[_7508]]) + 1
                mem[_7508 + ceil32(return_data.size)] = _7640
                require _7571 + (32 * _7640) + 32 <= return_data.size
                v = 0
                w = _7508 + _7571 + 32
                x = _7508 + ceil32(return_data.size) + 32
                while v < _7640:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _8169 = mem[_7508 + 32]
                require mem[_7508 + 32] <= test266151307()
                require _7508 + mem[_7508 + 32] + 31 < _7508 + return_data.size
                _8288 = mem[_7508 + mem[_7508 + 32]]
                if mem[_7508 + mem[_7508 + 32]] > test266151307():
                    revert with 0, 65
                _8369 = mem[64]
                if mem[64] + ceil32(32 * mem[_7508 + mem[_7508 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7508 + mem[_7508 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_7508 + mem[_7508 + 32]]) + 1
                mem[_8369] = _8288
                require _8169 + (32 * _8288) + 32 <= return_data.size
                v = 0
                w = _7508 + _8169 + 32
                x = _8369 + 32
                while v < _8288:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _8886 = mem[_7508 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _8886:
                    if v >= mem[_7508 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_4721]:
                        revert with 0, 50
                    mem[(32 * w) + _4721 + 32] = mem[(32 * v) + _7508 + ceil32(return_data.size) + 32]
                    if v >= mem[_8369]:
                        revert with 0, 50
                    if w >= mem[_4721 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _4721 + (32 * s + t) + 64] = mem[(32 * v) + _8369 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _8886 = mem[_7508 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        _7326 = mem[64]
        mem[mem[64]] = 64
        _7403 = mem[_4721]
        mem[mem[64] + 64] = mem[_4721]
        mem[mem[64] + 96 len 32 * _7403] = mem[_4721 + 32 len 32 * _7403]
        var65001 = _7403
        var65002 = _4721 + (32 * _7403) + 32
        mem[mem[64] + 32] = (32 * _7403) + 96
        _8215 = mem[_4721 + (32 * s + t) + 32]
        mem[_7326 + (32 * _7403) + 96] = mem[_4721 + (32 * s + t) + 32]
        mem[_7326 + (32 * _7403) + 128 len 32 * _8215] = mem[_4721 + (32 * s + t) + 64 len 32 * _8215]
        var70001 = _8215
        var70002 = _4721 + (32 * s + t) + (32 * _8215) + 64
        return memory
          from mem[64]
           len _7326 + (32 * _7403) + (32 * _8215) + -mem[64] + 128
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
    mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
    if not stor10[ext_call.return_data[31 len 1]].field_512:
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3200 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3200 + 32 len mem[_3200]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _4700 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4700] = address(stor5[idx].field_0)
            mem[_4700 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _4724 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_4724]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_4724]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4909 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _4985 = mem[_4909]
            require mem[_4909] <= test266151307()
            require _4909 + mem[_4909] + 31 < _4909 + return_data.size
            _5125 = mem[_4909 + mem[_4909]]
            if mem[_4909 + mem[_4909]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_4909 + mem[_4909]]) + 1 < 0 or _4909 + ceil32(return_data.size) + ceil32(32 * mem[_4909 + mem[_4909]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _4909 + ceil32(return_data.size) + ceil32(32 * mem[_4909 + mem[_4909]]) + 1
            mem[_4909 + ceil32(return_data.size)] = _5125
            require _4985 + (32 * _5125) + 32 <= return_data.size
            s = 0
            u = _4909 + _4985 + 32
            v = _4909 + ceil32(return_data.size) + 32
            while s < _5125:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _6169 = mem[_4909 + 32]
            require mem[_4909 + 32] <= test266151307()
            require _4909 + mem[_4909 + 32] + 31 < _4909 + return_data.size
            _6257 = mem[_4909 + mem[_4909 + 32]]
            if mem[_4909 + mem[_4909 + 32]] > test266151307():
                revert with 0, 65
            _6471 = mem[64]
            if mem[64] + ceil32(32 * mem[_4909 + mem[_4909 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_4909 + mem[_4909 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_4909 + mem[_4909 + 32]]) + 1
            mem[_6471] = _6257
            require _6169 + (32 * _6257) + 32 <= return_data.size
            s = 0
            u = _4909 + _6169 + 32
            v = _6471 + 32
            while s < _6257:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_4909 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_4909 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _4723 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _4908 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _4908 + (32 * s + t) + 32
            if not s + t:
                _5968 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _5968:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6077 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6077 + 32 len mem[_6077]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _5968 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_4723]:
                        revert with 0, 50
                    mem[(32 * u) + _4723 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_4908]:
                        revert with 0, 50
                    mem[(32 * u) + _4908 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5968 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _7266 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7266] = address(stor5[idx].field_0)
                    mem[_7266 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _7300 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _8035 = mem[_7300]
                        s = 0
                        t = u
                        while s < _8035:
                            if s >= mem[_7300]:
                                revert with 0, 50
                            if t >= mem[_4723]:
                                revert with 0, 50
                            mem[(32 * t) + _4723 + 32] = mem[(32 * s) + _7300 + 32]
                            if s >= mem[_7300 + 32]:
                                revert with 0, 50
                            if t >= mem[_4908]:
                                revert with 0, 50
                            mem[(32 * t) + _4908 + 32] = mem[(32 * s) + _7300 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8035 = mem[_7300]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7512 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _7575 = mem[_7512]
                        require mem[_7512] <= test266151307()
                        require _7512 + mem[_7512] + 31 < _7512 + return_data.size
                        _7641 = mem[_7512 + mem[_7512]]
                        if mem[_7512 + mem[_7512]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_7512 + mem[_7512]]) + 1 < 0 or _7512 + ceil32(return_data.size) + ceil32(32 * mem[_7512 + mem[_7512]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _7512 + ceil32(return_data.size) + ceil32(32 * mem[_7512 + mem[_7512]]) + 1
                        mem[_7512 + ceil32(return_data.size)] = _7641
                        require _7575 + (32 * _7641) + 32 <= return_data.size
                        s = 0
                        t = _7512 + _7575 + 32
                        v = _7512 + ceil32(return_data.size) + 32
                        while s < _7641:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8172 = mem[_7512 + 32]
                        require mem[_7512 + 32] <= test266151307()
                        require _7512 + mem[_7512 + 32] + 31 < _7512 + return_data.size
                        _8290 = mem[_7512 + mem[_7512 + 32]]
                        if mem[_7512 + mem[_7512 + 32]] > test266151307():
                            revert with 0, 65
                        _8370 = mem[64]
                        if mem[64] + ceil32(32 * mem[_7512 + mem[_7512 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7512 + mem[_7512 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_7512 + mem[_7512 + 32]]) + 1
                        mem[_8370] = _8290
                        require _8172 + (32 * _8290) + 32 <= return_data.size
                        s = 0
                        t = _7512 + _8172 + 32
                        v = _8370 + 32
                        while s < _8290:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _8887 = mem[_7512 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _8887:
                            if s >= mem[_7512 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_4723]:
                                revert with 0, 50
                            mem[(32 * t) + _4723 + 32] = mem[(32 * s) + _7512 + ceil32(return_data.size) + 32]
                            if s >= mem[_8370]:
                                revert with 0, 50
                            if t >= mem[_4908]:
                                revert with 0, 50
                            mem[(32 * t) + _4908 + 32] = mem[(32 * s) + _8370 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _8887 = mem[_7512 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                _7327 = mem[64]
                mem[mem[64]] = 64
                _7408 = mem[_4723]
                mem[mem[64] + 64] = mem[_4723]
                mem[mem[64] + 96 len 32 * _7408] = mem[_4723 + 32 len 32 * _7408]
                var63001 = _7408
                var63002 = _4723 + (32 * _7408) + 32
                mem[mem[64] + 32] = (32 * _7408) + 96
                _8217 = mem[_4908]
                mem[_7327 + (32 * _7408) + 96] = mem[_4908]
                mem[_7327 + (32 * _7408) + 128 len 32 * _8217] = mem[_4908 + 32 len 32 * _8217]
                var68001 = _8217
                var68002 = _4908 + (32 * _8217) + 32
                return memory
                  from mem[64]
                   len _7327 + (32 * _7408) + (32 * _8217) + -mem[64] + 128
            mem[_4908 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _5970 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _5970:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6084 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6084 + 32 len mem[_6084]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _5970 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_4723]:
                    revert with 0, 50
                mem[(32 * u) + _4723 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_4908]:
                    revert with 0, 50
                mem[(32 * u) + _4908 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5970 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _7271 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7271] = address(stor5[idx].field_0)
                mem[_7271 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _7301 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8036 = mem[_7301]
                    s = 0
                    t = u
                    while s < _8036:
                        if s >= mem[_7301]:
                            revert with 0, 50
                        if t >= mem[_4723]:
                            revert with 0, 50
                        mem[(32 * t) + _4723 + 32] = mem[(32 * s) + _7301 + 32]
                        if s >= mem[_7301 + 32]:
                            revert with 0, 50
                        if t >= mem[_4908]:
                            revert with 0, 50
                        mem[(32 * t) + _4908 + 32] = mem[(32 * s) + _7301 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _8036 = mem[_7301]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7516 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _7579 = mem[_7516]
                    require mem[_7516] <= test266151307()
                    require _7516 + mem[_7516] + 31 < _7516 + return_data.size
                    _7642 = mem[_7516 + mem[_7516]]
                    if mem[_7516 + mem[_7516]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7516 + mem[_7516]]) + 1 < 0 or _7516 + ceil32(return_data.size) + ceil32(32 * mem[_7516 + mem[_7516]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7516 + ceil32(return_data.size) + ceil32(32 * mem[_7516 + mem[_7516]]) + 1
                    mem[_7516 + ceil32(return_data.size)] = _7642
                    require _7579 + (32 * _7642) + 32 <= return_data.size
                    s = 0
                    t = _7516 + _7579 + 32
                    v = _7516 + ceil32(return_data.size) + 32
                    while s < _7642:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _8175 = mem[_7516 + 32]
                    require mem[_7516 + 32] <= test266151307()
                    require _7516 + mem[_7516 + 32] + 31 < _7516 + return_data.size
                    _8292 = mem[_7516 + mem[_7516 + 32]]
                    if mem[_7516 + mem[_7516 + 32]] > test266151307():
                        revert with 0, 65
                    _8371 = mem[64]
                    if mem[64] + ceil32(32 * mem[_7516 + mem[_7516 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7516 + mem[_7516 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_7516 + mem[_7516 + 32]]) + 1
                    mem[_8371] = _8292
                    require _8175 + (32 * _8292) + 32 <= return_data.size
                    s = 0
                    t = _7516 + _8175 + 32
                    v = _8371 + 32
                    while s < _8292:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _8888 = mem[_7516 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _8888:
                        if s >= mem[_7516 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_4723]:
                            revert with 0, 50
                        mem[(32 * t) + _4723 + 32] = mem[(32 * s) + _7516 + ceil32(return_data.size) + 32]
                        if s >= mem[_8371]:
                            revert with 0, 50
                        if t >= mem[_4908]:
                            revert with 0, 50
                        mem[(32 * t) + _4908 + 32] = mem[(32 * s) + _8371 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _8888 = mem[_7516 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _7328 = mem[64]
            mem[mem[64]] = 64
            _7413 = mem[_4723]
            mem[mem[64] + 64] = mem[_4723]
            mem[mem[64] + 96 len 32 * _7413] = mem[_4723 + 32 len 32 * _7413]
            var64001 = _7413
            var64002 = _4723 + (32 * _7413) + 32
            mem[mem[64] + 32] = (32 * _7413) + 96
            _8219 = mem[_4908]
            mem[_7328 + (32 * _7413) + 96] = mem[_4908]
            mem[_7328 + (32 * _7413) + 128 len 32 * _8219] = mem[_4908 + 32 len 32 * _8219]
            var69001 = _8219
            return memory
              from mem[64]
               len _7328 + (32 * _7413) + (32 * _8219) + -mem[64] + 128
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _4723 + (64 * s + t) + 64
        if not s + t:
            _5972 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _5972:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6091 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6091 + 32 len mem[_6091]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _5972 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_4723]:
                    revert with 0, 50
                mem[(32 * u) + _4723 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_4723 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _4723 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5972 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _7276 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7276] = address(stor5[idx].field_0)
                mem[_7276 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _7302 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8037 = mem[_7302]
                    v = 0
                    w = u
                    while v < _8037:
                        if v >= mem[_7302]:
                            revert with 0, 50
                        if w >= mem[_4723]:
                            revert with 0, 50
                        mem[(32 * w) + _4723 + 32] = mem[(32 * v) + _7302 + 32]
                        if v >= mem[_7302 + 32]:
                            revert with 0, 50
                        if w >= mem[_4723 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _4723 + (32 * s + t) + 64] = mem[(32 * v) + _7302 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8037 = mem[_7302]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7520 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _7583 = mem[_7520]
                    require mem[_7520] <= test266151307()
                    require _7520 + mem[_7520] + 31 < _7520 + return_data.size
                    _7643 = mem[_7520 + mem[_7520]]
                    if mem[_7520 + mem[_7520]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7520 + mem[_7520]]) + 1 < 0 or _7520 + ceil32(return_data.size) + ceil32(32 * mem[_7520 + mem[_7520]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7520 + ceil32(return_data.size) + ceil32(32 * mem[_7520 + mem[_7520]]) + 1
                    mem[_7520 + ceil32(return_data.size)] = _7643
                    require _7583 + (32 * _7643) + 32 <= return_data.size
                    v = 0
                    w = _7520 + _7583 + 32
                    x = _7520 + ceil32(return_data.size) + 32
                    while v < _7643:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8178 = mem[_7520 + 32]
                    require mem[_7520 + 32] <= test266151307()
                    require _7520 + mem[_7520 + 32] + 31 < _7520 + return_data.size
                    _8294 = mem[_7520 + mem[_7520 + 32]]
                    if mem[_7520 + mem[_7520 + 32]] > test266151307():
                        revert with 0, 65
                    _8372 = mem[64]
                    if mem[64] + ceil32(32 * mem[_7520 + mem[_7520 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7520 + mem[_7520 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_7520 + mem[_7520 + 32]]) + 1
                    mem[_8372] = _8294
                    require _8178 + (32 * _8294) + 32 <= return_data.size
                    v = 0
                    w = _7520 + _8178 + 32
                    x = _8372 + 32
                    while v < _8294:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8889 = mem[_7520 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _8889:
                        if v >= mem[_7520 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_4723]:
                            revert with 0, 50
                        mem[(32 * w) + _4723 + 32] = mem[(32 * v) + _7520 + ceil32(return_data.size) + 32]
                        if v >= mem[_8372]:
                            revert with 0, 50
                        if w >= mem[_4723 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _4723 + (32 * s + t) + 64] = mem[(32 * v) + _8372 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8889 = mem[_7520 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _7329 = mem[64]
            mem[mem[64]] = 64
            _7418 = mem[_4723]
            mem[mem[64] + 64] = mem[_4723]
            mem[mem[64] + 96 len 32 * _7418] = mem[_4723 + 32 len 32 * _7418]
            var64001 = _7418
            var64002 = _4723 + (32 * _7418) + 32
            mem[mem[64] + 32] = (32 * _7418) + 96
            _8221 = mem[_4723 + (32 * s + t) + 32]
            mem[_7329 + (32 * _7418) + 96] = mem[_4723 + (32 * s + t) + 32]
            mem[_7329 + (32 * _7418) + 128 len 32 * _8221] = mem[_4723 + (32 * s + t) + 64 len 32 * _8221]
            var69001 = _8221
            return memory
              from mem[64]
               len _7329 + (32 * _7418) + (32 * _8221) + -mem[64] + 128
        mem[_4723 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _5974 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _5974:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6098 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6098 + 32 len mem[_6098]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _5974 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_4723]:
                revert with 0, 50
            mem[(32 * u) + _4723 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_4723 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _4723 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _5974 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _7281 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7281] = address(stor5[idx].field_0)
            mem[_7281 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _7303 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _8038 = mem[_7303]
                v = 0
                w = u
                while v < _8038:
                    if v >= mem[_7303]:
                        revert with 0, 50
                    if w >= mem[_4723]:
                        revert with 0, 50
                    mem[(32 * w) + _4723 + 32] = mem[(32 * v) + _7303 + 32]
                    if v >= mem[_7303 + 32]:
                        revert with 0, 50
                    if w >= mem[_4723 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _4723 + (32 * s + t) + 64] = mem[(32 * v) + _7303 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _8038 = mem[_7303]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7524 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _7587 = mem[_7524]
                require mem[_7524] <= test266151307()
                require _7524 + mem[_7524] + 31 < _7524 + return_data.size
                _7644 = mem[_7524 + mem[_7524]]
                if mem[_7524 + mem[_7524]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7524 + mem[_7524]]) + 1 < 0 or _7524 + ceil32(return_data.size) + ceil32(32 * mem[_7524 + mem[_7524]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7524 + ceil32(return_data.size) + ceil32(32 * mem[_7524 + mem[_7524]]) + 1
                mem[_7524 + ceil32(return_data.size)] = _7644
                require _7587 + (32 * _7644) + 32 <= return_data.size
                v = 0
                w = _7524 + _7587 + 32
                x = _7524 + ceil32(return_data.size) + 32
                while v < _7644:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _8181 = mem[_7524 + 32]
                require mem[_7524 + 32] <= test266151307()
                require _7524 + mem[_7524 + 32] + 31 < _7524 + return_data.size
                _8296 = mem[_7524 + mem[_7524 + 32]]
                if mem[_7524 + mem[_7524 + 32]] > test266151307():
                    revert with 0, 65
                _8373 = mem[64]
                if mem[64] + ceil32(32 * mem[_7524 + mem[_7524 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7524 + mem[_7524 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_7524 + mem[_7524 + 32]]) + 1
                mem[_8373] = _8296
                require _8181 + (32 * _8296) + 32 <= return_data.size
                v = 0
                w = _7524 + _8181 + 32
                x = _8373 + 32
                while v < _8296:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _8890 = mem[_7524 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _8890:
                    if v >= mem[_7524 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_4723]:
                        revert with 0, 50
                    mem[(32 * w) + _4723 + 32] = mem[(32 * v) + _7524 + ceil32(return_data.size) + 32]
                    if v >= mem[_8373]:
                        revert with 0, 50
                    if w >= mem[_4723 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _4723 + (32 * s + t) + 64] = mem[(32 * v) + _8373 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _8890 = mem[_7524 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        _7330 = mem[64]
        mem[mem[64]] = 64
        _7423 = mem[_4723]
        mem[mem[64] + 64] = mem[_4723]
        mem[mem[64] + 96 len 32 * _7423] = mem[_4723 + 32 len 32 * _7423]
        var65001 = _7423
        var65002 = _4723 + (32 * _7423) + 32
        mem[mem[64] + 32] = (32 * _7423) + 96
        _8223 = mem[_4723 + (32 * s + t) + 32]
        mem[_7330 + (32 * _7423) + 96] = mem[_4723 + (32 * s + t) + 32]
        mem[_7330 + (32 * _7423) + 128 len 32 * _8223] = mem[_4723 + (32 * s + t) + 64 len 32 * _8223]
        var70001 = _8223
        var70002 = _4723 + (32 * s + t) + (32 * _8223) + 64
        return memory
          from mem[64]
           len _7330 + (32 * _7423) + (32 * _8223) + -mem[64] + 128
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
    idx = 0
    s = 0
    while idx < stor10[ext_call.return_data[31 len 1]].field_512:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _6106 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_6106 + 32 len mem[_6106]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = 5
        _7286 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7286] = address(stor5[idx].field_0)
        mem[_7286 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _7306 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            if t > !mem[_7306]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_7306]
            continue 
        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg1
        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        require ext_code.size(address(stor5[idx].field_256))
        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                gas gas_remaining wei
               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _7528 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 64
        _7592 = mem[_7528]
        require mem[_7528] <= test266151307()
        require _7528 + mem[_7528] + 31 < _7528 + return_data.size
        _7654 = mem[_7528 + mem[_7528]]
        if mem[_7528 + mem[_7528]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_7528 + mem[_7528]]) + 1 < 0 or _7528 + ceil32(return_data.size) + ceil32(32 * mem[_7528 + mem[_7528]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _7528 + ceil32(return_data.size) + ceil32(32 * mem[_7528 + mem[_7528]]) + 1
        mem[_7528 + ceil32(return_data.size)] = _7654
        require _7592 + (32 * _7654) + 32 <= return_data.size
        s = 0
        u = _7528 + _7592 + 32
        v = _7528 + ceil32(return_data.size) + 32
        while s < _7654:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        _8188 = mem[_7528 + 32]
        require mem[_7528 + 32] <= test266151307()
        require _7528 + mem[_7528 + 32] + 31 < _7528 + return_data.size
        _8297 = mem[_7528 + mem[_7528 + 32]]
        if mem[_7528 + mem[_7528 + 32]] > test266151307():
            revert with 0, 65
        _8382 = mem[64]
        if mem[64] + ceil32(32 * mem[_7528 + mem[_7528 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_7528 + mem[_7528 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_7528 + mem[_7528 + 32]]) + 1
        mem[_8382] = _8297
        require _8188 + (32 * _8297) + 32 <= return_data.size
        s = 0
        u = _7528 + _8188 + 32
        v = _8382 + 32
        while s < _8297:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        if t > !mem[_7528 + ceil32(return_data.size)]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + mem[_7528 + ceil32(return_data.size)]
        continue 
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _7305 = mem[64]
    mem[mem[64]] = s + t
    if s + t:
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _7305 + (64 * s + t) + 64
        if not s + t:
            _8044 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _8044:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _8111 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_8111 + 32 len mem[_8111]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _8044 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_7305]:
                    revert with 0, 50
                mem[(32 * u) + _7305 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_7305 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _7305 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _8044 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8653 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8653] = address(stor5[idx].field_0)
                mem[_8653 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8664 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _8893 = mem[_8664]
                    v = 0
                    w = u
                    while v < _8893:
                        if v >= mem[_8664]:
                            revert with 0, 50
                        if w >= mem[_7305]:
                            revert with 0, 50
                        mem[(32 * w) + _7305 + 32] = mem[(32 * v) + _8664 + 32]
                        if v >= mem[_8664 + 32]:
                            revert with 0, 50
                        if w >= mem[_7305 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _7305 + (32 * s + t) + 64] = mem[(32 * v) + _8664 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _8893 = mem[_8664]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8788 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8808 = mem[_8788]
                    require mem[_8788] <= test266151307()
                    require _8788 + mem[_8788] + 31 < _8788 + return_data.size
                    _8821 = mem[_8788 + mem[_8788]]
                    if mem[_8788 + mem[_8788]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8788 + mem[_8788]]) + 1 < 0 or _8788 + ceil32(return_data.size) + ceil32(32 * mem[_8788 + mem[_8788]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8788 + ceil32(return_data.size) + ceil32(32 * mem[_8788 + mem[_8788]]) + 1
                    mem[_8788 + ceil32(return_data.size)] = _8821
                    require _8808 + (32 * _8821) + 32 <= return_data.size
                    v = 0
                    w = _8788 + _8808 + 32
                    x = _8788 + ceil32(return_data.size) + 32
                    while v < _8821:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _8949 = mem[_8788 + 32]
                    require mem[_8788 + 32] <= test266151307()
                    require _8788 + mem[_8788 + 32] + 31 < _8788 + return_data.size
                    _9012 = mem[_8788 + mem[_8788 + 32]]
                    if mem[_8788 + mem[_8788 + 32]] > test266151307():
                        revert with 0, 65
                    _9021 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8788 + mem[_8788 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8788 + mem[_8788 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8788 + mem[_8788 + 32]]) + 1
                    mem[_9021] = _9012
                    require _8949 + (32 * _9012) + 32 <= return_data.size
                    v = 0
                    w = _8788 + _8949 + 32
                    x = _9021 + 32
                    while v < _9012:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9097 = mem[_8788 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9097:
                        if v >= mem[_8788 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_7305]:
                            revert with 0, 50
                        mem[(32 * w) + _7305 + 32] = mem[(32 * v) + _8788 + ceil32(return_data.size) + 32]
                        if v >= mem[_9021]:
                            revert with 0, 50
                        if w >= mem[_7305 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _7305 + (32 * s + t) + 64] = mem[(32 * v) + _9021 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9097 = mem[_8788 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            _8681 = mem[64]
            mem[mem[64]] = 64
            _8729 = mem[_7305]
            mem[mem[64] + 64] = mem[_7305]
            mem[mem[64] + 96 len 32 * _8729] = mem[_7305 + 32 len 32 * _8729]
            var68001 = _8729
            var68002 = _7305 + (32 * _8729) + 32
            mem[mem[64] + 32] = (32 * _8729) + 96
            _8971 = mem[_7305 + (32 * s + t) + 32]
            mem[_8681 + (32 * _8729) + 96] = mem[_7305 + (32 * s + t) + 32]
            mem[_8681 + (32 * _8729) + 128 len 32 * _8971] = mem[_7305 + (32 * s + t) + 64 len 32 * _8971]
            var73001 = _8971
            var73002 = _7305 + (32 * s + t) + (32 * _8971) + 64
            return memory
              from mem[64]
               len _8681 + (32 * _8729) + (32 * _8971) + -mem[64] + 128
        mem[_7305 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _8046 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _8046:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _8118 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_8118 + 32 len mem[_8118]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _8046 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_7305]:
                revert with 0, 50
            mem[(32 * u) + _7305 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_7305 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _7305 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _8046 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8658 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8658] = address(stor5[idx].field_0)
            mem[_8658 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8665 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _8894 = mem[_8665]
                v = 0
                w = u
                while v < _8894:
                    if v >= mem[_8665]:
                        revert with 0, 50
                    if w >= mem[_7305]:
                        revert with 0, 50
                    mem[(32 * w) + _7305 + 32] = mem[(32 * v) + _8665 + 32]
                    if v >= mem[_8665 + 32]:
                        revert with 0, 50
                    if w >= mem[_7305 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _7305 + (32 * s + t) + 64] = mem[(32 * v) + _8665 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _8894 = mem[_8665]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8792 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8812 = mem[_8792]
                require mem[_8792] <= test266151307()
                require _8792 + mem[_8792] + 31 < _8792 + return_data.size
                _8822 = mem[_8792 + mem[_8792]]
                if mem[_8792 + mem[_8792]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8792 + mem[_8792]]) + 1 < 0 or _8792 + ceil32(return_data.size) + ceil32(32 * mem[_8792 + mem[_8792]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8792 + ceil32(return_data.size) + ceil32(32 * mem[_8792 + mem[_8792]]) + 1
                mem[_8792 + ceil32(return_data.size)] = _8822
                require _8812 + (32 * _8822) + 32 <= return_data.size
                v = 0
                w = _8792 + _8812 + 32
                x = _8792 + ceil32(return_data.size) + 32
                while v < _8822:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _8952 = mem[_8792 + 32]
                require mem[_8792 + 32] <= test266151307()
                require _8792 + mem[_8792 + 32] + 31 < _8792 + return_data.size
                _9014 = mem[_8792 + mem[_8792 + 32]]
                if mem[_8792 + mem[_8792 + 32]] > test266151307():
                    revert with 0, 65
                _9022 = mem[64]
                if mem[64] + ceil32(32 * mem[_8792 + mem[_8792 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8792 + mem[_8792 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8792 + mem[_8792 + 32]]) + 1
                mem[_9022] = _9014
                require _8952 + (32 * _9014) + 32 <= return_data.size
                v = 0
                w = _8792 + _8952 + 32
                x = _9022 + 32
                while v < _9014:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _9098 = mem[_8792 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _9098:
                    if v >= mem[_8792 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_7305]:
                        revert with 0, 50
                    mem[(32 * w) + _7305 + 32] = mem[(32 * v) + _8792 + ceil32(return_data.size) + 32]
                    if v >= mem[_9022]:
                        revert with 0, 50
                    if w >= mem[_7305 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _7305 + (32 * s + t) + 64] = mem[(32 * v) + _9022 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _9098 = mem[_8792 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        _8682 = mem[64]
        mem[mem[64]] = 64
        _8734 = mem[_7305]
        mem[mem[64] + 64] = mem[_7305]
        mem[mem[64] + 96 len 32 * _8734] = mem[_7305 + 32 len 32 * _8734]
        var69001 = _8734
        mem[mem[64] + 32] = (32 * _8734) + 96
        _8973 = mem[_7305 + (32 * s + t) + 32]
        mem[_8682 + (32 * _8734) + 96] = mem[_7305 + (32 * s + t) + 32]
        mem[_8682 + (32 * _8734) + 128 len 32 * _8973] = mem[_7305 + (32 * s + t) + 64 len 32 * _8973]
        var74001 = _8973
        var74002 = _7305 + (32 * s + t) + (32 * _8973) + 64
        return memory
          from mem[64]
           len _8682 + (32 * _8734) + (32 * _8973) + -mem[64] + 128
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _7527 = mem[64] + (32 * s + t) + 32
    mem[mem[64] + (32 * s + t) + 32] = s + t
    mem[64] = _7527 + (32 * s + t) + 32
    if not s + t:
        _8040 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _8040:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _8097 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_8097 + 32 len mem[_8097]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _8040 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_7305]:
                revert with 0, 50
            mem[(32 * u) + _7305 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_7527]:
                revert with 0, 50
            mem[(32 * u) + _7527 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _8040 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8643 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8643] = address(stor5[idx].field_0)
            mem[_8643 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8662 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _8891 = mem[_8662]
                s = 0
                t = u
                while s < _8891:
                    if s >= mem[_8662]:
                        revert with 0, 50
                    if t >= mem[_7305]:
                        revert with 0, 50
                    mem[(32 * t) + _7305 + 32] = mem[(32 * s) + _8662 + 32]
                    if s >= mem[_8662 + 32]:
                        revert with 0, 50
                    if t >= mem[_7527]:
                        revert with 0, 50
                    mem[(32 * t) + _7527 + 32] = mem[(32 * s) + _8662 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _8891 = mem[_8662]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8780 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8800 = mem[_8780]
                require mem[_8780] <= test266151307()
                require _8780 + mem[_8780] + 31 < _8780 + return_data.size
                _8819 = mem[_8780 + mem[_8780]]
                if mem[_8780 + mem[_8780]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8780 + mem[_8780]]) + 1 < 0 or _8780 + ceil32(return_data.size) + ceil32(32 * mem[_8780 + mem[_8780]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8780 + ceil32(return_data.size) + ceil32(32 * mem[_8780 + mem[_8780]]) + 1
                mem[_8780 + ceil32(return_data.size)] = _8819
                require _8800 + (32 * _8819) + 32 <= return_data.size
                s = 0
                t = _8780 + _8800 + 32
                v = _8780 + ceil32(return_data.size) + 32
                while s < _8819:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _8943 = mem[_8780 + 32]
                require mem[_8780 + 32] <= test266151307()
                require _8780 + mem[_8780 + 32] + 31 < _8780 + return_data.size
                _9008 = mem[_8780 + mem[_8780 + 32]]
                if mem[_8780 + mem[_8780 + 32]] > test266151307():
                    revert with 0, 65
                _9019 = mem[64]
                if mem[64] + ceil32(32 * mem[_8780 + mem[_8780 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8780 + mem[_8780 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8780 + mem[_8780 + 32]]) + 1
                mem[_9019] = _9008
                require _8943 + (32 * _9008) + 32 <= return_data.size
                s = 0
                t = _8780 + _8943 + 32
                v = _9019 + 32
                while s < _9008:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9095 = mem[_8780 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _9095:
                    if s >= mem[_8780 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_7305]:
                        revert with 0, 50
                    mem[(32 * t) + _7305 + 32] = mem[(32 * s) + _8780 + ceil32(return_data.size) + 32]
                    if s >= mem[_9019]:
                        revert with 0, 50
                    if t >= mem[_7527]:
                        revert with 0, 50
                    mem[(32 * t) + _7527 + 32] = mem[(32 * s) + _9019 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9095 = mem[_8780 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        _8679 = mem[64]
        mem[mem[64]] = 64
        _8719 = mem[_7305]
        mem[mem[64] + 64] = mem[_7305]
        mem[mem[64] + 96 len 32 * _8719] = mem[_7305 + 32 len 32 * _8719]
        var67001 = _8719
        var67002 = _7305 + (32 * _8719) + 32
        mem[mem[64] + 32] = (32 * _8719) + 96
        _8967 = mem[_7527]
        mem[_8679 + (32 * _8719) + 96] = mem[_7527]
        mem[_8679 + (32 * _8719) + 128 len 32 * _8967] = mem[_7527 + 32 len 32 * _8967]
        var72001 = _8967
        var72002 = _7527 + (32 * _8967) + 32
        return memory
          from mem[64]
           len _8679 + (32 * _8719) + (32 * _8967) + -mem[64] + 128
    mem[_7527 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    _8042 = mem[mem[ceil32(return_data.size) + 160]]
    idx = 0
    u = 0
    while idx < _8042:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _8104 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_8104 + 32 len mem[_8104]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            _8042 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u
            continue 
        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
            revert with 0, 50
        if u >= mem[_7305]:
            revert with 0, 50
        mem[(32 * u) + _7305 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
            revert with 0, 50
        if u >= mem[_7527]:
            revert with 0, 50
        mem[(32 * u) + _7527 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
        if u == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        _8042 = mem[mem[ceil32(return_data.size) + 160]]
        idx = idx + 1
        u = u + 1
        continue 
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        _8648 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8648] = address(stor5[idx].field_0)
        mem[_8648 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _8663 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            _8892 = mem[_8663]
            s = 0
            t = u
            while s < _8892:
                if s >= mem[_8663]:
                    revert with 0, 50
                if t >= mem[_7305]:
                    revert with 0, 50
                mem[(32 * t) + _7305 + 32] = mem[(32 * s) + _8663 + 32]
                if s >= mem[_8663 + 32]:
                    revert with 0, 50
                if t >= mem[_7527]:
                    revert with 0, 50
                mem[(32 * t) + _7527 + 32] = mem[(32 * s) + _8663 + 64]
                if t == -1:
                    revert with 0, 17
                if s == -1:
                    revert with 0, 17
                _8892 = mem[_8663]
                s = s + 1
                t = t + 1
                continue 
        else:
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8784 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _8804 = mem[_8784]
            require mem[_8784] <= test266151307()
            require _8784 + mem[_8784] + 31 < _8784 + return_data.size
            _8820 = mem[_8784 + mem[_8784]]
            if mem[_8784 + mem[_8784]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8784 + mem[_8784]]) + 1 < 0 or _8784 + ceil32(return_data.size) + ceil32(32 * mem[_8784 + mem[_8784]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8784 + ceil32(return_data.size) + ceil32(32 * mem[_8784 + mem[_8784]]) + 1
            mem[_8784 + ceil32(return_data.size)] = _8820
            require _8804 + (32 * _8820) + 32 <= return_data.size
            s = 0
            t = _8784 + _8804 + 32
            v = _8784 + ceil32(return_data.size) + 32
            while s < _8820:
                mem[v] = mem[t]
                s = s + 1
                t = t + 32
                v = v + 32
                continue 
            _8946 = mem[_8784 + 32]
            require mem[_8784 + 32] <= test266151307()
            require _8784 + mem[_8784 + 32] + 31 < _8784 + return_data.size
            _9010 = mem[_8784 + mem[_8784 + 32]]
            if mem[_8784 + mem[_8784 + 32]] > test266151307():
                revert with 0, 65
            _9020 = mem[64]
            if mem[64] + ceil32(32 * mem[_8784 + mem[_8784 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8784 + mem[_8784 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_8784 + mem[_8784 + 32]]) + 1
            mem[_9020] = _9010
            require _8946 + (32 * _9010) + 32 <= return_data.size
            s = 0
            t = _8784 + _8946 + 32
            v = _9020 + 32
            while s < _9010:
                mem[v] = mem[t]
                s = s + 1
                t = t + 32
                v = v + 32
                continue 
            _9096 = mem[_8784 + ceil32(return_data.size)]
            s = 0
            t = u
            while s < _9096:
                if s >= mem[_8784 + ceil32(return_data.size)]:
                    revert with 0, 50
                if t >= mem[_7305]:
                    revert with 0, 50
                mem[(32 * t) + _7305 + 32] = mem[(32 * s) + _8784 + ceil32(return_data.size) + 32]
                if s >= mem[_9020]:
                    revert with 0, 50
                if t >= mem[_7527]:
                    revert with 0, 50
                mem[(32 * t) + _7527 + 32] = mem[(32 * s) + _9020 + 32]
                if t == -1:
                    revert with 0, 17
                if s == -1:
                    revert with 0, 17
                _9096 = mem[_8784 + ceil32(return_data.size)]
                s = s + 1
                t = t + 1
                continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if s > !t:
        revert with 0, 17
    if u != s + t:
        revert with 0, 1
    _8680 = mem[64]
    mem[mem[64]] = 64
    _8724 = mem[_7305]
    mem[mem[64] + 64] = mem[_7305]
    mem[mem[64] + 96 len 32 * _8724] = mem[_7305 + 32 len 32 * _8724]
    var68001 = _8724
    var68002 = _7305 + (32 * _8724) + 32
    mem[mem[64] + 32] = (32 * _8724) + 96
    _8969 = mem[_7527]
    mem[_8680 + (32 * _8724) + 96] = mem[_7527]
    mem[_8680 + (32 * _8724) + 128 len 32 * _8969] = mem[_7527 + 32 len 32 * _8969]
    var73001 = _8969
    var73002 = _7527 + (32 * _8969) + 32
    return memory
      from mem[64]
       len _8680 + (32 * _8724) + (32 * _8969) + -mem[64] + 128
}

function sub_df2534dd(?) {
    require calldata.size - 4 >= 32
    if not stor1[arg1].field_512:
        mem[96] = 0
        mem[128] = 0
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[160] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[164] = 64
        mem[228] = 0
        mem[260 len 0] = None
        mem[196] = stor1[arg1].field_512
        require ext_code.size(stor9)
        staticcall stor9.0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[160 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 160
        require return_data.size >= 32
        _147 = mem[160 len 4], 0
        require mem[160 len 4], 0 <= test266151307()
        require mem[160 len 4], 0 + 191 < return_data.size + 160
        _152 = mem[mem[160 len 4], 0 + 160]
        if mem[mem[160 len 4], 0 + 160] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 161 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 161
        mem[ceil32(return_data.size) + 160] = mem[mem[160 len 4], 0 + 160]
        require _147 + (32 * _152) + 32 <= return_data.size
        mem[ceil32(return_data.size) + 192 len 32 * _152] = mem[_147 + 192 len 32 * _152]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _152
        mem[mem[64] + 64 len 32 * _152] = mem[ceil32(return_data.size) + 192 len 32 * _152]
        return Array(len=_152, data=mem[mem[64] + 64 len 32 * _152])
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    mem[0] = ext_call.return_data[31 len 1]
    mem[32] = 10
    mem[ceil32(return_data.size) + 192] = stor10[ext_call.return_data[31 len 1]].field_0
    if not stor10[ext_call.return_data[31 len 1]].field_0:
        mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
        if not stor10[ext_call.return_data[31 len 1]].field_256:
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
            mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
            if not stor10[ext_call.return_data[31 len 1]].field_512:
                mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
                idx = 0
                s = 0
                while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _131 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_131 + 32 len mem[_131]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                idx = 0
                t = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _460 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_460] = address(stor5[idx].field_0)
                    mem[_460 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _474 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        if t > !mem[_474]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + mem[_474]
                        continue 
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _502 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _514 = mem[_502]
                    require mem[_502] <= test266151307()
                    require _502 + mem[_502] + 31 < _502 + return_data.size
                    _563 = mem[_502 + mem[_502]]
                    if mem[_502 + mem[_502]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_502 + mem[_502]]) + 1 < 0 or _502 + ceil32(return_data.size) + ceil32(32 * mem[_502 + mem[_502]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _502 + ceil32(return_data.size) + ceil32(32 * mem[_502 + mem[_502]]) + 1
                    mem[_502 + ceil32(return_data.size)] = _563
                    require _514 + (32 * _563) + 32 <= return_data.size
                    s = 0
                    u = _502 + _514 + 32
                    v = _502 + ceil32(return_data.size) + 32
                    while s < _563:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    _1085 = mem[_502 + 32]
                    require mem[_502 + 32] <= test266151307()
                    require _502 + mem[_502 + 32] + 31 < _502 + return_data.size
                    _1090 = mem[_502 + mem[_502 + 32]]
                    if mem[_502 + mem[_502 + 32]] > test266151307():
                        revert with 0, 65
                    _1180 = mem[64]
                    if mem[64] + ceil32(32 * mem[_502 + mem[_502 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_502 + mem[_502 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_502 + mem[_502 + 32]]) + 1
                    mem[_1180] = _1090
                    require _1085 + (32 * _1090) + 32 <= return_data.size
                    s = 0
                    u = _502 + _1085 + 32
                    v = _1180 + 32
                    while s < _1090:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    if t > !mem[_502 + ceil32(return_data.size)]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_502 + ceil32(return_data.size)]
                    continue 
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _473 = mem[64]
                mem[mem[64]] = s + t
                if not s + t:
                    if s > !t:
                        revert with 0, 17
                    if s + t > test266151307():
                        revert with 0, 65
                    _501 = mem[64] + (32 * s + t) + 32
                    mem[mem[64] + (32 * s + t) + 32] = s + t
                    mem[64] = _501 + (32 * s + t) + 32
                    if not s + t:
                        _1017 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = 0
                        u = 0
                        while idx < _1017:
                            mem[0] = arg1
                            mem[32] = 1
                            mem[mem[64] + 32] = idx
                            mem[mem[64] + 64] = stor1[arg1].field_512
                            mem[mem[64] + 96] = stor8
                            _1032 = mem[64]
                            mem[mem[64]] = 96
                            mem[64] = mem[64] + 128
                            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                                revert with 0, 50
                            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                revert with 0, 18
                            if sha3(mem[_1032 + 32 len mem[_1032]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                u = u
                                continue 
                            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                                revert with 0, 50
                            if u >= mem[_473]:
                                revert with 0, 50
                            mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            if u >= mem[_501]:
                                revert with 0, 50
                            mem[(32 * u) + _501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if u == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u + 1
                            continue 
                        idx = 0
                        while idx < stor5.length:
                            mem[0] = 5
                            _2196 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2196] = address(stor5[idx].field_0)
                            mem[_2196 + 32] = address(stor5[idx].field_256)
                            mem[0] = address(stor5[idx].field_0)
                            mem[32] = sha3(arg1, 1) + 3
                            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                                _2231 = mem[64]
                                mem[mem[64]] = 0
                                mem[mem[64] + 32] = 0
                                mem[64] = mem[64] + 64
                                _3495 = mem[_2231]
                                s = 0
                                t = u
                                while s < _3495:
                                    if s >= mem[_2231]:
                                        revert with 0, 50
                                    if t >= mem[_473]:
                                        revert with 0, 50
                                    mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2231 + 32]
                                    if s >= mem[_2231 + 32]:
                                        revert with 0, 50
                                    if t >= mem[_501]:
                                        revert with 0, 50
                                    mem[(32 * t) + _501 + 32] = mem[(32 * s) + _2231 + 64]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            else:
                                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = arg1
                                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                require ext_code.size(address(stor5[idx].field_256))
                                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                        gas gas_remaining wei
                                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2311 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _2349 = mem[_2311]
                                require mem[_2311] <= test266151307()
                                require _2311 + mem[_2311] + 31 < _2311 + return_data.size
                                _2468 = mem[_2311 + mem[_2311]]
                                if mem[_2311 + mem[_2311]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2311 + mem[_2311]]) + 1 < 0 or _2311 + ceil32(return_data.size) + ceil32(32 * mem[_2311 + mem[_2311]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2311 + ceil32(return_data.size) + ceil32(32 * mem[_2311 + mem[_2311]]) + 1
                                mem[_2311 + ceil32(return_data.size)] = _2468
                                require _2349 + (32 * _2468) + 32 <= return_data.size
                                s = 0
                                t = _2311 + _2349 + 32
                                v = _2311 + ceil32(return_data.size) + 32
                                while s < _2468:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _3649 = mem[_2311 + 32]
                                require mem[_2311 + 32] <= test266151307()
                                require _2311 + mem[_2311 + 32] + 31 < _2311 + return_data.size
                                _3696 = mem[_2311 + mem[_2311 + 32]]
                                if mem[_2311 + mem[_2311 + 32]] > test266151307():
                                    revert with 0, 65
                                _3875 = mem[64]
                                if mem[64] + ceil32(32 * mem[_2311 + mem[_2311 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2311 + mem[_2311 + 32]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + ceil32(32 * mem[_2311 + mem[_2311 + 32]]) + 1
                                mem[_3875] = _3696
                                require _3649 + (32 * _3696) + 32 <= return_data.size
                                s = 0
                                t = _2311 + _3649 + 32
                                v = _3875 + 32
                                while s < _3696:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _6860 = mem[_2311 + ceil32(return_data.size)]
                                s = 0
                                t = u
                                while s < _6860:
                                    if s >= mem[_2311 + ceil32(return_data.size)]:
                                        revert with 0, 50
                                    if t >= mem[_473]:
                                        revert with 0, 50
                                    mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2311 + ceil32(return_data.size) + 32]
                                    if s >= mem[_3875]:
                                        revert with 0, 50
                                    if t >= mem[_501]:
                                        revert with 0, 50
                                    mem[(32 * t) + _501 + 32] = mem[(32 * s) + _3875 + 32]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    _6860 = mem[_2311 + ceil32(return_data.size)]
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if s > !t:
                            revert with 0, 17
                        if u != s + t:
                            revert with 0, 1
                        if 0 >= stor9.length:
                            revert with 0, 50
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 64
                        _2301 = mem[_473]
                        mem[mem[64] + 68] = mem[_473]
                        mem[mem[64] + 100 len 32 * _2301] = mem[_473 + 32 len 32 * _2301]
                        mem[mem[64] + 36] = stor1[arg1].field_512
                        require ext_code.size(stor9)
                        staticcall stor9.0x15d2cfca with:
                                gas gas_remaining wei
                               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2301) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3695 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3805 = mem[_3695]
                        require mem[_3695] <= test266151307()
                        require _3695 + mem[_3695] + 31 < _3695 + return_data.size
                        _3945 = mem[_3695 + mem[_3695]]
                        if mem[_3695 + mem[_3695]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3695 + mem[_3695]]) + 1 < 0 or _3695 + ceil32(return_data.size) + ceil32(32 * mem[_3695 + mem[_3695]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3695 + ceil32(return_data.size) + ceil32(32 * mem[_3695 + mem[_3695]]) + 1
                        mem[_3695 + ceil32(return_data.size)] = _3945
                        require _3805 + (32 * _3945) + 32 <= return_data.size
                        mem[_3695 + ceil32(return_data.size) + 32 len 32 * _3945] = mem[_3695 + _3805 + 32 len 32 * _3945]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _3945
                        mem[mem[64] + 64 len 32 * _3945] = mem[_3695 + ceil32(return_data.size) + 32 len 32 * _3945]
                        return Array(len=_3945, data=mem[mem[64] + 64 len 32 * _3945])
                    mem[_501 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _1019 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1019:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1039 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1039 + 32 len mem[_1039]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_473]:
                            revert with 0, 50
                        mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_501]:
                            revert with 0, 50
                        mem[(32 * u) + _501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2201 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2201] = address(stor5[idx].field_0)
                        mem[_2201 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2232 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3496 = mem[_2232]
                            s = 0
                            t = u
                            while s < _3496:
                                if s >= mem[_2232]:
                                    revert with 0, 50
                                if t >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2232 + 32]
                                if s >= mem[_2232 + 32]:
                                    revert with 0, 50
                                if t >= mem[_501]:
                                    revert with 0, 50
                                mem[(32 * t) + _501 + 32] = mem[(32 * s) + _2232 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2314 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2352 = mem[_2314]
                            require mem[_2314] <= test266151307()
                            require _2314 + mem[_2314] + 31 < _2314 + return_data.size
                            _2470 = mem[_2314 + mem[_2314]]
                            if mem[_2314 + mem[_2314]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2314 + mem[_2314]]) + 1 < 0 or _2314 + ceil32(return_data.size) + ceil32(32 * mem[_2314 + mem[_2314]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2314 + ceil32(return_data.size) + ceil32(32 * mem[_2314 + mem[_2314]]) + 1
                            mem[_2314 + ceil32(return_data.size)] = _2470
                            require _2352 + (32 * _2470) + 32 <= return_data.size
                            s = 0
                            t = _2314 + _2352 + 32
                            v = _2314 + ceil32(return_data.size) + 32
                            while s < _2470:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _3652 = mem[_2314 + 32]
                            require mem[_2314 + 32] <= test266151307()
                            require _2314 + mem[_2314 + 32] + 31 < _2314 + return_data.size
                            _3698 = mem[_2314 + mem[_2314 + 32]]
                            if mem[_2314 + mem[_2314 + 32]] > test266151307():
                                revert with 0, 65
                            _3876 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2314 + mem[_2314 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2314 + mem[_2314 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2314 + mem[_2314 + 32]]) + 1
                            mem[_3876] = _3698
                            require _3652 + (32 * _3698) + 32 <= return_data.size
                            s = 0
                            t = _2314 + _3652 + 32
                            v = _3876 + 32
                            while s < _3698:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6861 = mem[_2314 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _6861:
                                if s >= mem[_2314 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2314 + ceil32(return_data.size) + 32]
                                if s >= mem[_3876]:
                                    revert with 0, 50
                                if t >= mem[_501]:
                                    revert with 0, 50
                                mem[(32 * t) + _501 + 32] = mem[(32 * s) + _3876 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6861 = mem[_2314 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _2303 = mem[_473]
                    mem[mem[64] + 68] = mem[_473]
                    mem[mem[64] + 100 len 32 * _2303] = mem[_473 + 32 len 32 * _2303]
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(stor9)
                    staticcall stor9.0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2303) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3697 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3806 = mem[_3697]
                    require mem[_3697] <= test266151307()
                    require _3697 + mem[_3697] + 31 < _3697 + return_data.size
                    _3946 = mem[_3697 + mem[_3697]]
                    if mem[_3697 + mem[_3697]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_3697 + mem[_3697]]) + 1 < 0 or _3697 + ceil32(return_data.size) + ceil32(32 * mem[_3697 + mem[_3697]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _3697 + ceil32(return_data.size) + ceil32(32 * mem[_3697 + mem[_3697]]) + 1
                    mem[_3697 + ceil32(return_data.size)] = _3946
                    require _3806 + (32 * _3946) + 32 <= return_data.size
                    mem[_3697 + ceil32(return_data.size) + 32 len 32 * _3946] = mem[_3697 + _3806 + 32 len 32 * _3946]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _3946
                    mem[mem[64] + 64 len 32 * _3946] = mem[_3697 + ceil32(return_data.size) + 32 len 32 * _3946]
                    return Array(len=_3946, data=mem[mem[64] + 64 len 32 * _3946])
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _473 + (64 * s + t) + 64
                if not s + t:
                    _1021 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1021:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1046 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1046 + 32 len mem[_1046]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_473]:
                            revert with 0, 50
                        mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_473 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _473 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2206 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2206] = address(stor5[idx].field_0)
                        mem[_2206 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2233 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3497 = mem[_2233]
                            v = 0
                            w = u
                            while v < _3497:
                                if v >= mem[_2233]:
                                    revert with 0, 50
                                if w >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2233 + 32]
                                if v >= mem[_2233 + 32]:
                                    revert with 0, 50
                                if w >= mem[_473 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _2233 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2317 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2355 = mem[_2317]
                            require mem[_2317] <= test266151307()
                            require _2317 + mem[_2317] + 31 < _2317 + return_data.size
                            _2472 = mem[_2317 + mem[_2317]]
                            if mem[_2317 + mem[_2317]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2317 + mem[_2317]]) + 1 < 0 or _2317 + ceil32(return_data.size) + ceil32(32 * mem[_2317 + mem[_2317]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2317 + ceil32(return_data.size) + ceil32(32 * mem[_2317 + mem[_2317]]) + 1
                            mem[_2317 + ceil32(return_data.size)] = _2472
                            require _2355 + (32 * _2472) + 32 <= return_data.size
                            v = 0
                            w = _2317 + _2355 + 32
                            x = _2317 + ceil32(return_data.size) + 32
                            while v < _2472:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _3655 = mem[_2317 + 32]
                            require mem[_2317 + 32] <= test266151307()
                            require _2317 + mem[_2317 + 32] + 31 < _2317 + return_data.size
                            _3700 = mem[_2317 + mem[_2317 + 32]]
                            if mem[_2317 + mem[_2317 + 32]] > test266151307():
                                revert with 0, 65
                            _3877 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2317 + mem[_2317 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2317 + mem[_2317 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2317 + mem[_2317 + 32]]) + 1
                            mem[_3877] = _3700
                            require _3655 + (32 * _3700) + 32 <= return_data.size
                            v = 0
                            w = _2317 + _3655 + 32
                            x = _3877 + 32
                            while v < _3700:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _6862 = mem[_2317 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _6862:
                                if v >= mem[_2317 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2317 + ceil32(return_data.size) + 32]
                                if v >= mem[_3877]:
                                    revert with 0, 50
                                if w >= mem[_473 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _3877 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _6862 = mem[_2317 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _2305 = mem[_473]
                    mem[mem[64] + 68] = mem[_473]
                    mem[mem[64] + 100 len 32 * _2305] = mem[_473 + 32 len 32 * _2305]
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(stor9)
                    staticcall stor9.0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2305) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3699 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3807 = mem[_3699]
                    require mem[_3699] <= test266151307()
                    require _3699 + mem[_3699] + 31 < _3699 + return_data.size
                    _3947 = mem[_3699 + mem[_3699]]
                    if mem[_3699 + mem[_3699]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_3699 + mem[_3699]]) + 1 < 0 or _3699 + ceil32(return_data.size) + ceil32(32 * mem[_3699 + mem[_3699]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _3699 + ceil32(return_data.size) + ceil32(32 * mem[_3699 + mem[_3699]]) + 1
                    mem[_3699 + ceil32(return_data.size)] = _3947
                    require _3807 + (32 * _3947) + 32 <= return_data.size
                    mem[_3699 + ceil32(return_data.size) + 32 len 32 * _3947] = mem[_3699 + _3807 + 32 len 32 * _3947]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _3947
                    mem[mem[64] + 64 len 32 * _3947] = mem[_3699 + ceil32(return_data.size) + 32 len 32 * _3947]
                    return Array(len=_3947, data=mem[mem[64] + 64 len 32 * _3947])
                mem[_473 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _1023 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _1023:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _1053 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_1053 + 32 len mem[_1053]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_473]:
                        revert with 0, 50
                    mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_473 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _473 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _2211 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2211] = address(stor5[idx].field_0)
                    mem[_2211 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _2234 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _3498 = mem[_2234]
                        v = 0
                        w = u
                        while v < _3498:
                            if v >= mem[_2234]:
                                revert with 0, 50
                            if w >= mem[_473]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2234 + 32]
                            if v >= mem[_2234 + 32]:
                                revert with 0, 50
                            if w >= mem[_473 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _2234 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2320 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _2358 = mem[_2320]
                        require mem[_2320] <= test266151307()
                        require _2320 + mem[_2320] + 31 < _2320 + return_data.size
                        _2474 = mem[_2320 + mem[_2320]]
                        if mem[_2320 + mem[_2320]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2320 + mem[_2320]]) + 1 < 0 or _2320 + ceil32(return_data.size) + ceil32(32 * mem[_2320 + mem[_2320]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2320 + ceil32(return_data.size) + ceil32(32 * mem[_2320 + mem[_2320]]) + 1
                        mem[_2320 + ceil32(return_data.size)] = _2474
                        require _2358 + (32 * _2474) + 32 <= return_data.size
                        v = 0
                        w = _2320 + _2358 + 32
                        x = _2320 + ceil32(return_data.size) + 32
                        while v < _2474:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _3658 = mem[_2320 + 32]
                        require mem[_2320 + 32] <= test266151307()
                        require _2320 + mem[_2320 + 32] + 31 < _2320 + return_data.size
                        _3702 = mem[_2320 + mem[_2320 + 32]]
                        if mem[_2320 + mem[_2320 + 32]] > test266151307():
                            revert with 0, 65
                        _3878 = mem[64]
                        if mem[64] + ceil32(32 * mem[_2320 + mem[_2320 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2320 + mem[_2320 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_2320 + mem[_2320 + 32]]) + 1
                        mem[_3878] = _3702
                        require _3658 + (32 * _3702) + 32 <= return_data.size
                        v = 0
                        w = _2320 + _3658 + 32
                        x = _3878 + 32
                        while v < _3702:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6863 = mem[_2320 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _6863:
                            if v >= mem[_2320 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_473]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2320 + ceil32(return_data.size) + 32]
                            if v >= mem[_3878]:
                                revert with 0, 50
                            if w >= mem[_473 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _3878 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6863 = mem[_2320 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _2307 = mem[_473]
                mem[mem[64] + 68] = mem[_473]
                mem[mem[64] + 100 len 32 * _2307] = mem[_473 + 32 len 32 * _2307]
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2307) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3701 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3808 = mem[_3701]
                require mem[_3701] <= test266151307()
                require _3701 + mem[_3701] + 31 < _3701 + return_data.size
                _3948 = mem[_3701 + mem[_3701]]
                if mem[_3701 + mem[_3701]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3701 + mem[_3701]]) + 1 < 0 or _3701 + ceil32(return_data.size) + ceil32(32 * mem[_3701 + mem[_3701]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3701 + ceil32(return_data.size) + ceil32(32 * mem[_3701 + mem[_3701]]) + 1
                mem[_3701 + ceil32(return_data.size)] = _3948
                require _3808 + (32 * _3948) + 32 <= return_data.size
                mem[_3701 + ceil32(return_data.size) + 32 len 32 * _3948] = mem[_3701 + _3808 + 32 len 32 * _3948]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _3948
                mem[mem[64] + 64 len 32 * _3948] = mem[_3701 + ceil32(return_data.size) + 32 len 32 * _3948]
                return Array(len=_3948, data=mem[mem[64] + 64 len 32 * _3948])
            mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
            idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
            s = 0
            while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
                mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1061 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1061 + 32 len mem[_1061]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2216 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2216] = address(stor5[idx].field_0)
                mem[_2216 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2237 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2237]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2237]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2324 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2363 = mem[_2324]
                require mem[_2324] <= test266151307()
                require _2324 + mem[_2324] + 31 < _2324 + return_data.size
                _2484 = mem[_2324 + mem[_2324]]
                if mem[_2324 + mem[_2324]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2324 + mem[_2324]]) + 1 < 0 or _2324 + ceil32(return_data.size) + ceil32(32 * mem[_2324 + mem[_2324]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2324 + ceil32(return_data.size) + ceil32(32 * mem[_2324 + mem[_2324]]) + 1
                mem[_2324 + ceil32(return_data.size)] = _2484
                require _2363 + (32 * _2484) + 32 <= return_data.size
                s = 0
                u = _2324 + _2363 + 32
                v = _2324 + ceil32(return_data.size) + 32
                while s < _2484:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3665 = mem[_2324 + 32]
                require mem[_2324 + 32] <= test266151307()
                require _2324 + mem[_2324 + 32] + 31 < _2324 + return_data.size
                _3703 = mem[_2324 + mem[_2324 + 32]]
                if mem[_2324 + mem[_2324 + 32]] > test266151307():
                    revert with 0, 65
                _3899 = mem[64]
                if mem[64] + ceil32(32 * mem[_2324 + mem[_2324 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2324 + mem[_2324 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2324 + mem[_2324 + 32]]) + 1
                mem[_3899] = _3703
                require _3665 + (32 * _3703) + 32 <= return_data.size
                s = 0
                u = _2324 + _3665 + 32
                v = _3899 + 32
                while s < _3703:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2324 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2324 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2236 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2323 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2323 + (32 * s + t) + 32
                if not s + t:
                    _3500 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3500:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3543 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3543 + 32 len mem[_3543]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3500 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2236]:
                            revert with 0, 50
                        mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2323]:
                            revert with 0, 50
                        mem[(32 * u) + _2323 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3500 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5318] = address(stor5[idx].field_0)
                        mem[_5318 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5392 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6864 = mem[_5392]
                            s = 0
                            t = u
                            while s < _6864:
                                if s >= mem[_5392]:
                                    revert with 0, 50
                                if t >= mem[_2236]:
                                    revert with 0, 50
                                mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5392 + 32]
                                if s >= mem[_5392 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2323]:
                                    revert with 0, 50
                                mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _5392 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6864 = mem[_5392]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5580 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5653 = mem[_5580]
                            require mem[_5580] <= test266151307()
                            require _5580 + mem[_5580] + 31 < _5580 + return_data.size
                            _5797 = mem[_5580 + mem[_5580]]
                            if mem[_5580 + mem[_5580]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5580 + mem[_5580]]) + 1 < 0 or _5580 + ceil32(return_data.size) + ceil32(32 * mem[_5580 + mem[_5580]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5580 + ceil32(return_data.size) + ceil32(32 * mem[_5580 + mem[_5580]]) + 1
                            mem[_5580 + ceil32(return_data.size)] = _5797
                            require _5653 + (32 * _5797) + 32 <= return_data.size
                            s = 0
                            t = _5580 + _5653 + 32
                            v = _5580 + ceil32(return_data.size) + 32
                            while s < _5797:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7048 = mem[_5580 + 32]
                            require mem[_5580 + 32] <= test266151307()
                            require _5580 + mem[_5580 + 32] + 31 < _5580 + return_data.size
                            _7165 = mem[_5580 + mem[_5580 + 32]]
                            if mem[_5580 + mem[_5580 + 32]] > test266151307():
                                revert with 0, 65
                            _7354 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5580 + mem[_5580 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5580 + mem[_5580 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5580 + mem[_5580 + 32]]) + 1
                            mem[_7354] = _7165
                            require _7048 + (32 * _7165) + 32 <= return_data.size
                            s = 0
                            t = _5580 + _7048 + 32
                            v = _7354 + 32
                            while s < _7165:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _9356 = mem[_5580 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _9356:
                                if s >= mem[_5580 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2236]:
                                    revert with 0, 50
                                mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5580 + ceil32(return_data.size) + 32]
                                if s >= mem[_7354]:
                                    revert with 0, 50
                                if t >= mem[_2323]:
                                    revert with 0, 50
                                mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _7354 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _9356 = mem[_5580 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5544 = mem[_2236]
                    mem[mem[64] + 68] = mem[_2236]
                    mem[mem[64] + 100 len 32 * _5544] = mem[_2236 + 32 len 32 * _5544]
                    idx = _5544
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(stor9)
                    staticcall stor9.0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5544) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7164 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7280 = mem[_7164]
                    require mem[_7164] <= test266151307()
                    require _7164 + mem[_7164] + 31 < _7164 + return_data.size
                    _7430 = mem[_7164 + mem[_7164]]
                    if mem[_7164 + mem[_7164]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7164 + mem[_7164]]) + 1 < 0 or _7164 + ceil32(return_data.size) + ceil32(32 * mem[_7164 + mem[_7164]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7164 + ceil32(return_data.size) + ceil32(32 * mem[_7164 + mem[_7164]]) + 1
                    mem[_7164 + ceil32(return_data.size)] = _7430
                    require _7280 + (32 * _7430) + 32 <= return_data.size
                    mem[_7164 + ceil32(return_data.size) + 32 len 32 * _7430] = mem[_7164 + _7280 + 32 len 32 * _7430]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7430
                    mem[mem[64] + 64 len 32 * _7430] = mem[_7164 + ceil32(return_data.size) + 32 len 32 * _7430]
                    var88001 = _7430
                    var88002 = _7164 + ceil32(return_data.size) + (32 * _7430) + 32
                    return Array(len=_7430, data=mem[mem[64] + 64 len 32 * _7430])
                mem[_2323 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3502 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3502:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3550 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3550 + 32 len mem[_3550]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3502 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2236]:
                        revert with 0, 50
                    mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2323]:
                        revert with 0, 50
                    mem[(32 * u) + _2323 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3502 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5323 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5323] = address(stor5[idx].field_0)
                    mem[_5323 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5393 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6865 = mem[_5393]
                        s = 0
                        t = u
                        while s < _6865:
                            if s >= mem[_5393]:
                                revert with 0, 50
                            if t >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5393 + 32]
                            if s >= mem[_5393 + 32]:
                                revert with 0, 50
                            if t >= mem[_2323]:
                                revert with 0, 50
                            mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _5393 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6865 = mem[_5393]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5583 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5656 = mem[_5583]
                        require mem[_5583] <= test266151307()
                        require _5583 + mem[_5583] + 31 < _5583 + return_data.size
                        _5799 = mem[_5583 + mem[_5583]]
                        if mem[_5583 + mem[_5583]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5583 + mem[_5583]]) + 1 < 0 or _5583 + ceil32(return_data.size) + ceil32(32 * mem[_5583 + mem[_5583]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5583 + ceil32(return_data.size) + ceil32(32 * mem[_5583 + mem[_5583]]) + 1
                        mem[_5583 + ceil32(return_data.size)] = _5799
                        require _5656 + (32 * _5799) + 32 <= return_data.size
                        s = 0
                        t = _5583 + _5656 + 32
                        v = _5583 + ceil32(return_data.size) + 32
                        while s < _5799:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7051 = mem[_5583 + 32]
                        require mem[_5583 + 32] <= test266151307()
                        require _5583 + mem[_5583 + 32] + 31 < _5583 + return_data.size
                        _7167 = mem[_5583 + mem[_5583 + 32]]
                        if mem[_5583 + mem[_5583 + 32]] > test266151307():
                            revert with 0, 65
                        _7355 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5583 + mem[_5583 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5583 + mem[_5583 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5583 + mem[_5583 + 32]]) + 1
                        mem[_7355] = _7167
                        require _7051 + (32 * _7167) + 32 <= return_data.size
                        s = 0
                        t = _5583 + _7051 + 32
                        v = _7355 + 32
                        while s < _7167:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9357 = mem[_5583 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9357:
                            if s >= mem[_5583 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5583 + ceil32(return_data.size) + 32]
                            if s >= mem[_7355]:
                                revert with 0, 50
                            if t >= mem[_2323]:
                                revert with 0, 50
                            mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _7355 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9357 = mem[_5583 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5546 = mem[_2236]
                mem[mem[64] + 68] = mem[_2236]
                mem[mem[64] + 100 len 32 * _5546] = mem[_2236 + 32 len 32 * _5546]
                idx = _5546
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5546) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7166 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7281 = mem[_7166]
                require mem[_7166] <= test266151307()
                require _7166 + mem[_7166] + 31 < _7166 + return_data.size
                _7431 = mem[_7166 + mem[_7166]]
                if mem[_7166 + mem[_7166]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7166 + mem[_7166]]) + 1 < 0 or _7166 + ceil32(return_data.size) + ceil32(32 * mem[_7166 + mem[_7166]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7166 + ceil32(return_data.size) + ceil32(32 * mem[_7166 + mem[_7166]]) + 1
                mem[_7166 + ceil32(return_data.size)] = _7431
                require _7281 + (32 * _7431) + 32 <= return_data.size
                mem[_7166 + ceil32(return_data.size) + 32 len 32 * _7431] = mem[_7166 + _7281 + 32 len 32 * _7431]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7431
                mem[mem[64] + 64 len 32 * _7431] = mem[_7166 + ceil32(return_data.size) + 32 len 32 * _7431]
                var89001 = _7431
                var89002 = _7166 + ceil32(return_data.size) + (32 * _7431) + 32
                return Array(len=_7431, data=mem[mem[64] + 64 len 32 * _7431])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2236 + (64 * s + t) + 64
            if not s + t:
                _3504 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3504:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3557 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3557 + 32 len mem[_3557]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3504 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2236]:
                        revert with 0, 50
                    mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2236 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2236 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3504 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5328] = address(stor5[idx].field_0)
                    mem[_5328 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5394 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6866 = mem[_5394]
                        v = 0
                        w = u
                        while v < _6866:
                            if v >= mem[_5394]:
                                revert with 0, 50
                            if w >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5394 + 32]
                            if v >= mem[_5394 + 32]:
                                revert with 0, 50
                            if w >= mem[_2236 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _5394 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6866 = mem[_5394]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5586 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5659 = mem[_5586]
                        require mem[_5586] <= test266151307()
                        require _5586 + mem[_5586] + 31 < _5586 + return_data.size
                        _5801 = mem[_5586 + mem[_5586]]
                        if mem[_5586 + mem[_5586]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5586 + mem[_5586]]) + 1 < 0 or _5586 + ceil32(return_data.size) + ceil32(32 * mem[_5586 + mem[_5586]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5586 + ceil32(return_data.size) + ceil32(32 * mem[_5586 + mem[_5586]]) + 1
                        mem[_5586 + ceil32(return_data.size)] = _5801
                        require _5659 + (32 * _5801) + 32 <= return_data.size
                        v = 0
                        w = _5586 + _5659 + 32
                        x = _5586 + ceil32(return_data.size) + 32
                        while v < _5801:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7054 = mem[_5586 + 32]
                        require mem[_5586 + 32] <= test266151307()
                        require _5586 + mem[_5586 + 32] + 31 < _5586 + return_data.size
                        _7169 = mem[_5586 + mem[_5586 + 32]]
                        if mem[_5586 + mem[_5586 + 32]] > test266151307():
                            revert with 0, 65
                        _7356 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5586 + mem[_5586 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5586 + mem[_5586 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5586 + mem[_5586 + 32]]) + 1
                        mem[_7356] = _7169
                        require _7054 + (32 * _7169) + 32 <= return_data.size
                        v = 0
                        w = _5586 + _7054 + 32
                        x = _7356 + 32
                        while v < _7169:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9358 = mem[_5586 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9358:
                            if v >= mem[_5586 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5586 + ceil32(return_data.size) + 32]
                            if v >= mem[_7356]:
                                revert with 0, 50
                            if w >= mem[_2236 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _7356 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9358 = mem[_5586 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5548 = mem[_2236]
                mem[mem[64] + 68] = mem[_2236]
                mem[mem[64] + 100 len 32 * _5548] = mem[_2236 + 32 len 32 * _5548]
                idx = _5548
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5548) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7168 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7282 = mem[_7168]
                require mem[_7168] <= test266151307()
                require _7168 + mem[_7168] + 31 < _7168 + return_data.size
                _7432 = mem[_7168 + mem[_7168]]
                if mem[_7168 + mem[_7168]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7168 + mem[_7168]]) + 1 < 0 or _7168 + ceil32(return_data.size) + ceil32(32 * mem[_7168 + mem[_7168]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7168 + ceil32(return_data.size) + ceil32(32 * mem[_7168 + mem[_7168]]) + 1
                mem[_7168 + ceil32(return_data.size)] = _7432
                require _7282 + (32 * _7432) + 32 <= return_data.size
                mem[_7168 + ceil32(return_data.size) + 32 len 32 * _7432] = mem[_7168 + _7282 + 32 len 32 * _7432]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7432
                mem[mem[64] + 64 len 32 * _7432] = mem[_7168 + ceil32(return_data.size) + 32 len 32 * _7432]
                var89001 = _7432
                var89002 = _7168 + ceil32(return_data.size) + (32 * _7432) + 32
                return Array(len=_7432, data=mem[mem[64] + 64 len 32 * _7432])
            mem[_2236 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3506 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3506:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3564 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3564 + 32 len mem[_3564]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3506 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2236]:
                    revert with 0, 50
                mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2236 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2236 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3506 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5333 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5333] = address(stor5[idx].field_0)
                mem[_5333 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5395 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6867 = mem[_5395]
                    v = 0
                    w = u
                    while v < _6867:
                        if v >= mem[_5395]:
                            revert with 0, 50
                        if w >= mem[_2236]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5395 + 32]
                        if v >= mem[_5395 + 32]:
                            revert with 0, 50
                        if w >= mem[_2236 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _5395 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _6867 = mem[_5395]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5589 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5662 = mem[_5589]
                    require mem[_5589] <= test266151307()
                    require _5589 + mem[_5589] + 31 < _5589 + return_data.size
                    _5803 = mem[_5589 + mem[_5589]]
                    if mem[_5589 + mem[_5589]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5589 + mem[_5589]]) + 1 < 0 or _5589 + ceil32(return_data.size) + ceil32(32 * mem[_5589 + mem[_5589]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5589 + ceil32(return_data.size) + ceil32(32 * mem[_5589 + mem[_5589]]) + 1
                    mem[_5589 + ceil32(return_data.size)] = _5803
                    require _5662 + (32 * _5803) + 32 <= return_data.size
                    v = 0
                    w = _5589 + _5662 + 32
                    x = _5589 + ceil32(return_data.size) + 32
                    while v < _5803:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _7057 = mem[_5589 + 32]
                    require mem[_5589 + 32] <= test266151307()
                    require _5589 + mem[_5589 + 32] + 31 < _5589 + return_data.size
                    _7171 = mem[_5589 + mem[_5589 + 32]]
                    if mem[_5589 + mem[_5589 + 32]] > test266151307():
                        revert with 0, 65
                    _7357 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5589 + mem[_5589 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5589 + mem[_5589 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5589 + mem[_5589 + 32]]) + 1
                    mem[_7357] = _7171
                    require _7057 + (32 * _7171) + 32 <= return_data.size
                    v = 0
                    w = _5589 + _7057 + 32
                    x = _7357 + 32
                    while v < _7171:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9359 = mem[_5589 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9359:
                        if v >= mem[_5589 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2236]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5589 + ceil32(return_data.size) + 32]
                        if v >= mem[_7357]:
                            revert with 0, 50
                        if w >= mem[_2236 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _7357 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9359 = mem[_5589 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5550 = mem[_2236]
            mem[mem[64] + 68] = mem[_2236]
            mem[mem[64] + 100 len 32 * _5550] = mem[_2236 + 32 len 32 * _5550]
            idx = _5550
            var63002 = _2236 + (32 * _5550) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5550) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7170 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7283 = mem[_7170]
            require mem[_7170] <= test266151307()
            require _7170 + mem[_7170] + 31 < _7170 + return_data.size
            _7433 = mem[_7170 + mem[_7170]]
            if mem[_7170 + mem[_7170]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7170 + mem[_7170]]) + 1 < 0 or _7170 + ceil32(return_data.size) + ceil32(32 * mem[_7170 + mem[_7170]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7170 + ceil32(return_data.size) + ceil32(32 * mem[_7170 + mem[_7170]]) + 1
            mem[_7170 + ceil32(return_data.size)] = _7433
            require _7283 + (32 * _7433) + 32 <= return_data.size
            mem[_7170 + ceil32(return_data.size) + 32 len 32 * _7433] = mem[_7170 + _7283 + 32 len 32 * _7433]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7433
            mem[mem[64] + 64 len 32 * _7433] = mem[_7170 + ceil32(return_data.size) + 32 len 32 * _7433]
            var90001 = _7433
            var90002 = _7170 + ceil32(return_data.size) + (32 * _7433) + 32
            return Array(len=_7433, data=mem[mem[64] + 64 len 32 * _7433])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1068 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1068 + 32 len mem[_1068]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2221 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2221] = address(stor5[idx].field_0)
                mem[_2221 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2239 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2239]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2239]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2326 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2366 = mem[_2326]
                require mem[_2326] <= test266151307()
                require _2326 + mem[_2326] + 31 < _2326 + return_data.size
                _2494 = mem[_2326 + mem[_2326]]
                if mem[_2326 + mem[_2326]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2326 + mem[_2326]]) + 1 < 0 or _2326 + ceil32(return_data.size) + ceil32(32 * mem[_2326 + mem[_2326]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2326 + ceil32(return_data.size) + ceil32(32 * mem[_2326 + mem[_2326]]) + 1
                mem[_2326 + ceil32(return_data.size)] = _2494
                require _2366 + (32 * _2494) + 32 <= return_data.size
                s = 0
                u = _2326 + _2366 + 32
                v = _2326 + ceil32(return_data.size) + 32
                while s < _2494:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3670 = mem[_2326 + 32]
                require mem[_2326 + 32] <= test266151307()
                require _2326 + mem[_2326 + 32] + 31 < _2326 + return_data.size
                _3704 = mem[_2326 + mem[_2326 + 32]]
                if mem[_2326 + mem[_2326 + 32]] > test266151307():
                    revert with 0, 65
                _3920 = mem[64]
                if mem[64] + ceil32(32 * mem[_2326 + mem[_2326 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2326 + mem[_2326 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2326 + mem[_2326 + 32]]) + 1
                mem[_3920] = _3704
                require _3670 + (32 * _3704) + 32 <= return_data.size
                s = 0
                u = _2326 + _3670 + 32
                v = _3920 + 32
                while s < _3704:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2326 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2326 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2238 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2238 + (64 * s + t) + 64
                if not s + t:
                    _3512 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3512:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3586 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3586 + 32 len mem[_3586]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3512 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2238]:
                            revert with 0, 50
                        mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2238 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2238 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3512 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5348 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5348] = address(stor5[idx].field_0)
                        mem[_5348 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5399 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6870 = mem[_5399]
                            v = 0
                            w = u
                            while v < _6870:
                                if v >= mem[_5399]:
                                    revert with 0, 50
                                if w >= mem[_2238]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5399 + 32]
                                if v >= mem[_5399 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2238 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _5399 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _6870 = mem[_5399]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5598 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5671 = mem[_5598]
                            require mem[_5598] <= test266151307()
                            require _5598 + mem[_5598] + 31 < _5598 + return_data.size
                            _5809 = mem[_5598 + mem[_5598]]
                            if mem[_5598 + mem[_5598]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5598 + mem[_5598]]) + 1 < 0 or _5598 + ceil32(return_data.size) + ceil32(32 * mem[_5598 + mem[_5598]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5598 + ceil32(return_data.size) + ceil32(32 * mem[_5598 + mem[_5598]]) + 1
                            mem[_5598 + ceil32(return_data.size)] = _5809
                            require _5671 + (32 * _5809) + 32 <= return_data.size
                            v = 0
                            w = _5598 + _5671 + 32
                            x = _5598 + ceil32(return_data.size) + 32
                            while v < _5809:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7066 = mem[_5598 + 32]
                            require mem[_5598 + 32] <= test266151307()
                            require _5598 + mem[_5598 + 32] + 31 < _5598 + return_data.size
                            _7177 = mem[_5598 + mem[_5598 + 32]]
                            if mem[_5598 + mem[_5598 + 32]] > test266151307():
                                revert with 0, 65
                            _7360 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5598 + mem[_5598 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5598 + mem[_5598 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5598 + mem[_5598 + 32]]) + 1
                            mem[_7360] = _7177
                            require _7066 + (32 * _7177) + 32 <= return_data.size
                            v = 0
                            w = _5598 + _7066 + 32
                            x = _7360 + 32
                            while v < _7177:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _9362 = mem[_5598 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _9362:
                                if v >= mem[_5598 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2238]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5598 + ceil32(return_data.size) + 32]
                                if v >= mem[_7360]:
                                    revert with 0, 50
                                if w >= mem[_2238 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _7360 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _9362 = mem[_5598 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5556 = mem[_2238]
                    mem[mem[64] + 68] = mem[_2238]
                    mem[mem[64] + 100 len 32 * _5556] = mem[_2238 + 32 len 32 * _5556]
                    idx = _5556
                    var62002 = _2238 + (32 * _5556) + 32
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(stor9)
                    staticcall stor9.0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5556) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7176 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7286 = mem[_7176]
                    require mem[_7176] <= test266151307()
                    require _7176 + mem[_7176] + 31 < _7176 + return_data.size
                    _7436 = mem[_7176 + mem[_7176]]
                    if mem[_7176 + mem[_7176]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7176 + mem[_7176]]) + 1 < 0 or _7176 + ceil32(return_data.size) + ceil32(32 * mem[_7176 + mem[_7176]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7176 + ceil32(return_data.size) + ceil32(32 * mem[_7176 + mem[_7176]]) + 1
                    mem[_7176 + ceil32(return_data.size)] = _7436
                    require _7286 + (32 * _7436) + 32 <= return_data.size
                    mem[_7176 + ceil32(return_data.size) + 32 len 32 * _7436] = mem[_7176 + _7286 + 32 len 32 * _7436]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7436
                    mem[mem[64] + 64 len 32 * _7436] = mem[_7176 + ceil32(return_data.size) + 32 len 32 * _7436]
                    var89001 = _7436
                    var89002 = _7176 + ceil32(return_data.size) + (32 * _7436) + 32
                    return Array(len=_7436, data=mem[mem[64] + 64 len 32 * _7436])
                mem[_2238 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3514 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3514:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3593 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3593 + 32 len mem[_3593]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3514 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2238]:
                        revert with 0, 50
                    mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2238 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2238 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3514 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5353 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5353] = address(stor5[idx].field_0)
                    mem[_5353 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5400 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6871 = mem[_5400]
                        v = 0
                        w = u
                        while v < _6871:
                            if v >= mem[_5400]:
                                revert with 0, 50
                            if w >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5400 + 32]
                            if v >= mem[_5400 + 32]:
                                revert with 0, 50
                            if w >= mem[_2238 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _5400 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6871 = mem[_5400]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5601 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5674 = mem[_5601]
                        require mem[_5601] <= test266151307()
                        require _5601 + mem[_5601] + 31 < _5601 + return_data.size
                        _5811 = mem[_5601 + mem[_5601]]
                        if mem[_5601 + mem[_5601]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5601 + mem[_5601]]) + 1 < 0 or _5601 + ceil32(return_data.size) + ceil32(32 * mem[_5601 + mem[_5601]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5601 + ceil32(return_data.size) + ceil32(32 * mem[_5601 + mem[_5601]]) + 1
                        mem[_5601 + ceil32(return_data.size)] = _5811
                        require _5674 + (32 * _5811) + 32 <= return_data.size
                        v = 0
                        w = _5601 + _5674 + 32
                        x = _5601 + ceil32(return_data.size) + 32
                        while v < _5811:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7069 = mem[_5601 + 32]
                        require mem[_5601 + 32] <= test266151307()
                        require _5601 + mem[_5601 + 32] + 31 < _5601 + return_data.size
                        _7179 = mem[_5601 + mem[_5601 + 32]]
                        if mem[_5601 + mem[_5601 + 32]] > test266151307():
                            revert with 0, 65
                        _7361 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5601 + mem[_5601 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5601 + mem[_5601 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5601 + mem[_5601 + 32]]) + 1
                        mem[_7361] = _7179
                        require _7069 + (32 * _7179) + 32 <= return_data.size
                        v = 0
                        w = _5601 + _7069 + 32
                        x = _7361 + 32
                        while v < _7179:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9363 = mem[_5601 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9363:
                            if v >= mem[_5601 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5601 + ceil32(return_data.size) + 32]
                            if v >= mem[_7361]:
                                revert with 0, 50
                            if w >= mem[_2238 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _7361 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9363 = mem[_5601 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5558 = mem[_2238]
                mem[mem[64] + 68] = mem[_2238]
                mem[mem[64] + 100 len 32 * _5558] = mem[_2238 + 32 len 32 * _5558]
                idx = _5558
                var63002 = _2238 + (32 * _5558) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5558) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7178 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7287 = mem[_7178]
                require mem[_7178] <= test266151307()
                require _7178 + mem[_7178] + 31 < _7178 + return_data.size
                _7437 = mem[_7178 + mem[_7178]]
                if mem[_7178 + mem[_7178]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7178 + mem[_7178]]) + 1 < 0 or _7178 + ceil32(return_data.size) + ceil32(32 * mem[_7178 + mem[_7178]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7178 + ceil32(return_data.size) + ceil32(32 * mem[_7178 + mem[_7178]]) + 1
                mem[_7178 + ceil32(return_data.size)] = _7437
                require _7287 + (32 * _7437) + 32 <= return_data.size
                mem[_7178 + ceil32(return_data.size) + 32 len 32 * _7437] = mem[_7178 + _7287 + 32 len 32 * _7437]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7437
                mem[mem[64] + 64 len 32 * _7437] = mem[_7178 + ceil32(return_data.size) + 32 len 32 * _7437]
                var90001 = _7437
                var90002 = _7178 + ceil32(return_data.size) + (32 * _7437) + 32
                return Array(len=_7437, data=mem[mem[64] + 64 len 32 * _7437])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2325 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2325 + (32 * s + t) + 32
            if s + t:
                mem[_2325 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3510 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3510:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3579 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3579 + 32 len mem[_3579]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3510 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2238]:
                        revert with 0, 50
                    mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2325]:
                        revert with 0, 50
                    mem[(32 * u) + _2325 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3510 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5343] = address(stor5[idx].field_0)
                    mem[_5343 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5398 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6869 = mem[_5398]
                        s = 0
                        t = u
                        while s < _6869:
                            if s >= mem[_5398]:
                                revert with 0, 50
                            if t >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5398 + 32]
                            if s >= mem[_5398 + 32]:
                                revert with 0, 50
                            if t >= mem[_2325]:
                                revert with 0, 50
                            mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _5398 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6869 = mem[_5398]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5595 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5668 = mem[_5595]
                        require mem[_5595] <= test266151307()
                        require _5595 + mem[_5595] + 31 < _5595 + return_data.size
                        _5807 = mem[_5595 + mem[_5595]]
                        if mem[_5595 + mem[_5595]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5595 + mem[_5595]]) + 1 < 0 or _5595 + ceil32(return_data.size) + ceil32(32 * mem[_5595 + mem[_5595]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5595 + ceil32(return_data.size) + ceil32(32 * mem[_5595 + mem[_5595]]) + 1
                        mem[_5595 + ceil32(return_data.size)] = _5807
                        require _5668 + (32 * _5807) + 32 <= return_data.size
                        s = 0
                        t = _5595 + _5668 + 32
                        v = _5595 + ceil32(return_data.size) + 32
                        while s < _5807:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7063 = mem[_5595 + 32]
                        require mem[_5595 + 32] <= test266151307()
                        require _5595 + mem[_5595 + 32] + 31 < _5595 + return_data.size
                        _7175 = mem[_5595 + mem[_5595 + 32]]
                        if mem[_5595 + mem[_5595 + 32]] > test266151307():
                            revert with 0, 65
                        _7359 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5595 + mem[_5595 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5595 + mem[_5595 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5595 + mem[_5595 + 32]]) + 1
                        mem[_7359] = _7175
                        require _7063 + (32 * _7175) + 32 <= return_data.size
                        s = 0
                        t = _5595 + _7063 + 32
                        v = _7359 + 32
                        while s < _7175:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9361 = mem[_5595 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9361:
                            if s >= mem[_5595 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5595 + ceil32(return_data.size) + 32]
                            if s >= mem[_7359]:
                                revert with 0, 50
                            if t >= mem[_2325]:
                                revert with 0, 50
                            mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _7359 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9361 = mem[_5595 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5554 = mem[_2238]
                mem[mem[64] + 68] = mem[_2238]
                mem[mem[64] + 100 len 32 * _5554] = mem[_2238 + 32 len 32 * _5554]
                idx = _5554
                var62002 = _2238 + (32 * _5554) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5554) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7174 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7285 = mem[_7174]
                require mem[_7174] <= test266151307()
                require _7174 + mem[_7174] + 31 < _7174 + return_data.size
                _7435 = mem[_7174 + mem[_7174]]
                if mem[_7174 + mem[_7174]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7174 + mem[_7174]]) + 1 < 0 or _7174 + ceil32(return_data.size) + ceil32(32 * mem[_7174 + mem[_7174]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7174 + ceil32(return_data.size) + ceil32(32 * mem[_7174 + mem[_7174]]) + 1
                mem[_7174 + ceil32(return_data.size)] = _7435
                require _7285 + (32 * _7435) + 32 <= return_data.size
                mem[_7174 + ceil32(return_data.size) + 32 len 32 * _7435] = mem[_7174 + _7285 + 32 len 32 * _7435]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7435
                mem[mem[64] + 64 len 32 * _7435] = mem[_7174 + ceil32(return_data.size) + 32 len 32 * _7435]
                var89001 = _7435
                var89002 = _7174 + ceil32(return_data.size) + (32 * _7435) + 32
                return Array(len=_7435, data=mem[mem[64] + 64 len 32 * _7435])
            _3508 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3508:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3572 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3572 + 32 len mem[_3572]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3508 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2238]:
                    revert with 0, 50
                mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2325]:
                    revert with 0, 50
                mem[(32 * u) + _2325 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3508 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5338 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5338] = address(stor5[idx].field_0)
                mem[_5338 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5397 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6868 = mem[_5397]
                    s = 0
                    t = u
                    while s < _6868:
                        if s >= mem[_5397]:
                            revert with 0, 50
                        if t >= mem[_2238]:
                            revert with 0, 50
                        mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5397 + 32]
                        if s >= mem[_5397 + 32]:
                            revert with 0, 50
                        if t >= mem[_2325]:
                            revert with 0, 50
                        mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _5397 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _6868 = mem[_5397]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5592 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5665 = mem[_5592]
                    require mem[_5592] <= test266151307()
                    require _5592 + mem[_5592] + 31 < _5592 + return_data.size
                    _5805 = mem[_5592 + mem[_5592]]
                    if mem[_5592 + mem[_5592]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5592 + mem[_5592]]) + 1 < 0 or _5592 + ceil32(return_data.size) + ceil32(32 * mem[_5592 + mem[_5592]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5592 + ceil32(return_data.size) + ceil32(32 * mem[_5592 + mem[_5592]]) + 1
                    mem[_5592 + ceil32(return_data.size)] = _5805
                    require _5665 + (32 * _5805) + 32 <= return_data.size
                    s = 0
                    t = _5592 + _5665 + 32
                    v = _5592 + ceil32(return_data.size) + 32
                    while s < _5805:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _7060 = mem[_5592 + 32]
                    require mem[_5592 + 32] <= test266151307()
                    require _5592 + mem[_5592 + 32] + 31 < _5592 + return_data.size
                    _7173 = mem[_5592 + mem[_5592 + 32]]
                    if mem[_5592 + mem[_5592 + 32]] > test266151307():
                        revert with 0, 65
                    _7358 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5592 + mem[_5592 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5592 + mem[_5592 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5592 + mem[_5592 + 32]]) + 1
                    mem[_7358] = _7173
                    require _7060 + (32 * _7173) + 32 <= return_data.size
                    s = 0
                    t = _5592 + _7060 + 32
                    v = _7358 + 32
                    while s < _7173:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9360 = mem[_5592 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _9360:
                        if s >= mem[_5592 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2238]:
                            revert with 0, 50
                        mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5592 + ceil32(return_data.size) + 32]
                        if s >= mem[_7358]:
                            revert with 0, 50
                        if t >= mem[_2325]:
                            revert with 0, 50
                        mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _7358 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9360 = mem[_5592 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5552 = mem[_2238]
            mem[mem[64] + 68] = mem[_2238]
            mem[mem[64] + 100 len 32 * _5552] = mem[_2238 + 32 len 32 * _5552]
            idx = _5552
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5552) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7172 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7284 = mem[_7172]
            require mem[_7172] <= test266151307()
            require _7172 + mem[_7172] + 31 < _7172 + return_data.size
            _7434 = mem[_7172 + mem[_7172]]
            if mem[_7172 + mem[_7172]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7172 + mem[_7172]]) + 1 < 0 or _7172 + ceil32(return_data.size) + ceil32(32 * mem[_7172 + mem[_7172]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7172 + ceil32(return_data.size) + ceil32(32 * mem[_7172 + mem[_7172]]) + 1
            mem[_7172 + ceil32(return_data.size)] = _7434
            require _7284 + (32 * _7434) + 32 <= return_data.size
            mem[_7172 + ceil32(return_data.size) + 32 len 32 * _7434] = mem[_7172 + _7284 + 32 len 32 * _7434]
            var80001 = _7434
            var80002 = _7172 + _7284 + (32 * _7434) + 32
            var80004 = _7172 + ceil32(return_data.size) + (32 * _7434) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7434
            mem[mem[64] + 64 len 32 * _7434] = mem[_7172 + ceil32(return_data.size) + 32 len 32 * _7434]
            var88001 = _7434
            var88002 = _7172 + ceil32(return_data.size) + (32 * _7434) + 32
            return Array(len=_7434, data=mem[mem[64] + 64 len 32 * _7434])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3601 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3601 + 32 len mem[_3601]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5358 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5358] = address(stor5[idx].field_0)
            mem[_5358 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5403 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5403]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5403]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5605 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5679 = mem[_5605]
            require mem[_5605] <= test266151307()
            require _5605 + mem[_5605] + 31 < _5605 + return_data.size
            _5821 = mem[_5605 + mem[_5605]]
            if mem[_5605 + mem[_5605]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5605 + mem[_5605]]) + 1 < 0 or _5605 + ceil32(return_data.size) + ceil32(32 * mem[_5605 + mem[_5605]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5605 + ceil32(return_data.size) + ceil32(32 * mem[_5605 + mem[_5605]]) + 1
            mem[_5605 + ceil32(return_data.size)] = _5821
            require _5679 + (32 * _5821) + 32 <= return_data.size
            s = 0
            u = _5605 + _5679 + 32
            v = _5605 + ceil32(return_data.size) + 32
            while s < _5821:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7076 = mem[_5605 + 32]
            require mem[_5605 + 32] <= test266151307()
            require _5605 + mem[_5605 + 32] + 31 < _5605 + return_data.size
            _7180 = mem[_5605 + mem[_5605 + 32]]
            if mem[_5605 + mem[_5605 + 32]] > test266151307():
                revert with 0, 65
            _7382 = mem[64]
            if mem[64] + ceil32(32 * mem[_5605 + mem[_5605 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5605 + mem[_5605 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5605 + mem[_5605 + 32]]) + 1
            mem[_7382] = _7180
            require _7076 + (32 * _7180) + 32 <= return_data.size
            s = 0
            u = _5605 + _7076 + 32
            v = _7382 + 32
            while s < _7180:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5605 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5605 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5402 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _5604 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5604 + (32 * s + t) + 32
            if not s + t:
                _6873 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6873:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6936 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6936 + 32 len mem[_6936]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6873 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5402]:
                        revert with 0, 50
                    mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5604]:
                        revert with 0, 50
                    mem[(32 * u) + _5604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6873 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8383] = address(stor5[idx].field_0)
                    mem[_8383 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8451 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9364 = mem[_8451]
                        s = 0
                        t = u
                        while s < _9364:
                            if s >= mem[_8451]:
                                revert with 0, 50
                            if t >= mem[_5402]:
                                revert with 0, 50
                            mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8451 + 32]
                            if s >= mem[_8451 + 32]:
                                revert with 0, 50
                            if t >= mem[_5604]:
                                revert with 0, 50
                            mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _8451 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9364 = mem[_8451]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8688 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8763 = mem[_8688]
                        require mem[_8688] <= test266151307()
                        require _8688 + mem[_8688] + 31 < _8688 + return_data.size
                        _8843 = mem[_8688 + mem[_8688]]
                        if mem[_8688 + mem[_8688]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8688 + mem[_8688]]) + 1 < 0 or _8688 + ceil32(return_data.size) + ceil32(32 * mem[_8688 + mem[_8688]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8688 + ceil32(return_data.size) + ceil32(32 * mem[_8688 + mem[_8688]]) + 1
                        mem[_8688 + ceil32(return_data.size)] = _8843
                        require _8763 + (32 * _8843) + 32 <= return_data.size
                        s = 0
                        t = _8688 + _8763 + 32
                        v = _8688 + ceil32(return_data.size) + 32
                        while s < _8843:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9493 = mem[_8688 + 32]
                        require mem[_8688 + 32] <= test266151307()
                        require _8688 + mem[_8688 + 32] + 31 < _8688 + return_data.size
                        _9639 = mem[_8688 + mem[_8688 + 32]]
                        if mem[_8688 + mem[_8688 + 32]] > test266151307():
                            revert with 0, 65
                        _9723 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8688 + mem[_8688 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8688 + mem[_8688 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8688 + mem[_8688 + 32]]) + 1
                        mem[_9723] = _9639
                        require _9493 + (32 * _9639) + 32 <= return_data.size
                        s = 0
                        t = _8688 + _9493 + 32
                        v = _9723 + 32
                        while s < _9639:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10436 = mem[_8688 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10436:
                            if s >= mem[_8688 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_5402]:
                                revert with 0, 50
                            mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8688 + ceil32(return_data.size) + 32]
                            if s >= mem[_9723]:
                                revert with 0, 50
                            if t >= mem[_5604]:
                                revert with 0, 50
                            mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _9723 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10436 = mem[_8688 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8636 = mem[_5402]
                mem[mem[64] + 68] = mem[_5402]
                mem[mem[64] + 100 len 32 * _8636] = mem[_5402 + 32 len 32 * _8636]
                idx = _8636
                var65002 = _5402 + (32 * _8636) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8636) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9638 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9691 = mem[_9638]
                require mem[_9638] <= test266151307()
                require _9638 + mem[_9638] + 31 < _9638 + return_data.size
                _9756 = mem[_9638 + mem[_9638]]
                if mem[_9638 + mem[_9638]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9638 + mem[_9638]]) + 1 < 0 or _9638 + ceil32(return_data.size) + ceil32(32 * mem[_9638 + mem[_9638]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9638 + ceil32(return_data.size) + ceil32(32 * mem[_9638 + mem[_9638]]) + 1
                mem[_9638 + ceil32(return_data.size)] = _9756
                require _9691 + (32 * _9756) + 32 <= return_data.size
                mem[_9638 + ceil32(return_data.size) + 32 len 32 * _9756] = mem[_9638 + _9691 + 32 len 32 * _9756]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9756
                mem[mem[64] + 64 len 32 * _9756] = mem[_9638 + ceil32(return_data.size) + 32 len 32 * _9756]
                var92001 = _9756
                var92002 = _9638 + ceil32(return_data.size) + (32 * _9756) + 32
                return Array(len=_9756, data=mem[mem[64] + 64 len 32 * _9756])
            mem[_5604 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6875 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6875:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6943 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6943 + 32 len mem[_6943]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6875 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5402]:
                    revert with 0, 50
                mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5604]:
                    revert with 0, 50
                mem[(32 * u) + _5604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6875 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8388 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8388] = address(stor5[idx].field_0)
                mem[_8388 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8452 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9365 = mem[_8452]
                    s = 0
                    t = u
                    while s < _9365:
                        if s >= mem[_8452]:
                            revert with 0, 50
                        if t >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8452 + 32]
                        if s >= mem[_8452 + 32]:
                            revert with 0, 50
                        if t >= mem[_5604]:
                            revert with 0, 50
                        mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _8452 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9365 = mem[_8452]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8691 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8766 = mem[_8691]
                    require mem[_8691] <= test266151307()
                    require _8691 + mem[_8691] + 31 < _8691 + return_data.size
                    _8845 = mem[_8691 + mem[_8691]]
                    if mem[_8691 + mem[_8691]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8691 + mem[_8691]]) + 1 < 0 or _8691 + ceil32(return_data.size) + ceil32(32 * mem[_8691 + mem[_8691]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8691 + ceil32(return_data.size) + ceil32(32 * mem[_8691 + mem[_8691]]) + 1
                    mem[_8691 + ceil32(return_data.size)] = _8845
                    require _8766 + (32 * _8845) + 32 <= return_data.size
                    s = 0
                    t = _8691 + _8766 + 32
                    v = _8691 + ceil32(return_data.size) + 32
                    while s < _8845:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9496 = mem[_8691 + 32]
                    require mem[_8691 + 32] <= test266151307()
                    require _8691 + mem[_8691 + 32] + 31 < _8691 + return_data.size
                    _9641 = mem[_8691 + mem[_8691 + 32]]
                    if mem[_8691 + mem[_8691 + 32]] > test266151307():
                        revert with 0, 65
                    _9724 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8691 + mem[_8691 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8691 + mem[_8691 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8691 + mem[_8691 + 32]]) + 1
                    mem[_9724] = _9641
                    require _9496 + (32 * _9641) + 32 <= return_data.size
                    s = 0
                    t = _8691 + _9496 + 32
                    v = _9724 + 32
                    while s < _9641:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10437 = mem[_8691 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10437:
                        if s >= mem[_8691 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8691 + ceil32(return_data.size) + 32]
                        if s >= mem[_9724]:
                            revert with 0, 50
                        if t >= mem[_5604]:
                            revert with 0, 50
                        mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _9724 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10437 = mem[_8691 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8638 = mem[_5402]
            mem[mem[64] + 68] = mem[_5402]
            mem[mem[64] + 100 len 32 * _8638] = mem[_5402 + 32 len 32 * _8638]
            idx = _8638
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8638) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9640 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9692 = mem[_9640]
            require mem[_9640] <= test266151307()
            require _9640 + mem[_9640] + 31 < _9640 + return_data.size
            _9757 = mem[_9640 + mem[_9640]]
            if mem[_9640 + mem[_9640]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9640 + mem[_9640]]) + 1 < 0 or _9640 + ceil32(return_data.size) + ceil32(32 * mem[_9640 + mem[_9640]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9640 + ceil32(return_data.size) + ceil32(32 * mem[_9640 + mem[_9640]]) + 1
            mem[_9640 + ceil32(return_data.size)] = _9757
            require _9692 + (32 * _9757) + 32 <= return_data.size
            mem[_9640 + ceil32(return_data.size) + 32 len 32 * _9757] = mem[_9640 + _9692 + 32 len 32 * _9757]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9757
            mem[mem[64] + 64 len 32 * _9757] = mem[_9640 + ceil32(return_data.size) + 32 len 32 * _9757]
            var93001 = _9757
            var93002 = _9640 + ceil32(return_data.size) + (32 * _9757) + 32
            return Array(len=_9757, data=mem[mem[64] + 64 len 32 * _9757])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5402 + (64 * s + t) + 64
        if not s + t:
            _6877 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6877:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6950 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6950 + 32 len mem[_6950]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6877 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5402]:
                    revert with 0, 50
                mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5402 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5402 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6877 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8393 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8393] = address(stor5[idx].field_0)
                mem[_8393 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8453 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9366 = mem[_8453]
                    v = 0
                    w = u
                    while v < _9366:
                        if v >= mem[_8453]:
                            revert with 0, 50
                        if w >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8453 + 32]
                        if v >= mem[_8453 + 32]:
                            revert with 0, 50
                        if w >= mem[_5402 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _8453 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9366 = mem[_8453]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8694 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8769 = mem[_8694]
                    require mem[_8694] <= test266151307()
                    require _8694 + mem[_8694] + 31 < _8694 + return_data.size
                    _8847 = mem[_8694 + mem[_8694]]
                    if mem[_8694 + mem[_8694]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8694 + mem[_8694]]) + 1 < 0 or _8694 + ceil32(return_data.size) + ceil32(32 * mem[_8694 + mem[_8694]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8694 + ceil32(return_data.size) + ceil32(32 * mem[_8694 + mem[_8694]]) + 1
                    mem[_8694 + ceil32(return_data.size)] = _8847
                    require _8769 + (32 * _8847) + 32 <= return_data.size
                    v = 0
                    w = _8694 + _8769 + 32
                    x = _8694 + ceil32(return_data.size) + 32
                    while v < _8847:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9499 = mem[_8694 + 32]
                    require mem[_8694 + 32] <= test266151307()
                    require _8694 + mem[_8694 + 32] + 31 < _8694 + return_data.size
                    _9643 = mem[_8694 + mem[_8694 + 32]]
                    if mem[_8694 + mem[_8694 + 32]] > test266151307():
                        revert with 0, 65
                    _9725 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8694 + mem[_8694 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8694 + mem[_8694 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8694 + mem[_8694 + 32]]) + 1
                    mem[_9725] = _9643
                    require _9499 + (32 * _9643) + 32 <= return_data.size
                    v = 0
                    w = _8694 + _9499 + 32
                    x = _9725 + 32
                    while v < _9643:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10438 = mem[_8694 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10438:
                        if v >= mem[_8694 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8694 + ceil32(return_data.size) + 32]
                        if v >= mem[_9725]:
                            revert with 0, 50
                        if w >= mem[_5402 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _9725 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10438 = mem[_8694 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8640 = mem[_5402]
            mem[mem[64] + 68] = mem[_5402]
            mem[mem[64] + 100 len 32 * _8640] = mem[_5402 + 32 len 32 * _8640]
            idx = _8640
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8640) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9642 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9693 = mem[_9642]
            require mem[_9642] <= test266151307()
            require _9642 + mem[_9642] + 31 < _9642 + return_data.size
            _9758 = mem[_9642 + mem[_9642]]
            if mem[_9642 + mem[_9642]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9642 + mem[_9642]]) + 1 < 0 or _9642 + ceil32(return_data.size) + ceil32(32 * mem[_9642 + mem[_9642]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9642 + ceil32(return_data.size) + ceil32(32 * mem[_9642 + mem[_9642]]) + 1
            mem[_9642 + ceil32(return_data.size)] = _9758
            require _9693 + (32 * _9758) + 32 <= return_data.size
            mem[_9642 + ceil32(return_data.size) + 32 len 32 * _9758] = mem[_9642 + _9693 + 32 len 32 * _9758]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9758
            mem[mem[64] + 64 len 32 * _9758] = mem[_9642 + ceil32(return_data.size) + 32 len 32 * _9758]
            var93001 = _9758
            var93002 = _9642 + ceil32(return_data.size) + (32 * _9758) + 32
            return Array(len=_9758, data=mem[mem[64] + 64 len 32 * _9758])
        mem[_5402 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _6879 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6879:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6957 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6957 + 32 len mem[_6957]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6879 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5402]:
                revert with 0, 50
            mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5402 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _5402 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6879 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8398 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8398] = address(stor5[idx].field_0)
            mem[_8398 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8454 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9367 = mem[_8454]
                v = 0
                w = u
                while v < _9367:
                    if v >= mem[_8454]:
                        revert with 0, 50
                    if w >= mem[_5402]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8454 + 32]
                    if v >= mem[_8454 + 32]:
                        revert with 0, 50
                    if w >= mem[_5402 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _8454 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _9367 = mem[_8454]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8697 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8772 = mem[_8697]
                require mem[_8697] <= test266151307()
                require _8697 + mem[_8697] + 31 < _8697 + return_data.size
                _8849 = mem[_8697 + mem[_8697]]
                if mem[_8697 + mem[_8697]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8697 + mem[_8697]]) + 1 < 0 or _8697 + ceil32(return_data.size) + ceil32(32 * mem[_8697 + mem[_8697]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8697 + ceil32(return_data.size) + ceil32(32 * mem[_8697 + mem[_8697]]) + 1
                mem[_8697 + ceil32(return_data.size)] = _8849
                require _8772 + (32 * _8849) + 32 <= return_data.size
                v = 0
                w = _8697 + _8772 + 32
                x = _8697 + ceil32(return_data.size) + 32
                while v < _8849:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _9502 = mem[_8697 + 32]
                require mem[_8697 + 32] <= test266151307()
                require _8697 + mem[_8697 + 32] + 31 < _8697 + return_data.size
                _9645 = mem[_8697 + mem[_8697 + 32]]
                if mem[_8697 + mem[_8697 + 32]] > test266151307():
                    revert with 0, 65
                _9726 = mem[64]
                if mem[64] + ceil32(32 * mem[_8697 + mem[_8697 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8697 + mem[_8697 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8697 + mem[_8697 + 32]]) + 1
                mem[_9726] = _9645
                require _9502 + (32 * _9645) + 32 <= return_data.size
                v = 0
                w = _8697 + _9502 + 32
                x = _9726 + 32
                while v < _9645:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10439 = mem[_8697 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _10439:
                    if v >= mem[_8697 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_5402]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8697 + ceil32(return_data.size) + 32]
                    if v >= mem[_9726]:
                        revert with 0, 50
                    if w >= mem[_5402 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _9726 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10439 = mem[_8697 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8642 = mem[_5402]
        mem[mem[64] + 68] = mem[_5402]
        mem[mem[64] + 100 len 32 * _8642] = mem[_5402 + 32 len 32 * _8642]
        idx = _8642
        var67002 = _5402 + (32 * _8642) + 32
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(stor9)
        staticcall stor9.0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8642) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9644 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9694 = mem[_9644]
        require mem[_9644] <= test266151307()
        require _9644 + mem[_9644] + 31 < _9644 + return_data.size
        _9759 = mem[_9644 + mem[_9644]]
        if mem[_9644 + mem[_9644]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9644 + mem[_9644]]) + 1 < 0 or _9644 + ceil32(return_data.size) + ceil32(32 * mem[_9644 + mem[_9644]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9644 + ceil32(return_data.size) + ceil32(32 * mem[_9644 + mem[_9644]]) + 1
        mem[_9644 + ceil32(return_data.size)] = _9759
        require _9694 + (32 * _9759) + 32 <= return_data.size
        mem[_9644 + ceil32(return_data.size) + 32 len 32 * _9759] = mem[_9644 + _9694 + 32 len 32 * _9759]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9759
        mem[mem[64] + 64 len 32 * _9759] = mem[_9644 + ceil32(return_data.size) + 32 len 32 * _9759]
        var94001 = _9759
        var94002 = _9644 + ceil32(return_data.size) + (32 * _9759) + 32
        return Array(len=_9759, data=mem[mem[64] + 64 len 32 * _9759])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10)
    mem[ceil32(return_data.size) + 224] = stor10[ext_call.return_data[31 len 1]].field_0
    idx = ceil32(return_data.size) + 224
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 192 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
    if not stor10[ext_call.return_data[31 len 1]].field_256:
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1075 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1075 + 32 len mem[_1075]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2226 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2226] = address(stor5[idx].field_0)
                mem[_2226 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2241 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2241]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2241]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2329 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2369 = mem[_2329]
                require mem[_2329] <= test266151307()
                require _2329 + mem[_2329] + 31 < _2329 + return_data.size
                _2507 = mem[_2329 + mem[_2329]]
                if mem[_2329 + mem[_2329]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2329 + mem[_2329]]) + 1 < 0 or _2329 + ceil32(return_data.size) + ceil32(32 * mem[_2329 + mem[_2329]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2329 + ceil32(return_data.size) + ceil32(32 * mem[_2329 + mem[_2329]]) + 1
                mem[_2329 + ceil32(return_data.size)] = _2507
                require _2369 + (32 * _2507) + 32 <= return_data.size
                s = 0
                u = _2329 + _2369 + 32
                v = _2329 + ceil32(return_data.size) + 32
                while s < _2507:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3676 = mem[_2329 + 32]
                require mem[_2329 + 32] <= test266151307()
                require _2329 + mem[_2329 + 32] + 31 < _2329 + return_data.size
                _3705 = mem[_2329 + mem[_2329 + 32]]
                if mem[_2329 + mem[_2329 + 32]] > test266151307():
                    revert with 0, 65
                _3942 = mem[64]
                if mem[64] + ceil32(32 * mem[_2329 + mem[_2329 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2329 + mem[_2329 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2329 + mem[_2329 + 32]]) + 1
                mem[_3942] = _3705
                require _3676 + (32 * _3705) + 32 <= return_data.size
                s = 0
                u = _2329 + _3676 + 32
                v = _3942 + 32
                while s < _3705:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2329 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2329 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2240 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2328 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2328 + (32 * s + t) + 32
                if s + t:
                    mem[_2328 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _3520 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3520:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3615 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3615 + 32 len mem[_3615]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3520 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2240]:
                            revert with 0, 50
                        mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2328]:
                            revert with 0, 50
                        mem[(32 * u) + _2328 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3520 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5368 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5368] = address(stor5[idx].field_0)
                        mem[_5368 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5405 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6881 = mem[_5405]
                            s = 0
                            t = u
                            while s < _6881:
                                if s >= mem[_5405]:
                                    revert with 0, 50
                                if t >= mem[_2240]:
                                    revert with 0, 50
                                mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5405 + 32]
                                if s >= mem[_5405 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2328]:
                                    revert with 0, 50
                                mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _5405 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6881 = mem[_5405]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5609 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5683 = mem[_5609]
                            require mem[_5609] <= test266151307()
                            require _5609 + mem[_5609] + 31 < _5609 + return_data.size
                            _5825 = mem[_5609 + mem[_5609]]
                            if mem[_5609 + mem[_5609]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5609 + mem[_5609]]) + 1 < 0 or _5609 + ceil32(return_data.size) + ceil32(32 * mem[_5609 + mem[_5609]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5609 + ceil32(return_data.size) + ceil32(32 * mem[_5609 + mem[_5609]]) + 1
                            mem[_5609 + ceil32(return_data.size)] = _5825
                            require _5683 + (32 * _5825) + 32 <= return_data.size
                            s = 0
                            t = _5609 + _5683 + 32
                            v = _5609 + ceil32(return_data.size) + 32
                            while s < _5825:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7080 = mem[_5609 + 32]
                            require mem[_5609 + 32] <= test266151307()
                            require _5609 + mem[_5609 + 32] + 31 < _5609 + return_data.size
                            _7184 = mem[_5609 + mem[_5609 + 32]]
                            if mem[_5609 + mem[_5609 + 32]] > test266151307():
                                revert with 0, 65
                            _7384 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5609 + mem[_5609 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5609 + mem[_5609 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5609 + mem[_5609 + 32]]) + 1
                            mem[_7384] = _7184
                            require _7080 + (32 * _7184) + 32 <= return_data.size
                            s = 0
                            t = _5609 + _7080 + 32
                            v = _7384 + 32
                            while s < _7184:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _9369 = mem[_5609 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _9369:
                                if s >= mem[_5609 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2240]:
                                    revert with 0, 50
                                mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5609 + ceil32(return_data.size) + 32]
                                if s >= mem[_7384]:
                                    revert with 0, 50
                                if t >= mem[_2328]:
                                    revert with 0, 50
                                mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _7384 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _9369 = mem[_5609 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5562 = mem[_2240]
                    mem[mem[64] + 68] = mem[_2240]
                    mem[mem[64] + 100 len 32 * _5562] = mem[_2240 + 32 len 32 * _5562]
                    idx = _5562
                    var62002 = _2240 + (32 * _5562) + 32
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(stor9)
                    staticcall stor9.0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5562) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7183 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7301 = mem[_7183]
                    require mem[_7183] <= test266151307()
                    require _7183 + mem[_7183] + 31 < _7183 + return_data.size
                    _7455 = mem[_7183 + mem[_7183]]
                    if mem[_7183 + mem[_7183]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7183 + mem[_7183]]) + 1 < 0 or _7183 + ceil32(return_data.size) + ceil32(32 * mem[_7183 + mem[_7183]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7183 + ceil32(return_data.size) + ceil32(32 * mem[_7183 + mem[_7183]]) + 1
                    mem[_7183 + ceil32(return_data.size)] = _7455
                    require _7301 + (32 * _7455) + 32 <= return_data.size
                    mem[_7183 + ceil32(return_data.size) + 32 len 32 * _7455] = mem[_7183 + _7301 + 32 len 32 * _7455]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7455
                    mem[mem[64] + 64 len 32 * _7455] = mem[_7183 + ceil32(return_data.size) + 32 len 32 * _7455]
                    var89001 = _7455
                    var89002 = _7183 + ceil32(return_data.size) + (32 * _7455) + 32
                    return Array(len=_7455, data=mem[mem[64] + 64 len 32 * _7455])
                _3518 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3518:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3608 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3608 + 32 len mem[_3608]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3518 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2240]:
                        revert with 0, 50
                    mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2328]:
                        revert with 0, 50
                    mem[(32 * u) + _2328 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3518 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5363 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5363] = address(stor5[idx].field_0)
                    mem[_5363 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5404 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6880 = mem[_5404]
                        s = 0
                        t = u
                        while s < _6880:
                            if s >= mem[_5404]:
                                revert with 0, 50
                            if t >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5404 + 32]
                            if s >= mem[_5404 + 32]:
                                revert with 0, 50
                            if t >= mem[_2328]:
                                revert with 0, 50
                            mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _5404 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6880 = mem[_5404]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5606 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5680 = mem[_5606]
                        require mem[_5606] <= test266151307()
                        require _5606 + mem[_5606] + 31 < _5606 + return_data.size
                        _5823 = mem[_5606 + mem[_5606]]
                        if mem[_5606 + mem[_5606]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5606 + mem[_5606]]) + 1 < 0 or _5606 + ceil32(return_data.size) + ceil32(32 * mem[_5606 + mem[_5606]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5606 + ceil32(return_data.size) + ceil32(32 * mem[_5606 + mem[_5606]]) + 1
                        mem[_5606 + ceil32(return_data.size)] = _5823
                        require _5680 + (32 * _5823) + 32 <= return_data.size
                        s = 0
                        t = _5606 + _5680 + 32
                        v = _5606 + ceil32(return_data.size) + 32
                        while s < _5823:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7077 = mem[_5606 + 32]
                        require mem[_5606 + 32] <= test266151307()
                        require _5606 + mem[_5606 + 32] + 31 < _5606 + return_data.size
                        _7182 = mem[_5606 + mem[_5606 + 32]]
                        if mem[_5606 + mem[_5606 + 32]] > test266151307():
                            revert with 0, 65
                        _7383 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5606 + mem[_5606 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5606 + mem[_5606 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5606 + mem[_5606 + 32]]) + 1
                        mem[_7383] = _7182
                        require _7077 + (32 * _7182) + 32 <= return_data.size
                        s = 0
                        t = _5606 + _7077 + 32
                        v = _7383 + 32
                        while s < _7182:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9368 = mem[_5606 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9368:
                            if s >= mem[_5606 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5606 + ceil32(return_data.size) + 32]
                            if s >= mem[_7383]:
                                revert with 0, 50
                            if t >= mem[_2328]:
                                revert with 0, 50
                            mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _7383 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9368 = mem[_5606 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5560 = mem[_2240]
                mem[mem[64] + 68] = mem[_2240]
                mem[mem[64] + 100 len 32 * _5560] = mem[_2240 + 32 len 32 * _5560]
                idx = _5560
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5560) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7181 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7300 = mem[_7181]
                require mem[_7181] <= test266151307()
                require _7181 + mem[_7181] + 31 < _7181 + return_data.size
                _7454 = mem[_7181 + mem[_7181]]
                if mem[_7181 + mem[_7181]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7181 + mem[_7181]]) + 1 < 0 or _7181 + ceil32(return_data.size) + ceil32(32 * mem[_7181 + mem[_7181]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7181 + ceil32(return_data.size) + ceil32(32 * mem[_7181 + mem[_7181]]) + 1
                mem[_7181 + ceil32(return_data.size)] = _7454
                require _7300 + (32 * _7454) + 32 <= return_data.size
                mem[_7181 + ceil32(return_data.size) + 32 len 32 * _7454] = mem[_7181 + _7300 + 32 len 32 * _7454]
                var80001 = _7454
                var80002 = _7181 + _7300 + (32 * _7454) + 32
                var80004 = _7181 + ceil32(return_data.size) + (32 * _7454) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7454
                mem[mem[64] + 64 len 32 * _7454] = mem[_7181 + ceil32(return_data.size) + 32 len 32 * _7454]
                var88001 = _7454
                var88002 = _7181 + ceil32(return_data.size) + (32 * _7454) + 32
                return Array(len=_7454, data=mem[mem[64] + 64 len 32 * _7454])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2240 + (64 * s + t) + 64
            if not s + t:
                _3522 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3522:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3622 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3622 + 32 len mem[_3622]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3522 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2240]:
                        revert with 0, 50
                    mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2240 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2240 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3522 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5373 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5373] = address(stor5[idx].field_0)
                    mem[_5373 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5406 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6882 = mem[_5406]
                        v = 0
                        w = u
                        while v < _6882:
                            if v >= mem[_5406]:
                                revert with 0, 50
                            if w >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5406 + 32]
                            if v >= mem[_5406 + 32]:
                                revert with 0, 50
                            if w >= mem[_2240 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _5406 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6882 = mem[_5406]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5612 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5686 = mem[_5612]
                        require mem[_5612] <= test266151307()
                        require _5612 + mem[_5612] + 31 < _5612 + return_data.size
                        _5827 = mem[_5612 + mem[_5612]]
                        if mem[_5612 + mem[_5612]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5612 + mem[_5612]]) + 1 < 0 or _5612 + ceil32(return_data.size) + ceil32(32 * mem[_5612 + mem[_5612]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5612 + ceil32(return_data.size) + ceil32(32 * mem[_5612 + mem[_5612]]) + 1
                        mem[_5612 + ceil32(return_data.size)] = _5827
                        require _5686 + (32 * _5827) + 32 <= return_data.size
                        v = 0
                        w = _5612 + _5686 + 32
                        x = _5612 + ceil32(return_data.size) + 32
                        while v < _5827:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7083 = mem[_5612 + 32]
                        require mem[_5612 + 32] <= test266151307()
                        require _5612 + mem[_5612 + 32] + 31 < _5612 + return_data.size
                        _7186 = mem[_5612 + mem[_5612 + 32]]
                        if mem[_5612 + mem[_5612 + 32]] > test266151307():
                            revert with 0, 65
                        _7385 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5612 + mem[_5612 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5612 + mem[_5612 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5612 + mem[_5612 + 32]]) + 1
                        mem[_7385] = _7186
                        require _7083 + (32 * _7186) + 32 <= return_data.size
                        v = 0
                        w = _5612 + _7083 + 32
                        x = _7385 + 32
                        while v < _7186:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9370 = mem[_5612 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9370:
                            if v >= mem[_5612 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5612 + ceil32(return_data.size) + 32]
                            if v >= mem[_7385]:
                                revert with 0, 50
                            if w >= mem[_2240 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _7385 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9370 = mem[_5612 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5564 = mem[_2240]
                mem[mem[64] + 68] = mem[_2240]
                mem[mem[64] + 100 len 32 * _5564] = mem[_2240 + 32 len 32 * _5564]
                idx = _5564
                var62002 = _2240 + (32 * _5564) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5564) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7185 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7302 = mem[_7185]
                require mem[_7185] <= test266151307()
                require _7185 + mem[_7185] + 31 < _7185 + return_data.size
                _7456 = mem[_7185 + mem[_7185]]
                if mem[_7185 + mem[_7185]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7185 + mem[_7185]]) + 1 < 0 or _7185 + ceil32(return_data.size) + ceil32(32 * mem[_7185 + mem[_7185]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7185 + ceil32(return_data.size) + ceil32(32 * mem[_7185 + mem[_7185]]) + 1
                mem[_7185 + ceil32(return_data.size)] = _7456
                require _7302 + (32 * _7456) + 32 <= return_data.size
                mem[_7185 + ceil32(return_data.size) + 32 len 32 * _7456] = mem[_7185 + _7302 + 32 len 32 * _7456]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7456
                mem[mem[64] + 64 len 32 * _7456] = mem[_7185 + ceil32(return_data.size) + 32 len 32 * _7456]
                var89001 = _7456
                var89002 = _7185 + ceil32(return_data.size) + (32 * _7456) + 32
                return Array(len=_7456, data=mem[mem[64] + 64 len 32 * _7456])
            mem[_2240 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3524 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3524:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3629 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3629 + 32 len mem[_3629]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3524 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2240]:
                    revert with 0, 50
                mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2240 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2240 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3524 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5378] = address(stor5[idx].field_0)
                mem[_5378 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5407 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6883 = mem[_5407]
                    v = 0
                    w = u
                    while v < _6883:
                        if v >= mem[_5407]:
                            revert with 0, 50
                        if w >= mem[_2240]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5407 + 32]
                        if v >= mem[_5407 + 32]:
                            revert with 0, 50
                        if w >= mem[_2240 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _5407 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _6883 = mem[_5407]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5615 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5689 = mem[_5615]
                    require mem[_5615] <= test266151307()
                    require _5615 + mem[_5615] + 31 < _5615 + return_data.size
                    _5829 = mem[_5615 + mem[_5615]]
                    if mem[_5615 + mem[_5615]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5615 + mem[_5615]]) + 1 < 0 or _5615 + ceil32(return_data.size) + ceil32(32 * mem[_5615 + mem[_5615]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5615 + ceil32(return_data.size) + ceil32(32 * mem[_5615 + mem[_5615]]) + 1
                    mem[_5615 + ceil32(return_data.size)] = _5829
                    require _5689 + (32 * _5829) + 32 <= return_data.size
                    v = 0
                    w = _5615 + _5689 + 32
                    x = _5615 + ceil32(return_data.size) + 32
                    while v < _5829:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _7086 = mem[_5615 + 32]
                    require mem[_5615 + 32] <= test266151307()
                    require _5615 + mem[_5615 + 32] + 31 < _5615 + return_data.size
                    _7188 = mem[_5615 + mem[_5615 + 32]]
                    if mem[_5615 + mem[_5615 + 32]] > test266151307():
                        revert with 0, 65
                    _7386 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5615 + mem[_5615 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5615 + mem[_5615 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5615 + mem[_5615 + 32]]) + 1
                    mem[_7386] = _7188
                    require _7086 + (32 * _7188) + 32 <= return_data.size
                    v = 0
                    w = _5615 + _7086 + 32
                    x = _7386 + 32
                    while v < _7188:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9371 = mem[_5615 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9371:
                        if v >= mem[_5615 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2240]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5615 + ceil32(return_data.size) + 32]
                        if v >= mem[_7386]:
                            revert with 0, 50
                        if w >= mem[_2240 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _7386 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9371 = mem[_5615 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5566 = mem[_2240]
            mem[mem[64] + 68] = mem[_2240]
            mem[mem[64] + 100 len 32 * _5566] = mem[_2240 + 32 len 32 * _5566]
            idx = _5566
            var63002 = _2240 + (32 * _5566) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5566) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7187 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7303 = mem[_7187]
            require mem[_7187] <= test266151307()
            require _7187 + mem[_7187] + 31 < _7187 + return_data.size
            _7457 = mem[_7187 + mem[_7187]]
            if mem[_7187 + mem[_7187]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7187 + mem[_7187]]) + 1 < 0 or _7187 + ceil32(return_data.size) + ceil32(32 * mem[_7187 + mem[_7187]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7187 + ceil32(return_data.size) + ceil32(32 * mem[_7187 + mem[_7187]]) + 1
            mem[_7187 + ceil32(return_data.size)] = _7457
            require _7303 + (32 * _7457) + 32 <= return_data.size
            mem[_7187 + ceil32(return_data.size) + 32 len 32 * _7457] = mem[_7187 + _7303 + 32 len 32 * _7457]
            var82001 = _7457
            var82002 = _7187 + _7303 + (32 * _7457) + 32
            var82004 = _7187 + ceil32(return_data.size) + (32 * _7457) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7457
            mem[mem[64] + 64 len 32 * _7457] = mem[_7187 + ceil32(return_data.size) + 32 len 32 * _7457]
            var90001 = _7457
            var90002 = _7187 + ceil32(return_data.size) + (32 * _7457) + 32
            return Array(len=_7457, data=mem[mem[64] + 64 len 32 * _7457])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3637 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3637 + 32 len mem[_3637]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5383 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5383] = address(stor5[idx].field_0)
            mem[_5383 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5410 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5410]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5410]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5619 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5694 = mem[_5619]
            require mem[_5619] <= test266151307()
            require _5619 + mem[_5619] + 31 < _5619 + return_data.size
            _5839 = mem[_5619 + mem[_5619]]
            if mem[_5619 + mem[_5619]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5619 + mem[_5619]]) + 1 < 0 or _5619 + ceil32(return_data.size) + ceil32(32 * mem[_5619 + mem[_5619]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5619 + ceil32(return_data.size) + ceil32(32 * mem[_5619 + mem[_5619]]) + 1
            mem[_5619 + ceil32(return_data.size)] = _5839
            require _5694 + (32 * _5839) + 32 <= return_data.size
            s = 0
            u = _5619 + _5694 + 32
            v = _5619 + ceil32(return_data.size) + 32
            while s < _5839:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7093 = mem[_5619 + 32]
            require mem[_5619 + 32] <= test266151307()
            require _5619 + mem[_5619 + 32] + 31 < _5619 + return_data.size
            _7189 = mem[_5619 + mem[_5619 + 32]]
            if mem[_5619 + mem[_5619 + 32]] > test266151307():
                revert with 0, 65
            _7407 = mem[64]
            if mem[64] + ceil32(32 * mem[_5619 + mem[_5619 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5619 + mem[_5619 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5619 + mem[_5619 + 32]]) + 1
            mem[_7407] = _7189
            require _7093 + (32 * _7189) + 32 <= return_data.size
            s = 0
            u = _5619 + _7093 + 32
            v = _7407 + 32
            while s < _7189:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5619 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5619 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5409 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5409 + (64 * s + t) + 64
            if not s + t:
                _6889 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6889:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6991 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6991 + 32 len mem[_6991]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6889 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5409]:
                        revert with 0, 50
                    mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5409 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _5409 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6889 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8417 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8417] = address(stor5[idx].field_0)
                    mem[_8417 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8458 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9374 = mem[_8458]
                        v = 0
                        w = u
                        while v < _9374:
                            if v >= mem[_8458]:
                                revert with 0, 50
                            if w >= mem[_5409]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8458 + 32]
                            if v >= mem[_8458 + 32]:
                                revert with 0, 50
                            if w >= mem[_5409 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _8458 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9374 = mem[_8458]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8718 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8781 = mem[_8718]
                        require mem[_8718] <= test266151307()
                        require _8718 + mem[_8718] + 31 < _8718 + return_data.size
                        _8855 = mem[_8718 + mem[_8718]]
                        if mem[_8718 + mem[_8718]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8718 + mem[_8718]]) + 1 < 0 or _8718 + ceil32(return_data.size) + ceil32(32 * mem[_8718 + mem[_8718]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8718 + ceil32(return_data.size) + ceil32(32 * mem[_8718 + mem[_8718]]) + 1
                        mem[_8718 + ceil32(return_data.size)] = _8855
                        require _8781 + (32 * _8855) + 32 <= return_data.size
                        v = 0
                        w = _8718 + _8781 + 32
                        x = _8718 + ceil32(return_data.size) + 32
                        while v < _8855:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9519 = mem[_8718 + 32]
                        require mem[_8718 + 32] <= test266151307()
                        require _8718 + mem[_8718 + 32] + 31 < _8718 + return_data.size
                        _9651 = mem[_8718 + mem[_8718 + 32]]
                        if mem[_8718 + mem[_8718 + 32]] > test266151307():
                            revert with 0, 65
                        _9729 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8718 + mem[_8718 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8718 + mem[_8718 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8718 + mem[_8718 + 32]]) + 1
                        mem[_9729] = _9651
                        require _9519 + (32 * _9651) + 32 <= return_data.size
                        v = 0
                        w = _8718 + _9519 + 32
                        x = _9729 + 32
                        while v < _9651:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10442 = mem[_8718 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10442:
                            if v >= mem[_8718 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_5409]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8718 + ceil32(return_data.size) + 32]
                            if v >= mem[_9729]:
                                revert with 0, 50
                            if w >= mem[_5409 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _9729 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10442 = mem[_8718 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8652 = mem[_5409]
                mem[mem[64] + 68] = mem[_5409]
                mem[mem[64] + 100 len 32 * _8652] = mem[_5409 + 32 len 32 * _8652]
                idx = _8652
                var66002 = _5409 + (32 * _8652) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8652) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9650 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9697 = mem[_9650]
                require mem[_9650] <= test266151307()
                require _9650 + mem[_9650] + 31 < _9650 + return_data.size
                _9762 = mem[_9650 + mem[_9650]]
                if mem[_9650 + mem[_9650]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9650 + mem[_9650]]) + 1 < 0 or _9650 + ceil32(return_data.size) + ceil32(32 * mem[_9650 + mem[_9650]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9650 + ceil32(return_data.size) + ceil32(32 * mem[_9650 + mem[_9650]]) + 1
                mem[_9650 + ceil32(return_data.size)] = _9762
                require _9697 + (32 * _9762) + 32 <= return_data.size
                mem[_9650 + ceil32(return_data.size) + 32 len 32 * _9762] = mem[_9650 + _9697 + 32 len 32 * _9762]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9762
                mem[mem[64] + 64 len 32 * _9762] = mem[_9650 + ceil32(return_data.size) + 32 len 32 * _9762]
                var93001 = _9762
                var93002 = _9650 + ceil32(return_data.size) + (32 * _9762) + 32
                return Array(len=_9762, data=mem[mem[64] + 64 len 32 * _9762])
            mem[_5409 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6891 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6891:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6998 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6998 + 32 len mem[_6998]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6891 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5409]:
                    revert with 0, 50
                mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5409 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5409 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6891 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8422 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8422] = address(stor5[idx].field_0)
                mem[_8422 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8459 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9375 = mem[_8459]
                    v = 0
                    w = u
                    while v < _9375:
                        if v >= mem[_8459]:
                            revert with 0, 50
                        if w >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8459 + 32]
                        if v >= mem[_8459 + 32]:
                            revert with 0, 50
                        if w >= mem[_5409 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _8459 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9375 = mem[_8459]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8721 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8784 = mem[_8721]
                    require mem[_8721] <= test266151307()
                    require _8721 + mem[_8721] + 31 < _8721 + return_data.size
                    _8857 = mem[_8721 + mem[_8721]]
                    if mem[_8721 + mem[_8721]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8721 + mem[_8721]]) + 1 < 0 or _8721 + ceil32(return_data.size) + ceil32(32 * mem[_8721 + mem[_8721]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8721 + ceil32(return_data.size) + ceil32(32 * mem[_8721 + mem[_8721]]) + 1
                    mem[_8721 + ceil32(return_data.size)] = _8857
                    require _8784 + (32 * _8857) + 32 <= return_data.size
                    v = 0
                    w = _8721 + _8784 + 32
                    x = _8721 + ceil32(return_data.size) + 32
                    while v < _8857:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9522 = mem[_8721 + 32]
                    require mem[_8721 + 32] <= test266151307()
                    require _8721 + mem[_8721 + 32] + 31 < _8721 + return_data.size
                    _9653 = mem[_8721 + mem[_8721 + 32]]
                    if mem[_8721 + mem[_8721 + 32]] > test266151307():
                        revert with 0, 65
                    _9730 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8721 + mem[_8721 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8721 + mem[_8721 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8721 + mem[_8721 + 32]]) + 1
                    mem[_9730] = _9653
                    require _9522 + (32 * _9653) + 32 <= return_data.size
                    v = 0
                    w = _8721 + _9522 + 32
                    x = _9730 + 32
                    while v < _9653:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10443 = mem[_8721 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10443:
                        if v >= mem[_8721 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8721 + ceil32(return_data.size) + 32]
                        if v >= mem[_9730]:
                            revert with 0, 50
                        if w >= mem[_5409 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _9730 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10443 = mem[_8721 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8654 = mem[_5409]
            mem[mem[64] + 68] = mem[_5409]
            mem[mem[64] + 100 len 32 * _8654] = mem[_5409 + 32 len 32 * _8654]
            idx = _8654
            var67002 = _5409 + (32 * _8654) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8654) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9652 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9698 = mem[_9652]
            require mem[_9652] <= test266151307()
            require _9652 + mem[_9652] + 31 < _9652 + return_data.size
            _9763 = mem[_9652 + mem[_9652]]
            if mem[_9652 + mem[_9652]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9652 + mem[_9652]]) + 1 < 0 or _9652 + ceil32(return_data.size) + ceil32(32 * mem[_9652 + mem[_9652]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9652 + ceil32(return_data.size) + ceil32(32 * mem[_9652 + mem[_9652]]) + 1
            mem[_9652 + ceil32(return_data.size)] = _9763
            require _9698 + (32 * _9763) + 32 <= return_data.size
            mem[_9652 + ceil32(return_data.size) + 32 len 32 * _9763] = mem[_9652 + _9698 + 32 len 32 * _9763]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9763
            mem[mem[64] + 64 len 32 * _9763] = mem[_9652 + ceil32(return_data.size) + 32 len 32 * _9763]
            var94001 = _9763
            var94002 = _9652 + ceil32(return_data.size) + (32 * _9763) + 32
            return Array(len=_9763, data=mem[mem[64] + 64 len 32 * _9763])
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5618 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5618 + (32 * s + t) + 32
        if s + t:
            mem[_5618 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6887 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6887:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6984 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6984 + 32 len mem[_6984]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6887 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5409]:
                    revert with 0, 50
                mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5618]:
                    revert with 0, 50
                mem[(32 * u) + _5618 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6887 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8412 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8412] = address(stor5[idx].field_0)
                mem[_8412 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8457 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9373 = mem[_8457]
                    s = 0
                    t = u
                    while s < _9373:
                        if s >= mem[_8457]:
                            revert with 0, 50
                        if t >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8457 + 32]
                        if s >= mem[_8457 + 32]:
                            revert with 0, 50
                        if t >= mem[_5618]:
                            revert with 0, 50
                        mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _8457 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9373 = mem[_8457]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8715 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8778 = mem[_8715]
                    require mem[_8715] <= test266151307()
                    require _8715 + mem[_8715] + 31 < _8715 + return_data.size
                    _8853 = mem[_8715 + mem[_8715]]
                    if mem[_8715 + mem[_8715]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8715 + mem[_8715]]) + 1 < 0 or _8715 + ceil32(return_data.size) + ceil32(32 * mem[_8715 + mem[_8715]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8715 + ceil32(return_data.size) + ceil32(32 * mem[_8715 + mem[_8715]]) + 1
                    mem[_8715 + ceil32(return_data.size)] = _8853
                    require _8778 + (32 * _8853) + 32 <= return_data.size
                    s = 0
                    t = _8715 + _8778 + 32
                    v = _8715 + ceil32(return_data.size) + 32
                    while s < _8853:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9516 = mem[_8715 + 32]
                    require mem[_8715 + 32] <= test266151307()
                    require _8715 + mem[_8715 + 32] + 31 < _8715 + return_data.size
                    _9649 = mem[_8715 + mem[_8715 + 32]]
                    if mem[_8715 + mem[_8715 + 32]] > test266151307():
                        revert with 0, 65
                    _9728 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8715 + mem[_8715 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8715 + mem[_8715 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8715 + mem[_8715 + 32]]) + 1
                    mem[_9728] = _9649
                    require _9516 + (32 * _9649) + 32 <= return_data.size
                    s = 0
                    t = _8715 + _9516 + 32
                    v = _9728 + 32
                    while s < _9649:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10441 = mem[_8715 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10441:
                        if s >= mem[_8715 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8715 + ceil32(return_data.size) + 32]
                        if s >= mem[_9728]:
                            revert with 0, 50
                        if t >= mem[_5618]:
                            revert with 0, 50
                        mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _9728 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10441 = mem[_8715 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8650 = mem[_5409]
            mem[mem[64] + 68] = mem[_5409]
            mem[mem[64] + 100 len 32 * _8650] = mem[_5409 + 32 len 32 * _8650]
            idx = _8650
            var66002 = _5409 + (32 * _8650) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8650) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9648 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9696 = mem[_9648]
            require mem[_9648] <= test266151307()
            require _9648 + mem[_9648] + 31 < _9648 + return_data.size
            _9761 = mem[_9648 + mem[_9648]]
            if mem[_9648 + mem[_9648]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9648 + mem[_9648]]) + 1 < 0 or _9648 + ceil32(return_data.size) + ceil32(32 * mem[_9648 + mem[_9648]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9648 + ceil32(return_data.size) + ceil32(32 * mem[_9648 + mem[_9648]]) + 1
            mem[_9648 + ceil32(return_data.size)] = _9761
            require _9696 + (32 * _9761) + 32 <= return_data.size
            mem[_9648 + ceil32(return_data.size) + 32 len 32 * _9761] = mem[_9648 + _9696 + 32 len 32 * _9761]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9761
            mem[mem[64] + 64 len 32 * _9761] = mem[_9648 + ceil32(return_data.size) + 32 len 32 * _9761]
            var93001 = _9761
            var93002 = _9648 + ceil32(return_data.size) + (32 * _9761) + 32
            return Array(len=_9761, data=mem[mem[64] + 64 len 32 * _9761])
        _6885 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6885:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6977 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6977 + 32 len mem[_6977]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6885 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5409]:
                revert with 0, 50
            mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5618]:
                revert with 0, 50
            mem[(32 * u) + _5618 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6885 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8407 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8407] = address(stor5[idx].field_0)
            mem[_8407 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8456 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9372 = mem[_8456]
                s = 0
                t = u
                while s < _9372:
                    if s >= mem[_8456]:
                        revert with 0, 50
                    if t >= mem[_5409]:
                        revert with 0, 50
                    mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8456 + 32]
                    if s >= mem[_8456 + 32]:
                        revert with 0, 50
                    if t >= mem[_5618]:
                        revert with 0, 50
                    mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _8456 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9372 = mem[_8456]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8712 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8775 = mem[_8712]
                require mem[_8712] <= test266151307()
                require _8712 + mem[_8712] + 31 < _8712 + return_data.size
                _8851 = mem[_8712 + mem[_8712]]
                if mem[_8712 + mem[_8712]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8712 + mem[_8712]]) + 1 < 0 or _8712 + ceil32(return_data.size) + ceil32(32 * mem[_8712 + mem[_8712]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8712 + ceil32(return_data.size) + ceil32(32 * mem[_8712 + mem[_8712]]) + 1
                mem[_8712 + ceil32(return_data.size)] = _8851
                require _8775 + (32 * _8851) + 32 <= return_data.size
                s = 0
                t = _8712 + _8775 + 32
                v = _8712 + ceil32(return_data.size) + 32
                while s < _8851:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9513 = mem[_8712 + 32]
                require mem[_8712 + 32] <= test266151307()
                require _8712 + mem[_8712 + 32] + 31 < _8712 + return_data.size
                _9647 = mem[_8712 + mem[_8712 + 32]]
                if mem[_8712 + mem[_8712 + 32]] > test266151307():
                    revert with 0, 65
                _9727 = mem[64]
                if mem[64] + ceil32(32 * mem[_8712 + mem[_8712 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8712 + mem[_8712 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8712 + mem[_8712 + 32]]) + 1
                mem[_9727] = _9647
                require _9513 + (32 * _9647) + 32 <= return_data.size
                s = 0
                t = _8712 + _9513 + 32
                v = _9727 + 32
                while s < _9647:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10440 = mem[_8712 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10440:
                    if s >= mem[_8712 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_5409]:
                        revert with 0, 50
                    mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8712 + ceil32(return_data.size) + 32]
                    if s >= mem[_9727]:
                        revert with 0, 50
                    if t >= mem[_5618]:
                        revert with 0, 50
                    mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _9727 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10440 = mem[_8712 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8648 = mem[_5409]
        mem[mem[64] + 68] = mem[_5409]
        mem[mem[64] + 100 len 32 * _8648] = mem[_5409 + 32 len 32 * _8648]
        idx = _8648
        var65002 = _5409 + (32 * _8648) + 32
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(stor9)
        staticcall stor9.0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8648) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9646 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9695 = mem[_9646]
        require mem[_9646] <= test266151307()
        require _9646 + mem[_9646] + 31 < _9646 + return_data.size
        _9760 = mem[_9646 + mem[_9646]]
        if mem[_9646 + mem[_9646]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9646 + mem[_9646]]) + 1 < 0 or _9646 + ceil32(return_data.size) + ceil32(32 * mem[_9646 + mem[_9646]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9646 + ceil32(return_data.size) + ceil32(32 * mem[_9646 + mem[_9646]]) + 1
        mem[_9646 + ceil32(return_data.size)] = _9760
        require _9695 + (32 * _9760) + 32 <= return_data.size
        mem[_9646 + ceil32(return_data.size) + 32 len 32 * _9760] = mem[_9646 + _9695 + 32 len 32 * _9760]
        var84001 = _9760
        var84002 = _9646 + _9695 + (32 * _9760) + 32
        var84004 = _9646 + ceil32(return_data.size) + (32 * _9760) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9760
        mem[mem[64] + 64 len 32 * _9760] = mem[_9646 + ceil32(return_data.size) + 32 len 32 * _9760]
        var92001 = _9760
        var92002 = _9646 + ceil32(return_data.size) + (32 * _9760) + 32
        return Array(len=_9760, data=mem[mem[64] + 64 len 32 * _9760])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
    mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
    if not stor10[ext_call.return_data[31 len 1]].field_512:
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3644 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3644 + 32 len mem[_3644]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5388] = address(stor5[idx].field_0)
            mem[_5388 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5412 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5412]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5412]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5621 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5697 = mem[_5621]
            require mem[_5621] <= test266151307()
            require _5621 + mem[_5621] + 31 < _5621 + return_data.size
            _5849 = mem[_5621 + mem[_5621]]
            if mem[_5621 + mem[_5621]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5621 + mem[_5621]]) + 1 < 0 or _5621 + ceil32(return_data.size) + ceil32(32 * mem[_5621 + mem[_5621]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5621 + ceil32(return_data.size) + ceil32(32 * mem[_5621 + mem[_5621]]) + 1
            mem[_5621 + ceil32(return_data.size)] = _5849
            require _5697 + (32 * _5849) + 32 <= return_data.size
            s = 0
            u = _5621 + _5697 + 32
            v = _5621 + ceil32(return_data.size) + 32
            while s < _5849:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7098 = mem[_5621 + 32]
            require mem[_5621 + 32] <= test266151307()
            require _5621 + mem[_5621 + 32] + 31 < _5621 + return_data.size
            _7190 = mem[_5621 + mem[_5621 + 32]]
            if mem[_5621 + mem[_5621 + 32]] > test266151307():
                revert with 0, 65
            _7428 = mem[64]
            if mem[64] + ceil32(32 * mem[_5621 + mem[_5621 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5621 + mem[_5621 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5621 + mem[_5621 + 32]]) + 1
            mem[_7428] = _7190
            require _7098 + (32 * _7190) + 32 <= return_data.size
            s = 0
            u = _5621 + _7098 + 32
            v = _7428 + 32
            while s < _7190:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5621 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5621 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5411 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5411 + (64 * s + t) + 64
            if not s + t:
                _6897 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6897:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7020 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7020 + 32 len mem[_7020]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6897 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5411]:
                        revert with 0, 50
                    mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5411 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _5411 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6897 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8437] = address(stor5[idx].field_0)
                    mem[_8437 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8463 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9378 = mem[_8463]
                        v = 0
                        w = u
                        while v < _9378:
                            if v >= mem[_8463]:
                                revert with 0, 50
                            if w >= mem[_5411]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8463 + 32]
                            if v >= mem[_8463 + 32]:
                                revert with 0, 50
                            if w >= mem[_5411 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _8463 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9378 = mem[_8463]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8730 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8793 = mem[_8730]
                        require mem[_8730] <= test266151307()
                        require _8730 + mem[_8730] + 31 < _8730 + return_data.size
                        _8863 = mem[_8730 + mem[_8730]]
                        if mem[_8730 + mem[_8730]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8730 + mem[_8730]]) + 1 < 0 or _8730 + ceil32(return_data.size) + ceil32(32 * mem[_8730 + mem[_8730]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8730 + ceil32(return_data.size) + ceil32(32 * mem[_8730 + mem[_8730]]) + 1
                        mem[_8730 + ceil32(return_data.size)] = _8863
                        require _8793 + (32 * _8863) + 32 <= return_data.size
                        v = 0
                        w = _8730 + _8793 + 32
                        x = _8730 + ceil32(return_data.size) + 32
                        while v < _8863:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9531 = mem[_8730 + 32]
                        require mem[_8730 + 32] <= test266151307()
                        require _8730 + mem[_8730 + 32] + 31 < _8730 + return_data.size
                        _9659 = mem[_8730 + mem[_8730 + 32]]
                        if mem[_8730 + mem[_8730 + 32]] > test266151307():
                            revert with 0, 65
                        _9733 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8730 + mem[_8730 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8730 + mem[_8730 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8730 + mem[_8730 + 32]]) + 1
                        mem[_9733] = _9659
                        require _9531 + (32 * _9659) + 32 <= return_data.size
                        v = 0
                        w = _8730 + _9531 + 32
                        x = _9733 + 32
                        while v < _9659:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10446 = mem[_8730 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10446:
                            if v >= mem[_8730 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_5411]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8730 + ceil32(return_data.size) + 32]
                            if v >= mem[_9733]:
                                revert with 0, 50
                            if w >= mem[_5411 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _9733 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10446 = mem[_8730 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8660 = mem[_5411]
                mem[mem[64] + 68] = mem[_5411]
                mem[mem[64] + 100 len 32 * _8660] = mem[_5411 + 32 len 32 * _8660]
                idx = _8660
                var66002 = _5411 + (32 * _8660) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(stor9)
                staticcall stor9.0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8660) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9658 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9701 = mem[_9658]
                require mem[_9658] <= test266151307()
                require _9658 + mem[_9658] + 31 < _9658 + return_data.size
                _9766 = mem[_9658 + mem[_9658]]
                if mem[_9658 + mem[_9658]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9658 + mem[_9658]]) + 1 < 0 or _9658 + ceil32(return_data.size) + ceil32(32 * mem[_9658 + mem[_9658]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9658 + ceil32(return_data.size) + ceil32(32 * mem[_9658 + mem[_9658]]) + 1
                mem[_9658 + ceil32(return_data.size)] = _9766
                require _9701 + (32 * _9766) + 32 <= return_data.size
                mem[_9658 + ceil32(return_data.size) + 32 len 32 * _9766] = mem[_9658 + _9701 + 32 len 32 * _9766]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9766
                mem[mem[64] + 64 len 32 * _9766] = mem[_9658 + ceil32(return_data.size) + 32 len 32 * _9766]
                var93001 = _9766
                var93002 = _9658 + ceil32(return_data.size) + (32 * _9766) + 32
                return Array(len=_9766, data=mem[mem[64] + 64 len 32 * _9766])
            mem[_5411 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6899 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6899:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7027 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7027 + 32 len mem[_7027]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6899 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5411]:
                    revert with 0, 50
                mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5411 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5411 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6899 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8442 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8442] = address(stor5[idx].field_0)
                mem[_8442 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8464 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9379 = mem[_8464]
                    v = 0
                    w = u
                    while v < _9379:
                        if v >= mem[_8464]:
                            revert with 0, 50
                        if w >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8464 + 32]
                        if v >= mem[_8464 + 32]:
                            revert with 0, 50
                        if w >= mem[_5411 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _8464 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9379 = mem[_8464]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8733 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8796 = mem[_8733]
                    require mem[_8733] <= test266151307()
                    require _8733 + mem[_8733] + 31 < _8733 + return_data.size
                    _8865 = mem[_8733 + mem[_8733]]
                    if mem[_8733 + mem[_8733]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8733 + mem[_8733]]) + 1 < 0 or _8733 + ceil32(return_data.size) + ceil32(32 * mem[_8733 + mem[_8733]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8733 + ceil32(return_data.size) + ceil32(32 * mem[_8733 + mem[_8733]]) + 1
                    mem[_8733 + ceil32(return_data.size)] = _8865
                    require _8796 + (32 * _8865) + 32 <= return_data.size
                    v = 0
                    w = _8733 + _8796 + 32
                    x = _8733 + ceil32(return_data.size) + 32
                    while v < _8865:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9534 = mem[_8733 + 32]
                    require mem[_8733 + 32] <= test266151307()
                    require _8733 + mem[_8733 + 32] + 31 < _8733 + return_data.size
                    _9661 = mem[_8733 + mem[_8733 + 32]]
                    if mem[_8733 + mem[_8733 + 32]] > test266151307():
                        revert with 0, 65
                    _9734 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8733 + mem[_8733 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8733 + mem[_8733 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8733 + mem[_8733 + 32]]) + 1
                    mem[_9734] = _9661
                    require _9534 + (32 * _9661) + 32 <= return_data.size
                    v = 0
                    w = _8733 + _9534 + 32
                    x = _9734 + 32
                    while v < _9661:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10447 = mem[_8733 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10447:
                        if v >= mem[_8733 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8733 + ceil32(return_data.size) + 32]
                        if v >= mem[_9734]:
                            revert with 0, 50
                        if w >= mem[_5411 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _9734 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10447 = mem[_8733 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8662 = mem[_5411]
            mem[mem[64] + 68] = mem[_5411]
            mem[mem[64] + 100 len 32 * _8662] = mem[_5411 + 32 len 32 * _8662]
            idx = _8662
            var67002 = _5411 + (32 * _8662) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8662) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9660 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9702 = mem[_9660]
            require mem[_9660] <= test266151307()
            require _9660 + mem[_9660] + 31 < _9660 + return_data.size
            _9767 = mem[_9660 + mem[_9660]]
            if mem[_9660 + mem[_9660]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9660 + mem[_9660]]) + 1 < 0 or _9660 + ceil32(return_data.size) + ceil32(32 * mem[_9660 + mem[_9660]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9660 + ceil32(return_data.size) + ceil32(32 * mem[_9660 + mem[_9660]]) + 1
            mem[_9660 + ceil32(return_data.size)] = _9767
            require _9702 + (32 * _9767) + 32 <= return_data.size
            mem[_9660 + ceil32(return_data.size) + 32 len 32 * _9767] = mem[_9660 + _9702 + 32 len 32 * _9767]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9767
            mem[mem[64] + 64 len 32 * _9767] = mem[_9660 + ceil32(return_data.size) + 32 len 32 * _9767]
            var94001 = _9767
            var94002 = _9660 + ceil32(return_data.size) + (32 * _9767) + 32
            return Array(len=_9767, data=mem[mem[64] + 64 len 32 * _9767])
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5620 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5620 + (32 * s + t) + 32
        if s + t:
            mem[_5620 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6895 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6895:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7013 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7013 + 32 len mem[_7013]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6895 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5411]:
                    revert with 0, 50
                mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5620]:
                    revert with 0, 50
                mem[(32 * u) + _5620 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6895 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8432 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8432] = address(stor5[idx].field_0)
                mem[_8432 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8462 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9377 = mem[_8462]
                    s = 0
                    t = u
                    while s < _9377:
                        if s >= mem[_8462]:
                            revert with 0, 50
                        if t >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8462 + 32]
                        if s >= mem[_8462 + 32]:
                            revert with 0, 50
                        if t >= mem[_5620]:
                            revert with 0, 50
                        mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _8462 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9377 = mem[_8462]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8727 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8790 = mem[_8727]
                    require mem[_8727] <= test266151307()
                    require _8727 + mem[_8727] + 31 < _8727 + return_data.size
                    _8861 = mem[_8727 + mem[_8727]]
                    if mem[_8727 + mem[_8727]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8727 + mem[_8727]]) + 1 < 0 or _8727 + ceil32(return_data.size) + ceil32(32 * mem[_8727 + mem[_8727]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8727 + ceil32(return_data.size) + ceil32(32 * mem[_8727 + mem[_8727]]) + 1
                    mem[_8727 + ceil32(return_data.size)] = _8861
                    require _8790 + (32 * _8861) + 32 <= return_data.size
                    s = 0
                    t = _8727 + _8790 + 32
                    v = _8727 + ceil32(return_data.size) + 32
                    while s < _8861:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9528 = mem[_8727 + 32]
                    require mem[_8727 + 32] <= test266151307()
                    require _8727 + mem[_8727 + 32] + 31 < _8727 + return_data.size
                    _9657 = mem[_8727 + mem[_8727 + 32]]
                    if mem[_8727 + mem[_8727 + 32]] > test266151307():
                        revert with 0, 65
                    _9732 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8727 + mem[_8727 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8727 + mem[_8727 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8727 + mem[_8727 + 32]]) + 1
                    mem[_9732] = _9657
                    require _9528 + (32 * _9657) + 32 <= return_data.size
                    s = 0
                    t = _8727 + _9528 + 32
                    v = _9732 + 32
                    while s < _9657:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10445 = mem[_8727 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10445:
                        if s >= mem[_8727 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8727 + ceil32(return_data.size) + 32]
                        if s >= mem[_9732]:
                            revert with 0, 50
                        if t >= mem[_5620]:
                            revert with 0, 50
                        mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _9732 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10445 = mem[_8727 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8658 = mem[_5411]
            mem[mem[64] + 68] = mem[_5411]
            mem[mem[64] + 100 len 32 * _8658] = mem[_5411 + 32 len 32 * _8658]
            idx = _8658
            var66002 = _5411 + (32 * _8658) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8658) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9656 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9700 = mem[_9656]
            require mem[_9656] <= test266151307()
            require _9656 + mem[_9656] + 31 < _9656 + return_data.size
            _9765 = mem[_9656 + mem[_9656]]
            if mem[_9656 + mem[_9656]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9656 + mem[_9656]]) + 1 < 0 or _9656 + ceil32(return_data.size) + ceil32(32 * mem[_9656 + mem[_9656]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9656 + ceil32(return_data.size) + ceil32(32 * mem[_9656 + mem[_9656]]) + 1
            mem[_9656 + ceil32(return_data.size)] = _9765
            require _9700 + (32 * _9765) + 32 <= return_data.size
            mem[_9656 + ceil32(return_data.size) + 32 len 32 * _9765] = mem[_9656 + _9700 + 32 len 32 * _9765]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9765
            mem[mem[64] + 64 len 32 * _9765] = mem[_9656 + ceil32(return_data.size) + 32 len 32 * _9765]
            var93001 = _9765
            var93002 = _9656 + ceil32(return_data.size) + (32 * _9765) + 32
            return Array(len=_9765, data=mem[mem[64] + 64 len 32 * _9765])
        _6893 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6893:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7006 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7006 + 32 len mem[_7006]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6893 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5411]:
                revert with 0, 50
            mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5620]:
                revert with 0, 50
            mem[(32 * u) + _5620 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6893 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8427 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8427] = address(stor5[idx].field_0)
            mem[_8427 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8461 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9376 = mem[_8461]
                s = 0
                t = u
                while s < _9376:
                    if s >= mem[_8461]:
                        revert with 0, 50
                    if t >= mem[_5411]:
                        revert with 0, 50
                    mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8461 + 32]
                    if s >= mem[_8461 + 32]:
                        revert with 0, 50
                    if t >= mem[_5620]:
                        revert with 0, 50
                    mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _8461 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9376 = mem[_8461]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8724 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8787 = mem[_8724]
                require mem[_8724] <= test266151307()
                require _8724 + mem[_8724] + 31 < _8724 + return_data.size
                _8859 = mem[_8724 + mem[_8724]]
                if mem[_8724 + mem[_8724]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8724 + mem[_8724]]) + 1 < 0 or _8724 + ceil32(return_data.size) + ceil32(32 * mem[_8724 + mem[_8724]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8724 + ceil32(return_data.size) + ceil32(32 * mem[_8724 + mem[_8724]]) + 1
                mem[_8724 + ceil32(return_data.size)] = _8859
                require _8787 + (32 * _8859) + 32 <= return_data.size
                s = 0
                t = _8724 + _8787 + 32
                v = _8724 + ceil32(return_data.size) + 32
                while s < _8859:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9525 = mem[_8724 + 32]
                require mem[_8724 + 32] <= test266151307()
                require _8724 + mem[_8724 + 32] + 31 < _8724 + return_data.size
                _9655 = mem[_8724 + mem[_8724 + 32]]
                if mem[_8724 + mem[_8724 + 32]] > test266151307():
                    revert with 0, 65
                _9731 = mem[64]
                if mem[64] + ceil32(32 * mem[_8724 + mem[_8724 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8724 + mem[_8724 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8724 + mem[_8724 + 32]]) + 1
                mem[_9731] = _9655
                require _9525 + (32 * _9655) + 32 <= return_data.size
                s = 0
                t = _8724 + _9525 + 32
                v = _9731 + 32
                while s < _9655:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10444 = mem[_8724 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10444:
                    if s >= mem[_8724 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_5411]:
                        revert with 0, 50
                    mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8724 + ceil32(return_data.size) + 32]
                    if s >= mem[_9731]:
                        revert with 0, 50
                    if t >= mem[_5620]:
                        revert with 0, 50
                    mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _9731 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10444 = mem[_8724 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8656 = mem[_5411]
        mem[mem[64] + 68] = mem[_5411]
        mem[mem[64] + 100 len 32 * _8656] = mem[_5411 + 32 len 32 * _8656]
        idx = _8656
        var65002 = _5411 + (32 * _8656) + 32
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(stor9)
        staticcall stor9.0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8656) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9654 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9699 = mem[_9654]
        require mem[_9654] <= test266151307()
        require _9654 + mem[_9654] + 31 < _9654 + return_data.size
        _9764 = mem[_9654 + mem[_9654]]
        if mem[_9654 + mem[_9654]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9654 + mem[_9654]]) + 1 < 0 or _9654 + ceil32(return_data.size) + ceil32(32 * mem[_9654 + mem[_9654]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9654 + ceil32(return_data.size) + ceil32(32 * mem[_9654 + mem[_9654]]) + 1
        mem[_9654 + ceil32(return_data.size)] = _9764
        require _9699 + (32 * _9764) + 32 <= return_data.size
        mem[_9654 + ceil32(return_data.size) + 32 len 32 * _9764] = mem[_9654 + _9699 + 32 len 32 * _9764]
        var84001 = _9764
        var84002 = _9654 + _9699 + (32 * _9764) + 32
        var84004 = _9654 + ceil32(return_data.size) + (32 * _9764) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9764
        mem[mem[64] + 64 len 32 * _9764] = mem[_9654 + ceil32(return_data.size) + 32 len 32 * _9764]
        var92001 = _9764
        var92002 = _9654 + ceil32(return_data.size) + (32 * _9764) + 32
        return Array(len=_9764, data=mem[mem[64] + 64 len 32 * _9764])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
    idx = 0
    s = 0
    while idx < stor10[ext_call.return_data[31 len 1]].field_512:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _7035 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_7035 + 32 len mem[_7035]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = 5
        _8447 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8447] = address(stor5[idx].field_0)
        mem[_8447 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _8467 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            if t > !mem[_8467]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_8467]
            continue 
        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg1
        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        require ext_code.size(address(stor5[idx].field_256))
        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                gas gas_remaining wei
               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _8737 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 64
        _8801 = mem[_8737]
        require mem[_8737] <= test266151307()
        require _8737 + mem[_8737] + 31 < _8737 + return_data.size
        _8875 = mem[_8737 + mem[_8737]]
        if mem[_8737 + mem[_8737]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_8737 + mem[_8737]]) + 1 < 0 or _8737 + ceil32(return_data.size) + ceil32(32 * mem[_8737 + mem[_8737]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _8737 + ceil32(return_data.size) + ceil32(32 * mem[_8737 + mem[_8737]]) + 1
        mem[_8737 + ceil32(return_data.size)] = _8875
        require _8801 + (32 * _8875) + 32 <= return_data.size
        s = 0
        u = _8737 + _8801 + 32
        v = _8737 + ceil32(return_data.size) + 32
        while s < _8875:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        _9541 = mem[_8737 + 32]
        require mem[_8737 + 32] <= test266151307()
        require _8737 + mem[_8737 + 32] + 31 < _8737 + return_data.size
        _9662 = mem[_8737 + mem[_8737 + 32]]
        if mem[_8737 + mem[_8737 + 32]] > test266151307():
            revert with 0, 65
        _9755 = mem[64]
        if mem[64] + ceil32(32 * mem[_8737 + mem[_8737 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8737 + mem[_8737 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_8737 + mem[_8737 + 32]]) + 1
        mem[_9755] = _9662
        require _9541 + (32 * _9662) + 32 <= return_data.size
        s = 0
        u = _8737 + _9541 + 32
        v = _9755 + 32
        while s < _9662:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        if t > !mem[_8737 + ceil32(return_data.size)]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + mem[_8737 + ceil32(return_data.size)]
        continue 
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _8466 = mem[64]
    mem[mem[64]] = s + t
    if not s + t:
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _8736 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _8736 + (32 * s + t) + 32
        if not s + t:
            _9381 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _9381:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _9450 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_9450 + 32 len mem[_9450]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _9381 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_8466]:
                    revert with 0, 50
                mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_8736]:
                    revert with 0, 50
                mem[(32 * u) + _8736 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _9381 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _10128 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10128] = address(stor5[idx].field_0)
                mem[_10128 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _10147 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10448 = mem[_10147]
                    s = 0
                    t = u
                    while s < _10448:
                        if s >= mem[_10147]:
                            revert with 0, 50
                        if t >= mem[_8466]:
                            revert with 0, 50
                        mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10147 + 32]
                        if s >= mem[_10147 + 32]:
                            revert with 0, 50
                        if t >= mem[_8736]:
                            revert with 0, 50
                        mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10147 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10448 = mem[_10147]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _10308 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _10328 = mem[_10308]
                    require mem[_10308] <= test266151307()
                    require _10308 + mem[_10308] + 31 < _10308 + return_data.size
                    _10345 = mem[_10308 + mem[_10308]]
                    if mem[_10308 + mem[_10308]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_10308 + mem[_10308]]) + 1 < 0 or _10308 + ceil32(return_data.size) + ceil32(32 * mem[_10308 + mem[_10308]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _10308 + ceil32(return_data.size) + ceil32(32 * mem[_10308 + mem[_10308]]) + 1
                    mem[_10308 + ceil32(return_data.size)] = _10345
                    require _10328 + (32 * _10345) + 32 <= return_data.size
                    s = 0
                    t = _10308 + _10328 + 32
                    v = _10308 + ceil32(return_data.size) + 32
                    while s < _10345:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10512 = mem[_10308 + 32]
                    require mem[_10308 + 32] <= test266151307()
                    require _10308 + mem[_10308 + 32] + 31 < _10308 + return_data.size
                    _10589 = mem[_10308 + mem[_10308 + 32]]
                    if mem[_10308 + mem[_10308 + 32]] > test266151307():
                        revert with 0, 65
                    _10600 = mem[64]
                    if mem[64] + ceil32(32 * mem[_10308 + mem[_10308 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10308 + mem[_10308 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_10308 + mem[_10308 + 32]]) + 1
                    mem[_10600] = _10589
                    require _10512 + (32 * _10589) + 32 <= return_data.size
                    s = 0
                    t = _10308 + _10512 + 32
                    v = _10600 + 32
                    while s < _10589:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10716 = mem[_10308 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10716:
                        if s >= mem[_10308 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_8466]:
                            revert with 0, 50
                        mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10308 + ceil32(return_data.size) + 32]
                        if s >= mem[_10600]:
                            revert with 0, 50
                        if t >= mem[_8736]:
                            revert with 0, 50
                        mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10600 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10716 = mem[_10308 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _10264 = mem[_8466]
            mem[mem[64] + 68] = mem[_8466]
            mem[mem[64] + 100 len 32 * _10264] = mem[_8466 + 32 len 32 * _10264]
            idx = _10264
            var69002 = _8466 + (32 * _10264) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(stor9)
            staticcall stor9.0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10264) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10588 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10596 = mem[_10588]
            require mem[_10588] <= test266151307()
            require _10588 + mem[_10588] + 31 < _10588 + return_data.size
            _10604 = mem[_10588 + mem[_10588]]
            if mem[_10588 + mem[_10588]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10588 + mem[_10588]]) + 1 < 0 or _10588 + ceil32(return_data.size) + ceil32(32 * mem[_10588 + mem[_10588]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10588 + ceil32(return_data.size) + ceil32(32 * mem[_10588 + mem[_10588]]) + 1
            mem[_10588 + ceil32(return_data.size)] = _10604
            require _10596 + (32 * _10604) + 32 <= return_data.size
            mem[_10588 + ceil32(return_data.size) + 32 len 32 * _10604] = mem[_10588 + _10596 + 32 len 32 * _10604]
            var88001 = _10604
            var88002 = _10588 + _10596 + (32 * _10604) + 32
            var88004 = _10588 + ceil32(return_data.size) + (32 * _10604) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10604
            mem[mem[64] + 64 len 32 * _10604] = mem[_10588 + ceil32(return_data.size) + 32 len 32 * _10604]
            var96001 = _10604
            var96002 = _10588 + ceil32(return_data.size) + (32 * _10604) + 32
            return Array(len=_10604, data=mem[mem[64] + 64 len 32 * _10604])
        mem[_8736 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _9383 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _9383:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _9457 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_9457 + 32 len mem[_9457]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _9383 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_8466]:
                revert with 0, 50
            mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_8736]:
                revert with 0, 50
            mem[(32 * u) + _8736 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _9383 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _10133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10133] = address(stor5[idx].field_0)
            mem[_10133 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _10148 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10449 = mem[_10148]
                s = 0
                t = u
                while s < _10449:
                    if s >= mem[_10148]:
                        revert with 0, 50
                    if t >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10148 + 32]
                    if s >= mem[_10148 + 32]:
                        revert with 0, 50
                    if t >= mem[_8736]:
                        revert with 0, 50
                    mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10148 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10449 = mem[_10148]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10311 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _10331 = mem[_10311]
                require mem[_10311] <= test266151307()
                require _10311 + mem[_10311] + 31 < _10311 + return_data.size
                _10347 = mem[_10311 + mem[_10311]]
                if mem[_10311 + mem[_10311]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10311 + mem[_10311]]) + 1 < 0 or _10311 + ceil32(return_data.size) + ceil32(32 * mem[_10311 + mem[_10311]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10311 + ceil32(return_data.size) + ceil32(32 * mem[_10311 + mem[_10311]]) + 1
                mem[_10311 + ceil32(return_data.size)] = _10347
                require _10331 + (32 * _10347) + 32 <= return_data.size
                s = 0
                t = _10311 + _10331 + 32
                v = _10311 + ceil32(return_data.size) + 32
                while s < _10347:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10515 = mem[_10311 + 32]
                require mem[_10311 + 32] <= test266151307()
                require _10311 + mem[_10311 + 32] + 31 < _10311 + return_data.size
                _10591 = mem[_10311 + mem[_10311 + 32]]
                if mem[_10311 + mem[_10311 + 32]] > test266151307():
                    revert with 0, 65
                _10601 = mem[64]
                if mem[64] + ceil32(32 * mem[_10311 + mem[_10311 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10311 + mem[_10311 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_10311 + mem[_10311 + 32]]) + 1
                mem[_10601] = _10591
                require _10515 + (32 * _10591) + 32 <= return_data.size
                s = 0
                t = _10311 + _10515 + 32
                v = _10601 + 32
                while s < _10591:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10717 = mem[_10311 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10717:
                    if s >= mem[_10311 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10311 + ceil32(return_data.size) + 32]
                    if s >= mem[_10601]:
                        revert with 0, 50
                    if t >= mem[_8736]:
                        revert with 0, 50
                    mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10601 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10717 = mem[_10311 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _10266 = mem[_8466]
        mem[mem[64] + 68] = mem[_8466]
        mem[mem[64] + 100 len 32 * _10266] = mem[_8466 + 32 len 32 * _10266]
        idx = _10266
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(stor9)
        staticcall stor9.0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10266) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10590 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10597 = mem[_10590]
        require mem[_10590] <= test266151307()
        require _10590 + mem[_10590] + 31 < _10590 + return_data.size
        _10605 = mem[_10590 + mem[_10590]]
        if mem[_10590 + mem[_10590]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10590 + mem[_10590]]) + 1 < 0 or _10590 + ceil32(return_data.size) + ceil32(32 * mem[_10590 + mem[_10590]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10590 + ceil32(return_data.size) + ceil32(32 * mem[_10590 + mem[_10590]]) + 1
        mem[_10590 + ceil32(return_data.size)] = _10605
        require _10597 + (32 * _10605) + 32 <= return_data.size
        mem[_10590 + ceil32(return_data.size) + 32 len 32 * _10605] = mem[_10590 + _10597 + 32 len 32 * _10605]
        var89001 = _10605
        var89002 = _10590 + _10597 + (32 * _10605) + 32
        var89004 = _10590 + ceil32(return_data.size) + (32 * _10605) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10605
        mem[mem[64] + 64 len 32 * _10605] = mem[_10590 + ceil32(return_data.size) + 32 len 32 * _10605]
        var97001 = _10605
        var97002 = _10590 + ceil32(return_data.size) + (32 * _10605) + 32
        return Array(len=_10605, data=mem[mem[64] + 64 len 32 * _10605])
    mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    mem[mem[64] + (32 * s + t) + 32] = s + t
    mem[64] = _8466 + (64 * s + t) + 64
    if not s + t:
        _9385 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _9385:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _9464 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_9464 + 32 len mem[_9464]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _9385 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_8466]:
                revert with 0, 50
            mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_8466 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _8466 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _9385 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _10138 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10138] = address(stor5[idx].field_0)
            mem[_10138 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _10149 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10450 = mem[_10149]
                v = 0
                w = u
                while v < _10450:
                    if v >= mem[_10149]:
                        revert with 0, 50
                    if w >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10149 + 32]
                    if v >= mem[_10149 + 32]:
                        revert with 0, 50
                    if w >= mem[_8466 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10149 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10450 = mem[_10149]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10314 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _10334 = mem[_10314]
                require mem[_10314] <= test266151307()
                require _10314 + mem[_10314] + 31 < _10314 + return_data.size
                _10349 = mem[_10314 + mem[_10314]]
                if mem[_10314 + mem[_10314]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10314 + mem[_10314]]) + 1 < 0 or _10314 + ceil32(return_data.size) + ceil32(32 * mem[_10314 + mem[_10314]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10314 + ceil32(return_data.size) + ceil32(32 * mem[_10314 + mem[_10314]]) + 1
                mem[_10314 + ceil32(return_data.size)] = _10349
                require _10334 + (32 * _10349) + 32 <= return_data.size
                v = 0
                w = _10314 + _10334 + 32
                x = _10314 + ceil32(return_data.size) + 32
                while v < _10349:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10518 = mem[_10314 + 32]
                require mem[_10314 + 32] <= test266151307()
                require _10314 + mem[_10314 + 32] + 31 < _10314 + return_data.size
                _10593 = mem[_10314 + mem[_10314 + 32]]
                if mem[_10314 + mem[_10314 + 32]] > test266151307():
                    revert with 0, 65
                _10602 = mem[64]
                if mem[64] + ceil32(32 * mem[_10314 + mem[_10314 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10314 + mem[_10314 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_10314 + mem[_10314 + 32]]) + 1
                mem[_10602] = _10593
                require _10518 + (32 * _10593) + 32 <= return_data.size
                v = 0
                w = _10314 + _10518 + 32
                x = _10602 + 32
                while v < _10593:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10718 = mem[_10314 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _10718:
                    if v >= mem[_10314 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10314 + ceil32(return_data.size) + 32]
                    if v >= mem[_10602]:
                        revert with 0, 50
                    if w >= mem[_8466 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10602 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10718 = mem[_10314 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _10268 = mem[_8466]
        mem[mem[64] + 68] = mem[_8466]
        mem[mem[64] + 100 len 32 * _10268] = mem[_8466 + 32 len 32 * _10268]
        idx = _10268
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(stor9)
        staticcall stor9.0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10268) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10592 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10598 = mem[_10592]
        require mem[_10592] <= test266151307()
        require _10592 + mem[_10592] + 31 < _10592 + return_data.size
        _10606 = mem[_10592 + mem[_10592]]
        if mem[_10592 + mem[_10592]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10592 + mem[_10592]]) + 1 < 0 or _10592 + ceil32(return_data.size) + ceil32(32 * mem[_10592 + mem[_10592]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10592 + ceil32(return_data.size) + ceil32(32 * mem[_10592 + mem[_10592]]) + 1
        mem[_10592 + ceil32(return_data.size)] = _10606
        require _10598 + (32 * _10606) + 32 <= return_data.size
        mem[_10592 + ceil32(return_data.size) + 32 len 32 * _10606] = mem[_10592 + _10598 + 32 len 32 * _10606]
        var89001 = _10606
        var89002 = _10592 + _10598 + (32 * _10606) + 32
        var89004 = _10592 + ceil32(return_data.size) + (32 * _10606) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10606
        mem[mem[64] + 64 len 32 * _10606] = mem[_10592 + ceil32(return_data.size) + 32 len 32 * _10606]
        var97001 = _10606
        var97002 = _10592 + ceil32(return_data.size) + (32 * _10606) + 32
        return Array(len=_10606, data=mem[mem[64] + 64 len 32 * _10606])
    mem[_8466 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    _9387 = mem[mem[ceil32(return_data.size) + 160]]
    idx = 0
    u = 0
    while idx < _9387:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _9471 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_9471 + 32 len mem[_9471]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            _9387 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u
            continue 
        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
            revert with 0, 50
        if u >= mem[_8466]:
            revert with 0, 50
        mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
            revert with 0, 50
        if u >= mem[_8466 + (32 * s + t) + 32]:
            revert with 0, 50
        mem[(32 * u) + _8466 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
        if u == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        _9387 = mem[mem[ceil32(return_data.size) + 160]]
        idx = idx + 1
        u = u + 1
        continue 
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        _10143 = mem[64]
        mem[64] = mem[64] + 64
        mem[_10143] = address(stor5[idx].field_0)
        mem[_10143 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _10150 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            _10451 = mem[_10150]
            v = 0
            w = u
            while v < _10451:
                if v >= mem[_10150]:
                    revert with 0, 50
                if w >= mem[_8466]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10150 + 32]
                if v >= mem[_10150 + 32]:
                    revert with 0, 50
                if w >= mem[_8466 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10150 + 64]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _10451 = mem[_10150]
                v = v + 1
                w = w + 1
                continue 
        else:
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10317 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _10337 = mem[_10317]
            require mem[_10317] <= test266151307()
            require _10317 + mem[_10317] + 31 < _10317 + return_data.size
            _10351 = mem[_10317 + mem[_10317]]
            if mem[_10317 + mem[_10317]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10317 + mem[_10317]]) + 1 < 0 or _10317 + ceil32(return_data.size) + ceil32(32 * mem[_10317 + mem[_10317]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10317 + ceil32(return_data.size) + ceil32(32 * mem[_10317 + mem[_10317]]) + 1
            mem[_10317 + ceil32(return_data.size)] = _10351
            require _10337 + (32 * _10351) + 32 <= return_data.size
            v = 0
            w = _10317 + _10337 + 32
            x = _10317 + ceil32(return_data.size) + 32
            while v < _10351:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _10521 = mem[_10317 + 32]
            require mem[_10317 + 32] <= test266151307()
            require _10317 + mem[_10317 + 32] + 31 < _10317 + return_data.size
            _10595 = mem[_10317 + mem[_10317 + 32]]
            if mem[_10317 + mem[_10317 + 32]] > test266151307():
                revert with 0, 65
            _10603 = mem[64]
            if mem[64] + ceil32(32 * mem[_10317 + mem[_10317 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10317 + mem[_10317 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_10317 + mem[_10317 + 32]]) + 1
            mem[_10603] = _10595
            require _10521 + (32 * _10595) + 32 <= return_data.size
            v = 0
            w = _10317 + _10521 + 32
            x = _10603 + 32
            while v < _10595:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _10719 = mem[_10317 + ceil32(return_data.size)]
            v = 0
            w = u
            while v < _10719:
                if v >= mem[_10317 + ceil32(return_data.size)]:
                    revert with 0, 50
                if w >= mem[_8466]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10317 + ceil32(return_data.size) + 32]
                if v >= mem[_10603]:
                    revert with 0, 50
                if w >= mem[_8466 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10603 + 32]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _10719 = mem[_10317 + ceil32(return_data.size)]
                v = v + 1
                w = w + 1
                continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if s > !t:
        revert with 0, 17
    if u != s + t:
        revert with 0, 1
    if 0 >= stor9.length:
        revert with 0, 50
    mem[0] = arg1
    mem[32] = 1
    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 64
    _10270 = mem[_8466]
    mem[mem[64] + 68] = mem[_8466]
    mem[mem[64] + 100 len 32 * _10270] = mem[_8466 + 32 len 32 * _10270]
    idx = _10270
    var71002 = _8466 + (32 * _10270) + 32
    mem[mem[64] + 36] = stor1[arg1].field_512
    require ext_code.size(stor9)
    staticcall stor9.0x15d2cfca with:
            gas gas_remaining wei
           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10270) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _10594 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _10599 = mem[_10594]
    require mem[_10594] <= test266151307()
    require _10594 + mem[_10594] + 31 < _10594 + return_data.size
    _10607 = mem[_10594 + mem[_10594]]
    if mem[_10594 + mem[_10594]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_10594 + mem[_10594]]) + 1 < 0 or _10594 + ceil32(return_data.size) + ceil32(32 * mem[_10594 + mem[_10594]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _10594 + ceil32(return_data.size) + ceil32(32 * mem[_10594 + mem[_10594]]) + 1
    mem[_10594 + ceil32(return_data.size)] = _10607
    require _10599 + (32 * _10607) + 32 <= return_data.size
    mem[_10594 + ceil32(return_data.size) + 32 len 32 * _10607] = mem[_10594 + _10599 + 32 len 32 * _10607]
    var90001 = _10607
    var90002 = _10594 + _10599 + (32 * _10607) + 32
    var90004 = _10594 + ceil32(return_data.size) + (32 * _10607) + 32
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _10607
    mem[mem[64] + 64 len 32 * _10607] = mem[_10594 + ceil32(return_data.size) + 32 len 32 * _10607]
    var98001 = _10607
    var98002 = _10594 + ceil32(return_data.size) + (32 * _10607) + 32
    return Array(len=_10607, data=mem[mem[64] + 64 len 32 * _10607])
}

function sub_d29b478e(?) {
    require calldata.size - 4 >= 64
    require arg2 < stor5.length
    if not stor1[arg1].field_512:
        mem[96] = 0
        mem[128] = 0
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[160] = address(stor5[arg2].field_0)
        mem[192] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            return ''
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[224] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[228] = 96
        mem[324] = 0
        mem[356 len 0] = None
        mem[260] = arg1
        mem[292] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[224 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 224
        require return_data.size >= 32
        _167 = mem[224 len 4], 0
        require mem[224 len 4], 0 <= test266151307()
        require mem[224 len 4], 0 + 255 < return_data.size + 224
        _172 = mem[mem[224 len 4], 0 + 224]
        if mem[mem[224 len 4], 0 + 224] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[mem[224 len 4], 0 + 224]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[224 len 4], 0 + 224]) + 225 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[224 len 4], 0 + 224]) + 225
        mem[ceil32(return_data.size) + 224] = mem[mem[224 len 4], 0 + 224]
        require _167 + (32 * _172) + 32 <= return_data.size
        mem[ceil32(return_data.size) + 256 len 32 * _172] = mem[_167 + 256 len 32 * _172]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _172
        mem[mem[64] + 64 len 32 * _172] = mem[ceil32(return_data.size) + 256 len 32 * _172]
        return Array(len=_172, data=mem[mem[64] + 64 len 32 * _172])
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    mem[0] = ext_call.return_data[31 len 1]
    mem[32] = 10
    mem[ceil32(return_data.size) + 192] = stor10[ext_call.return_data[31 len 1]].field_0
    if not stor10[ext_call.return_data[31 len 1]].field_0:
        mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
        if not stor10[ext_call.return_data[31 len 1]].field_256:
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
            mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
            if not stor10[ext_call.return_data[31 len 1]].field_512:
                mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
                idx = 0
                s = 0
                while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _149 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_149 + 32 len mem[_149]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                idx = 0
                t = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_516] = address(stor5[idx].field_0)
                    mem[_516 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _530 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        if t > !mem[_530]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + mem[_530]
                        continue 
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _558 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _570 = mem[_558]
                    require mem[_558] <= test266151307()
                    require _558 + mem[_558] + 31 < _558 + return_data.size
                    _619 = mem[_558 + mem[_558]]
                    if mem[_558 + mem[_558]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_558 + mem[_558]]) + 1 < 0 or _558 + ceil32(return_data.size) + ceil32(32 * mem[_558 + mem[_558]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _558 + ceil32(return_data.size) + ceil32(32 * mem[_558 + mem[_558]]) + 1
                    mem[_558 + ceil32(return_data.size)] = _619
                    require _570 + (32 * _619) + 32 <= return_data.size
                    s = 0
                    u = _558 + _570 + 32
                    v = _558 + ceil32(return_data.size) + 32
                    while s < _619:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    _1204 = mem[_558 + 32]
                    require mem[_558 + 32] <= test266151307()
                    require _558 + mem[_558 + 32] + 31 < _558 + return_data.size
                    _1209 = mem[_558 + mem[_558 + 32]]
                    if mem[_558 + mem[_558 + 32]] > test266151307():
                        revert with 0, 65
                    _1307 = mem[64]
                    if mem[64] + ceil32(32 * mem[_558 + mem[_558 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_558 + mem[_558 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_558 + mem[_558 + 32]]) + 1
                    mem[_1307] = _1209
                    require _1204 + (32 * _1209) + 32 <= return_data.size
                    s = 0
                    u = _558 + _1204 + 32
                    v = _1307 + 32
                    while s < _1209:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    if t > !mem[_558 + ceil32(return_data.size)]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_558 + ceil32(return_data.size)]
                    continue 
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _529 = mem[64]
                mem[mem[64]] = s + t
                if not s + t:
                    if s > !t:
                        revert with 0, 17
                    if s + t > test266151307():
                        revert with 0, 65
                    _557 = mem[64] + (32 * s + t) + 32
                    mem[mem[64] + (32 * s + t) + 32] = s + t
                    mem[64] = _557 + (32 * s + t) + 32
                    if not s + t:
                        _1136 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = 0
                        u = 0
                        while idx < _1136:
                            mem[0] = arg1
                            mem[32] = 1
                            mem[mem[64] + 32] = idx
                            mem[mem[64] + 64] = stor1[arg1].field_512
                            mem[mem[64] + 96] = stor8
                            _1151 = mem[64]
                            mem[mem[64]] = 96
                            mem[64] = mem[64] + 128
                            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                                revert with 0, 50
                            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                revert with 0, 18
                            if sha3(mem[_1151 + 32 len mem[_1151]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                u = u
                                continue 
                            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                                revert with 0, 50
                            if u >= mem[_529]:
                                revert with 0, 50
                            mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            if u >= mem[_557]:
                                revert with 0, 50
                            mem[(32 * u) + _557 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if u == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u + 1
                            continue 
                        idx = 0
                        while idx < stor5.length:
                            mem[0] = 5
                            _2459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2459] = address(stor5[idx].field_0)
                            mem[_2459 + 32] = address(stor5[idx].field_256)
                            mem[0] = address(stor5[idx].field_0)
                            mem[32] = sha3(arg1, 1) + 3
                            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                                _2494 = mem[64]
                                mem[mem[64]] = 0
                                mem[mem[64] + 32] = 0
                                mem[64] = mem[64] + 64
                                _3929 = mem[_2494]
                                s = 0
                                t = u
                                while s < _3929:
                                    if s >= mem[_2494]:
                                        revert with 0, 50
                                    if t >= mem[_529]:
                                        revert with 0, 50
                                    mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2494 + 32]
                                    if s >= mem[_2494 + 32]:
                                        revert with 0, 50
                                    if t >= mem[_557]:
                                        revert with 0, 50
                                    mem[(32 * t) + _557 + 32] = mem[(32 * s) + _2494 + 64]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            else:
                                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = arg1
                                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                require ext_code.size(address(stor5[idx].field_256))
                                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                        gas gas_remaining wei
                                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2587 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _2629 = mem[_2587]
                                require mem[_2587] <= test266151307()
                                require _2587 + mem[_2587] + 31 < _2587 + return_data.size
                                _2755 = mem[_2587 + mem[_2587]]
                                if mem[_2587 + mem[_2587]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2587 + mem[_2587]]) + 1 < 0 or _2587 + ceil32(return_data.size) + ceil32(32 * mem[_2587 + mem[_2587]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2587 + ceil32(return_data.size) + ceil32(32 * mem[_2587 + mem[_2587]]) + 1
                                mem[_2587 + ceil32(return_data.size)] = _2755
                                require _2629 + (32 * _2755) + 32 <= return_data.size
                                s = 0
                                t = _2587 + _2629 + 32
                                v = _2587 + ceil32(return_data.size) + 32
                                while s < _2755:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _4087 = mem[_2587 + 32]
                                require mem[_2587 + 32] <= test266151307()
                                require _2587 + mem[_2587 + 32] + 31 < _2587 + return_data.size
                                _4138 = mem[_2587 + mem[_2587 + 32]]
                                if mem[_2587 + mem[_2587 + 32]] > test266151307():
                                    revert with 0, 65
                                _4317 = mem[64]
                                if mem[64] + ceil32(32 * mem[_2587 + mem[_2587 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2587 + mem[_2587 + 32]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + ceil32(32 * mem[_2587 + mem[_2587 + 32]]) + 1
                                mem[_4317] = _4138
                                require _4087 + (32 * _4138) + 32 <= return_data.size
                                s = 0
                                t = _2587 + _4087 + 32
                                v = _4317 + 32
                                while s < _4138:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _7743 = mem[_2587 + ceil32(return_data.size)]
                                s = 0
                                t = u
                                while s < _7743:
                                    if s >= mem[_2587 + ceil32(return_data.size)]:
                                        revert with 0, 50
                                    if t >= mem[_529]:
                                        revert with 0, 50
                                    mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2587 + ceil32(return_data.size) + 32]
                                    if s >= mem[_4317]:
                                        revert with 0, 50
                                    if t >= mem[_557]:
                                        revert with 0, 50
                                    mem[(32 * t) + _557 + 32] = mem[(32 * s) + _4317 + 32]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    _7743 = mem[_2587 + ceil32(return_data.size)]
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if s > !t:
                            revert with 0, 17
                        if u != s + t:
                            revert with 0, 1
                        if arg2 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        _2506 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2506] = address(stor5[arg2].field_0)
                        mem[_2506 + 32] = address(stor5[arg2].field_256)
                        mem[0] = address(stor5[arg2].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                            _2539 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_2539 + 32] = 32
                            mem[_2539 + 64] = mem[_2539]
                            mem[_2539 + 96 len 32 * mem[_2539]] = mem[_2539 + 32 len 32 * mem[_2539]]
                            return memory
                              from mem[64]
                               len _2539 + (32 * mem[_2539]) + -mem[64] + 96
                        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                            revert with 0, 17
                        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 96
                        _2656 = mem[_529]
                        mem[mem[64] + 100] = mem[_529]
                        mem[mem[64] + 132 len 32 * _2656] = mem[_529 + 32 len 32 * _2656]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[arg2].field_256))
                        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                                gas gas_remaining wei
                               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2656) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4137 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4247 = mem[_4137]
                        require mem[_4137] <= test266151307()
                        require _4137 + mem[_4137] + 31 < _4137 + return_data.size
                        _4411 = mem[_4137 + mem[_4137]]
                        if mem[_4137 + mem[_4137]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4137 + mem[_4137]]) + 1 < 0 or _4137 + ceil32(return_data.size) + ceil32(32 * mem[_4137 + mem[_4137]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4137 + ceil32(return_data.size) + ceil32(32 * mem[_4137 + mem[_4137]]) + 1
                        mem[_4137 + ceil32(return_data.size)] = _4411
                        require _4247 + (32 * _4411) + 32 <= return_data.size
                        mem[_4137 + ceil32(return_data.size) + 32 len 32 * _4411] = mem[_4137 + _4247 + 32 len 32 * _4411]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _4411
                        mem[mem[64] + 64 len 32 * _4411] = mem[_4137 + ceil32(return_data.size) + 32 len 32 * _4411]
                        return Array(len=_4411, data=mem[mem[64] + 64 len 32 * _4411])
                    mem[_557 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _1138 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1138:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1158 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1158 + 32 len mem[_1158]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_529]:
                            revert with 0, 50
                        mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_557]:
                            revert with 0, 50
                        mem[(32 * u) + _557 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2464] = address(stor5[idx].field_0)
                        mem[_2464 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2495 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3930 = mem[_2495]
                            s = 0
                            t = u
                            while s < _3930:
                                if s >= mem[_2495]:
                                    revert with 0, 50
                                if t >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2495 + 32]
                                if s >= mem[_2495 + 32]:
                                    revert with 0, 50
                                if t >= mem[_557]:
                                    revert with 0, 50
                                mem[(32 * t) + _557 + 32] = mem[(32 * s) + _2495 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2591 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2633 = mem[_2591]
                            require mem[_2591] <= test266151307()
                            require _2591 + mem[_2591] + 31 < _2591 + return_data.size
                            _2757 = mem[_2591 + mem[_2591]]
                            if mem[_2591 + mem[_2591]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2591 + mem[_2591]]) + 1 < 0 or _2591 + ceil32(return_data.size) + ceil32(32 * mem[_2591 + mem[_2591]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2591 + ceil32(return_data.size) + ceil32(32 * mem[_2591 + mem[_2591]]) + 1
                            mem[_2591 + ceil32(return_data.size)] = _2757
                            require _2633 + (32 * _2757) + 32 <= return_data.size
                            s = 0
                            t = _2591 + _2633 + 32
                            v = _2591 + ceil32(return_data.size) + 32
                            while s < _2757:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _4090 = mem[_2591 + 32]
                            require mem[_2591 + 32] <= test266151307()
                            require _2591 + mem[_2591 + 32] + 31 < _2591 + return_data.size
                            _4140 = mem[_2591 + mem[_2591 + 32]]
                            if mem[_2591 + mem[_2591 + 32]] > test266151307():
                                revert with 0, 65
                            _4318 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2591 + mem[_2591 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2591 + mem[_2591 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2591 + mem[_2591 + 32]]) + 1
                            mem[_4318] = _4140
                            require _4090 + (32 * _4140) + 32 <= return_data.size
                            s = 0
                            t = _2591 + _4090 + 32
                            v = _4318 + 32
                            while s < _4140:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7744 = mem[_2591 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _7744:
                                if s >= mem[_2591 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2591 + ceil32(return_data.size) + 32]
                                if s >= mem[_4318]:
                                    revert with 0, 50
                                if t >= mem[_557]:
                                    revert with 0, 50
                                mem[(32 * t) + _557 + 32] = mem[(32 * s) + _4318 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _7744 = mem[_2591 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _2511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2511] = address(stor5[arg2].field_0)
                    mem[_2511 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _2545 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_2545 + 32] = 32
                        mem[_2545 + 64] = mem[_2545]
                        mem[_2545 + 96 len 32 * mem[_2545]] = mem[_2545 + 32 len 32 * mem[_2545]]
                        return memory
                          from mem[64]
                           len _2545 + (32 * mem[_2545]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _2657 = mem[_529]
                    mem[mem[64] + 100] = mem[_529]
                    mem[mem[64] + 132 len 32 * _2657] = mem[_529 + 32 len 32 * _2657]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2657) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4139 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _4248 = mem[_4139]
                    require mem[_4139] <= test266151307()
                    require _4139 + mem[_4139] + 31 < _4139 + return_data.size
                    _4412 = mem[_4139 + mem[_4139]]
                    if mem[_4139 + mem[_4139]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4139 + mem[_4139]]) + 1 < 0 or _4139 + ceil32(return_data.size) + ceil32(32 * mem[_4139 + mem[_4139]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4139 + ceil32(return_data.size) + ceil32(32 * mem[_4139 + mem[_4139]]) + 1
                    mem[_4139 + ceil32(return_data.size)] = _4412
                    require _4248 + (32 * _4412) + 32 <= return_data.size
                    mem[_4139 + ceil32(return_data.size) + 32 len 32 * _4412] = mem[_4139 + _4248 + 32 len 32 * _4412]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _4412
                    mem[mem[64] + 64 len 32 * _4412] = mem[_4139 + ceil32(return_data.size) + 32 len 32 * _4412]
                    return Array(len=_4412, data=mem[mem[64] + 64 len 32 * _4412])
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _529 + (64 * s + t) + 64
                if not s + t:
                    _1140 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1140:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1165 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1165 + 32 len mem[_1165]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_529]:
                            revert with 0, 50
                        mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_529 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _529 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2469 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2469] = address(stor5[idx].field_0)
                        mem[_2469 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2496 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3931 = mem[_2496]
                            v = 0
                            w = u
                            while v < _3931:
                                if v >= mem[_2496]:
                                    revert with 0, 50
                                if w >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2496 + 32]
                                if v >= mem[_2496 + 32]:
                                    revert with 0, 50
                                if w >= mem[_529 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _2496 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2595 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2637 = mem[_2595]
                            require mem[_2595] <= test266151307()
                            require _2595 + mem[_2595] + 31 < _2595 + return_data.size
                            _2759 = mem[_2595 + mem[_2595]]
                            if mem[_2595 + mem[_2595]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2595 + mem[_2595]]) + 1 < 0 or _2595 + ceil32(return_data.size) + ceil32(32 * mem[_2595 + mem[_2595]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2595 + ceil32(return_data.size) + ceil32(32 * mem[_2595 + mem[_2595]]) + 1
                            mem[_2595 + ceil32(return_data.size)] = _2759
                            require _2637 + (32 * _2759) + 32 <= return_data.size
                            v = 0
                            w = _2595 + _2637 + 32
                            x = _2595 + ceil32(return_data.size) + 32
                            while v < _2759:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _4093 = mem[_2595 + 32]
                            require mem[_2595 + 32] <= test266151307()
                            require _2595 + mem[_2595 + 32] + 31 < _2595 + return_data.size
                            _4142 = mem[_2595 + mem[_2595 + 32]]
                            if mem[_2595 + mem[_2595 + 32]] > test266151307():
                                revert with 0, 65
                            _4319 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2595 + mem[_2595 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2595 + mem[_2595 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2595 + mem[_2595 + 32]]) + 1
                            mem[_4319] = _4142
                            require _4093 + (32 * _4142) + 32 <= return_data.size
                            v = 0
                            w = _2595 + _4093 + 32
                            x = _4319 + 32
                            while v < _4142:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7745 = mem[_2595 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _7745:
                                if v >= mem[_2595 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2595 + ceil32(return_data.size) + 32]
                                if v >= mem[_4319]:
                                    revert with 0, 50
                                if w >= mem[_529 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _4319 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _7745 = mem[_2595 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _2516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2516] = address(stor5[arg2].field_0)
                    mem[_2516 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _2551 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_2551 + 32] = 32
                        mem[_2551 + 64] = mem[_2551]
                        mem[_2551 + 96 len 32 * mem[_2551]] = mem[_2551 + 32 len 32 * mem[_2551]]
                        return memory
                          from mem[64]
                           len _2551 + (32 * mem[_2551]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _2658 = mem[_529]
                    mem[mem[64] + 100] = mem[_529]
                    mem[mem[64] + 132 len 32 * _2658] = mem[_529 + 32 len 32 * _2658]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2658) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4141 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _4249 = mem[_4141]
                    require mem[_4141] <= test266151307()
                    require _4141 + mem[_4141] + 31 < _4141 + return_data.size
                    _4413 = mem[_4141 + mem[_4141]]
                    if mem[_4141 + mem[_4141]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4141 + mem[_4141]]) + 1 < 0 or _4141 + ceil32(return_data.size) + ceil32(32 * mem[_4141 + mem[_4141]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4141 + ceil32(return_data.size) + ceil32(32 * mem[_4141 + mem[_4141]]) + 1
                    mem[_4141 + ceil32(return_data.size)] = _4413
                    require _4249 + (32 * _4413) + 32 <= return_data.size
                    mem[_4141 + ceil32(return_data.size) + 32 len 32 * _4413] = mem[_4141 + _4249 + 32 len 32 * _4413]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _4413
                    mem[mem[64] + 64 len 32 * _4413] = mem[_4141 + ceil32(return_data.size) + 32 len 32 * _4413]
                    return Array(len=_4413, data=mem[mem[64] + 64 len 32 * _4413])
                mem[_529 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _1142 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _1142:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _1172 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_1172 + 32 len mem[_1172]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_529]:
                        revert with 0, 50
                    mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_529 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _529 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _2474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2474] = address(stor5[idx].field_0)
                    mem[_2474 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _2497 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _3932 = mem[_2497]
                        v = 0
                        w = u
                        while v < _3932:
                            if v >= mem[_2497]:
                                revert with 0, 50
                            if w >= mem[_529]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2497 + 32]
                            if v >= mem[_2497 + 32]:
                                revert with 0, 50
                            if w >= mem[_529 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _2497 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2599 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _2641 = mem[_2599]
                        require mem[_2599] <= test266151307()
                        require _2599 + mem[_2599] + 31 < _2599 + return_data.size
                        _2761 = mem[_2599 + mem[_2599]]
                        if mem[_2599 + mem[_2599]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2599 + mem[_2599]]) + 1 < 0 or _2599 + ceil32(return_data.size) + ceil32(32 * mem[_2599 + mem[_2599]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2599 + ceil32(return_data.size) + ceil32(32 * mem[_2599 + mem[_2599]]) + 1
                        mem[_2599 + ceil32(return_data.size)] = _2761
                        require _2641 + (32 * _2761) + 32 <= return_data.size
                        v = 0
                        w = _2599 + _2641 + 32
                        x = _2599 + ceil32(return_data.size) + 32
                        while v < _2761:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _4096 = mem[_2599 + 32]
                        require mem[_2599 + 32] <= test266151307()
                        require _2599 + mem[_2599 + 32] + 31 < _2599 + return_data.size
                        _4144 = mem[_2599 + mem[_2599 + 32]]
                        if mem[_2599 + mem[_2599 + 32]] > test266151307():
                            revert with 0, 65
                        _4320 = mem[64]
                        if mem[64] + ceil32(32 * mem[_2599 + mem[_2599 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2599 + mem[_2599 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_2599 + mem[_2599 + 32]]) + 1
                        mem[_4320] = _4144
                        require _4096 + (32 * _4144) + 32 <= return_data.size
                        v = 0
                        w = _2599 + _4096 + 32
                        x = _4320 + 32
                        while v < _4144:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7746 = mem[_2599 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _7746:
                            if v >= mem[_2599 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_529]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2599 + ceil32(return_data.size) + 32]
                            if v >= mem[_4320]:
                                revert with 0, 50
                            if w >= mem[_529 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _4320 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7746 = mem[_2599 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _2521 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2521] = address(stor5[arg2].field_0)
                mem[_2521 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _2557 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_2557 + 32] = 32
                    mem[_2557 + 64] = mem[_2557]
                    mem[_2557 + 96 len 32 * mem[_2557]] = mem[_2557 + 32 len 32 * mem[_2557]]
                    return memory
                      from mem[64]
                       len _2557 + (32 * mem[_2557]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _2659 = mem[_529]
                mem[mem[64] + 100] = mem[_529]
                mem[mem[64] + 132 len 32 * _2659] = mem[_529 + 32 len 32 * _2659]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2659) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4143 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4250 = mem[_4143]
                require mem[_4143] <= test266151307()
                require _4143 + mem[_4143] + 31 < _4143 + return_data.size
                _4414 = mem[_4143 + mem[_4143]]
                if mem[_4143 + mem[_4143]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_4143 + mem[_4143]]) + 1 < 0 or _4143 + ceil32(return_data.size) + ceil32(32 * mem[_4143 + mem[_4143]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _4143 + ceil32(return_data.size) + ceil32(32 * mem[_4143 + mem[_4143]]) + 1
                mem[_4143 + ceil32(return_data.size)] = _4414
                require _4250 + (32 * _4414) + 32 <= return_data.size
                mem[_4143 + ceil32(return_data.size) + 32 len 32 * _4414] = mem[_4143 + _4250 + 32 len 32 * _4414]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _4414
                mem[mem[64] + 64 len 32 * _4414] = mem[_4143 + ceil32(return_data.size) + 32 len 32 * _4414]
                return Array(len=_4414, data=mem[mem[64] + 64 len 32 * _4414])
            mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
            idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
            s = 0
            while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
                mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1180 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1180 + 32 len mem[_1180]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2479 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2479] = address(stor5[idx].field_0)
                mem[_2479 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2500 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2500]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2500]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2603 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2646 = mem[_2603]
                require mem[_2603] <= test266151307()
                require _2603 + mem[_2603] + 31 < _2603 + return_data.size
                _2771 = mem[_2603 + mem[_2603]]
                if mem[_2603 + mem[_2603]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2603 + mem[_2603]]) + 1 < 0 or _2603 + ceil32(return_data.size) + ceil32(32 * mem[_2603 + mem[_2603]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2603 + ceil32(return_data.size) + ceil32(32 * mem[_2603 + mem[_2603]]) + 1
                mem[_2603 + ceil32(return_data.size)] = _2771
                require _2646 + (32 * _2771) + 32 <= return_data.size
                s = 0
                u = _2603 + _2646 + 32
                v = _2603 + ceil32(return_data.size) + 32
                while s < _2771:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _4103 = mem[_2603 + 32]
                require mem[_2603 + 32] <= test266151307()
                require _2603 + mem[_2603 + 32] + 31 < _2603 + return_data.size
                _4145 = mem[_2603 + mem[_2603 + 32]]
                if mem[_2603 + mem[_2603 + 32]] > test266151307():
                    revert with 0, 65
                _4349 = mem[64]
                if mem[64] + ceil32(32 * mem[_2603 + mem[_2603 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2603 + mem[_2603 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2603 + mem[_2603 + 32]]) + 1
                mem[_4349] = _4145
                require _4103 + (32 * _4145) + 32 <= return_data.size
                s = 0
                u = _2603 + _4103 + 32
                v = _4349 + 32
                while s < _4145:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2603 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2603 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2499 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2499 + (64 * s + t) + 64
                if not s + t:
                    _3938 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3938:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3995 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3995 + 32 len mem[_3995]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3938 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2499]:
                            revert with 0, 50
                        mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2499 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2499 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3938 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5986] = address(stor5[idx].field_0)
                        mem[_5986 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _6052 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _7749 = mem[_6052]
                            v = 0
                            w = u
                            while v < _7749:
                                if v >= mem[_6052]:
                                    revert with 0, 50
                                if w >= mem[_2499]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6052 + 32]
                                if v >= mem[_6052 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2499 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _6052 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _7749 = mem[_6052]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6283 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _6368 = mem[_6283]
                            require mem[_6283] <= test266151307()
                            require _6283 + mem[_6283] + 31 < _6283 + return_data.size
                            _6531 = mem[_6283 + mem[_6283]]
                            if mem[_6283 + mem[_6283]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_6283 + mem[_6283]]) + 1 < 0 or _6283 + ceil32(return_data.size) + ceil32(32 * mem[_6283 + mem[_6283]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _6283 + ceil32(return_data.size) + ceil32(32 * mem[_6283 + mem[_6283]]) + 1
                            mem[_6283 + ceil32(return_data.size)] = _6531
                            require _6368 + (32 * _6531) + 32 <= return_data.size
                            v = 0
                            w = _6283 + _6368 + 32
                            x = _6283 + ceil32(return_data.size) + 32
                            while v < _6531:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7949 = mem[_6283 + 32]
                            require mem[_6283 + 32] <= test266151307()
                            require _6283 + mem[_6283 + 32] + 31 < _6283 + return_data.size
                            _8076 = mem[_6283 + mem[_6283 + 32]]
                            if mem[_6283 + mem[_6283 + 32]] > test266151307():
                                revert with 0, 65
                            _8263 = mem[64]
                            if mem[64] + ceil32(32 * mem[_6283 + mem[_6283 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6283 + mem[_6283 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_6283 + mem[_6283 + 32]]) + 1
                            mem[_8263] = _8076
                            require _7949 + (32 * _8076) + 32 <= return_data.size
                            v = 0
                            w = _6283 + _7949 + 32
                            x = _8263 + 32
                            while v < _8076:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _10553 = mem[_6283 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _10553:
                                if v >= mem[_6283 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2499]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6283 + ceil32(return_data.size) + 32]
                                if v >= mem[_8263]:
                                    revert with 0, 50
                                if w >= mem[_2499 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _8263 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _10553 = mem[_6283 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _6094 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6094] = address(stor5[arg2].field_0)
                    mem[_6094 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _6176 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_6176 + 32] = 32
                        mem[_6176 + 64] = mem[_6176]
                        mem[_6176 + 96 len 32 * mem[_6176]] = mem[_6176 + 32 len 32 * mem[_6176]]
                        var66001 = mem[_6176]
                        var66002 = _6176 + (32 * mem[_6176]) + 32
                        return memory
                          from mem[64]
                           len _6176 + (32 * mem[_6176]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _6418 = mem[_2499]
                    mem[mem[64] + 100] = mem[_2499]
                    mem[mem[64] + 132 len 32 * _6418] = mem[_2499 + 32 len 32 * _6418]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6418) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8075 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8189 = mem[_8075]
                    require mem[_8075] <= test266151307()
                    require _8075 + mem[_8075] + 31 < _8075 + return_data.size
                    _8363 = mem[_8075 + mem[_8075]]
                    if mem[_8075 + mem[_8075]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8075 + mem[_8075]]) + 1 < 0 or _8075 + ceil32(return_data.size) + ceil32(32 * mem[_8075 + mem[_8075]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8075 + ceil32(return_data.size) + ceil32(32 * mem[_8075 + mem[_8075]]) + 1
                    mem[_8075 + ceil32(return_data.size)] = _8363
                    require _8189 + (32 * _8363) + 32 <= return_data.size
                    mem[_8075 + ceil32(return_data.size) + 32 len 32 * _8363] = mem[_8075 + _8189 + 32 len 32 * _8363]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _8363
                    mem[mem[64] + 64 len 32 * _8363] = mem[_8075 + ceil32(return_data.size) + 32 len 32 * _8363]
                    return Array(len=_8363, data=mem[mem[64] + 64 len 32 * _8363])
                mem[_2499 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3940 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3940:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4002 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4002 + 32 len mem[_4002]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3940 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2499]:
                        revert with 0, 50
                    mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2499 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2499 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3940 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5991 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5991] = address(stor5[idx].field_0)
                    mem[_5991 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6053 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7750 = mem[_6053]
                        v = 0
                        w = u
                        while v < _7750:
                            if v >= mem[_6053]:
                                revert with 0, 50
                            if w >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6053 + 32]
                            if v >= mem[_6053 + 32]:
                                revert with 0, 50
                            if w >= mem[_2499 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _6053 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7750 = mem[_6053]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6287 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6372 = mem[_6287]
                        require mem[_6287] <= test266151307()
                        require _6287 + mem[_6287] + 31 < _6287 + return_data.size
                        _6533 = mem[_6287 + mem[_6287]]
                        if mem[_6287 + mem[_6287]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6287 + mem[_6287]]) + 1 < 0 or _6287 + ceil32(return_data.size) + ceil32(32 * mem[_6287 + mem[_6287]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6287 + ceil32(return_data.size) + ceil32(32 * mem[_6287 + mem[_6287]]) + 1
                        mem[_6287 + ceil32(return_data.size)] = _6533
                        require _6372 + (32 * _6533) + 32 <= return_data.size
                        v = 0
                        w = _6287 + _6372 + 32
                        x = _6287 + ceil32(return_data.size) + 32
                        while v < _6533:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7952 = mem[_6287 + 32]
                        require mem[_6287 + 32] <= test266151307()
                        require _6287 + mem[_6287 + 32] + 31 < _6287 + return_data.size
                        _8078 = mem[_6287 + mem[_6287 + 32]]
                        if mem[_6287 + mem[_6287 + 32]] > test266151307():
                            revert with 0, 65
                        _8264 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6287 + mem[_6287 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6287 + mem[_6287 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6287 + mem[_6287 + 32]]) + 1
                        mem[_8264] = _8078
                        require _7952 + (32 * _8078) + 32 <= return_data.size
                        v = 0
                        w = _6287 + _7952 + 32
                        x = _8264 + 32
                        while v < _8078:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10554 = mem[_6287 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10554:
                            if v >= mem[_6287 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6287 + ceil32(return_data.size) + 32]
                            if v >= mem[_8264]:
                                revert with 0, 50
                            if w >= mem[_2499 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _8264 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10554 = mem[_6287 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6099 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6099] = address(stor5[arg2].field_0)
                mem[_6099 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6182 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6182 + 32] = 32
                    mem[_6182 + 64] = mem[_6182]
                    mem[_6182 + 96 len 32 * mem[_6182]] = mem[_6182 + 32 len 32 * mem[_6182]]
                    return memory
                      from mem[64]
                       len _6182 + (32 * mem[_6182]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6419 = mem[_2499]
                mem[mem[64] + 100] = mem[_2499]
                mem[mem[64] + 132 len 32 * _6419] = mem[_2499 + 32 len 32 * _6419]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6419) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8077 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8190 = mem[_8077]
                require mem[_8077] <= test266151307()
                require _8077 + mem[_8077] + 31 < _8077 + return_data.size
                _8364 = mem[_8077 + mem[_8077]]
                if mem[_8077 + mem[_8077]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8077 + mem[_8077]]) + 1 < 0 or _8077 + ceil32(return_data.size) + ceil32(32 * mem[_8077 + mem[_8077]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8077 + ceil32(return_data.size) + ceil32(32 * mem[_8077 + mem[_8077]]) + 1
                mem[_8077 + ceil32(return_data.size)] = _8364
                require _8190 + (32 * _8364) + 32 <= return_data.size
                mem[_8077 + ceil32(return_data.size) + 32 len 32 * _8364] = mem[_8077 + _8190 + 32 len 32 * _8364]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8364
                mem[mem[64] + 64 len 32 * _8364] = mem[_8077 + ceil32(return_data.size) + 32 len 32 * _8364]
                return Array(len=_8364, data=mem[mem[64] + 64 len 32 * _8364])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2602 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2602 + (32 * s + t) + 32
            if s + t:
                mem[_2602 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3936 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3936:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3988 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3988 + 32 len mem[_3988]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3936 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2499]:
                        revert with 0, 50
                    mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2602]:
                        revert with 0, 50
                    mem[(32 * u) + _2602 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3936 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5981 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5981] = address(stor5[idx].field_0)
                    mem[_5981 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6051 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7748 = mem[_6051]
                        s = 0
                        t = u
                        while s < _7748:
                            if s >= mem[_6051]:
                                revert with 0, 50
                            if t >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6051 + 32]
                            if s >= mem[_6051 + 32]:
                                revert with 0, 50
                            if t >= mem[_2602]:
                                revert with 0, 50
                            mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _6051 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _7748 = mem[_6051]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6279 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6364 = mem[_6279]
                        require mem[_6279] <= test266151307()
                        require _6279 + mem[_6279] + 31 < _6279 + return_data.size
                        _6529 = mem[_6279 + mem[_6279]]
                        if mem[_6279 + mem[_6279]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6279 + mem[_6279]]) + 1 < 0 or _6279 + ceil32(return_data.size) + ceil32(32 * mem[_6279 + mem[_6279]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6279 + ceil32(return_data.size) + ceil32(32 * mem[_6279 + mem[_6279]]) + 1
                        mem[_6279 + ceil32(return_data.size)] = _6529
                        require _6364 + (32 * _6529) + 32 <= return_data.size
                        s = 0
                        t = _6279 + _6364 + 32
                        v = _6279 + ceil32(return_data.size) + 32
                        while s < _6529:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7946 = mem[_6279 + 32]
                        require mem[_6279 + 32] <= test266151307()
                        require _6279 + mem[_6279 + 32] + 31 < _6279 + return_data.size
                        _8074 = mem[_6279 + mem[_6279 + 32]]
                        if mem[_6279 + mem[_6279 + 32]] > test266151307():
                            revert with 0, 65
                        _8262 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6279 + mem[_6279 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6279 + mem[_6279 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6279 + mem[_6279 + 32]]) + 1
                        mem[_8262] = _8074
                        require _7946 + (32 * _8074) + 32 <= return_data.size
                        s = 0
                        t = _6279 + _7946 + 32
                        v = _8262 + 32
                        while s < _8074:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10552 = mem[_6279 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10552:
                            if s >= mem[_6279 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6279 + ceil32(return_data.size) + 32]
                            if s >= mem[_8262]:
                                revert with 0, 50
                            if t >= mem[_2602]:
                                revert with 0, 50
                            mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _8262 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10552 = mem[_6279 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6089 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6089] = address(stor5[arg2].field_0)
                mem[_6089 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6170 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6170 + 32] = 32
                    mem[_6170 + 64] = mem[_6170]
                    mem[_6170 + 96 len 32 * mem[_6170]] = mem[_6170 + 32 len 32 * mem[_6170]]
                    var66001 = mem[_6170]
                    var66002 = _6170 + (32 * mem[_6170]) + 32
                    return memory
                      from mem[64]
                       len _6170 + (32 * mem[_6170]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6417 = mem[_2499]
                mem[mem[64] + 100] = mem[_2499]
                mem[mem[64] + 132 len 32 * _6417] = mem[_2499 + 32 len 32 * _6417]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6417) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8073 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8188 = mem[_8073]
                require mem[_8073] <= test266151307()
                require _8073 + mem[_8073] + 31 < _8073 + return_data.size
                _8362 = mem[_8073 + mem[_8073]]
                if mem[_8073 + mem[_8073]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8073 + mem[_8073]]) + 1 < 0 or _8073 + ceil32(return_data.size) + ceil32(32 * mem[_8073 + mem[_8073]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8073 + ceil32(return_data.size) + ceil32(32 * mem[_8073 + mem[_8073]]) + 1
                mem[_8073 + ceil32(return_data.size)] = _8362
                require _8188 + (32 * _8362) + 32 <= return_data.size
                mem[_8073 + ceil32(return_data.size) + 32 len 32 * _8362] = mem[_8073 + _8188 + 32 len 32 * _8362]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8362
                mem[mem[64] + 64 len 32 * _8362] = mem[_8073 + ceil32(return_data.size) + 32 len 32 * _8362]
                return Array(len=_8362, data=mem[mem[64] + 64 len 32 * _8362])
            _3934 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3934:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3981 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3981 + 32 len mem[_3981]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3934 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2499]:
                    revert with 0, 50
                mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2602]:
                    revert with 0, 50
                mem[(32 * u) + _2602 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3934 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5976 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5976] = address(stor5[idx].field_0)
                mem[_5976 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _6050 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _7747 = mem[_6050]
                    s = 0
                    t = u
                    while s < _7747:
                        if s >= mem[_6050]:
                            revert with 0, 50
                        if t >= mem[_2499]:
                            revert with 0, 50
                        mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6050 + 32]
                        if s >= mem[_6050 + 32]:
                            revert with 0, 50
                        if t >= mem[_2602]:
                            revert with 0, 50
                        mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _6050 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _7747 = mem[_6050]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6275 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _6360 = mem[_6275]
                    require mem[_6275] <= test266151307()
                    require _6275 + mem[_6275] + 31 < _6275 + return_data.size
                    _6527 = mem[_6275 + mem[_6275]]
                    if mem[_6275 + mem[_6275]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_6275 + mem[_6275]]) + 1 < 0 or _6275 + ceil32(return_data.size) + ceil32(32 * mem[_6275 + mem[_6275]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _6275 + ceil32(return_data.size) + ceil32(32 * mem[_6275 + mem[_6275]]) + 1
                    mem[_6275 + ceil32(return_data.size)] = _6527
                    require _6360 + (32 * _6527) + 32 <= return_data.size
                    s = 0
                    t = _6275 + _6360 + 32
                    v = _6275 + ceil32(return_data.size) + 32
                    while s < _6527:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _7943 = mem[_6275 + 32]
                    require mem[_6275 + 32] <= test266151307()
                    require _6275 + mem[_6275 + 32] + 31 < _6275 + return_data.size
                    _8072 = mem[_6275 + mem[_6275 + 32]]
                    if mem[_6275 + mem[_6275 + 32]] > test266151307():
                        revert with 0, 65
                    _8261 = mem[64]
                    if mem[64] + ceil32(32 * mem[_6275 + mem[_6275 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6275 + mem[_6275 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_6275 + mem[_6275 + 32]]) + 1
                    mem[_8261] = _8072
                    require _7943 + (32 * _8072) + 32 <= return_data.size
                    s = 0
                    t = _6275 + _7943 + 32
                    v = _8261 + 32
                    while s < _8072:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10551 = mem[_6275 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10551:
                        if s >= mem[_6275 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2499]:
                            revert with 0, 50
                        mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6275 + ceil32(return_data.size) + 32]
                        if s >= mem[_8261]:
                            revert with 0, 50
                        if t >= mem[_2602]:
                            revert with 0, 50
                        mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _8261 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10551 = mem[_6275 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _6084 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6084] = address(stor5[arg2].field_0)
            mem[_6084 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _6164 = mem[64]
                mem[64] = mem[64] + 32
                mem[_6164 + 32] = 32
                mem[_6164 + 64] = mem[_6164]
                mem[_6164 + 96 len 32 * mem[_6164]] = mem[_6164 + 32 len 32 * mem[_6164]]
                var65001 = mem[_6164]
                var65002 = _6164 + (32 * mem[_6164]) + 32
                return memory
                  from mem[64]
                   len _6164 + (32 * mem[_6164]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _6416 = mem[_2499]
            mem[mem[64] + 100] = mem[_2499]
            mem[mem[64] + 132 len 32 * _6416] = mem[_2499 + 32 len 32 * _6416]
            var66001 = _6416
            var66002 = _2499 + (32 * _6416) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6416) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8071 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _8187 = mem[_8071]
            require mem[_8071] <= test266151307()
            require _8071 + mem[_8071] + 31 < _8071 + return_data.size
            _8361 = mem[_8071 + mem[_8071]]
            if mem[_8071 + mem[_8071]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8071 + mem[_8071]]) + 1 < 0 or _8071 + ceil32(return_data.size) + ceil32(32 * mem[_8071 + mem[_8071]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8071 + ceil32(return_data.size) + ceil32(32 * mem[_8071 + mem[_8071]]) + 1
            mem[_8071 + ceil32(return_data.size)] = _8361
            require _8187 + (32 * _8361) + 32 <= return_data.size
            mem[_8071 + ceil32(return_data.size) + 32 len 32 * _8361] = mem[_8071 + _8187 + 32 len 32 * _8361]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _8361
            mem[mem[64] + 64 len 32 * _8361] = mem[_8071 + ceil32(return_data.size) + 32 len 32 * _8361]
            return Array(len=_8361, data=mem[mem[64] + 64 len 32 * _8361])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1187 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1187 + 32 len mem[_1187]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2484 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2484] = address(stor5[idx].field_0)
                mem[_2484 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2502 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2502]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2502]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2605 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2649 = mem[_2605]
                require mem[_2605] <= test266151307()
                require _2605 + mem[_2605] + 31 < _2605 + return_data.size
                _2781 = mem[_2605 + mem[_2605]]
                if mem[_2605 + mem[_2605]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2605 + mem[_2605]]) + 1 < 0 or _2605 + ceil32(return_data.size) + ceil32(32 * mem[_2605 + mem[_2605]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2605 + ceil32(return_data.size) + ceil32(32 * mem[_2605 + mem[_2605]]) + 1
                mem[_2605 + ceil32(return_data.size)] = _2781
                require _2649 + (32 * _2781) + 32 <= return_data.size
                s = 0
                u = _2605 + _2649 + 32
                v = _2605 + ceil32(return_data.size) + 32
                while s < _2781:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _4108 = mem[_2605 + 32]
                require mem[_2605 + 32] <= test266151307()
                require _2605 + mem[_2605 + 32] + 31 < _2605 + return_data.size
                _4146 = mem[_2605 + mem[_2605 + 32]]
                if mem[_2605 + mem[_2605 + 32]] > test266151307():
                    revert with 0, 65
                _4378 = mem[64]
                if mem[64] + ceil32(32 * mem[_2605 + mem[_2605 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2605 + mem[_2605 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2605 + mem[_2605 + 32]]) + 1
                mem[_4378] = _4146
                require _4108 + (32 * _4146) + 32 <= return_data.size
                s = 0
                u = _2605 + _4108 + 32
                v = _4378 + 32
                while s < _4146:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2605 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2605 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2501 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2604 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2604 + (32 * s + t) + 32
                if not s + t:
                    _3942 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3942:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _4010 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_4010 + 32 len mem[_4010]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3942 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2501]:
                            revert with 0, 50
                        mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2604]:
                            revert with 0, 50
                        mem[(32 * u) + _2604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3942 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5996 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5996] = address(stor5[idx].field_0)
                        mem[_5996 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _6055 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _7751 = mem[_6055]
                            s = 0
                            t = u
                            while s < _7751:
                                if s >= mem[_6055]:
                                    revert with 0, 50
                                if t >= mem[_2501]:
                                    revert with 0, 50
                                mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6055 + 32]
                                if s >= mem[_6055 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2604]:
                                    revert with 0, 50
                                mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _6055 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _7751 = mem[_6055]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6291 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _6376 = mem[_6291]
                            require mem[_6291] <= test266151307()
                            require _6291 + mem[_6291] + 31 < _6291 + return_data.size
                            _6535 = mem[_6291 + mem[_6291]]
                            if mem[_6291 + mem[_6291]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_6291 + mem[_6291]]) + 1 < 0 or _6291 + ceil32(return_data.size) + ceil32(32 * mem[_6291 + mem[_6291]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _6291 + ceil32(return_data.size) + ceil32(32 * mem[_6291 + mem[_6291]]) + 1
                            mem[_6291 + ceil32(return_data.size)] = _6535
                            require _6376 + (32 * _6535) + 32 <= return_data.size
                            s = 0
                            t = _6291 + _6376 + 32
                            v = _6291 + ceil32(return_data.size) + 32
                            while s < _6535:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7955 = mem[_6291 + 32]
                            require mem[_6291 + 32] <= test266151307()
                            require _6291 + mem[_6291 + 32] + 31 < _6291 + return_data.size
                            _8080 = mem[_6291 + mem[_6291 + 32]]
                            if mem[_6291 + mem[_6291 + 32]] > test266151307():
                                revert with 0, 65
                            _8265 = mem[64]
                            if mem[64] + ceil32(32 * mem[_6291 + mem[_6291 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6291 + mem[_6291 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_6291 + mem[_6291 + 32]]) + 1
                            mem[_8265] = _8080
                            require _7955 + (32 * _8080) + 32 <= return_data.size
                            s = 0
                            t = _6291 + _7955 + 32
                            v = _8265 + 32
                            while s < _8080:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _10555 = mem[_6291 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _10555:
                                if s >= mem[_6291 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2501]:
                                    revert with 0, 50
                                mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6291 + ceil32(return_data.size) + 32]
                                if s >= mem[_8265]:
                                    revert with 0, 50
                                if t >= mem[_2604]:
                                    revert with 0, 50
                                mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _8265 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _10555 = mem[_6291 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _6104 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6104] = address(stor5[arg2].field_0)
                    mem[_6104 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _6188 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_6188 + 32] = 32
                        mem[_6188 + 64] = mem[_6188]
                        mem[_6188 + 96 len 32 * mem[_6188]] = mem[_6188 + 32 len 32 * mem[_6188]]
                        var65001 = mem[_6188]
                        var65002 = _6188 + (32 * mem[_6188]) + 32
                        return memory
                          from mem[64]
                           len _6188 + (32 * mem[_6188]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _6420 = mem[_2501]
                    mem[mem[64] + 100] = mem[_2501]
                    mem[mem[64] + 132 len 32 * _6420] = mem[_2501 + 32 len 32 * _6420]
                    var66001 = _6420
                    var66002 = _2501 + (32 * _6420) + 32
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6420) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8079 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8191 = mem[_8079]
                    require mem[_8079] <= test266151307()
                    require _8079 + mem[_8079] + 31 < _8079 + return_data.size
                    _8365 = mem[_8079 + mem[_8079]]
                    if mem[_8079 + mem[_8079]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8079 + mem[_8079]]) + 1 < 0 or _8079 + ceil32(return_data.size) + ceil32(32 * mem[_8079 + mem[_8079]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8079 + ceil32(return_data.size) + ceil32(32 * mem[_8079 + mem[_8079]]) + 1
                    mem[_8079 + ceil32(return_data.size)] = _8365
                    require _8191 + (32 * _8365) + 32 <= return_data.size
                    mem[_8079 + ceil32(return_data.size) + 32 len 32 * _8365] = mem[_8079 + _8191 + 32 len 32 * _8365]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _8365
                    mem[mem[64] + 64 len 32 * _8365] = mem[_8079 + ceil32(return_data.size) + 32 len 32 * _8365]
                    var93001 = _8365
                    var93002 = _8079 + ceil32(return_data.size) + (32 * _8365) + 32
                    return Array(len=_8365, data=mem[mem[64] + 64 len 32 * _8365])
                mem[_2604 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3944 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3944:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4017 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4017 + 32 len mem[_4017]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3944 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2501]:
                        revert with 0, 50
                    mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2604]:
                        revert with 0, 50
                    mem[(32 * u) + _2604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3944 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6001] = address(stor5[idx].field_0)
                    mem[_6001 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6056 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7752 = mem[_6056]
                        s = 0
                        t = u
                        while s < _7752:
                            if s >= mem[_6056]:
                                revert with 0, 50
                            if t >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6056 + 32]
                            if s >= mem[_6056 + 32]:
                                revert with 0, 50
                            if t >= mem[_2604]:
                                revert with 0, 50
                            mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _6056 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _7752 = mem[_6056]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6295 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6380 = mem[_6295]
                        require mem[_6295] <= test266151307()
                        require _6295 + mem[_6295] + 31 < _6295 + return_data.size
                        _6537 = mem[_6295 + mem[_6295]]
                        if mem[_6295 + mem[_6295]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6295 + mem[_6295]]) + 1 < 0 or _6295 + ceil32(return_data.size) + ceil32(32 * mem[_6295 + mem[_6295]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6295 + ceil32(return_data.size) + ceil32(32 * mem[_6295 + mem[_6295]]) + 1
                        mem[_6295 + ceil32(return_data.size)] = _6537
                        require _6380 + (32 * _6537) + 32 <= return_data.size
                        s = 0
                        t = _6295 + _6380 + 32
                        v = _6295 + ceil32(return_data.size) + 32
                        while s < _6537:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7958 = mem[_6295 + 32]
                        require mem[_6295 + 32] <= test266151307()
                        require _6295 + mem[_6295 + 32] + 31 < _6295 + return_data.size
                        _8082 = mem[_6295 + mem[_6295 + 32]]
                        if mem[_6295 + mem[_6295 + 32]] > test266151307():
                            revert with 0, 65
                        _8266 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6295 + mem[_6295 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6295 + mem[_6295 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6295 + mem[_6295 + 32]]) + 1
                        mem[_8266] = _8082
                        require _7958 + (32 * _8082) + 32 <= return_data.size
                        s = 0
                        t = _6295 + _7958 + 32
                        v = _8266 + 32
                        while s < _8082:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10556 = mem[_6295 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10556:
                            if s >= mem[_6295 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6295 + ceil32(return_data.size) + 32]
                            if s >= mem[_8266]:
                                revert with 0, 50
                            if t >= mem[_2604]:
                                revert with 0, 50
                            mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _8266 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10556 = mem[_6295 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6109] = address(stor5[arg2].field_0)
                mem[_6109 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6194 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6194 + 32] = 32
                    mem[_6194 + 64] = mem[_6194]
                    mem[_6194 + 96 len 32 * mem[_6194]] = mem[_6194 + 32 len 32 * mem[_6194]]
                    var66001 = mem[_6194]
                    var66002 = _6194 + (32 * mem[_6194]) + 32
                    return memory
                      from mem[64]
                       len _6194 + (32 * mem[_6194]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6421 = mem[_2501]
                mem[mem[64] + 100] = mem[_2501]
                mem[mem[64] + 132 len 32 * _6421] = mem[_2501 + 32 len 32 * _6421]
                var67001 = _6421
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6421) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8081 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8192 = mem[_8081]
                require mem[_8081] <= test266151307()
                require _8081 + mem[_8081] + 31 < _8081 + return_data.size
                _8366 = mem[_8081 + mem[_8081]]
                if mem[_8081 + mem[_8081]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8081 + mem[_8081]]) + 1 < 0 or _8081 + ceil32(return_data.size) + ceil32(32 * mem[_8081 + mem[_8081]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8081 + ceil32(return_data.size) + ceil32(32 * mem[_8081 + mem[_8081]]) + 1
                mem[_8081 + ceil32(return_data.size)] = _8366
                require _8192 + (32 * _8366) + 32 <= return_data.size
                mem[_8081 + ceil32(return_data.size) + 32 len 32 * _8366] = mem[_8081 + _8192 + 32 len 32 * _8366]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8366
                mem[mem[64] + 64 len 32 * _8366] = mem[_8081 + ceil32(return_data.size) + 32 len 32 * _8366]
                var94001 = _8366
                var94002 = _8081 + ceil32(return_data.size) + (32 * _8366) + 32
                return Array(len=_8366, data=mem[mem[64] + 64 len 32 * _8366])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2501 + (64 * s + t) + 64
            if not s + t:
                _3946 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3946:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4024 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4024 + 32 len mem[_4024]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3946 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2501]:
                        revert with 0, 50
                    mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2501 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2501 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3946 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6006 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6006] = address(stor5[idx].field_0)
                    mem[_6006 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6057 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7753 = mem[_6057]
                        v = 0
                        w = u
                        while v < _7753:
                            if v >= mem[_6057]:
                                revert with 0, 50
                            if w >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6057 + 32]
                            if v >= mem[_6057 + 32]:
                                revert with 0, 50
                            if w >= mem[_2501 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _6057 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7753 = mem[_6057]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6299 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6384 = mem[_6299]
                        require mem[_6299] <= test266151307()
                        require _6299 + mem[_6299] + 31 < _6299 + return_data.size
                        _6539 = mem[_6299 + mem[_6299]]
                        if mem[_6299 + mem[_6299]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6299 + mem[_6299]]) + 1 < 0 or _6299 + ceil32(return_data.size) + ceil32(32 * mem[_6299 + mem[_6299]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6299 + ceil32(return_data.size) + ceil32(32 * mem[_6299 + mem[_6299]]) + 1
                        mem[_6299 + ceil32(return_data.size)] = _6539
                        require _6384 + (32 * _6539) + 32 <= return_data.size
                        v = 0
                        w = _6299 + _6384 + 32
                        x = _6299 + ceil32(return_data.size) + 32
                        while v < _6539:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7961 = mem[_6299 + 32]
                        require mem[_6299 + 32] <= test266151307()
                        require _6299 + mem[_6299 + 32] + 31 < _6299 + return_data.size
                        _8084 = mem[_6299 + mem[_6299 + 32]]
                        if mem[_6299 + mem[_6299 + 32]] > test266151307():
                            revert with 0, 65
                        _8267 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6299 + mem[_6299 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6299 + mem[_6299 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6299 + mem[_6299 + 32]]) + 1
                        mem[_8267] = _8084
                        require _7961 + (32 * _8084) + 32 <= return_data.size
                        v = 0
                        w = _6299 + _7961 + 32
                        x = _8267 + 32
                        while v < _8084:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10557 = mem[_6299 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10557:
                            if v >= mem[_6299 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6299 + ceil32(return_data.size) + 32]
                            if v >= mem[_8267]:
                                revert with 0, 50
                            if w >= mem[_2501 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _8267 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10557 = mem[_6299 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6114 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6114] = address(stor5[arg2].field_0)
                mem[_6114 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6200 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6200 + 32] = 32
                    mem[_6200 + 64] = mem[_6200]
                    mem[_6200 + 96 len 32 * mem[_6200]] = mem[_6200 + 32 len 32 * mem[_6200]]
                    var66001 = mem[_6200]
                    var66002 = _6200 + (32 * mem[_6200]) + 32
                    return memory
                      from mem[64]
                       len _6200 + (32 * mem[_6200]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6422 = mem[_2501]
                mem[mem[64] + 100] = mem[_2501]
                mem[mem[64] + 132 len 32 * _6422] = mem[_2501 + 32 len 32 * _6422]
                var67001 = _6422
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6422) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8083 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8193 = mem[_8083]
                require mem[_8083] <= test266151307()
                require _8083 + mem[_8083] + 31 < _8083 + return_data.size
                _8367 = mem[_8083 + mem[_8083]]
                if mem[_8083 + mem[_8083]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8083 + mem[_8083]]) + 1 < 0 or _8083 + ceil32(return_data.size) + ceil32(32 * mem[_8083 + mem[_8083]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8083 + ceil32(return_data.size) + ceil32(32 * mem[_8083 + mem[_8083]]) + 1
                mem[_8083 + ceil32(return_data.size)] = _8367
                require _8193 + (32 * _8367) + 32 <= return_data.size
                mem[_8083 + ceil32(return_data.size) + 32 len 32 * _8367] = mem[_8083 + _8193 + 32 len 32 * _8367]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8367
                mem[mem[64] + 64 len 32 * _8367] = mem[_8083 + ceil32(return_data.size) + 32 len 32 * _8367]
                var94001 = _8367
                var94002 = _8083 + ceil32(return_data.size) + (32 * _8367) + 32
                return Array(len=_8367, data=mem[mem[64] + 64 len 32 * _8367])
            mem[_2501 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3948 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3948:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _4031 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_4031 + 32 len mem[_4031]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3948 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2501]:
                    revert with 0, 50
                mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2501 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2501 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3948 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _6011 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6011] = address(stor5[idx].field_0)
                mem[_6011 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _6058 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _7754 = mem[_6058]
                    v = 0
                    w = u
                    while v < _7754:
                        if v >= mem[_6058]:
                            revert with 0, 50
                        if w >= mem[_2501]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6058 + 32]
                        if v >= mem[_6058 + 32]:
                            revert with 0, 50
                        if w >= mem[_2501 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _6058 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _7754 = mem[_6058]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6303 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _6388 = mem[_6303]
                    require mem[_6303] <= test266151307()
                    require _6303 + mem[_6303] + 31 < _6303 + return_data.size
                    _6541 = mem[_6303 + mem[_6303]]
                    if mem[_6303 + mem[_6303]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_6303 + mem[_6303]]) + 1 < 0 or _6303 + ceil32(return_data.size) + ceil32(32 * mem[_6303 + mem[_6303]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _6303 + ceil32(return_data.size) + ceil32(32 * mem[_6303 + mem[_6303]]) + 1
                    mem[_6303 + ceil32(return_data.size)] = _6541
                    require _6388 + (32 * _6541) + 32 <= return_data.size
                    v = 0
                    w = _6303 + _6388 + 32
                    x = _6303 + ceil32(return_data.size) + 32
                    while v < _6541:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _7964 = mem[_6303 + 32]
                    require mem[_6303 + 32] <= test266151307()
                    require _6303 + mem[_6303 + 32] + 31 < _6303 + return_data.size
                    _8086 = mem[_6303 + mem[_6303 + 32]]
                    if mem[_6303 + mem[_6303 + 32]] > test266151307():
                        revert with 0, 65
                    _8268 = mem[64]
                    if mem[64] + ceil32(32 * mem[_6303 + mem[_6303 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6303 + mem[_6303 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_6303 + mem[_6303 + 32]]) + 1
                    mem[_8268] = _8086
                    require _7964 + (32 * _8086) + 32 <= return_data.size
                    v = 0
                    w = _6303 + _7964 + 32
                    x = _8268 + 32
                    while v < _8086:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10558 = mem[_6303 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10558:
                        if v >= mem[_6303 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2501]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6303 + ceil32(return_data.size) + 32]
                        if v >= mem[_8268]:
                            revert with 0, 50
                        if w >= mem[_2501 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _8268 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10558 = mem[_6303 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _6119 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6119] = address(stor5[arg2].field_0)
            mem[_6119 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _6206 = mem[64]
                mem[64] = mem[64] + 32
                mem[_6206 + 32] = 32
                mem[_6206 + 64] = mem[_6206]
                mem[_6206 + 96 len 32 * mem[_6206]] = mem[_6206 + 32 len 32 * mem[_6206]]
                var67001 = mem[_6206]
                return memory
                  from mem[64]
                   len _6206 + (32 * mem[_6206]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _6423 = mem[_2501]
            mem[mem[64] + 100] = mem[_2501]
            mem[mem[64] + 132 len 32 * _6423] = mem[_2501 + 32 len 32 * _6423]
            var68001 = _6423
            var68002 = _2501 + (32 * _6423) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6423) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8085 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _8194 = mem[_8085]
            require mem[_8085] <= test266151307()
            require _8085 + mem[_8085] + 31 < _8085 + return_data.size
            _8368 = mem[_8085 + mem[_8085]]
            if mem[_8085 + mem[_8085]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8085 + mem[_8085]]) + 1 < 0 or _8085 + ceil32(return_data.size) + ceil32(32 * mem[_8085 + mem[_8085]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8085 + ceil32(return_data.size) + ceil32(32 * mem[_8085 + mem[_8085]]) + 1
            mem[_8085 + ceil32(return_data.size)] = _8368
            require _8194 + (32 * _8368) + 32 <= return_data.size
            mem[_8085 + ceil32(return_data.size) + 32 len 32 * _8368] = mem[_8085 + _8194 + 32 len 32 * _8368]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _8368
            mem[mem[64] + 64 len 32 * _8368] = mem[_8085 + ceil32(return_data.size) + 32 len 32 * _8368]
            var95001 = _8368
            var95002 = _8085 + ceil32(return_data.size) + (32 * _8368) + 32
            return Array(len=_8368, data=mem[mem[64] + 64 len 32 * _8368])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _4039 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_4039 + 32 len mem[_4039]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _6016 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6016] = address(stor5[idx].field_0)
            mem[_6016 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _6061 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_6061]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_6061]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6307 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _6393 = mem[_6307]
            require mem[_6307] <= test266151307()
            require _6307 + mem[_6307] + 31 < _6307 + return_data.size
            _6551 = mem[_6307 + mem[_6307]]
            if mem[_6307 + mem[_6307]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_6307 + mem[_6307]]) + 1 < 0 or _6307 + ceil32(return_data.size) + ceil32(32 * mem[_6307 + mem[_6307]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _6307 + ceil32(return_data.size) + ceil32(32 * mem[_6307 + mem[_6307]]) + 1
            mem[_6307 + ceil32(return_data.size)] = _6551
            require _6393 + (32 * _6551) + 32 <= return_data.size
            s = 0
            u = _6307 + _6393 + 32
            v = _6307 + ceil32(return_data.size) + 32
            while s < _6551:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7971 = mem[_6307 + 32]
            require mem[_6307 + 32] <= test266151307()
            require _6307 + mem[_6307 + 32] + 31 < _6307 + return_data.size
            _8087 = mem[_6307 + mem[_6307 + 32]]
            if mem[_6307 + mem[_6307 + 32]] > test266151307():
                revert with 0, 65
            _8297 = mem[64]
            if mem[64] + ceil32(32 * mem[_6307 + mem[_6307 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6307 + mem[_6307 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_6307 + mem[_6307 + 32]]) + 1
            mem[_8297] = _8087
            require _7971 + (32 * _8087) + 32 <= return_data.size
            s = 0
            u = _6307 + _7971 + 32
            v = _8297 + 32
            while s < _8087:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_6307 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_6307 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _6060 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _6306 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _6306 + (32 * s + t) + 32
            if not s + t:
                _7756 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _7756:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7827 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7827 + 32 len mem[_7827]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _7756 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_6060]:
                        revert with 0, 50
                    mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_6306]:
                        revert with 0, 50
                    mem[(32 * u) + _6306 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7756 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _9434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9434] = address(stor5[idx].field_0)
                    mem[_9434 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _9502 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _10559 = mem[_9502]
                        s = 0
                        t = u
                        while s < _10559:
                            if s >= mem[_9502]:
                                revert with 0, 50
                            if t >= mem[_6060]:
                                revert with 0, 50
                            mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9502 + 32]
                            if s >= mem[_9502 + 32]:
                                revert with 0, 50
                            if t >= mem[_6306]:
                                revert with 0, 50
                            mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _9502 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10559 = mem[_9502]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9776 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _9863 = mem[_9776]
                        require mem[_9776] <= test266151307()
                        require _9776 + mem[_9776] + 31 < _9776 + return_data.size
                        _9966 = mem[_9776 + mem[_9776]]
                        if mem[_9776 + mem[_9776]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_9776 + mem[_9776]]) + 1 < 0 or _9776 + ceil32(return_data.size) + ceil32(32 * mem[_9776 + mem[_9776]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _9776 + ceil32(return_data.size) + ceil32(32 * mem[_9776 + mem[_9776]]) + 1
                        mem[_9776 + ceil32(return_data.size)] = _9966
                        require _9863 + (32 * _9966) + 32 <= return_data.size
                        s = 0
                        t = _9776 + _9863 + 32
                        v = _9776 + ceil32(return_data.size) + 32
                        while s < _9966:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10700 = mem[_9776 + 32]
                        require mem[_9776 + 32] <= test266151307()
                        require _9776 + mem[_9776 + 32] + 31 < _9776 + return_data.size
                        _10858 = mem[_9776 + mem[_9776 + 32]]
                        if mem[_9776 + mem[_9776 + 32]] > test266151307():
                            revert with 0, 65
                        _10942 = mem[64]
                        if mem[64] + ceil32(32 * mem[_9776 + mem[_9776 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9776 + mem[_9776 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_9776 + mem[_9776 + 32]]) + 1
                        mem[_10942] = _10858
                        require _10700 + (32 * _10858) + 32 <= return_data.size
                        s = 0
                        t = _9776 + _10700 + 32
                        v = _10942 + 32
                        while s < _10858:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _11727 = mem[_9776 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _11727:
                            if s >= mem[_9776 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_6060]:
                                revert with 0, 50
                            mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9776 + ceil32(return_data.size) + 32]
                            if s >= mem[_10942]:
                                revert with 0, 50
                            if t >= mem[_6306]:
                                revert with 0, 50
                            mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _10942 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _11727 = mem[_9776 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _9552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9552] = address(stor5[arg2].field_0)
                mem[_9552 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _9641 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_9641 + 32] = 32
                    mem[_9641 + 64] = mem[_9641]
                    mem[_9641 + 96 len 32 * mem[_9641]] = mem[_9641 + 32 len 32 * mem[_9641]]
                    var69001 = mem[_9641]
                    var69002 = _9641 + (32 * mem[_9641]) + 32
                    return memory
                      from mem[64]
                       len _9641 + (32 * mem[_9641]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _9913 = mem[_6060]
                mem[mem[64] + 100] = mem[_6060]
                mem[mem[64] + 132 len 32 * _9913] = mem[_6060 + 32 len 32 * _9913]
                var70001 = _9913
                var70002 = _6060 + (32 * _9913) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9913) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10857 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _10910 = mem[_10857]
                require mem[_10857] <= test266151307()
                require _10857 + mem[_10857] + 31 < _10857 + return_data.size
                _10983 = mem[_10857 + mem[_10857]]
                if mem[_10857 + mem[_10857]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10857 + mem[_10857]]) + 1 < 0 or _10857 + ceil32(return_data.size) + ceil32(32 * mem[_10857 + mem[_10857]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10857 + ceil32(return_data.size) + ceil32(32 * mem[_10857 + mem[_10857]]) + 1
                mem[_10857 + ceil32(return_data.size)] = _10983
                require _10910 + (32 * _10983) + 32 <= return_data.size
                mem[_10857 + ceil32(return_data.size) + 32 len 32 * _10983] = mem[_10857 + _10910 + 32 len 32 * _10983]
                var89001 = _10983
                var89002 = _10857 + _10910 + (32 * _10983) + 32
                var89004 = _10857 + ceil32(return_data.size) + (32 * _10983) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _10983
                mem[mem[64] + 64 len 32 * _10983] = mem[_10857 + ceil32(return_data.size) + 32 len 32 * _10983]
                return Array(len=_10983, data=mem[mem[64] + 64 len 32 * _10983])
            mem[_6306 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _7758 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7758:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7834 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7834 + 32 len mem[_7834]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7758 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6060]:
                    revert with 0, 50
                mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6306]:
                    revert with 0, 50
                mem[(32 * u) + _6306 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7758 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9439 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9439] = address(stor5[idx].field_0)
                mem[_9439 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9503 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10560 = mem[_9503]
                    s = 0
                    t = u
                    while s < _10560:
                        if s >= mem[_9503]:
                            revert with 0, 50
                        if t >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9503 + 32]
                        if s >= mem[_9503 + 32]:
                            revert with 0, 50
                        if t >= mem[_6306]:
                            revert with 0, 50
                        mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _9503 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10560 = mem[_9503]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9780 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9867 = mem[_9780]
                    require mem[_9780] <= test266151307()
                    require _9780 + mem[_9780] + 31 < _9780 + return_data.size
                    _9968 = mem[_9780 + mem[_9780]]
                    if mem[_9780 + mem[_9780]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9780 + mem[_9780]]) + 1 < 0 or _9780 + ceil32(return_data.size) + ceil32(32 * mem[_9780 + mem[_9780]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9780 + ceil32(return_data.size) + ceil32(32 * mem[_9780 + mem[_9780]]) + 1
                    mem[_9780 + ceil32(return_data.size)] = _9968
                    require _9867 + (32 * _9968) + 32 <= return_data.size
                    s = 0
                    t = _9780 + _9867 + 32
                    v = _9780 + ceil32(return_data.size) + 32
                    while s < _9968:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10703 = mem[_9780 + 32]
                    require mem[_9780 + 32] <= test266151307()
                    require _9780 + mem[_9780 + 32] + 31 < _9780 + return_data.size
                    _10860 = mem[_9780 + mem[_9780 + 32]]
                    if mem[_9780 + mem[_9780 + 32]] > test266151307():
                        revert with 0, 65
                    _10943 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9780 + mem[_9780 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9780 + mem[_9780 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9780 + mem[_9780 + 32]]) + 1
                    mem[_10943] = _10860
                    require _10703 + (32 * _10860) + 32 <= return_data.size
                    s = 0
                    t = _9780 + _10703 + 32
                    v = _10943 + 32
                    while s < _10860:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11728 = mem[_9780 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _11728:
                        if s >= mem[_9780 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9780 + ceil32(return_data.size) + 32]
                        if s >= mem[_10943]:
                            revert with 0, 50
                        if t >= mem[_6306]:
                            revert with 0, 50
                        mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _10943 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11728 = mem[_9780 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9557 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9557] = address(stor5[arg2].field_0)
            mem[_9557 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9647 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9647 + 32] = 32
                mem[_9647 + 64] = mem[_9647]
                mem[_9647 + 96 len 32 * mem[_9647]] = mem[_9647 + 32 len 32 * mem[_9647]]
                var70001 = mem[_9647]
                var70002 = _9647 + (32 * mem[_9647]) + 32
                return memory
                  from mem[64]
                   len _9647 + (32 * mem[_9647]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9914 = mem[_6060]
            mem[mem[64] + 100] = mem[_6060]
            mem[mem[64] + 132 len 32 * _9914] = mem[_6060 + 32 len 32 * _9914]
            var71001 = _9914
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9914) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10859 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10911 = mem[_10859]
            require mem[_10859] <= test266151307()
            require _10859 + mem[_10859] + 31 < _10859 + return_data.size
            _10984 = mem[_10859 + mem[_10859]]
            if mem[_10859 + mem[_10859]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10859 + mem[_10859]]) + 1 < 0 or _10859 + ceil32(return_data.size) + ceil32(32 * mem[_10859 + mem[_10859]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10859 + ceil32(return_data.size) + ceil32(32 * mem[_10859 + mem[_10859]]) + 1
            mem[_10859 + ceil32(return_data.size)] = _10984
            require _10911 + (32 * _10984) + 32 <= return_data.size
            mem[_10859 + ceil32(return_data.size) + 32 len 32 * _10984] = mem[_10859 + _10911 + 32 len 32 * _10984]
            var90001 = _10984
            var90002 = _10859 + _10911 + (32 * _10984) + 32
            var90004 = _10859 + ceil32(return_data.size) + (32 * _10984) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10984
            mem[mem[64] + 64 len 32 * _10984] = mem[_10859 + ceil32(return_data.size) + 32 len 32 * _10984]
            return Array(len=_10984, data=mem[mem[64] + 64 len 32 * _10984])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _6060 + (64 * s + t) + 64
        if not s + t:
            _7760 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7760:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7841 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7841 + 32 len mem[_7841]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7760 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6060]:
                    revert with 0, 50
                mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6060 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _6060 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7760 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9444 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9444] = address(stor5[idx].field_0)
                mem[_9444 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9504 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10561 = mem[_9504]
                    v = 0
                    w = u
                    while v < _10561:
                        if v >= mem[_9504]:
                            revert with 0, 50
                        if w >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9504 + 32]
                        if v >= mem[_9504 + 32]:
                            revert with 0, 50
                        if w >= mem[_6060 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _9504 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10561 = mem[_9504]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9784 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9871 = mem[_9784]
                    require mem[_9784] <= test266151307()
                    require _9784 + mem[_9784] + 31 < _9784 + return_data.size
                    _9970 = mem[_9784 + mem[_9784]]
                    if mem[_9784 + mem[_9784]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9784 + mem[_9784]]) + 1 < 0 or _9784 + ceil32(return_data.size) + ceil32(32 * mem[_9784 + mem[_9784]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9784 + ceil32(return_data.size) + ceil32(32 * mem[_9784 + mem[_9784]]) + 1
                    mem[_9784 + ceil32(return_data.size)] = _9970
                    require _9871 + (32 * _9970) + 32 <= return_data.size
                    v = 0
                    w = _9784 + _9871 + 32
                    x = _9784 + ceil32(return_data.size) + 32
                    while v < _9970:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10706 = mem[_9784 + 32]
                    require mem[_9784 + 32] <= test266151307()
                    require _9784 + mem[_9784 + 32] + 31 < _9784 + return_data.size
                    _10862 = mem[_9784 + mem[_9784 + 32]]
                    if mem[_9784 + mem[_9784 + 32]] > test266151307():
                        revert with 0, 65
                    _10944 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9784 + mem[_9784 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9784 + mem[_9784 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9784 + mem[_9784 + 32]]) + 1
                    mem[_10944] = _10862
                    require _10706 + (32 * _10862) + 32 <= return_data.size
                    v = 0
                    w = _9784 + _10706 + 32
                    x = _10944 + 32
                    while v < _10862:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _11729 = mem[_9784 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _11729:
                        if v >= mem[_9784 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9784 + ceil32(return_data.size) + 32]
                        if v >= mem[_10944]:
                            revert with 0, 50
                        if w >= mem[_6060 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _10944 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _11729 = mem[_9784 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9562 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9562] = address(stor5[arg2].field_0)
            mem[_9562 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9653 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9653 + 32] = 32
                mem[_9653 + 64] = mem[_9653]
                mem[_9653 + 96 len 32 * mem[_9653]] = mem[_9653 + 32 len 32 * mem[_9653]]
                var70001 = mem[_9653]
                var70002 = _9653 + (32 * mem[_9653]) + 32
                return memory
                  from mem[64]
                   len _9653 + (32 * mem[_9653]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9915 = mem[_6060]
            mem[mem[64] + 100] = mem[_6060]
            mem[mem[64] + 132 len 32 * _9915] = mem[_6060 + 32 len 32 * _9915]
            var71001 = _9915
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9915) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10861 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10912 = mem[_10861]
            require mem[_10861] <= test266151307()
            require _10861 + mem[_10861] + 31 < _10861 + return_data.size
            _10985 = mem[_10861 + mem[_10861]]
            if mem[_10861 + mem[_10861]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10861 + mem[_10861]]) + 1 < 0 or _10861 + ceil32(return_data.size) + ceil32(32 * mem[_10861 + mem[_10861]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10861 + ceil32(return_data.size) + ceil32(32 * mem[_10861 + mem[_10861]]) + 1
            mem[_10861 + ceil32(return_data.size)] = _10985
            require _10912 + (32 * _10985) + 32 <= return_data.size
            mem[_10861 + ceil32(return_data.size) + 32 len 32 * _10985] = mem[_10861 + _10912 + 32 len 32 * _10985]
            var90001 = _10985
            var90002 = _10861 + _10912 + (32 * _10985) + 32
            var90004 = _10861 + ceil32(return_data.size) + (32 * _10985) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10985
            mem[mem[64] + 64 len 32 * _10985] = mem[_10861 + ceil32(return_data.size) + 32 len 32 * _10985]
            return Array(len=_10985, data=mem[mem[64] + 64 len 32 * _10985])
        mem[_6060 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _7762 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _7762:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7848 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7848 + 32 len mem[_7848]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _7762 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_6060]:
                revert with 0, 50
            mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_6060 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _6060 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7762 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _9449 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9449] = address(stor5[idx].field_0)
            mem[_9449 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _9505 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10562 = mem[_9505]
                v = 0
                w = u
                while v < _10562:
                    if v >= mem[_9505]:
                        revert with 0, 50
                    if w >= mem[_6060]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9505 + 32]
                    if v >= mem[_9505 + 32]:
                        revert with 0, 50
                    if w >= mem[_6060 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _9505 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10562 = mem[_9505]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9788 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _9875 = mem[_9788]
                require mem[_9788] <= test266151307()
                require _9788 + mem[_9788] + 31 < _9788 + return_data.size
                _9972 = mem[_9788 + mem[_9788]]
                if mem[_9788 + mem[_9788]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9788 + mem[_9788]]) + 1 < 0 or _9788 + ceil32(return_data.size) + ceil32(32 * mem[_9788 + mem[_9788]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9788 + ceil32(return_data.size) + ceil32(32 * mem[_9788 + mem[_9788]]) + 1
                mem[_9788 + ceil32(return_data.size)] = _9972
                require _9875 + (32 * _9972) + 32 <= return_data.size
                v = 0
                w = _9788 + _9875 + 32
                x = _9788 + ceil32(return_data.size) + 32
                while v < _9972:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10709 = mem[_9788 + 32]
                require mem[_9788 + 32] <= test266151307()
                require _9788 + mem[_9788 + 32] + 31 < _9788 + return_data.size
                _10864 = mem[_9788 + mem[_9788 + 32]]
                if mem[_9788 + mem[_9788 + 32]] > test266151307():
                    revert with 0, 65
                _10945 = mem[64]
                if mem[64] + ceil32(32 * mem[_9788 + mem[_9788 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9788 + mem[_9788 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_9788 + mem[_9788 + 32]]) + 1
                mem[_10945] = _10864
                require _10709 + (32 * _10864) + 32 <= return_data.size
                v = 0
                w = _9788 + _10709 + 32
                x = _10945 + 32
                while v < _10864:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11730 = mem[_9788 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _11730:
                    if v >= mem[_9788 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_6060]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9788 + ceil32(return_data.size) + 32]
                    if v >= mem[_10945]:
                        revert with 0, 50
                    if w >= mem[_6060 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _10945 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11730 = mem[_9788 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _9567 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9567] = address(stor5[arg2].field_0)
        mem[_9567 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _9659 = mem[64]
            mem[64] = mem[64] + 32
            mem[_9659 + 32] = 32
            mem[_9659 + 64] = mem[_9659]
            mem[_9659 + 96 len 32 * mem[_9659]] = mem[_9659 + 32 len 32 * mem[_9659]]
            var71001 = mem[_9659]
            return memory
              from mem[64]
               len _9659 + (32 * mem[_9659]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _9916 = mem[_6060]
        mem[mem[64] + 100] = mem[_6060]
        mem[mem[64] + 132 len 32 * _9916] = mem[_6060 + 32 len 32 * _9916]
        var72001 = _9916
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9916) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10863 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10913 = mem[_10863]
        require mem[_10863] <= test266151307()
        require _10863 + mem[_10863] + 31 < _10863 + return_data.size
        _10986 = mem[_10863 + mem[_10863]]
        if mem[_10863 + mem[_10863]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10863 + mem[_10863]]) + 1 < 0 or _10863 + ceil32(return_data.size) + ceil32(32 * mem[_10863 + mem[_10863]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10863 + ceil32(return_data.size) + ceil32(32 * mem[_10863 + mem[_10863]]) + 1
        mem[_10863 + ceil32(return_data.size)] = _10986
        require _10913 + (32 * _10986) + 32 <= return_data.size
        mem[_10863 + ceil32(return_data.size) + 32 len 32 * _10986] = mem[_10863 + _10913 + 32 len 32 * _10986]
        var91001 = _10986
        var91002 = _10863 + _10913 + (32 * _10986) + 32
        var91004 = _10863 + ceil32(return_data.size) + (32 * _10986) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10986
        mem[mem[64] + 64 len 32 * _10986] = mem[_10863 + ceil32(return_data.size) + 32 len 32 * _10986]
        return Array(len=_10986, data=mem[mem[64] + 64 len 32 * _10986])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10)
    mem[ceil32(return_data.size) + 224] = stor10[ext_call.return_data[31 len 1]].field_0
    idx = ceil32(return_data.size) + 224
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 192 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
    if not stor10[ext_call.return_data[31 len 1]].field_256:
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1194 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1194 + 32 len mem[_1194]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2489 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2489] = address(stor5[idx].field_0)
                mem[_2489 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2504 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2504]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2504]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2608 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2652 = mem[_2608]
                require mem[_2608] <= test266151307()
                require _2608 + mem[_2608] + 31 < _2608 + return_data.size
                _2794 = mem[_2608 + mem[_2608]]
                if mem[_2608 + mem[_2608]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2608 + mem[_2608]]) + 1 < 0 or _2608 + ceil32(return_data.size) + ceil32(32 * mem[_2608 + mem[_2608]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2608 + ceil32(return_data.size) + ceil32(32 * mem[_2608 + mem[_2608]]) + 1
                mem[_2608 + ceil32(return_data.size)] = _2794
                require _2652 + (32 * _2794) + 32 <= return_data.size
                s = 0
                u = _2608 + _2652 + 32
                v = _2608 + ceil32(return_data.size) + 32
                while s < _2794:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _4114 = mem[_2608 + 32]
                require mem[_2608 + 32] <= test266151307()
                require _2608 + mem[_2608 + 32] + 31 < _2608 + return_data.size
                _4147 = mem[_2608 + mem[_2608 + 32]]
                if mem[_2608 + mem[_2608 + 32]] > test266151307():
                    revert with 0, 65
                _4408 = mem[64]
                if mem[64] + ceil32(32 * mem[_2608 + mem[_2608 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2608 + mem[_2608 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2608 + mem[_2608 + 32]]) + 1
                mem[_4408] = _4147
                require _4114 + (32 * _4147) + 32 <= return_data.size
                s = 0
                u = _2608 + _4114 + 32
                v = _4408 + 32
                while s < _4147:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2608 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2608 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2503 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2503 + (64 * s + t) + 64
                if not s + t:
                    _3956 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3956:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _4060 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_4060 + 32 len mem[_4060]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3956 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2503]:
                            revert with 0, 50
                        mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2503 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2503 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3956 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _6031 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6031] = address(stor5[idx].field_0)
                        mem[_6031 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _6064 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _7765 = mem[_6064]
                            v = 0
                            w = u
                            while v < _7765:
                                if v >= mem[_6064]:
                                    revert with 0, 50
                                if w >= mem[_2503]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6064 + 32]
                                if v >= mem[_6064 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2503 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _6064 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _7765 = mem[_6064]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6317 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _6403 = mem[_6317]
                            require mem[_6317] <= test266151307()
                            require _6317 + mem[_6317] + 31 < _6317 + return_data.size
                            _6557 = mem[_6317 + mem[_6317]]
                            if mem[_6317 + mem[_6317]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_6317 + mem[_6317]]) + 1 < 0 or _6317 + ceil32(return_data.size) + ceil32(32 * mem[_6317 + mem[_6317]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _6317 + ceil32(return_data.size) + ceil32(32 * mem[_6317 + mem[_6317]]) + 1
                            mem[_6317 + ceil32(return_data.size)] = _6557
                            require _6403 + (32 * _6557) + 32 <= return_data.size
                            v = 0
                            w = _6317 + _6403 + 32
                            x = _6317 + ceil32(return_data.size) + 32
                            while v < _6557:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7978 = mem[_6317 + 32]
                            require mem[_6317 + 32] <= test266151307()
                            require _6317 + mem[_6317 + 32] + 31 < _6317 + return_data.size
                            _8093 = mem[_6317 + mem[_6317 + 32]]
                            if mem[_6317 + mem[_6317 + 32]] > test266151307():
                                revert with 0, 65
                            _8300 = mem[64]
                            if mem[64] + ceil32(32 * mem[_6317 + mem[_6317 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6317 + mem[_6317 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_6317 + mem[_6317 + 32]]) + 1
                            mem[_8300] = _8093
                            require _7978 + (32 * _8093) + 32 <= return_data.size
                            v = 0
                            w = _6317 + _7978 + 32
                            x = _8300 + 32
                            while v < _8093:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _10565 = mem[_6317 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _10565:
                                if v >= mem[_6317 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2503]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6317 + ceil32(return_data.size) + 32]
                                if v >= mem[_8300]:
                                    revert with 0, 50
                                if w >= mem[_2503 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _8300 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _10565 = mem[_6317 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _6135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6135] = address(stor5[arg2].field_0)
                    mem[_6135 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _6227 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_6227 + 32] = 32
                        mem[_6227 + 64] = mem[_6227]
                        mem[_6227 + 96 len 32 * mem[_6227]] = mem[_6227 + 32 len 32 * mem[_6227]]
                        var66001 = mem[_6227]
                        var66002 = _6227 + (32 * mem[_6227]) + 32
                        return memory
                          from mem[64]
                           len _6227 + (32 * mem[_6227]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _6437 = mem[_2503]
                    mem[mem[64] + 100] = mem[_2503]
                    mem[mem[64] + 132 len 32 * _6437] = mem[_2503 + 32 len 32 * _6437]
                    var67001 = _6437
                    var67002 = _2503 + (32 * _6437) + 32
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6437) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8092 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8209 = mem[_8092]
                    require mem[_8092] <= test266151307()
                    require _8092 + mem[_8092] + 31 < _8092 + return_data.size
                    _8395 = mem[_8092 + mem[_8092]]
                    if mem[_8092 + mem[_8092]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8092 + mem[_8092]]) + 1 < 0 or _8092 + ceil32(return_data.size) + ceil32(32 * mem[_8092 + mem[_8092]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8092 + ceil32(return_data.size) + ceil32(32 * mem[_8092 + mem[_8092]]) + 1
                    mem[_8092 + ceil32(return_data.size)] = _8395
                    require _8209 + (32 * _8395) + 32 <= return_data.size
                    mem[_8092 + ceil32(return_data.size) + 32 len 32 * _8395] = mem[_8092 + _8209 + 32 len 32 * _8395]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _8395
                    mem[mem[64] + 64 len 32 * _8395] = mem[_8092 + ceil32(return_data.size) + 32 len 32 * _8395]
                    var94001 = _8395
                    var94002 = _8092 + ceil32(return_data.size) + (32 * _8395) + 32
                    return Array(len=_8395, data=mem[mem[64] + 64 len 32 * _8395])
                mem[_2503 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3958 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3958:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4067 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4067 + 32 len mem[_4067]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3958 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2503]:
                        revert with 0, 50
                    mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2503 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2503 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3958 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6036 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6036] = address(stor5[idx].field_0)
                    mem[_6036 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6065 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7766 = mem[_6065]
                        v = 0
                        w = u
                        while v < _7766:
                            if v >= mem[_6065]:
                                revert with 0, 50
                            if w >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6065 + 32]
                            if v >= mem[_6065 + 32]:
                                revert with 0, 50
                            if w >= mem[_2503 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _6065 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7766 = mem[_6065]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6321 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6407 = mem[_6321]
                        require mem[_6321] <= test266151307()
                        require _6321 + mem[_6321] + 31 < _6321 + return_data.size
                        _6559 = mem[_6321 + mem[_6321]]
                        if mem[_6321 + mem[_6321]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6321 + mem[_6321]]) + 1 < 0 or _6321 + ceil32(return_data.size) + ceil32(32 * mem[_6321 + mem[_6321]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6321 + ceil32(return_data.size) + ceil32(32 * mem[_6321 + mem[_6321]]) + 1
                        mem[_6321 + ceil32(return_data.size)] = _6559
                        require _6407 + (32 * _6559) + 32 <= return_data.size
                        v = 0
                        w = _6321 + _6407 + 32
                        x = _6321 + ceil32(return_data.size) + 32
                        while v < _6559:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7981 = mem[_6321 + 32]
                        require mem[_6321 + 32] <= test266151307()
                        require _6321 + mem[_6321 + 32] + 31 < _6321 + return_data.size
                        _8095 = mem[_6321 + mem[_6321 + 32]]
                        if mem[_6321 + mem[_6321 + 32]] > test266151307():
                            revert with 0, 65
                        _8301 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6321 + mem[_6321 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6321 + mem[_6321 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6321 + mem[_6321 + 32]]) + 1
                        mem[_8301] = _8095
                        require _7981 + (32 * _8095) + 32 <= return_data.size
                        v = 0
                        w = _6321 + _7981 + 32
                        x = _8301 + 32
                        while v < _8095:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10566 = mem[_6321 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10566:
                            if v >= mem[_6321 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6321 + ceil32(return_data.size) + 32]
                            if v >= mem[_8301]:
                                revert with 0, 50
                            if w >= mem[_2503 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _8301 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10566 = mem[_6321 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6140 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6140] = address(stor5[arg2].field_0)
                mem[_6140 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6233 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6233 + 32] = 32
                    mem[_6233 + 64] = mem[_6233]
                    mem[_6233 + 96 len 32 * mem[_6233]] = mem[_6233 + 32 len 32 * mem[_6233]]
                    var67001 = mem[_6233]
                    var67002 = _6233 + (32 * mem[_6233]) + 32
                    return memory
                      from mem[64]
                       len _6233 + (32 * mem[_6233]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6438 = mem[_2503]
                mem[mem[64] + 100] = mem[_2503]
                mem[mem[64] + 132 len 32 * _6438] = mem[_2503 + 32 len 32 * _6438]
                var68001 = _6438
                var68002 = _2503 + (32 * _6438) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6438) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8094 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8210 = mem[_8094]
                require mem[_8094] <= test266151307()
                require _8094 + mem[_8094] + 31 < _8094 + return_data.size
                _8396 = mem[_8094 + mem[_8094]]
                if mem[_8094 + mem[_8094]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8094 + mem[_8094]]) + 1 < 0 or _8094 + ceil32(return_data.size) + ceil32(32 * mem[_8094 + mem[_8094]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8094 + ceil32(return_data.size) + ceil32(32 * mem[_8094 + mem[_8094]]) + 1
                mem[_8094 + ceil32(return_data.size)] = _8396
                require _8210 + (32 * _8396) + 32 <= return_data.size
                mem[_8094 + ceil32(return_data.size) + 32 len 32 * _8396] = mem[_8094 + _8210 + 32 len 32 * _8396]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8396
                mem[mem[64] + 64 len 32 * _8396] = mem[_8094 + ceil32(return_data.size) + 32 len 32 * _8396]
                var95001 = _8396
                var95002 = _8094 + ceil32(return_data.size) + (32 * _8396) + 32
                return Array(len=_8396, data=mem[mem[64] + 64 len 32 * _8396])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2607 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2607 + (32 * s + t) + 32
            if s + t:
                mem[_2607 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3954 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3954:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4053 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4053 + 32 len mem[_4053]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3954 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2503]:
                        revert with 0, 50
                    mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2607]:
                        revert with 0, 50
                    mem[(32 * u) + _2607 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3954 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6026 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6026] = address(stor5[idx].field_0)
                    mem[_6026 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6063 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7764 = mem[_6063]
                        s = 0
                        t = u
                        while s < _7764:
                            if s >= mem[_6063]:
                                revert with 0, 50
                            if t >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6063 + 32]
                            if s >= mem[_6063 + 32]:
                                revert with 0, 50
                            if t >= mem[_2607]:
                                revert with 0, 50
                            mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _6063 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _7764 = mem[_6063]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6313 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6399 = mem[_6313]
                        require mem[_6313] <= test266151307()
                        require _6313 + mem[_6313] + 31 < _6313 + return_data.size
                        _6555 = mem[_6313 + mem[_6313]]
                        if mem[_6313 + mem[_6313]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6313 + mem[_6313]]) + 1 < 0 or _6313 + ceil32(return_data.size) + ceil32(32 * mem[_6313 + mem[_6313]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6313 + ceil32(return_data.size) + ceil32(32 * mem[_6313 + mem[_6313]]) + 1
                        mem[_6313 + ceil32(return_data.size)] = _6555
                        require _6399 + (32 * _6555) + 32 <= return_data.size
                        s = 0
                        t = _6313 + _6399 + 32
                        v = _6313 + ceil32(return_data.size) + 32
                        while s < _6555:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7975 = mem[_6313 + 32]
                        require mem[_6313 + 32] <= test266151307()
                        require _6313 + mem[_6313 + 32] + 31 < _6313 + return_data.size
                        _8091 = mem[_6313 + mem[_6313 + 32]]
                        if mem[_6313 + mem[_6313 + 32]] > test266151307():
                            revert with 0, 65
                        _8299 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6313 + mem[_6313 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6313 + mem[_6313 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6313 + mem[_6313 + 32]]) + 1
                        mem[_8299] = _8091
                        require _7975 + (32 * _8091) + 32 <= return_data.size
                        s = 0
                        t = _6313 + _7975 + 32
                        v = _8299 + 32
                        while s < _8091:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10564 = mem[_6313 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10564:
                            if s >= mem[_6313 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6313 + ceil32(return_data.size) + 32]
                            if s >= mem[_8299]:
                                revert with 0, 50
                            if t >= mem[_2607]:
                                revert with 0, 50
                            mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _8299 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10564 = mem[_6313 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6130 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6130] = address(stor5[arg2].field_0)
                mem[_6130 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6221 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6221 + 32] = 32
                    mem[_6221 + 64] = mem[_6221]
                    mem[_6221 + 96 len 32 * mem[_6221]] = mem[_6221 + 32 len 32 * mem[_6221]]
                    var66001 = mem[_6221]
                    var66002 = _6221 + (32 * mem[_6221]) + 32
                    return memory
                      from mem[64]
                       len _6221 + (32 * mem[_6221]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6436 = mem[_2503]
                mem[mem[64] + 100] = mem[_2503]
                mem[mem[64] + 132 len 32 * _6436] = mem[_2503 + 32 len 32 * _6436]
                var67001 = _6436
                var67002 = _2503 + (32 * _6436) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6436) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8090 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8208 = mem[_8090]
                require mem[_8090] <= test266151307()
                require _8090 + mem[_8090] + 31 < _8090 + return_data.size
                _8394 = mem[_8090 + mem[_8090]]
                if mem[_8090 + mem[_8090]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8090 + mem[_8090]]) + 1 < 0 or _8090 + ceil32(return_data.size) + ceil32(32 * mem[_8090 + mem[_8090]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8090 + ceil32(return_data.size) + ceil32(32 * mem[_8090 + mem[_8090]]) + 1
                mem[_8090 + ceil32(return_data.size)] = _8394
                require _8208 + (32 * _8394) + 32 <= return_data.size
                mem[_8090 + ceil32(return_data.size) + 32 len 32 * _8394] = mem[_8090 + _8208 + 32 len 32 * _8394]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8394
                mem[mem[64] + 64 len 32 * _8394] = mem[_8090 + ceil32(return_data.size) + 32 len 32 * _8394]
                var94001 = _8394
                var94002 = _8090 + ceil32(return_data.size) + (32 * _8394) + 32
                return Array(len=_8394, data=mem[mem[64] + 64 len 32 * _8394])
            _3952 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3952:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _4046 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_4046 + 32 len mem[_4046]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3952 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2503]:
                    revert with 0, 50
                mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2607]:
                    revert with 0, 50
                mem[(32 * u) + _2607 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3952 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _6021 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6021] = address(stor5[idx].field_0)
                mem[_6021 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _6062 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _7763 = mem[_6062]
                    s = 0
                    t = u
                    while s < _7763:
                        if s >= mem[_6062]:
                            revert with 0, 50
                        if t >= mem[_2503]:
                            revert with 0, 50
                        mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6062 + 32]
                        if s >= mem[_6062 + 32]:
                            revert with 0, 50
                        if t >= mem[_2607]:
                            revert with 0, 50
                        mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _6062 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _7763 = mem[_6062]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6309 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _6395 = mem[_6309]
                    require mem[_6309] <= test266151307()
                    require _6309 + mem[_6309] + 31 < _6309 + return_data.size
                    _6553 = mem[_6309 + mem[_6309]]
                    if mem[_6309 + mem[_6309]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_6309 + mem[_6309]]) + 1 < 0 or _6309 + ceil32(return_data.size) + ceil32(32 * mem[_6309 + mem[_6309]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _6309 + ceil32(return_data.size) + ceil32(32 * mem[_6309 + mem[_6309]]) + 1
                    mem[_6309 + ceil32(return_data.size)] = _6553
                    require _6395 + (32 * _6553) + 32 <= return_data.size
                    s = 0
                    t = _6309 + _6395 + 32
                    v = _6309 + ceil32(return_data.size) + 32
                    while s < _6553:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _7972 = mem[_6309 + 32]
                    require mem[_6309 + 32] <= test266151307()
                    require _6309 + mem[_6309 + 32] + 31 < _6309 + return_data.size
                    _8089 = mem[_6309 + mem[_6309 + 32]]
                    if mem[_6309 + mem[_6309 + 32]] > test266151307():
                        revert with 0, 65
                    _8298 = mem[64]
                    if mem[64] + ceil32(32 * mem[_6309 + mem[_6309 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6309 + mem[_6309 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_6309 + mem[_6309 + 32]]) + 1
                    mem[_8298] = _8089
                    require _7972 + (32 * _8089) + 32 <= return_data.size
                    s = 0
                    t = _6309 + _7972 + 32
                    v = _8298 + 32
                    while s < _8089:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10563 = mem[_6309 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10563:
                        if s >= mem[_6309 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2503]:
                            revert with 0, 50
                        mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6309 + ceil32(return_data.size) + 32]
                        if s >= mem[_8298]:
                            revert with 0, 50
                        if t >= mem[_2607]:
                            revert with 0, 50
                        mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _8298 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10563 = mem[_6309 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _6125 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6125] = address(stor5[arg2].field_0)
            mem[_6125 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _6215 = mem[64]
                mem[64] = mem[64] + 32
                mem[_6215 + 32] = 32
                mem[_6215 + 64] = mem[_6215]
                mem[_6215 + 96 len 32 * mem[_6215]] = mem[_6215 + 32 len 32 * mem[_6215]]
                var65001 = mem[_6215]
                var65002 = _6215 + (32 * mem[_6215]) + 32
                return memory
                  from mem[64]
                   len _6215 + (32 * mem[_6215]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _6435 = mem[_2503]
            mem[mem[64] + 100] = mem[_2503]
            mem[mem[64] + 132 len 32 * _6435] = mem[_2503 + 32 len 32 * _6435]
            var66001 = _6435
            var66002 = _2503 + (32 * _6435) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6435) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8088 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _8207 = mem[_8088]
            require mem[_8088] <= test266151307()
            require _8088 + mem[_8088] + 31 < _8088 + return_data.size
            _8393 = mem[_8088 + mem[_8088]]
            if mem[_8088 + mem[_8088]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8088 + mem[_8088]]) + 1 < 0 or _8088 + ceil32(return_data.size) + ceil32(32 * mem[_8088 + mem[_8088]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8088 + ceil32(return_data.size) + ceil32(32 * mem[_8088 + mem[_8088]]) + 1
            mem[_8088 + ceil32(return_data.size)] = _8393
            require _8207 + (32 * _8393) + 32 <= return_data.size
            mem[_8088 + ceil32(return_data.size) + 32 len 32 * _8393] = mem[_8088 + _8207 + 32 len 32 * _8393]
            var85001 = _8393
            var85002 = _8088 + _8207 + (32 * _8393) + 32
            var85004 = _8088 + ceil32(return_data.size) + (32 * _8393) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _8393
            mem[mem[64] + 64 len 32 * _8393] = mem[_8088 + ceil32(return_data.size) + 32 len 32 * _8393]
            var93001 = _8393
            var93002 = _8088 + ceil32(return_data.size) + (32 * _8393) + 32
            return Array(len=_8393, data=mem[mem[64] + 64 len 32 * _8393])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _4075 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_4075 + 32 len mem[_4075]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _6041 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6041] = address(stor5[idx].field_0)
            mem[_6041 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _6068 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_6068]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_6068]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6325 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _6412 = mem[_6325]
            require mem[_6325] <= test266151307()
            require _6325 + mem[_6325] + 31 < _6325 + return_data.size
            _6569 = mem[_6325 + mem[_6325]]
            if mem[_6325 + mem[_6325]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_6325 + mem[_6325]]) + 1 < 0 or _6325 + ceil32(return_data.size) + ceil32(32 * mem[_6325 + mem[_6325]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _6325 + ceil32(return_data.size) + ceil32(32 * mem[_6325 + mem[_6325]]) + 1
            mem[_6325 + ceil32(return_data.size)] = _6569
            require _6412 + (32 * _6569) + 32 <= return_data.size
            s = 0
            u = _6325 + _6412 + 32
            v = _6325 + ceil32(return_data.size) + 32
            while s < _6569:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7988 = mem[_6325 + 32]
            require mem[_6325 + 32] <= test266151307()
            require _6325 + mem[_6325 + 32] + 31 < _6325 + return_data.size
            _8096 = mem[_6325 + mem[_6325 + 32]]
            if mem[_6325 + mem[_6325 + 32]] > test266151307():
                revert with 0, 65
            _8330 = mem[64]
            if mem[64] + ceil32(32 * mem[_6325 + mem[_6325 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6325 + mem[_6325 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_6325 + mem[_6325 + 32]]) + 1
            mem[_8330] = _8096
            require _7988 + (32 * _8096) + 32 <= return_data.size
            s = 0
            u = _6325 + _7988 + 32
            v = _8330 + 32
            while s < _8096:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_6325 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_6325 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _6067 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _6324 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _6324 + (32 * s + t) + 32
            if not s + t:
                _7768 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _7768:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7872 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7872 + 32 len mem[_7872]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _7768 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_6067]:
                        revert with 0, 50
                    mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_6324]:
                        revert with 0, 50
                    mem[(32 * u) + _6324 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7768 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _9458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9458] = address(stor5[idx].field_0)
                    mem[_9458 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _9507 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _10567 = mem[_9507]
                        s = 0
                        t = u
                        while s < _10567:
                            if s >= mem[_9507]:
                                revert with 0, 50
                            if t >= mem[_6067]:
                                revert with 0, 50
                            mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9507 + 32]
                            if s >= mem[_9507 + 32]:
                                revert with 0, 50
                            if t >= mem[_6324]:
                                revert with 0, 50
                            mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _9507 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10567 = mem[_9507]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9804 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _9879 = mem[_9804]
                        require mem[_9804] <= test266151307()
                        require _9804 + mem[_9804] + 31 < _9804 + return_data.size
                        _9974 = mem[_9804 + mem[_9804]]
                        if mem[_9804 + mem[_9804]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_9804 + mem[_9804]]) + 1 < 0 or _9804 + ceil32(return_data.size) + ceil32(32 * mem[_9804 + mem[_9804]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _9804 + ceil32(return_data.size) + ceil32(32 * mem[_9804 + mem[_9804]]) + 1
                        mem[_9804 + ceil32(return_data.size)] = _9974
                        require _9879 + (32 * _9974) + 32 <= return_data.size
                        s = 0
                        t = _9804 + _9879 + 32
                        v = _9804 + ceil32(return_data.size) + 32
                        while s < _9974:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10720 = mem[_9804 + 32]
                        require mem[_9804 + 32] <= test266151307()
                        require _9804 + mem[_9804 + 32] + 31 < _9804 + return_data.size
                        _10866 = mem[_9804 + mem[_9804 + 32]]
                        if mem[_9804 + mem[_9804 + 32]] > test266151307():
                            revert with 0, 65
                        _10946 = mem[64]
                        if mem[64] + ceil32(32 * mem[_9804 + mem[_9804 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9804 + mem[_9804 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_9804 + mem[_9804 + 32]]) + 1
                        mem[_10946] = _10866
                        require _10720 + (32 * _10866) + 32 <= return_data.size
                        s = 0
                        t = _9804 + _10720 + 32
                        v = _10946 + 32
                        while s < _10866:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _11731 = mem[_9804 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _11731:
                            if s >= mem[_9804 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_6067]:
                                revert with 0, 50
                            mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9804 + ceil32(return_data.size) + 32]
                            if s >= mem[_10946]:
                                revert with 0, 50
                            if t >= mem[_6324]:
                                revert with 0, 50
                            mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _10946 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _11731 = mem[_9804 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _9576 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9576] = address(stor5[arg2].field_0)
                mem[_9576 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _9677 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_9677 + 32] = 32
                    mem[_9677 + 64] = mem[_9677]
                    mem[_9677 + 96 len 32 * mem[_9677]] = mem[_9677 + 32 len 32 * mem[_9677]]
                    var69001 = mem[_9677]
                    var69002 = _9677 + (32 * mem[_9677]) + 32
                    return memory
                      from mem[64]
                       len _9677 + (32 * mem[_9677]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _9917 = mem[_6067]
                mem[mem[64] + 100] = mem[_6067]
                mem[mem[64] + 132 len 32 * _9917] = mem[_6067 + 32 len 32 * _9917]
                var70001 = _9917
                var70002 = _6067 + (32 * _9917) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9917) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10865 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _10914 = mem[_10865]
                require mem[_10865] <= test266151307()
                require _10865 + mem[_10865] + 31 < _10865 + return_data.size
                _10987 = mem[_10865 + mem[_10865]]
                if mem[_10865 + mem[_10865]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10865 + mem[_10865]]) + 1 < 0 or _10865 + ceil32(return_data.size) + ceil32(32 * mem[_10865 + mem[_10865]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10865 + ceil32(return_data.size) + ceil32(32 * mem[_10865 + mem[_10865]]) + 1
                mem[_10865 + ceil32(return_data.size)] = _10987
                require _10914 + (32 * _10987) + 32 <= return_data.size
                mem[_10865 + ceil32(return_data.size) + 32 len 32 * _10987] = mem[_10865 + _10914 + 32 len 32 * _10987]
                var89001 = _10987
                var89002 = _10865 + _10914 + (32 * _10987) + 32
                var89004 = _10865 + ceil32(return_data.size) + (32 * _10987) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _10987
                mem[mem[64] + 64 len 32 * _10987] = mem[_10865 + ceil32(return_data.size) + 32 len 32 * _10987]
                var97001 = _10987
                var97002 = _10865 + ceil32(return_data.size) + (32 * _10987) + 32
                return Array(len=_10987, data=mem[mem[64] + 64 len 32 * _10987])
            mem[_6324 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _7770 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7770:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7879 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7879 + 32 len mem[_7879]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7770 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6067]:
                    revert with 0, 50
                mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6324]:
                    revert with 0, 50
                mem[(32 * u) + _6324 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7770 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9463 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9463] = address(stor5[idx].field_0)
                mem[_9463 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9508 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10568 = mem[_9508]
                    s = 0
                    t = u
                    while s < _10568:
                        if s >= mem[_9508]:
                            revert with 0, 50
                        if t >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9508 + 32]
                        if s >= mem[_9508 + 32]:
                            revert with 0, 50
                        if t >= mem[_6324]:
                            revert with 0, 50
                        mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _9508 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10568 = mem[_9508]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9808 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9883 = mem[_9808]
                    require mem[_9808] <= test266151307()
                    require _9808 + mem[_9808] + 31 < _9808 + return_data.size
                    _9976 = mem[_9808 + mem[_9808]]
                    if mem[_9808 + mem[_9808]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9808 + mem[_9808]]) + 1 < 0 or _9808 + ceil32(return_data.size) + ceil32(32 * mem[_9808 + mem[_9808]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9808 + ceil32(return_data.size) + ceil32(32 * mem[_9808 + mem[_9808]]) + 1
                    mem[_9808 + ceil32(return_data.size)] = _9976
                    require _9883 + (32 * _9976) + 32 <= return_data.size
                    s = 0
                    t = _9808 + _9883 + 32
                    v = _9808 + ceil32(return_data.size) + 32
                    while s < _9976:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10723 = mem[_9808 + 32]
                    require mem[_9808 + 32] <= test266151307()
                    require _9808 + mem[_9808 + 32] + 31 < _9808 + return_data.size
                    _10868 = mem[_9808 + mem[_9808 + 32]]
                    if mem[_9808 + mem[_9808 + 32]] > test266151307():
                        revert with 0, 65
                    _10947 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9808 + mem[_9808 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9808 + mem[_9808 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9808 + mem[_9808 + 32]]) + 1
                    mem[_10947] = _10868
                    require _10723 + (32 * _10868) + 32 <= return_data.size
                    s = 0
                    t = _9808 + _10723 + 32
                    v = _10947 + 32
                    while s < _10868:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11732 = mem[_9808 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _11732:
                        if s >= mem[_9808 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9808 + ceil32(return_data.size) + 32]
                        if s >= mem[_10947]:
                            revert with 0, 50
                        if t >= mem[_6324]:
                            revert with 0, 50
                        mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _10947 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11732 = mem[_9808 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9581 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9581] = address(stor5[arg2].field_0)
            mem[_9581 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9683 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9683 + 32] = 32
                mem[_9683 + 64] = mem[_9683]
                mem[_9683 + 96 len 32 * mem[_9683]] = mem[_9683 + 32 len 32 * mem[_9683]]
                var70001 = mem[_9683]
                var70002 = _9683 + (32 * mem[_9683]) + 32
                return memory
                  from mem[64]
                   len _9683 + (32 * mem[_9683]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9918 = mem[_6067]
            mem[mem[64] + 100] = mem[_6067]
            mem[mem[64] + 132 len 32 * _9918] = mem[_6067 + 32 len 32 * _9918]
            var71001 = _9918
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9918) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10867 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10915 = mem[_10867]
            require mem[_10867] <= test266151307()
            require _10867 + mem[_10867] + 31 < _10867 + return_data.size
            _10988 = mem[_10867 + mem[_10867]]
            if mem[_10867 + mem[_10867]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10867 + mem[_10867]]) + 1 < 0 or _10867 + ceil32(return_data.size) + ceil32(32 * mem[_10867 + mem[_10867]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10867 + ceil32(return_data.size) + ceil32(32 * mem[_10867 + mem[_10867]]) + 1
            mem[_10867 + ceil32(return_data.size)] = _10988
            require _10915 + (32 * _10988) + 32 <= return_data.size
            mem[_10867 + ceil32(return_data.size) + 32 len 32 * _10988] = mem[_10867 + _10915 + 32 len 32 * _10988]
            var90001 = _10988
            var90002 = _10867 + _10915 + (32 * _10988) + 32
            var90004 = _10867 + ceil32(return_data.size) + (32 * _10988) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10988
            mem[mem[64] + 64 len 32 * _10988] = mem[_10867 + ceil32(return_data.size) + 32 len 32 * _10988]
            var98001 = _10988
            var98002 = _10867 + ceil32(return_data.size) + (32 * _10988) + 32
            return Array(len=_10988, data=mem[mem[64] + 64 len 32 * _10988])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _6067 + (64 * s + t) + 64
        if not s + t:
            _7772 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7772:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7886 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7886 + 32 len mem[_7886]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7772 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6067]:
                    revert with 0, 50
                mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6067 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _6067 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7772 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9468 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9468] = address(stor5[idx].field_0)
                mem[_9468 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9509 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10569 = mem[_9509]
                    v = 0
                    w = u
                    while v < _10569:
                        if v >= mem[_9509]:
                            revert with 0, 50
                        if w >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9509 + 32]
                        if v >= mem[_9509 + 32]:
                            revert with 0, 50
                        if w >= mem[_6067 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _9509 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10569 = mem[_9509]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9812 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9887 = mem[_9812]
                    require mem[_9812] <= test266151307()
                    require _9812 + mem[_9812] + 31 < _9812 + return_data.size
                    _9978 = mem[_9812 + mem[_9812]]
                    if mem[_9812 + mem[_9812]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9812 + mem[_9812]]) + 1 < 0 or _9812 + ceil32(return_data.size) + ceil32(32 * mem[_9812 + mem[_9812]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9812 + ceil32(return_data.size) + ceil32(32 * mem[_9812 + mem[_9812]]) + 1
                    mem[_9812 + ceil32(return_data.size)] = _9978
                    require _9887 + (32 * _9978) + 32 <= return_data.size
                    v = 0
                    w = _9812 + _9887 + 32
                    x = _9812 + ceil32(return_data.size) + 32
                    while v < _9978:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10726 = mem[_9812 + 32]
                    require mem[_9812 + 32] <= test266151307()
                    require _9812 + mem[_9812 + 32] + 31 < _9812 + return_data.size
                    _10870 = mem[_9812 + mem[_9812 + 32]]
                    if mem[_9812 + mem[_9812 + 32]] > test266151307():
                        revert with 0, 65
                    _10948 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9812 + mem[_9812 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9812 + mem[_9812 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9812 + mem[_9812 + 32]]) + 1
                    mem[_10948] = _10870
                    require _10726 + (32 * _10870) + 32 <= return_data.size
                    v = 0
                    w = _9812 + _10726 + 32
                    x = _10948 + 32
                    while v < _10870:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _11733 = mem[_9812 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _11733:
                        if v >= mem[_9812 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9812 + ceil32(return_data.size) + 32]
                        if v >= mem[_10948]:
                            revert with 0, 50
                        if w >= mem[_6067 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _10948 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _11733 = mem[_9812 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9586 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9586] = address(stor5[arg2].field_0)
            mem[_9586 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9689 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9689 + 32] = 32
                mem[_9689 + 64] = mem[_9689]
                mem[_9689 + 96 len 32 * mem[_9689]] = mem[_9689 + 32 len 32 * mem[_9689]]
                var70001 = mem[_9689]
                var70002 = _9689 + (32 * mem[_9689]) + 32
                return memory
                  from mem[64]
                   len _9689 + (32 * mem[_9689]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9919 = mem[_6067]
            mem[mem[64] + 100] = mem[_6067]
            mem[mem[64] + 132 len 32 * _9919] = mem[_6067 + 32 len 32 * _9919]
            var71001 = _9919
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9919) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10869 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10916 = mem[_10869]
            require mem[_10869] <= test266151307()
            require _10869 + mem[_10869] + 31 < _10869 + return_data.size
            _10989 = mem[_10869 + mem[_10869]]
            if mem[_10869 + mem[_10869]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10869 + mem[_10869]]) + 1 < 0 or _10869 + ceil32(return_data.size) + ceil32(32 * mem[_10869 + mem[_10869]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10869 + ceil32(return_data.size) + ceil32(32 * mem[_10869 + mem[_10869]]) + 1
            mem[_10869 + ceil32(return_data.size)] = _10989
            require _10916 + (32 * _10989) + 32 <= return_data.size
            mem[_10869 + ceil32(return_data.size) + 32 len 32 * _10989] = mem[_10869 + _10916 + 32 len 32 * _10989]
            var90001 = _10989
            var90002 = _10869 + _10916 + (32 * _10989) + 32
            var90004 = _10869 + ceil32(return_data.size) + (32 * _10989) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10989
            mem[mem[64] + 64 len 32 * _10989] = mem[_10869 + ceil32(return_data.size) + 32 len 32 * _10989]
            var98001 = _10989
            var98002 = _10869 + ceil32(return_data.size) + (32 * _10989) + 32
            return Array(len=_10989, data=mem[mem[64] + 64 len 32 * _10989])
        mem[_6067 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _7774 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _7774:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7893 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7893 + 32 len mem[_7893]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _7774 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_6067]:
                revert with 0, 50
            mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_6067 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _6067 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7774 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _9473 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9473] = address(stor5[idx].field_0)
            mem[_9473 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _9510 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10570 = mem[_9510]
                v = 0
                w = u
                while v < _10570:
                    if v >= mem[_9510]:
                        revert with 0, 50
                    if w >= mem[_6067]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9510 + 32]
                    if v >= mem[_9510 + 32]:
                        revert with 0, 50
                    if w >= mem[_6067 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _9510 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10570 = mem[_9510]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9816 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _9891 = mem[_9816]
                require mem[_9816] <= test266151307()
                require _9816 + mem[_9816] + 31 < _9816 + return_data.size
                _9980 = mem[_9816 + mem[_9816]]
                if mem[_9816 + mem[_9816]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9816 + mem[_9816]]) + 1 < 0 or _9816 + ceil32(return_data.size) + ceil32(32 * mem[_9816 + mem[_9816]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9816 + ceil32(return_data.size) + ceil32(32 * mem[_9816 + mem[_9816]]) + 1
                mem[_9816 + ceil32(return_data.size)] = _9980
                require _9891 + (32 * _9980) + 32 <= return_data.size
                v = 0
                w = _9816 + _9891 + 32
                x = _9816 + ceil32(return_data.size) + 32
                while v < _9980:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10729 = mem[_9816 + 32]
                require mem[_9816 + 32] <= test266151307()
                require _9816 + mem[_9816 + 32] + 31 < _9816 + return_data.size
                _10872 = mem[_9816 + mem[_9816 + 32]]
                if mem[_9816 + mem[_9816 + 32]] > test266151307():
                    revert with 0, 65
                _10949 = mem[64]
                if mem[64] + ceil32(32 * mem[_9816 + mem[_9816 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9816 + mem[_9816 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_9816 + mem[_9816 + 32]]) + 1
                mem[_10949] = _10872
                require _10729 + (32 * _10872) + 32 <= return_data.size
                v = 0
                w = _9816 + _10729 + 32
                x = _10949 + 32
                while v < _10872:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11734 = mem[_9816 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _11734:
                    if v >= mem[_9816 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_6067]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9816 + ceil32(return_data.size) + 32]
                    if v >= mem[_10949]:
                        revert with 0, 50
                    if w >= mem[_6067 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _10949 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11734 = mem[_9816 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _9591 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9591] = address(stor5[arg2].field_0)
        mem[_9591 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _9695 = mem[64]
            mem[64] = mem[64] + 32
            mem[_9695 + 32] = 32
            mem[_9695 + 64] = mem[_9695]
            mem[_9695 + 96 len 32 * mem[_9695]] = mem[_9695 + 32 len 32 * mem[_9695]]
            var71001 = mem[_9695]
            return memory
              from mem[64]
               len _9695 + (32 * mem[_9695]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _9920 = mem[_6067]
        mem[mem[64] + 100] = mem[_6067]
        mem[mem[64] + 132 len 32 * _9920] = mem[_6067 + 32 len 32 * _9920]
        var72001 = _9920
        var72002 = _6067 + (32 * _9920) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9920) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10871 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10917 = mem[_10871]
        require mem[_10871] <= test266151307()
        require _10871 + mem[_10871] + 31 < _10871 + return_data.size
        _10990 = mem[_10871 + mem[_10871]]
        if mem[_10871 + mem[_10871]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10871 + mem[_10871]]) + 1 < 0 or _10871 + ceil32(return_data.size) + ceil32(32 * mem[_10871 + mem[_10871]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10871 + ceil32(return_data.size) + ceil32(32 * mem[_10871 + mem[_10871]]) + 1
        mem[_10871 + ceil32(return_data.size)] = _10990
        require _10917 + (32 * _10990) + 32 <= return_data.size
        mem[_10871 + ceil32(return_data.size) + 32 len 32 * _10990] = mem[_10871 + _10917 + 32 len 32 * _10990]
        var91001 = _10990
        var91002 = _10871 + _10917 + (32 * _10990) + 32
        var91004 = _10871 + ceil32(return_data.size) + (32 * _10990) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10990
        mem[mem[64] + 64 len 32 * _10990] = mem[_10871 + ceil32(return_data.size) + 32 len 32 * _10990]
        var99001 = _10990
        var99002 = _10871 + ceil32(return_data.size) + (32 * _10990) + 32
        return Array(len=_10990, data=mem[mem[64] + 64 len 32 * _10990])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
    mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
    if not stor10[ext_call.return_data[31 len 1]].field_512:
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _4082 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_4082 + 32 len mem[_4082]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _6046 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6046] = address(stor5[idx].field_0)
            mem[_6046 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _6070 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_6070]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_6070]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6327 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _6415 = mem[_6327]
            require mem[_6327] <= test266151307()
            require _6327 + mem[_6327] + 31 < _6327 + return_data.size
            _6579 = mem[_6327 + mem[_6327]]
            if mem[_6327 + mem[_6327]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_6327 + mem[_6327]]) + 1 < 0 or _6327 + ceil32(return_data.size) + ceil32(32 * mem[_6327 + mem[_6327]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _6327 + ceil32(return_data.size) + ceil32(32 * mem[_6327 + mem[_6327]]) + 1
            mem[_6327 + ceil32(return_data.size)] = _6579
            require _6415 + (32 * _6579) + 32 <= return_data.size
            s = 0
            u = _6327 + _6415 + 32
            v = _6327 + ceil32(return_data.size) + 32
            while s < _6579:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7993 = mem[_6327 + 32]
            require mem[_6327 + 32] <= test266151307()
            require _6327 + mem[_6327 + 32] + 31 < _6327 + return_data.size
            _8097 = mem[_6327 + mem[_6327 + 32]]
            if mem[_6327 + mem[_6327 + 32]] > test266151307():
                revert with 0, 65
            _8359 = mem[64]
            if mem[64] + ceil32(32 * mem[_6327 + mem[_6327 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6327 + mem[_6327 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_6327 + mem[_6327 + 32]]) + 1
            mem[_8359] = _8097
            require _7993 + (32 * _8097) + 32 <= return_data.size
            s = 0
            u = _6327 + _7993 + 32
            v = _8359 + 32
            while s < _8097:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_6327 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_6327 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _6069 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _6326 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _6326 + (32 * s + t) + 32
            if not s + t:
                _7776 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _7776:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7901 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7901 + 32 len mem[_7901]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _7776 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_6069]:
                        revert with 0, 50
                    mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_6326]:
                        revert with 0, 50
                    mem[(32 * u) + _6326 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7776 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _9478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9478] = address(stor5[idx].field_0)
                    mem[_9478 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _9512 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _10571 = mem[_9512]
                        s = 0
                        t = u
                        while s < _10571:
                            if s >= mem[_9512]:
                                revert with 0, 50
                            if t >= mem[_6069]:
                                revert with 0, 50
                            mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9512 + 32]
                            if s >= mem[_9512 + 32]:
                                revert with 0, 50
                            if t >= mem[_6326]:
                                revert with 0, 50
                            mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _9512 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10571 = mem[_9512]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9820 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _9895 = mem[_9820]
                        require mem[_9820] <= test266151307()
                        require _9820 + mem[_9820] + 31 < _9820 + return_data.size
                        _9982 = mem[_9820 + mem[_9820]]
                        if mem[_9820 + mem[_9820]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_9820 + mem[_9820]]) + 1 < 0 or _9820 + ceil32(return_data.size) + ceil32(32 * mem[_9820 + mem[_9820]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _9820 + ceil32(return_data.size) + ceil32(32 * mem[_9820 + mem[_9820]]) + 1
                        mem[_9820 + ceil32(return_data.size)] = _9982
                        require _9895 + (32 * _9982) + 32 <= return_data.size
                        s = 0
                        t = _9820 + _9895 + 32
                        v = _9820 + ceil32(return_data.size) + 32
                        while s < _9982:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10732 = mem[_9820 + 32]
                        require mem[_9820 + 32] <= test266151307()
                        require _9820 + mem[_9820 + 32] + 31 < _9820 + return_data.size
                        _10874 = mem[_9820 + mem[_9820 + 32]]
                        if mem[_9820 + mem[_9820 + 32]] > test266151307():
                            revert with 0, 65
                        _10950 = mem[64]
                        if mem[64] + ceil32(32 * mem[_9820 + mem[_9820 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9820 + mem[_9820 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_9820 + mem[_9820 + 32]]) + 1
                        mem[_10950] = _10874
                        require _10732 + (32 * _10874) + 32 <= return_data.size
                        s = 0
                        t = _9820 + _10732 + 32
                        v = _10950 + 32
                        while s < _10874:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _11735 = mem[_9820 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _11735:
                            if s >= mem[_9820 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_6069]:
                                revert with 0, 50
                            mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9820 + ceil32(return_data.size) + 32]
                            if s >= mem[_10950]:
                                revert with 0, 50
                            if t >= mem[_6326]:
                                revert with 0, 50
                            mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _10950 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _11735 = mem[_9820 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _9596 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9596] = address(stor5[arg2].field_0)
                mem[_9596 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _9701 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_9701 + 32] = 32
                    mem[_9701 + 64] = mem[_9701]
                    mem[_9701 + 96 len 32 * mem[_9701]] = mem[_9701 + 32 len 32 * mem[_9701]]
                    var69001 = mem[_9701]
                    var69002 = _9701 + (32 * mem[_9701]) + 32
                    return memory
                      from mem[64]
                       len _9701 + (32 * mem[_9701]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _9921 = mem[_6069]
                mem[mem[64] + 100] = mem[_6069]
                mem[mem[64] + 132 len 32 * _9921] = mem[_6069 + 32 len 32 * _9921]
                var70001 = _9921
                var70002 = _6069 + (32 * _9921) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9921) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10873 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _10918 = mem[_10873]
                require mem[_10873] <= test266151307()
                require _10873 + mem[_10873] + 31 < _10873 + return_data.size
                _10991 = mem[_10873 + mem[_10873]]
                if mem[_10873 + mem[_10873]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10873 + mem[_10873]]) + 1 < 0 or _10873 + ceil32(return_data.size) + ceil32(32 * mem[_10873 + mem[_10873]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10873 + ceil32(return_data.size) + ceil32(32 * mem[_10873 + mem[_10873]]) + 1
                mem[_10873 + ceil32(return_data.size)] = _10991
                require _10918 + (32 * _10991) + 32 <= return_data.size
                mem[_10873 + ceil32(return_data.size) + 32 len 32 * _10991] = mem[_10873 + _10918 + 32 len 32 * _10991]
                var89001 = _10991
                var89002 = _10873 + _10918 + (32 * _10991) + 32
                var89004 = _10873 + ceil32(return_data.size) + (32 * _10991) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _10991
                mem[mem[64] + 64 len 32 * _10991] = mem[_10873 + ceil32(return_data.size) + 32 len 32 * _10991]
                var97001 = _10991
                var97002 = _10873 + ceil32(return_data.size) + (32 * _10991) + 32
                return Array(len=_10991, data=mem[mem[64] + 64 len 32 * _10991])
            mem[_6326 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _7778 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7778:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7908 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7908 + 32 len mem[_7908]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7778 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6069]:
                    revert with 0, 50
                mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6326]:
                    revert with 0, 50
                mem[(32 * u) + _6326 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7778 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9483 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9483] = address(stor5[idx].field_0)
                mem[_9483 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9513 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10572 = mem[_9513]
                    s = 0
                    t = u
                    while s < _10572:
                        if s >= mem[_9513]:
                            revert with 0, 50
                        if t >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9513 + 32]
                        if s >= mem[_9513 + 32]:
                            revert with 0, 50
                        if t >= mem[_6326]:
                            revert with 0, 50
                        mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _9513 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10572 = mem[_9513]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9824 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9899 = mem[_9824]
                    require mem[_9824] <= test266151307()
                    require _9824 + mem[_9824] + 31 < _9824 + return_data.size
                    _9984 = mem[_9824 + mem[_9824]]
                    if mem[_9824 + mem[_9824]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9824 + mem[_9824]]) + 1 < 0 or _9824 + ceil32(return_data.size) + ceil32(32 * mem[_9824 + mem[_9824]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9824 + ceil32(return_data.size) + ceil32(32 * mem[_9824 + mem[_9824]]) + 1
                    mem[_9824 + ceil32(return_data.size)] = _9984
                    require _9899 + (32 * _9984) + 32 <= return_data.size
                    s = 0
                    t = _9824 + _9899 + 32
                    v = _9824 + ceil32(return_data.size) + 32
                    while s < _9984:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10735 = mem[_9824 + 32]
                    require mem[_9824 + 32] <= test266151307()
                    require _9824 + mem[_9824 + 32] + 31 < _9824 + return_data.size
                    _10876 = mem[_9824 + mem[_9824 + 32]]
                    if mem[_9824 + mem[_9824 + 32]] > test266151307():
                        revert with 0, 65
                    _10951 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9824 + mem[_9824 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9824 + mem[_9824 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9824 + mem[_9824 + 32]]) + 1
                    mem[_10951] = _10876
                    require _10735 + (32 * _10876) + 32 <= return_data.size
                    s = 0
                    t = _9824 + _10735 + 32
                    v = _10951 + 32
                    while s < _10876:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11736 = mem[_9824 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _11736:
                        if s >= mem[_9824 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9824 + ceil32(return_data.size) + 32]
                        if s >= mem[_10951]:
                            revert with 0, 50
                        if t >= mem[_6326]:
                            revert with 0, 50
                        mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _10951 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11736 = mem[_9824 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9601 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9601] = address(stor5[arg2].field_0)
            mem[_9601 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9707 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9707 + 32] = 32
                mem[_9707 + 64] = mem[_9707]
                mem[_9707 + 96 len 32 * mem[_9707]] = mem[_9707 + 32 len 32 * mem[_9707]]
                var70001 = mem[_9707]
                var70002 = _9707 + (32 * mem[_9707]) + 32
                return memory
                  from mem[64]
                   len _9707 + (32 * mem[_9707]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9922 = mem[_6069]
            mem[mem[64] + 100] = mem[_6069]
            mem[mem[64] + 132 len 32 * _9922] = mem[_6069 + 32 len 32 * _9922]
            var71001 = _9922
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9922) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10875 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10919 = mem[_10875]
            require mem[_10875] <= test266151307()
            require _10875 + mem[_10875] + 31 < _10875 + return_data.size
            _10992 = mem[_10875 + mem[_10875]]
            if mem[_10875 + mem[_10875]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10875 + mem[_10875]]) + 1 < 0 or _10875 + ceil32(return_data.size) + ceil32(32 * mem[_10875 + mem[_10875]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10875 + ceil32(return_data.size) + ceil32(32 * mem[_10875 + mem[_10875]]) + 1
            mem[_10875 + ceil32(return_data.size)] = _10992
            require _10919 + (32 * _10992) + 32 <= return_data.size
            mem[_10875 + ceil32(return_data.size) + 32 len 32 * _10992] = mem[_10875 + _10919 + 32 len 32 * _10992]
            var90001 = _10992
            var90002 = _10875 + _10919 + (32 * _10992) + 32
            var90004 = _10875 + ceil32(return_data.size) + (32 * _10992) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10992
            mem[mem[64] + 64 len 32 * _10992] = mem[_10875 + ceil32(return_data.size) + 32 len 32 * _10992]
            var98001 = _10992
            var98002 = _10875 + ceil32(return_data.size) + (32 * _10992) + 32
            return Array(len=_10992, data=mem[mem[64] + 64 len 32 * _10992])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _6069 + (64 * s + t) + 64
        if not s + t:
            _7780 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7780:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7915 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7915 + 32 len mem[_7915]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7780 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6069]:
                    revert with 0, 50
                mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6069 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _6069 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7780 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9488 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9488] = address(stor5[idx].field_0)
                mem[_9488 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9514 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10573 = mem[_9514]
                    v = 0
                    w = u
                    while v < _10573:
                        if v >= mem[_9514]:
                            revert with 0, 50
                        if w >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9514 + 32]
                        if v >= mem[_9514 + 32]:
                            revert with 0, 50
                        if w >= mem[_6069 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _9514 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10573 = mem[_9514]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9828 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9903 = mem[_9828]
                    require mem[_9828] <= test266151307()
                    require _9828 + mem[_9828] + 31 < _9828 + return_data.size
                    _9986 = mem[_9828 + mem[_9828]]
                    if mem[_9828 + mem[_9828]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9828 + mem[_9828]]) + 1 < 0 or _9828 + ceil32(return_data.size) + ceil32(32 * mem[_9828 + mem[_9828]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9828 + ceil32(return_data.size) + ceil32(32 * mem[_9828 + mem[_9828]]) + 1
                    mem[_9828 + ceil32(return_data.size)] = _9986
                    require _9903 + (32 * _9986) + 32 <= return_data.size
                    v = 0
                    w = _9828 + _9903 + 32
                    x = _9828 + ceil32(return_data.size) + 32
                    while v < _9986:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10738 = mem[_9828 + 32]
                    require mem[_9828 + 32] <= test266151307()
                    require _9828 + mem[_9828 + 32] + 31 < _9828 + return_data.size
                    _10878 = mem[_9828 + mem[_9828 + 32]]
                    if mem[_9828 + mem[_9828 + 32]] > test266151307():
                        revert with 0, 65
                    _10952 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9828 + mem[_9828 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9828 + mem[_9828 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9828 + mem[_9828 + 32]]) + 1
                    mem[_10952] = _10878
                    require _10738 + (32 * _10878) + 32 <= return_data.size
                    v = 0
                    w = _9828 + _10738 + 32
                    x = _10952 + 32
                    while v < _10878:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _11737 = mem[_9828 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _11737:
                        if v >= mem[_9828 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9828 + ceil32(return_data.size) + 32]
                        if v >= mem[_10952]:
                            revert with 0, 50
                        if w >= mem[_6069 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _10952 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _11737 = mem[_9828 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9606 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9606] = address(stor5[arg2].field_0)
            mem[_9606 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9713 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9713 + 32] = 32
                mem[_9713 + 64] = mem[_9713]
                mem[_9713 + 96 len 32 * mem[_9713]] = mem[_9713 + 32 len 32 * mem[_9713]]
                var70001 = mem[_9713]
                var70002 = _9713 + (32 * mem[_9713]) + 32
                return memory
                  from mem[64]
                   len _9713 + (32 * mem[_9713]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9923 = mem[_6069]
            mem[mem[64] + 100] = mem[_6069]
            mem[mem[64] + 132 len 32 * _9923] = mem[_6069 + 32 len 32 * _9923]
            var71001 = _9923
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9923) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10877 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10920 = mem[_10877]
            require mem[_10877] <= test266151307()
            require _10877 + mem[_10877] + 31 < _10877 + return_data.size
            _10993 = mem[_10877 + mem[_10877]]
            if mem[_10877 + mem[_10877]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10877 + mem[_10877]]) + 1 < 0 or _10877 + ceil32(return_data.size) + ceil32(32 * mem[_10877 + mem[_10877]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10877 + ceil32(return_data.size) + ceil32(32 * mem[_10877 + mem[_10877]]) + 1
            mem[_10877 + ceil32(return_data.size)] = _10993
            require _10920 + (32 * _10993) + 32 <= return_data.size
            mem[_10877 + ceil32(return_data.size) + 32 len 32 * _10993] = mem[_10877 + _10920 + 32 len 32 * _10993]
            var90001 = _10993
            var90002 = _10877 + _10920 + (32 * _10993) + 32
            var90004 = _10877 + ceil32(return_data.size) + (32 * _10993) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10993
            mem[mem[64] + 64 len 32 * _10993] = mem[_10877 + ceil32(return_data.size) + 32 len 32 * _10993]
            var98001 = _10993
            var98002 = _10877 + ceil32(return_data.size) + (32 * _10993) + 32
            return Array(len=_10993, data=mem[mem[64] + 64 len 32 * _10993])
        mem[_6069 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _7782 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _7782:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7922 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7922 + 32 len mem[_7922]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _7782 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_6069]:
                revert with 0, 50
            mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_6069 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _6069 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7782 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _9493 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9493] = address(stor5[idx].field_0)
            mem[_9493 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _9515 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10574 = mem[_9515]
                v = 0
                w = u
                while v < _10574:
                    if v >= mem[_9515]:
                        revert with 0, 50
                    if w >= mem[_6069]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9515 + 32]
                    if v >= mem[_9515 + 32]:
                        revert with 0, 50
                    if w >= mem[_6069 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _9515 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10574 = mem[_9515]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9832 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _9907 = mem[_9832]
                require mem[_9832] <= test266151307()
                require _9832 + mem[_9832] + 31 < _9832 + return_data.size
                _9988 = mem[_9832 + mem[_9832]]
                if mem[_9832 + mem[_9832]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9832 + mem[_9832]]) + 1 < 0 or _9832 + ceil32(return_data.size) + ceil32(32 * mem[_9832 + mem[_9832]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9832 + ceil32(return_data.size) + ceil32(32 * mem[_9832 + mem[_9832]]) + 1
                mem[_9832 + ceil32(return_data.size)] = _9988
                require _9907 + (32 * _9988) + 32 <= return_data.size
                v = 0
                w = _9832 + _9907 + 32
                x = _9832 + ceil32(return_data.size) + 32
                while v < _9988:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10741 = mem[_9832 + 32]
                require mem[_9832 + 32] <= test266151307()
                require _9832 + mem[_9832 + 32] + 31 < _9832 + return_data.size
                _10880 = mem[_9832 + mem[_9832 + 32]]
                if mem[_9832 + mem[_9832 + 32]] > test266151307():
                    revert with 0, 65
                _10953 = mem[64]
                if mem[64] + ceil32(32 * mem[_9832 + mem[_9832 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9832 + mem[_9832 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_9832 + mem[_9832 + 32]]) + 1
                mem[_10953] = _10880
                require _10741 + (32 * _10880) + 32 <= return_data.size
                v = 0
                w = _9832 + _10741 + 32
                x = _10953 + 32
                while v < _10880:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11738 = mem[_9832 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _11738:
                    if v >= mem[_9832 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_6069]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9832 + ceil32(return_data.size) + 32]
                    if v >= mem[_10953]:
                        revert with 0, 50
                    if w >= mem[_6069 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _10953 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11738 = mem[_9832 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _9611 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9611] = address(stor5[arg2].field_0)
        mem[_9611 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _9719 = mem[64]
            mem[64] = mem[64] + 32
            mem[_9719 + 32] = 32
            mem[_9719 + 64] = mem[_9719]
            mem[_9719 + 96 len 32 * mem[_9719]] = mem[_9719 + 32 len 32 * mem[_9719]]
            var71001 = mem[_9719]
            return memory
              from mem[64]
               len _9719 + (32 * mem[_9719]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _9924 = mem[_6069]
        mem[mem[64] + 100] = mem[_6069]
        mem[mem[64] + 132 len 32 * _9924] = mem[_6069 + 32 len 32 * _9924]
        var72001 = _9924
        var72002 = _6069 + (32 * _9924) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9924) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10879 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10921 = mem[_10879]
        require mem[_10879] <= test266151307()
        require _10879 + mem[_10879] + 31 < _10879 + return_data.size
        _10994 = mem[_10879 + mem[_10879]]
        if mem[_10879 + mem[_10879]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10879 + mem[_10879]]) + 1 < 0 or _10879 + ceil32(return_data.size) + ceil32(32 * mem[_10879 + mem[_10879]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10879 + ceil32(return_data.size) + ceil32(32 * mem[_10879 + mem[_10879]]) + 1
        mem[_10879 + ceil32(return_data.size)] = _10994
        require _10921 + (32 * _10994) + 32 <= return_data.size
        mem[_10879 + ceil32(return_data.size) + 32 len 32 * _10994] = mem[_10879 + _10921 + 32 len 32 * _10994]
        var91001 = _10994
        var91002 = _10879 + _10921 + (32 * _10994) + 32
        var91004 = _10879 + ceil32(return_data.size) + (32 * _10994) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10994
        mem[mem[64] + 64 len 32 * _10994] = mem[_10879 + ceil32(return_data.size) + 32 len 32 * _10994]
        var99001 = _10994
        var99002 = _10879 + ceil32(return_data.size) + (32 * _10994) + 32
        return Array(len=_10994, data=mem[mem[64] + 64 len 32 * _10994])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
    idx = 0
    s = 0
    while idx < stor10[ext_call.return_data[31 len 1]].field_512:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _7930 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_7930 + 32 len mem[_7930]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = 5
        _9498 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9498] = address(stor5[idx].field_0)
        mem[_9498 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _9518 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            if t > !mem[_9518]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_9518]
            continue 
        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg1
        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        require ext_code.size(address(stor5[idx].field_256))
        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                gas gas_remaining wei
               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9836 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 64
        _9912 = mem[_9836]
        require mem[_9836] <= test266151307()
        require _9836 + mem[_9836] + 31 < _9836 + return_data.size
        _9998 = mem[_9836 + mem[_9836]]
        if mem[_9836 + mem[_9836]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9836 + mem[_9836]]) + 1 < 0 or _9836 + ceil32(return_data.size) + ceil32(32 * mem[_9836 + mem[_9836]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9836 + ceil32(return_data.size) + ceil32(32 * mem[_9836 + mem[_9836]]) + 1
        mem[_9836 + ceil32(return_data.size)] = _9998
        require _9912 + (32 * _9998) + 32 <= return_data.size
        s = 0
        u = _9836 + _9912 + 32
        v = _9836 + ceil32(return_data.size) + 32
        while s < _9998:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        _10748 = mem[_9836 + 32]
        require mem[_9836 + 32] <= test266151307()
        require _9836 + mem[_9836 + 32] + 31 < _9836 + return_data.size
        _10881 = mem[_9836 + mem[_9836 + 32]]
        if mem[_9836 + mem[_9836 + 32]] > test266151307():
            revert with 0, 65
        _10982 = mem[64]
        if mem[64] + ceil32(32 * mem[_9836 + mem[_9836 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9836 + mem[_9836 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_9836 + mem[_9836 + 32]]) + 1
        mem[_10982] = _10881
        require _10748 + (32 * _10881) + 32 <= return_data.size
        s = 0
        u = _9836 + _10748 + 32
        v = _10982 + 32
        while s < _10881:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        if t > !mem[_9836 + ceil32(return_data.size)]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + mem[_9836 + ceil32(return_data.size)]
        continue 
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _9517 = mem[64]
    mem[mem[64]] = s + t
    if not s + t:
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _9835 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _9835 + (32 * s + t) + 32
        if not s + t:
            _10576 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _10576:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _10657 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_10657 + 32 len mem[_10657]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _10576 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_9517]:
                    revert with 0, 50
                mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_9835]:
                    revert with 0, 50
                mem[(32 * u) + _9835 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _10576 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _11383 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11383] = address(stor5[idx].field_0)
                mem[_11383 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _11402 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _11739 = mem[_11402]
                    s = 0
                    t = u
                    while s < _11739:
                        if s >= mem[_11402]:
                            revert with 0, 50
                        if t >= mem[_9517]:
                            revert with 0, 50
                        mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11402 + 32]
                        if s >= mem[_11402 + 32]:
                            revert with 0, 50
                        if t >= mem[_9835]:
                            revert with 0, 50
                        mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11402 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11739 = mem[_11402]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11576 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _11600 = mem[_11576]
                    require mem[_11576] <= test266151307()
                    require _11576 + mem[_11576] + 31 < _11576 + return_data.size
                    _11624 = mem[_11576 + mem[_11576]]
                    if mem[_11576 + mem[_11576]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_11576 + mem[_11576]]) + 1 < 0 or _11576 + ceil32(return_data.size) + ceil32(32 * mem[_11576 + mem[_11576]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _11576 + ceil32(return_data.size) + ceil32(32 * mem[_11576 + mem[_11576]]) + 1
                    mem[_11576 + ceil32(return_data.size)] = _11624
                    require _11600 + (32 * _11624) + 32 <= return_data.size
                    s = 0
                    t = _11576 + _11600 + 32
                    v = _11576 + ceil32(return_data.size) + 32
                    while s < _11624:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11807 = mem[_11576 + 32]
                    require mem[_11576 + 32] <= test266151307()
                    require _11576 + mem[_11576 + 32] + 31 < _11576 + return_data.size
                    _11888 = mem[_11576 + mem[_11576 + 32]]
                    if mem[_11576 + mem[_11576 + 32]] > test266151307():
                        revert with 0, 65
                    _11899 = mem[64]
                    if mem[64] + ceil32(32 * mem[_11576 + mem[_11576 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11576 + mem[_11576 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_11576 + mem[_11576 + 32]]) + 1
                    mem[_11899] = _11888
                    require _11807 + (32 * _11888) + 32 <= return_data.size
                    s = 0
                    t = _11576 + _11807 + 32
                    v = _11899 + 32
                    while s < _11888:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _12015 = mem[_11576 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _12015:
                        if s >= mem[_11576 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_9517]:
                            revert with 0, 50
                        mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11576 + ceil32(return_data.size) + 32]
                        if s >= mem[_11899]:
                            revert with 0, 50
                        if t >= mem[_9835]:
                            revert with 0, 50
                        mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11899 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _12015 = mem[_11576 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _11444 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11444] = address(stor5[arg2].field_0)
            mem[_11444 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _11500 = mem[64]
                mem[64] = mem[64] + 32
                mem[_11500 + 32] = 32
                mem[_11500 + 64] = mem[_11500]
                mem[_11500 + 96 len 32 * mem[_11500]] = mem[_11500 + 32 len 32 * mem[_11500]]
                var73001 = mem[_11500]
                var73002 = _11500 + (32 * mem[_11500]) + 32
                return memory
                  from mem[64]
                   len _11500 + (32 * mem[_11500]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _11615 = mem[_9517]
            mem[mem[64] + 100] = mem[_9517]
            mem[mem[64] + 132 len 32 * _11615] = mem[_9517 + 32 len 32 * _11615]
            var74001 = _11615
            var74002 = _9517 + (32 * _11615) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11615) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _11887 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _11895 = mem[_11887]
            require mem[_11887] <= test266151307()
            require _11887 + mem[_11887] + 31 < _11887 + return_data.size
            _11903 = mem[_11887 + mem[_11887]]
            if mem[_11887 + mem[_11887]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_11887 + mem[_11887]]) + 1 < 0 or _11887 + ceil32(return_data.size) + ceil32(32 * mem[_11887 + mem[_11887]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _11887 + ceil32(return_data.size) + ceil32(32 * mem[_11887 + mem[_11887]]) + 1
            mem[_11887 + ceil32(return_data.size)] = _11903
            require _11895 + (32 * _11903) + 32 <= return_data.size
            mem[_11887 + ceil32(return_data.size) + 32 len 32 * _11903] = mem[_11887 + _11895 + 32 len 32 * _11903]
            var93001 = _11903
            var93002 = _11887 + _11895 + (32 * _11903) + 32
            var93004 = _11887 + ceil32(return_data.size) + (32 * _11903) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _11903
            mem[mem[64] + 64 len 32 * _11903] = mem[_11887 + ceil32(return_data.size) + 32 len 32 * _11903]
            return Array(len=_11903, data=mem[mem[64] + 64 len 32 * _11903])
        mem[_9835 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _10578 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _10578:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _10664 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_10664 + 32 len mem[_10664]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _10578 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_9517]:
                revert with 0, 50
            mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_9835]:
                revert with 0, 50
            mem[(32 * u) + _9835 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _10578 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _11388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11388] = address(stor5[idx].field_0)
            mem[_11388 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _11403 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _11740 = mem[_11403]
                s = 0
                t = u
                while s < _11740:
                    if s >= mem[_11403]:
                        revert with 0, 50
                    if t >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11403 + 32]
                    if s >= mem[_11403 + 32]:
                        revert with 0, 50
                    if t >= mem[_9835]:
                        revert with 0, 50
                    mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11403 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _11740 = mem[_11403]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11580 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _11604 = mem[_11580]
                require mem[_11580] <= test266151307()
                require _11580 + mem[_11580] + 31 < _11580 + return_data.size
                _11626 = mem[_11580 + mem[_11580]]
                if mem[_11580 + mem[_11580]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_11580 + mem[_11580]]) + 1 < 0 or _11580 + ceil32(return_data.size) + ceil32(32 * mem[_11580 + mem[_11580]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _11580 + ceil32(return_data.size) + ceil32(32 * mem[_11580 + mem[_11580]]) + 1
                mem[_11580 + ceil32(return_data.size)] = _11626
                require _11604 + (32 * _11626) + 32 <= return_data.size
                s = 0
                t = _11580 + _11604 + 32
                v = _11580 + ceil32(return_data.size) + 32
                while s < _11626:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _11810 = mem[_11580 + 32]
                require mem[_11580 + 32] <= test266151307()
                require _11580 + mem[_11580 + 32] + 31 < _11580 + return_data.size
                _11890 = mem[_11580 + mem[_11580 + 32]]
                if mem[_11580 + mem[_11580 + 32]] > test266151307():
                    revert with 0, 65
                _11900 = mem[64]
                if mem[64] + ceil32(32 * mem[_11580 + mem[_11580 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11580 + mem[_11580 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_11580 + mem[_11580 + 32]]) + 1
                mem[_11900] = _11890
                require _11810 + (32 * _11890) + 32 <= return_data.size
                s = 0
                t = _11580 + _11810 + 32
                v = _11900 + 32
                while s < _11890:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _12016 = mem[_11580 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _12016:
                    if s >= mem[_11580 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11580 + ceil32(return_data.size) + 32]
                    if s >= mem[_11900]:
                        revert with 0, 50
                    if t >= mem[_9835]:
                        revert with 0, 50
                    mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11900 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _12016 = mem[_11580 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _11449 = mem[64]
        mem[64] = mem[64] + 64
        mem[_11449] = address(stor5[arg2].field_0)
        mem[_11449 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _11506 = mem[64]
            mem[64] = mem[64] + 32
            mem[_11506 + 32] = 32
            mem[_11506 + 64] = mem[_11506]
            mem[_11506 + 96 len 32 * mem[_11506]] = mem[_11506 + 32 len 32 * mem[_11506]]
            var74001 = mem[_11506]
            var74002 = _11506 + (32 * mem[_11506]) + 32
            return memory
              from mem[64]
               len _11506 + (32 * mem[_11506]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _11616 = mem[_9517]
        mem[mem[64] + 100] = mem[_9517]
        mem[mem[64] + 132 len 32 * _11616] = mem[_9517 + 32 len 32 * _11616]
        var75001 = _11616
        var75002 = _9517 + (32 * _11616) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11616) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11889 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11896 = mem[_11889]
        require mem[_11889] <= test266151307()
        require _11889 + mem[_11889] + 31 < _11889 + return_data.size
        _11904 = mem[_11889 + mem[_11889]]
        if mem[_11889 + mem[_11889]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_11889 + mem[_11889]]) + 1 < 0 or _11889 + ceil32(return_data.size) + ceil32(32 * mem[_11889 + mem[_11889]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _11889 + ceil32(return_data.size) + ceil32(32 * mem[_11889 + mem[_11889]]) + 1
        mem[_11889 + ceil32(return_data.size)] = _11904
        require _11896 + (32 * _11904) + 32 <= return_data.size
        mem[_11889 + ceil32(return_data.size) + 32 len 32 * _11904] = mem[_11889 + _11896 + 32 len 32 * _11904]
        var94001 = _11904
        var94002 = _11889 + _11896 + (32 * _11904) + 32
        var94004 = _11889 + ceil32(return_data.size) + (32 * _11904) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _11904
        mem[mem[64] + 64 len 32 * _11904] = mem[_11889 + ceil32(return_data.size) + 32 len 32 * _11904]
        return Array(len=_11904, data=mem[mem[64] + 64 len 32 * _11904])
    mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    mem[mem[64] + (32 * s + t) + 32] = s + t
    mem[64] = _9517 + (64 * s + t) + 64
    if not s + t:
        _10580 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _10580:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _10671 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_10671 + 32 len mem[_10671]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _10580 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_9517]:
                revert with 0, 50
            mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_9517 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _9517 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _10580 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _11393 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11393] = address(stor5[idx].field_0)
            mem[_11393 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _11404 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _11741 = mem[_11404]
                v = 0
                w = u
                while v < _11741:
                    if v >= mem[_11404]:
                        revert with 0, 50
                    if w >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11404 + 32]
                    if v >= mem[_11404 + 32]:
                        revert with 0, 50
                    if w >= mem[_9517 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11404 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11741 = mem[_11404]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11584 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _11608 = mem[_11584]
                require mem[_11584] <= test266151307()
                require _11584 + mem[_11584] + 31 < _11584 + return_data.size
                _11628 = mem[_11584 + mem[_11584]]
                if mem[_11584 + mem[_11584]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_11584 + mem[_11584]]) + 1 < 0 or _11584 + ceil32(return_data.size) + ceil32(32 * mem[_11584 + mem[_11584]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _11584 + ceil32(return_data.size) + ceil32(32 * mem[_11584 + mem[_11584]]) + 1
                mem[_11584 + ceil32(return_data.size)] = _11628
                require _11608 + (32 * _11628) + 32 <= return_data.size
                v = 0
                w = _11584 + _11608 + 32
                x = _11584 + ceil32(return_data.size) + 32
                while v < _11628:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11813 = mem[_11584 + 32]
                require mem[_11584 + 32] <= test266151307()
                require _11584 + mem[_11584 + 32] + 31 < _11584 + return_data.size
                _11892 = mem[_11584 + mem[_11584 + 32]]
                if mem[_11584 + mem[_11584 + 32]] > test266151307():
                    revert with 0, 65
                _11901 = mem[64]
                if mem[64] + ceil32(32 * mem[_11584 + mem[_11584 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11584 + mem[_11584 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_11584 + mem[_11584 + 32]]) + 1
                mem[_11901] = _11892
                require _11813 + (32 * _11892) + 32 <= return_data.size
                v = 0
                w = _11584 + _11813 + 32
                x = _11901 + 32
                while v < _11892:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _12017 = mem[_11584 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _12017:
                    if v >= mem[_11584 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11584 + ceil32(return_data.size) + 32]
                    if v >= mem[_11901]:
                        revert with 0, 50
                    if w >= mem[_9517 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11901 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _12017 = mem[_11584 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _11454 = mem[64]
        mem[64] = mem[64] + 64
        mem[_11454] = address(stor5[arg2].field_0)
        mem[_11454 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _11512 = mem[64]
            mem[64] = mem[64] + 32
            mem[_11512 + 32] = 32
            mem[_11512 + 64] = mem[_11512]
            mem[_11512 + 96 len 32 * mem[_11512]] = mem[_11512 + 32 len 32 * mem[_11512]]
            var74001 = mem[_11512]
            var74002 = _11512 + (32 * mem[_11512]) + 32
            return memory
              from mem[64]
               len _11512 + (32 * mem[_11512]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _11617 = mem[_9517]
        mem[mem[64] + 100] = mem[_9517]
        mem[mem[64] + 132 len 32 * _11617] = mem[_9517 + 32 len 32 * _11617]
        var75001 = _11617
        var75002 = _9517 + (32 * _11617) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11617) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11891 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11897 = mem[_11891]
        require mem[_11891] <= test266151307()
        require _11891 + mem[_11891] + 31 < _11891 + return_data.size
        _11905 = mem[_11891 + mem[_11891]]
        if mem[_11891 + mem[_11891]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_11891 + mem[_11891]]) + 1 < 0 or _11891 + ceil32(return_data.size) + ceil32(32 * mem[_11891 + mem[_11891]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _11891 + ceil32(return_data.size) + ceil32(32 * mem[_11891 + mem[_11891]]) + 1
        mem[_11891 + ceil32(return_data.size)] = _11905
        require _11897 + (32 * _11905) + 32 <= return_data.size
        mem[_11891 + ceil32(return_data.size) + 32 len 32 * _11905] = mem[_11891 + _11897 + 32 len 32 * _11905]
        var94001 = _11905
        var94002 = _11891 + _11897 + (32 * _11905) + 32
        var94004 = _11891 + ceil32(return_data.size) + (32 * _11905) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _11905
        mem[mem[64] + 64 len 32 * _11905] = mem[_11891 + ceil32(return_data.size) + 32 len 32 * _11905]
        return Array(len=_11905, data=mem[mem[64] + 64 len 32 * _11905])
    mem[_9517 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    _10582 = mem[mem[ceil32(return_data.size) + 160]]
    idx = 0
    u = 0
    while idx < _10582:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _10678 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_10678 + 32 len mem[_10678]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            _10582 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u
            continue 
        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
            revert with 0, 50
        if u >= mem[_9517]:
            revert with 0, 50
        mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
            revert with 0, 50
        if u >= mem[_9517 + (32 * s + t) + 32]:
            revert with 0, 50
        mem[(32 * u) + _9517 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
        if u == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        _10582 = mem[mem[ceil32(return_data.size) + 160]]
        idx = idx + 1
        u = u + 1
        continue 
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        _11398 = mem[64]
        mem[64] = mem[64] + 64
        mem[_11398] = address(stor5[idx].field_0)
        mem[_11398 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _11405 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            _11742 = mem[_11405]
            v = 0
            w = u
            while v < _11742:
                if v >= mem[_11405]:
                    revert with 0, 50
                if w >= mem[_9517]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11405 + 32]
                if v >= mem[_11405 + 32]:
                    revert with 0, 50
                if w >= mem[_9517 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11405 + 64]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _11742 = mem[_11405]
                v = v + 1
                w = w + 1
                continue 
        else:
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _11588 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _11612 = mem[_11588]
            require mem[_11588] <= test266151307()
            require _11588 + mem[_11588] + 31 < _11588 + return_data.size
            _11630 = mem[_11588 + mem[_11588]]
            if mem[_11588 + mem[_11588]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_11588 + mem[_11588]]) + 1 < 0 or _11588 + ceil32(return_data.size) + ceil32(32 * mem[_11588 + mem[_11588]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _11588 + ceil32(return_data.size) + ceil32(32 * mem[_11588 + mem[_11588]]) + 1
            mem[_11588 + ceil32(return_data.size)] = _11630
            require _11612 + (32 * _11630) + 32 <= return_data.size
            v = 0
            w = _11588 + _11612 + 32
            x = _11588 + ceil32(return_data.size) + 32
            while v < _11630:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _11816 = mem[_11588 + 32]
            require mem[_11588 + 32] <= test266151307()
            require _11588 + mem[_11588 + 32] + 31 < _11588 + return_data.size
            _11894 = mem[_11588 + mem[_11588 + 32]]
            if mem[_11588 + mem[_11588 + 32]] > test266151307():
                revert with 0, 65
            _11902 = mem[64]
            if mem[64] + ceil32(32 * mem[_11588 + mem[_11588 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11588 + mem[_11588 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_11588 + mem[_11588 + 32]]) + 1
            mem[_11902] = _11894
            require _11816 + (32 * _11894) + 32 <= return_data.size
            v = 0
            w = _11588 + _11816 + 32
            x = _11902 + 32
            while v < _11894:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _12018 = mem[_11588 + ceil32(return_data.size)]
            v = 0
            w = u
            while v < _12018:
                if v >= mem[_11588 + ceil32(return_data.size)]:
                    revert with 0, 50
                if w >= mem[_9517]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11588 + ceil32(return_data.size) + 32]
                if v >= mem[_11902]:
                    revert with 0, 50
                if w >= mem[_9517 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11902 + 32]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _12018 = mem[_11588 + ceil32(return_data.size)]
                v = v + 1
                w = w + 1
                continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if s > !t:
        revert with 0, 17
    if u != s + t:
        revert with 0, 1
    if arg2 >= stor5.length:
        revert with 0, 50
    mem[0] = 5
    _11459 = mem[64]
    mem[64] = mem[64] + 64
    mem[_11459] = address(stor5[arg2].field_0)
    mem[_11459 + 32] = address(stor5[arg2].field_256)
    mem[0] = address(stor5[arg2].field_0)
    mem[32] = sha3(arg1, 1) + 3
    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
        _11518 = mem[64]
        mem[64] = mem[64] + 32
        mem[_11518 + 32] = 32
        mem[_11518 + 64] = mem[_11518]
        mem[_11518 + 96 len 32 * mem[_11518]] = mem[_11518 + 32 len 32 * mem[_11518]]
        var75001 = mem[_11518]
        var75002 = _11518 + (32 * mem[_11518]) + 32
        return memory
          from mem[64]
           len _11518 + (32 * mem[_11518]) + -mem[64] + 96
    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
        revert with 0, 17
    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 96
    _11618 = mem[_9517]
    mem[mem[64] + 100] = mem[_9517]
    mem[mem[64] + 132 len 32 * _11618] = mem[_9517 + 32 len 32 * _11618]
    var76001 = _11618
    var76002 = _9517 + (32 * _11618) + 32
    mem[mem[64] + 36] = arg1
    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
    require ext_code.size(address(stor5[arg2].field_256))
    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
            gas gas_remaining wei
           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11618) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _11893 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _11898 = mem[_11893]
    require mem[_11893] <= test266151307()
    require _11893 + mem[_11893] + 31 < _11893 + return_data.size
    _11906 = mem[_11893 + mem[_11893]]
    if mem[_11893 + mem[_11893]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_11893 + mem[_11893]]) + 1 < 0 or _11893 + ceil32(return_data.size) + ceil32(32 * mem[_11893 + mem[_11893]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _11893 + ceil32(return_data.size) + ceil32(32 * mem[_11893 + mem[_11893]]) + 1
    mem[_11893 + ceil32(return_data.size)] = _11906
    require _11898 + (32 * _11906) + 32 <= return_data.size
    mem[_11893 + ceil32(return_data.size) + 32 len 32 * _11906] = mem[_11893 + _11898 + 32 len 32 * _11906]
    var95001 = _11906
    var95002 = _11893 + _11898 + (32 * _11906) + 32
    var95004 = _11893 + ceil32(return_data.size) + (32 * _11906) + 32
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _11906
    mem[mem[64] + 64 len 32 * _11906] = mem[_11893 + ceil32(return_data.size) + 32 len 32 * _11906]
    return Array(len=_11906, data=mem[mem[64] + 64 len 32 * _11906])
}



}
